/*! jQuery v3.2.1 | (c) JS Foundation and other contributors | jquery.org/license */
!function(a,b){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){"use strict";var c=[],d=a.document,e=Object.getPrototypeOf,f=c.slice,g=c.concat,h=c.push,i=c.indexOf,j={},k=j.toString,l=j.hasOwnProperty,m=l.toString,n=m.call(Object),o={};function p(a,b){b=b||d;var c=b.createElement("script");c.text=a,b.head.appendChild(c).parentNode.removeChild(c)}var q="3.2.1",r=function(a,b){return new r.fn.init(a,b)},s=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,t=/^-ms-/,u=/-([a-z])/g,v=function(a,b){return b.toUpperCase()};r.fn=r.prototype={jquery:q,constructor:r,length:0,toArray:function(){return f.call(this)},get:function(a){return null==a?f.call(this):a<0?this[a+this.length]:this[a]},pushStack:function(a){var b=r.merge(this.constructor(),a);return b.prevObject=this,b},each:function(a){return r.each(this,a)},map:function(a){return this.pushStack(r.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(f.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(a<0?b:0);return this.pushStack(c>=0&&c<b?[this[c]]:[])},end:function(){return this.prevObject||this.constructor()},push:h,sort:c.sort,splice:c.splice},r.extend=r.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||r.isFunction(g)||(g={}),h===i&&(g=this,h--);h<i;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(r.isPlainObject(d)||(e=Array.isArray(d)))?(e?(e=!1,f=c&&Array.isArray(c)?c:[]):f=c&&r.isPlainObject(c)?c:{},g[b]=r.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},r.extend({expando:"jQuery"+(q+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===r.type(a)},isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){var b=r.type(a);return("number"===b||"string"===b)&&!isNaN(a-parseFloat(a))},isPlainObject:function(a){var b,c;return!(!a||"[object Object]"!==k.call(a))&&(!(b=e(a))||(c=l.call(b,"constructor")&&b.constructor,"function"==typeof c&&m.call(c)===n))},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?j[k.call(a)]||"object":typeof a},globalEval:function(a){p(a)},camelCase:function(a){return a.replace(t,"ms-").replace(u,v)},each:function(a,b){var c,d=0;if(w(a)){for(c=a.length;d<c;d++)if(b.call(a[d],d,a[d])===!1)break}else for(d in a)if(b.call(a[d],d,a[d])===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(s,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(w(Object(a))?r.merge(c,"string"==typeof a?[a]:a):h.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:i.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;d<c;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;f<g;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,e,f=0,h=[];if(w(a))for(d=a.length;f<d;f++)e=b(a[f],f,c),null!=e&&h.push(e);else for(f in a)e=b(a[f],f,c),null!=e&&h.push(e);return g.apply([],h)},guid:1,proxy:function(a,b){var c,d,e;if("string"==typeof b&&(c=a[b],b=a,a=c),r.isFunction(a))return d=f.call(arguments,2),e=function(){return a.apply(b||this,d.concat(f.call(arguments)))},e.guid=a.guid=a.guid||r.guid++,e},now:Date.now,support:o}),"function"==typeof Symbol&&(r.fn[Symbol.iterator]=c[Symbol.iterator]),r.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(a,b){j["[object "+b+"]"]=b.toLowerCase()});function w(a){var b=!!a&&"length"in a&&a.length,c=r.type(a);return"function"!==c&&!r.isWindow(a)&&("array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a)}var x=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C={}.hasOwnProperty,D=[],E=D.pop,F=D.push,G=D.push,H=D.slice,I=function(a,b){for(var c=0,d=a.length;c<d;c++)if(a[c]===b)return c;return-1},J="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",K="[\\x20\\t\\r\\n\\f]",L="(?:\\\\.|[\\w-]|[^\0-\\xa0])+",M="\\["+K+"*("+L+")(?:"+K+"*([*^$|!~]?=)"+K+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+L+"))|)"+K+"*\\]",N=":("+L+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+M+")*)|.*)\\)|)",O=new RegExp(K+"+","g"),P=new RegExp("^"+K+"+|((?:^|[^\\\\])(?:\\\\.)*)"+K+"+$","g"),Q=new RegExp("^"+K+"*,"+K+"*"),R=new RegExp("^"+K+"*([>+~]|"+K+")"+K+"*"),S=new RegExp("="+K+"*([^\\]'\"]*?)"+K+"*\\]","g"),T=new RegExp(N),U=new RegExp("^"+L+"$"),V={ID:new RegExp("^#("+L+")"),CLASS:new RegExp("^\\.("+L+")"),TAG:new RegExp("^("+L+"|[*])"),ATTR:new RegExp("^"+M),PSEUDO:new RegExp("^"+N),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+K+"*(even|odd|(([+-]|)(\\d*)n|)"+K+"*(?:([+-]|)"+K+"*(\\d+)|))"+K+"*\\)|)","i"),bool:new RegExp("^(?:"+J+")$","i"),needsContext:new RegExp("^"+K+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+K+"*((?:-\\d)?\\d*)"+K+"*\\)|)(?=[^-]|$)","i")},W=/^(?:input|select|textarea|button)$/i,X=/^h\d$/i,Y=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,$=/[+~]/,_=new RegExp("\\\\([\\da-f]{1,6}"+K+"?|("+K+")|.)","ig"),aa=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:d<0?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ba=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ca=function(a,b){return b?"\0"===a?"\ufffd":a.slice(0,-1)+"\\"+a.charCodeAt(a.length-1).toString(16)+" ":"\\"+a},da=function(){m()},ea=ta(function(a){return a.disabled===!0&&("form"in a||"label"in a)},{dir:"parentNode",next:"legend"});try{G.apply(D=H.call(v.childNodes),v.childNodes),D[v.childNodes.length].nodeType}catch(fa){G={apply:D.length?function(a,b){F.apply(a,H.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s=b&&b.ownerDocument,w=b?b.nodeType:9;if(d=d||[],"string"!=typeof a||!a||1!==w&&9!==w&&11!==w)return d;if(!e&&((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,p)){if(11!==w&&(l=Z.exec(a)))if(f=l[1]){if(9===w){if(!(j=b.getElementById(f)))return d;if(j.id===f)return d.push(j),d}else if(s&&(j=s.getElementById(f))&&t(b,j)&&j.id===f)return d.push(j),d}else{if(l[2])return G.apply(d,b.getElementsByTagName(a)),d;if((f=l[3])&&c.getElementsByClassName&&b.getElementsByClassName)return G.apply(d,b.getElementsByClassName(f)),d}if(c.qsa&&!A[a+" "]&&(!q||!q.test(a))){if(1!==w)s=b,r=a;else if("object"!==b.nodeName.toLowerCase()){(k=b.getAttribute("id"))?k=k.replace(ba,ca):b.setAttribute("id",k=u),o=g(a),h=o.length;while(h--)o[h]="#"+k+" "+sa(o[h]);r=o.join(","),s=$.test(a)&&qa(b.parentNode)||b}if(r)try{return G.apply(d,s.querySelectorAll(r)),d}catch(x){}finally{k===u&&b.removeAttribute("id")}}}return i(a.replace(P,"$1"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement("fieldset");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split("|"),e=c.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&a.sourceIndex-b.sourceIndex;if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function oa(a){return function(b){return"form"in b?b.parentNode&&b.disabled===!1?"label"in b?"label"in b.parentNode?b.parentNode.disabled===a:b.disabled===a:b.isDisabled===a||b.isDisabled!==!a&&ea(b)===a:b.disabled===a:"label"in b&&b.disabled===a}}function pa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function qa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return!!b&&"HTML"!==b.nodeName},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=n.documentElement,p=!f(n),v!==n&&(e=n.defaultView)&&e.top!==e&&(e.addEventListener?e.addEventListener("unload",da,!1):e.attachEvent&&e.attachEvent("onunload",da)),c.attributes=ja(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ja(function(a){return a.appendChild(n.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=Y.test(n.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!n.getElementsByName||!n.getElementsByName(u).length}),c.getById?(d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){return a.getAttribute("id")===b}},d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c?[c]:[]}}):(d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}},d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c,d,e,f=b.getElementById(a);if(f){if(c=f.getAttributeNode("id"),c&&c.value===a)return[f];e=b.getElementsByName(a),d=0;while(f=e[d++])if(c=f.getAttributeNode("id"),c&&c.value===a)return[f]}return[]}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){if("undefined"!=typeof b.getElementsByClassName&&p)return b.getElementsByClassName(a)},r=[],q=[],(c.qsa=Y.test(n.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\r\\' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+K+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+K+"*(?:value|"+J+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ja(function(a){a.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var b=n.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+K+"*[*^$|!~]?="),2!==a.querySelectorAll(":enabled").length&&q.push(":enabled",":disabled"),o.appendChild(a).disabled=!0,2!==a.querySelectorAll(":disabled").length&&q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=Y.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,"*"),s.call(a,"[s!='']:x"),r.push("!=",N)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=Y.test(o.compareDocumentPosition),t=b||Y.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===n||a.ownerDocument===v&&t(v,a)?-1:b===n||b.ownerDocument===v&&t(v,b)?1:k?I(k,a)-I(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,g=[a],h=[b];if(!e||!f)return a===n?-1:b===n?1:e?-1:f?1:k?I(k,a)-I(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)g.unshift(c);c=b;while(c=c.parentNode)h.unshift(c);while(g[d]===h[d])d++;return d?la(g[d],h[d]):g[d]===v?-1:h[d]===v?1:0},n):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(S,"='$1']"),c.matchesSelector&&p&&!A[b+" "]&&(!r||!r.test(b))&&(!q||!q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&C.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.escape=function(a){return(a+"").replace(ba,ca)},ga.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:V,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(_,aa),a[3]=(a[3]||a[4]||a[5]||"").replace(_,aa),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return V.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&T.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(_,aa).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+K+")"+a+"("+K+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?"!="===b:!b||(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(O," ")+" ").indexOf(c)>-1:"|="===b&&(e===c||e.slice(0,c.length+1)===c+"-"))}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h,t=!1;if(q){if(f){while(p){m=b;while(m=m[p])if(h?m.nodeName.toLowerCase()===r:1===m.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){m=q,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n&&j[2],m=n&&q.childNodes[n];while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if(1===m.nodeType&&++t&&m===b){k[a]=[w,n,t];break}}else if(s&&(m=b,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n),t===!1)while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if((h?m.nodeName.toLowerCase()===r:1===m.nodeType)&&++t&&(s&&(l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),k[a]=[w,t]),m===b))break;return t-=e,t===d||t%d===0&&t/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=I(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(P,"$1"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(_,aa),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return U.test(a||"")||ga.error("unsupported lang: "+a),a=a.replace(_,aa).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:oa(!1),disabled:oa(!0),checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return X.test(a.nodeName)},input:function(a){return W.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:pa(function(){return[0]}),last:pa(function(a,b){return[b-1]}),eq:pa(function(a,b,c){return[c<0?c+b:c]}),even:pa(function(a,b){for(var c=0;c<b;c+=2)a.push(c);return a}),odd:pa(function(a,b){for(var c=1;c<b;c+=2)a.push(c);return a}),lt:pa(function(a,b,c){for(var d=c<0?c+b:c;--d>=0;)a.push(d);return a}),gt:pa(function(a,b,c){for(var d=c<0?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function ra(){}ra.prototype=d.filters=d.pseudos,d.setFilters=new ra,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){c&&!(e=Q.exec(h))||(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=R.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(P," ")}),h=h.slice(c.length));for(g in d.filter)!(e=V[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function sa(a){for(var b=0,c=a.length,d="";b<c;b++)d+=a[b].value;return d}function ta(a,b,c){var d=b.dir,e=b.next,f=e||d,g=c&&"parentNode"===f,h=x++;return b.first?function(b,c,e){while(b=b[d])if(1===b.nodeType||g)return a(b,c,e);return!1}:function(b,c,i){var j,k,l,m=[w,h];if(i){while(b=b[d])if((1===b.nodeType||g)&&a(b,c,i))return!0}else while(b=b[d])if(1===b.nodeType||g)if(l=b[u]||(b[u]={}),k=l[b.uniqueID]||(l[b.uniqueID]={}),e&&e===b.nodeName.toLowerCase())b=b[d]||b;else{if((j=k[f])&&j[0]===w&&j[1]===h)return m[2]=j[2];if(k[f]=m,m[2]=a(b,c,i))return!0}return!1}}function ua(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function va(a,b,c){for(var d=0,e=b.length;d<e;d++)ga(a,b[d],c);return c}function wa(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;h<i;h++)(f=a[h])&&(c&&!c(f,d,e)||(g.push(f),j&&b.push(h)));return g}function xa(a,b,c,d,e,f){return d&&!d[u]&&(d=xa(d)),e&&!e[u]&&(e=xa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||va(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:wa(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=wa(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?I(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=wa(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):G.apply(g,r)})}function ya(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=ta(function(a){return a===b},h,!0),l=ta(function(a){return I(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];i<f;i++)if(c=d.relative[a[i].type])m=[ta(ua(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;e<f;e++)if(d.relative[a[e].type])break;return xa(i>1&&ua(m),i>1&&sa(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(P,"$1"),c,i<e&&ya(a.slice(i,e)),e<f&&ya(a=a.slice(e)),e<f&&sa(a))}m.push(c)}return ua(m)}function za(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,o,q,r=0,s="0",t=f&&[],u=[],v=j,x=f||e&&d.find.TAG("*",k),y=w+=null==v?1:Math.random()||.1,z=x.length;for(k&&(j=g===n||g||k);s!==z&&null!=(l=x[s]);s++){if(e&&l){o=0,g||l.ownerDocument===n||(m(l),h=!p);while(q=a[o++])if(q(l,g||n,h)){i.push(l);break}k&&(w=y)}c&&((l=!q&&l)&&r--,f&&t.push(l))}if(r+=s,c&&s!==r){o=0;while(q=b[o++])q(t,u,g,h);if(f){if(r>0)while(s--)t[s]||u[s]||(u[s]=E.call(i));u=wa(u)}G.apply(i,u),k&&!f&&u.length>0&&r+b.length>1&&ga.uniqueSort(i)}return k&&(w=y,j=v),t};return c?ia(f):f}return h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=ya(b[c]),f[u]?d.push(f):e.push(f);f=A(a,za(e,d)),f.selector=a}return f},i=ga.select=function(a,b,c,e){var f,i,j,k,l,m="function"==typeof a&&a,n=!e&&g(a=m.selector||a);if(c=c||[],1===n.length){if(i=n[0]=n[0].slice(0),i.length>2&&"ID"===(j=i[0]).type&&9===b.nodeType&&p&&d.relative[i[1].type]){if(b=(d.find.ID(j.matches[0].replace(_,aa),b)||[])[0],!b)return c;m&&(b=b.parentNode),a=a.slice(i.shift().value.length)}f=V.needsContext.test(a)?0:i.length;while(f--){if(j=i[f],d.relative[k=j.type])break;if((l=d.find[k])&&(e=l(j.matches[0].replace(_,aa),$.test(i[0].type)&&qa(b.parentNode)||b))){if(i.splice(f,1),a=e.length&&sa(i),!a)return G.apply(c,e),c;break}}}return(m||h(a,n))(e,b,!p,c,!b||$.test(a)&&qa(b.parentNode)||b),c},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement("fieldset"))}),ja(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||ka("type|href|height|width",function(a,b,c){if(!c)return a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ka("value",function(a,b,c){if(!c&&"input"===a.nodeName.toLowerCase())return a.defaultValue}),ja(function(a){return null==a.getAttribute("disabled")})||ka(J,function(a,b,c){var d;if(!c)return a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),ga}(a);r.find=x,r.expr=x.selectors,r.expr[":"]=r.expr.pseudos,r.uniqueSort=r.unique=x.uniqueSort,r.text=x.getText,r.isXMLDoc=x.isXML,r.contains=x.contains,r.escapeSelector=x.escape;var y=function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&r(a).is(c))break;d.push(a)}return d},z=function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c},A=r.expr.match.needsContext;function B(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()}var C=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i,D=/^.[^:#\[\.,]*$/;function E(a,b,c){return r.isFunction(b)?r.grep(a,function(a,d){return!!b.call(a,d,a)!==c}):b.nodeType?r.grep(a,function(a){return a===b!==c}):"string"!=typeof b?r.grep(a,function(a){return i.call(b,a)>-1!==c}):D.test(b)?r.filter(b,a,c):(b=r.filter(b,a),r.grep(a,function(a){return i.call(b,a)>-1!==c&&1===a.nodeType}))}r.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?r.find.matchesSelector(d,a)?[d]:[]:r.find.matches(a,r.grep(b,function(a){return 1===a.nodeType}))},r.fn.extend({find:function(a){var b,c,d=this.length,e=this;if("string"!=typeof a)return this.pushStack(r(a).filter(function(){for(b=0;b<d;b++)if(r.contains(e[b],this))return!0}));for(c=this.pushStack([]),b=0;b<d;b++)r.find(a,e[b],c);return d>1?r.uniqueSort(c):c},filter:function(a){return this.pushStack(E(this,a||[],!1))},not:function(a){return this.pushStack(E(this,a||[],!0))},is:function(a){return!!E(this,"string"==typeof a&&A.test(a)?r(a):a||[],!1).length}});var F,G=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,H=r.fn.init=function(a,b,c){var e,f;if(!a)return this;if(c=c||F,"string"==typeof a){if(e="<"===a[0]&&">"===a[a.length-1]&&a.length>=3?[null,a,null]:G.exec(a),!e||!e[1]&&b)return!b||b.jquery?(b||c).find(a):this.constructor(b).find(a);if(e[1]){if(b=b instanceof r?b[0]:b,r.merge(this,r.parseHTML(e[1],b&&b.nodeType?b.ownerDocument||b:d,!0)),C.test(e[1])&&r.isPlainObject(b))for(e in b)r.isFunction(this[e])?this[e](b[e]):this.attr(e,b[e]);return this}return f=d.getElementById(e[2]),f&&(this[0]=f,this.length=1),this}return a.nodeType?(this[0]=a,this.length=1,this):r.isFunction(a)?void 0!==c.ready?c.ready(a):a(r):r.makeArray(a,this)};H.prototype=r.fn,F=r(d);var I=/^(?:parents|prev(?:Until|All))/,J={children:!0,contents:!0,next:!0,prev:!0};r.fn.extend({has:function(a){var b=r(a,this),c=b.length;return this.filter(function(){for(var a=0;a<c;a++)if(r.contains(this,b[a]))return!0})},closest:function(a,b){var c,d=0,e=this.length,f=[],g="string"!=typeof a&&r(a);if(!A.test(a))for(;d<e;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&r.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?r.uniqueSort(f):f)},index:function(a){return a?"string"==typeof a?i.call(r(a),this[0]):i.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(r.uniqueSort(r.merge(this.get(),r(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function K(a,b){while((a=a[b])&&1!==a.nodeType);return a}r.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return y(a,"parentNode")},parentsUntil:function(a,b,c){return y(a,"parentNode",c)},next:function(a){return K(a,"nextSibling")},prev:function(a){return K(a,"previousSibling")},nextAll:function(a){return y(a,"nextSibling")},prevAll:function(a){return y(a,"previousSibling")},nextUntil:function(a,b,c){return y(a,"nextSibling",c)},prevUntil:function(a,b,c){return y(a,"previousSibling",c)},siblings:function(a){return z((a.parentNode||{}).firstChild,a)},children:function(a){return z(a.firstChild)},contents:function(a){return B(a,"iframe")?a.contentDocument:(B(a,"template")&&(a=a.content||a),r.merge([],a.childNodes))}},function(a,b){r.fn[a]=function(c,d){var e=r.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=r.filter(d,e)),this.length>1&&(J[a]||r.uniqueSort(e),I.test(a)&&e.reverse()),this.pushStack(e)}});var L=/[^\x20\t\r\n\f]+/g;function M(a){var b={};return r.each(a.match(L)||[],function(a,c){b[c]=!0}),b}r.Callbacks=function(a){a="string"==typeof a?M(a):r.extend({},a);var b,c,d,e,f=[],g=[],h=-1,i=function(){for(e=e||a.once,d=b=!0;g.length;h=-1){c=g.shift();while(++h<f.length)f[h].apply(c[0],c[1])===!1&&a.stopOnFalse&&(h=f.length,c=!1)}a.memory||(c=!1),b=!1,e&&(f=c?[]:"")},j={add:function(){return f&&(c&&!b&&(h=f.length-1,g.push(c)),function d(b){r.each(b,function(b,c){r.isFunction(c)?a.unique&&j.has(c)||f.push(c):c&&c.length&&"string"!==r.type(c)&&d(c)})}(arguments),c&&!b&&i()),this},remove:function(){return r.each(arguments,function(a,b){var c;while((c=r.inArray(b,f,c))>-1)f.splice(c,1),c<=h&&h--}),this},has:function(a){return a?r.inArray(a,f)>-1:f.length>0},empty:function(){return f&&(f=[]),this},disable:function(){return e=g=[],f=c="",this},disabled:function(){return!f},lock:function(){return e=g=[],c||b||(f=c=""),this},locked:function(){return!!e},fireWith:function(a,c){return e||(c=c||[],c=[a,c.slice?c.slice():c],g.push(c),b||i()),this},fire:function(){return j.fireWith(this,arguments),this},fired:function(){return!!d}};return j};function N(a){return a}function O(a){throw a}function P(a,b,c,d){var e;try{a&&r.isFunction(e=a.promise)?e.call(a).done(b).fail(c):a&&r.isFunction(e=a.then)?e.call(a,b,c):b.apply(void 0,[a].slice(d))}catch(a){c.apply(void 0,[a])}}r.extend({Deferred:function(b){var c=[["notify","progress",r.Callbacks("memory"),r.Callbacks("memory"),2],["resolve","done",r.Callbacks("once memory"),r.Callbacks("once memory"),0,"resolved"],["reject","fail",r.Callbacks("once memory"),r.Callbacks("once memory"),1,"rejected"]],d="pending",e={state:function(){return d},always:function(){return f.done(arguments).fail(arguments),this},"catch":function(a){return e.then(null,a)},pipe:function(){var a=arguments;return r.Deferred(function(b){r.each(c,function(c,d){var e=r.isFunction(a[d[4]])&&a[d[4]];f[d[1]](function(){var a=e&&e.apply(this,arguments);a&&r.isFunction(a.promise)?a.promise().progress(b.notify).done(b.resolve).fail(b.reject):b[d[0]+"With"](this,e?[a]:arguments)})}),a=null}).promise()},then:function(b,d,e){var f=0;function g(b,c,d,e){return function(){var h=this,i=arguments,j=function(){var a,j;if(!(b<f)){if(a=d.apply(h,i),a===c.promise())throw new TypeError("Thenable self-resolution");j=a&&("object"==typeof a||"function"==typeof a)&&a.then,r.isFunction(j)?e?j.call(a,g(f,c,N,e),g(f,c,O,e)):(f++,j.call(a,g(f,c,N,e),g(f,c,O,e),g(f,c,N,c.notifyWith))):(d!==N&&(h=void 0,i=[a]),(e||c.resolveWith)(h,i))}},k=e?j:function(){try{j()}catch(a){r.Deferred.exceptionHook&&r.Deferred.exceptionHook(a,k.stackTrace),b+1>=f&&(d!==O&&(h=void 0,i=[a]),c.rejectWith(h,i))}};b?k():(r.Deferred.getStackHook&&(k.stackTrace=r.Deferred.getStackHook()),a.setTimeout(k))}}return r.Deferred(function(a){c[0][3].add(g(0,a,r.isFunction(e)?e:N,a.notifyWith)),c[1][3].add(g(0,a,r.isFunction(b)?b:N)),c[2][3].add(g(0,a,r.isFunction(d)?d:O))}).promise()},promise:function(a){return null!=a?r.extend(a,e):e}},f={};return r.each(c,function(a,b){var g=b[2],h=b[5];e[b[1]]=g.add,h&&g.add(function(){d=h},c[3-a][2].disable,c[0][2].lock),g.add(b[3].fire),f[b[0]]=function(){return f[b[0]+"With"](this===f?void 0:this,arguments),this},f[b[0]+"With"]=g.fireWith}),e.promise(f),b&&b.call(f,f),f},when:function(a){var b=arguments.length,c=b,d=Array(c),e=f.call(arguments),g=r.Deferred(),h=function(a){return function(c){d[a]=this,e[a]=arguments.length>1?f.call(arguments):c,--b||g.resolveWith(d,e)}};if(b<=1&&(P(a,g.done(h(c)).resolve,g.reject,!b),"pending"===g.state()||r.isFunction(e[c]&&e[c].then)))return g.then();while(c--)P(e[c],h(c),g.reject);return g.promise()}});var Q=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;r.Deferred.exceptionHook=function(b,c){a.console&&a.console.warn&&b&&Q.test(b.name)&&a.console.warn("jQuery.Deferred exception: "+b.message,b.stack,c)},r.readyException=function(b){a.setTimeout(function(){throw b})};var R=r.Deferred();r.fn.ready=function(a){return R.then(a)["catch"](function(a){r.readyException(a)}),this},r.extend({isReady:!1,readyWait:1,ready:function(a){(a===!0?--r.readyWait:r.isReady)||(r.isReady=!0,a!==!0&&--r.readyWait>0||R.resolveWith(d,[r]))}}),r.ready.then=R.then;function S(){d.removeEventListener("DOMContentLoaded",S),
a.removeEventListener("load",S),r.ready()}"complete"===d.readyState||"loading"!==d.readyState&&!d.documentElement.doScroll?a.setTimeout(r.ready):(d.addEventListener("DOMContentLoaded",S),a.addEventListener("load",S));var T=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===r.type(c)){e=!0;for(h in c)T(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,r.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(r(a),c)})),b))for(;h<i;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},U=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function V(){this.expando=r.expando+V.uid++}V.uid=1,V.prototype={cache:function(a){var b=a[this.expando];return b||(b={},U(a)&&(a.nodeType?a[this.expando]=b:Object.defineProperty(a,this.expando,{value:b,configurable:!0}))),b},set:function(a,b,c){var d,e=this.cache(a);if("string"==typeof b)e[r.camelCase(b)]=c;else for(d in b)e[r.camelCase(d)]=b[d];return e},get:function(a,b){return void 0===b?this.cache(a):a[this.expando]&&a[this.expando][r.camelCase(b)]},access:function(a,b,c){return void 0===b||b&&"string"==typeof b&&void 0===c?this.get(a,b):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d=a[this.expando];if(void 0!==d){if(void 0!==b){Array.isArray(b)?b=b.map(r.camelCase):(b=r.camelCase(b),b=b in d?[b]:b.match(L)||[]),c=b.length;while(c--)delete d[b[c]]}(void 0===b||r.isEmptyObject(d))&&(a.nodeType?a[this.expando]=void 0:delete a[this.expando])}},hasData:function(a){var b=a[this.expando];return void 0!==b&&!r.isEmptyObject(b)}};var W=new V,X=new V,Y=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,Z=/[A-Z]/g;function $(a){return"true"===a||"false"!==a&&("null"===a?null:a===+a+""?+a:Y.test(a)?JSON.parse(a):a)}function _(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d="data-"+b.replace(Z,"-$&").toLowerCase(),c=a.getAttribute(d),"string"==typeof c){try{c=$(c)}catch(e){}X.set(a,b,c)}else c=void 0;return c}r.extend({hasData:function(a){return X.hasData(a)||W.hasData(a)},data:function(a,b,c){return X.access(a,b,c)},removeData:function(a,b){X.remove(a,b)},_data:function(a,b,c){return W.access(a,b,c)},_removeData:function(a,b){W.remove(a,b)}}),r.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=X.get(f),1===f.nodeType&&!W.get(f,"hasDataAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=r.camelCase(d.slice(5)),_(f,d,e[d])));W.set(f,"hasDataAttrs",!0)}return e}return"object"==typeof a?this.each(function(){X.set(this,a)}):T(this,function(b){var c;if(f&&void 0===b){if(c=X.get(f,a),void 0!==c)return c;if(c=_(f,a),void 0!==c)return c}else this.each(function(){X.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){X.remove(this,a)})}}),r.extend({queue:function(a,b,c){var d;if(a)return b=(b||"fx")+"queue",d=W.get(a,b),c&&(!d||Array.isArray(c)?d=W.access(a,b,r.makeArray(c)):d.push(c)),d||[]},dequeue:function(a,b){b=b||"fx";var c=r.queue(a,b),d=c.length,e=c.shift(),f=r._queueHooks(a,b),g=function(){r.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return W.get(a,c)||W.access(a,c,{empty:r.Callbacks("once memory").add(function(){W.remove(a,[b+"queue",c])})})}}),r.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?r.queue(this[0],a):void 0===b?this:this.each(function(){var c=r.queue(this,a,b);r._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&r.dequeue(this,a)})},dequeue:function(a){return this.each(function(){r.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=r.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=W.get(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var aa=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,ba=new RegExp("^(?:([+-])=|)("+aa+")([a-z%]*)$","i"),ca=["Top","Right","Bottom","Left"],da=function(a,b){return a=b||a,"none"===a.style.display||""===a.style.display&&r.contains(a.ownerDocument,a)&&"none"===r.css(a,"display")},ea=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};function fa(a,b,c,d){var e,f=1,g=20,h=d?function(){return d.cur()}:function(){return r.css(a,b,"")},i=h(),j=c&&c[3]||(r.cssNumber[b]?"":"px"),k=(r.cssNumber[b]||"px"!==j&&+i)&&ba.exec(r.css(a,b));if(k&&k[3]!==j){j=j||k[3],c=c||[],k=+i||1;do f=f||".5",k/=f,r.style(a,b,k+j);while(f!==(f=h()/i)&&1!==f&&--g)}return c&&(k=+k||+i||0,e=c[1]?k+(c[1]+1)*c[2]:+c[2],d&&(d.unit=j,d.start=k,d.end=e)),e}var ga={};function ha(a){var b,c=a.ownerDocument,d=a.nodeName,e=ga[d];return e?e:(b=c.body.appendChild(c.createElement(d)),e=r.css(b,"display"),b.parentNode.removeChild(b),"none"===e&&(e="block"),ga[d]=e,e)}function ia(a,b){for(var c,d,e=[],f=0,g=a.length;f<g;f++)d=a[f],d.style&&(c=d.style.display,b?("none"===c&&(e[f]=W.get(d,"display")||null,e[f]||(d.style.display="")),""===d.style.display&&da(d)&&(e[f]=ha(d))):"none"!==c&&(e[f]="none",W.set(d,"display",c)));for(f=0;f<g;f++)null!=e[f]&&(a[f].style.display=e[f]);return a}r.fn.extend({show:function(){return ia(this,!0)},hide:function(){return ia(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){da(this)?r(this).show():r(this).hide()})}});var ja=/^(?:checkbox|radio)$/i,ka=/<([a-z][^\/\0>\x20\t\r\n\f]+)/i,la=/^$|\/(?:java|ecma)script/i,ma={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};ma.optgroup=ma.option,ma.tbody=ma.tfoot=ma.colgroup=ma.caption=ma.thead,ma.th=ma.td;function na(a,b){var c;return c="undefined"!=typeof a.getElementsByTagName?a.getElementsByTagName(b||"*"):"undefined"!=typeof a.querySelectorAll?a.querySelectorAll(b||"*"):[],void 0===b||b&&B(a,b)?r.merge([a],c):c}function oa(a,b){for(var c=0,d=a.length;c<d;c++)W.set(a[c],"globalEval",!b||W.get(b[c],"globalEval"))}var pa=/<|&#?\w+;/;function qa(a,b,c,d,e){for(var f,g,h,i,j,k,l=b.createDocumentFragment(),m=[],n=0,o=a.length;n<o;n++)if(f=a[n],f||0===f)if("object"===r.type(f))r.merge(m,f.nodeType?[f]:f);else if(pa.test(f)){g=g||l.appendChild(b.createElement("div")),h=(ka.exec(f)||["",""])[1].toLowerCase(),i=ma[h]||ma._default,g.innerHTML=i[1]+r.htmlPrefilter(f)+i[2],k=i[0];while(k--)g=g.lastChild;r.merge(m,g.childNodes),g=l.firstChild,g.textContent=""}else m.push(b.createTextNode(f));l.textContent="",n=0;while(f=m[n++])if(d&&r.inArray(f,d)>-1)e&&e.push(f);else if(j=r.contains(f.ownerDocument,f),g=na(l.appendChild(f),"script"),j&&oa(g),c){k=0;while(f=g[k++])la.test(f.type||"")&&c.push(f)}return l}!function(){var a=d.createDocumentFragment(),b=a.appendChild(d.createElement("div")),c=d.createElement("input");c.setAttribute("type","radio"),c.setAttribute("checked","checked"),c.setAttribute("name","t"),b.appendChild(c),o.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML="<textarea>x</textarea>",o.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var ra=d.documentElement,sa=/^key/,ta=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,ua=/^([^.]*)(?:\.(.+)|)/;function va(){return!0}function wa(){return!1}function xa(){try{return d.activeElement}catch(a){}}function ya(a,b,c,d,e,f){var g,h;if("object"==typeof b){"string"!=typeof c&&(d=d||c,c=void 0);for(h in b)ya(a,h,c,d,b[h],f);return a}if(null==d&&null==e?(e=c,d=c=void 0):null==e&&("string"==typeof c?(e=d,d=void 0):(e=d,d=c,c=void 0)),e===!1)e=wa;else if(!e)return a;return 1===f&&(g=e,e=function(a){return r().off(a),g.apply(this,arguments)},e.guid=g.guid||(g.guid=r.guid++)),a.each(function(){r.event.add(this,b,e,d,c)})}r.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,p,q=W.get(a);if(q){c.handler&&(f=c,c=f.handler,e=f.selector),e&&r.find.matchesSelector(ra,e),c.guid||(c.guid=r.guid++),(i=q.events)||(i=q.events={}),(g=q.handle)||(g=q.handle=function(b){return"undefined"!=typeof r&&r.event.triggered!==b.type?r.event.dispatch.apply(a,arguments):void 0}),b=(b||"").match(L)||[""],j=b.length;while(j--)h=ua.exec(b[j])||[],n=p=h[1],o=(h[2]||"").split(".").sort(),n&&(l=r.event.special[n]||{},n=(e?l.delegateType:l.bindType)||n,l=r.event.special[n]||{},k=r.extend({type:n,origType:p,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&r.expr.match.needsContext.test(e),namespace:o.join(".")},f),(m=i[n])||(m=i[n]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,o,g)!==!1||a.addEventListener&&a.addEventListener(n,g)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),r.event.global[n]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,p,q=W.hasData(a)&&W.get(a);if(q&&(i=q.events)){b=(b||"").match(L)||[""],j=b.length;while(j--)if(h=ua.exec(b[j])||[],n=p=h[1],o=(h[2]||"").split(".").sort(),n){l=r.event.special[n]||{},n=(d?l.delegateType:l.bindType)||n,m=i[n]||[],h=h[2]&&new RegExp("(^|\\.)"+o.join("\\.(?:.*\\.|)")+"(\\.|$)"),g=f=m.length;while(f--)k=m[f],!e&&p!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&("**"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,o,q.handle)!==!1||r.removeEvent(a,n,q.handle),delete i[n])}else for(n in i)r.event.remove(a,n+b[j],c,d,!0);r.isEmptyObject(i)&&W.remove(a,"handle events")}},dispatch:function(a){var b=r.event.fix(a),c,d,e,f,g,h,i=new Array(arguments.length),j=(W.get(this,"events")||{})[b.type]||[],k=r.event.special[b.type]||{};for(i[0]=b,c=1;c<arguments.length;c++)i[c]=arguments[c];if(b.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,b)!==!1){h=r.event.handlers.call(this,b,j),c=0;while((f=h[c++])&&!b.isPropagationStopped()){b.currentTarget=f.elem,d=0;while((g=f.handlers[d++])&&!b.isImmediatePropagationStopped())b.rnamespace&&!b.rnamespace.test(g.namespace)||(b.handleObj=g,b.data=g.data,e=((r.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==e&&(b.result=e)===!1&&(b.preventDefault(),b.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,b),b.result}},handlers:function(a,b){var c,d,e,f,g,h=[],i=b.delegateCount,j=a.target;if(i&&j.nodeType&&!("click"===a.type&&a.button>=1))for(;j!==this;j=j.parentNode||this)if(1===j.nodeType&&("click"!==a.type||j.disabled!==!0)){for(f=[],g={},c=0;c<i;c++)d=b[c],e=d.selector+" ",void 0===g[e]&&(g[e]=d.needsContext?r(e,this).index(j)>-1:r.find(e,this,null,[j]).length),g[e]&&f.push(d);f.length&&h.push({elem:j,handlers:f})}return j=this,i<b.length&&h.push({elem:j,handlers:b.slice(i)}),h},addProp:function(a,b){Object.defineProperty(r.Event.prototype,a,{enumerable:!0,configurable:!0,get:r.isFunction(b)?function(){if(this.originalEvent)return b(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[a]},set:function(b){Object.defineProperty(this,a,{enumerable:!0,configurable:!0,writable:!0,value:b})}})},fix:function(a){return a[r.expando]?a:new r.Event(a)},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==xa()&&this.focus)return this.focus(),!1},delegateType:"focusin"},blur:{trigger:function(){if(this===xa()&&this.blur)return this.blur(),!1},delegateType:"focusout"},click:{trigger:function(){if("checkbox"===this.type&&this.click&&B(this,"input"))return this.click(),!1},_default:function(a){return B(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}}},r.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c)},r.Event=function(a,b){return this instanceof r.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?va:wa,this.target=a.target&&3===a.target.nodeType?a.target.parentNode:a.target,this.currentTarget=a.currentTarget,this.relatedTarget=a.relatedTarget):this.type=a,b&&r.extend(this,b),this.timeStamp=a&&a.timeStamp||r.now(),void(this[r.expando]=!0)):new r.Event(a,b)},r.Event.prototype={constructor:r.Event,isDefaultPrevented:wa,isPropagationStopped:wa,isImmediatePropagationStopped:wa,isSimulated:!1,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=va,a&&!this.isSimulated&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=va,a&&!this.isSimulated&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=va,a&&!this.isSimulated&&a.stopImmediatePropagation(),this.stopPropagation()}},r.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(a){var b=a.button;return null==a.which&&sa.test(a.type)?null!=a.charCode?a.charCode:a.keyCode:!a.which&&void 0!==b&&ta.test(a.type)?1&b?1:2&b?3:4&b?2:0:a.which}},r.event.addProp),r.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){r.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return e&&(e===d||r.contains(d,e))||(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),r.fn.extend({on:function(a,b,c,d){return ya(this,a,b,c,d)},one:function(a,b,c,d){return ya(this,a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,r(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return b!==!1&&"function"!=typeof b||(c=b,b=void 0),c===!1&&(c=wa),this.each(function(){r.event.remove(this,a,c,b)})}});var za=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,Aa=/<script|<style|<link/i,Ba=/checked\s*(?:[^=]|=\s*.checked.)/i,Ca=/^true\/(.*)/,Da=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function Ea(a,b){return B(a,"table")&&B(11!==b.nodeType?b:b.firstChild,"tr")?r(">tbody",a)[0]||a:a}function Fa(a){return a.type=(null!==a.getAttribute("type"))+"/"+a.type,a}function Ga(a){var b=Ca.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function Ha(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(W.hasData(a)&&(f=W.access(a),g=W.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;c<d;c++)r.event.add(b,e,j[e][c])}X.hasData(a)&&(h=X.access(a),i=r.extend({},h),X.set(b,i))}}function Ia(a,b){var c=b.nodeName.toLowerCase();"input"===c&&ja.test(a.type)?b.checked=a.checked:"input"!==c&&"textarea"!==c||(b.defaultValue=a.defaultValue)}function Ja(a,b,c,d){b=g.apply([],b);var e,f,h,i,j,k,l=0,m=a.length,n=m-1,q=b[0],s=r.isFunction(q);if(s||m>1&&"string"==typeof q&&!o.checkClone&&Ba.test(q))return a.each(function(e){var f=a.eq(e);s&&(b[0]=q.call(this,e,f.html())),Ja(f,b,c,d)});if(m&&(e=qa(b,a[0].ownerDocument,!1,a,d),f=e.firstChild,1===e.childNodes.length&&(e=f),f||d)){for(h=r.map(na(e,"script"),Fa),i=h.length;l<m;l++)j=e,l!==n&&(j=r.clone(j,!0,!0),i&&r.merge(h,na(j,"script"))),c.call(a[l],j,l);if(i)for(k=h[h.length-1].ownerDocument,r.map(h,Ga),l=0;l<i;l++)j=h[l],la.test(j.type||"")&&!W.access(j,"globalEval")&&r.contains(k,j)&&(j.src?r._evalUrl&&r._evalUrl(j.src):p(j.textContent.replace(Da,""),k))}return a}function Ka(a,b,c){for(var d,e=b?r.filter(b,a):a,f=0;null!=(d=e[f]);f++)c||1!==d.nodeType||r.cleanData(na(d)),d.parentNode&&(c&&r.contains(d.ownerDocument,d)&&oa(na(d,"script")),d.parentNode.removeChild(d));return a}r.extend({htmlPrefilter:function(a){return a.replace(za,"<$1></$2>")},clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=r.contains(a.ownerDocument,a);if(!(o.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||r.isXMLDoc(a)))for(g=na(h),f=na(a),d=0,e=f.length;d<e;d++)Ia(f[d],g[d]);if(b)if(c)for(f=f||na(a),g=g||na(h),d=0,e=f.length;d<e;d++)Ha(f[d],g[d]);else Ha(a,h);return g=na(h,"script"),g.length>0&&oa(g,!i&&na(a,"script")),h},cleanData:function(a){for(var b,c,d,e=r.event.special,f=0;void 0!==(c=a[f]);f++)if(U(c)){if(b=c[W.expando]){if(b.events)for(d in b.events)e[d]?r.event.remove(c,d):r.removeEvent(c,d,b.handle);c[W.expando]=void 0}c[X.expando]&&(c[X.expando]=void 0)}}}),r.fn.extend({detach:function(a){return Ka(this,a,!0)},remove:function(a){return Ka(this,a)},text:function(a){return T(this,function(a){return void 0===a?r.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=a)})},null,a,arguments.length)},append:function(){return Ja(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Ea(this,a);b.appendChild(a)}})},prepend:function(){return Ja(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Ea(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return Ja(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return Ja(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(r.cleanData(na(a,!1)),a.textContent="");return this},clone:function(a,b){return a=null!=a&&a,b=null==b?a:b,this.map(function(){return r.clone(this,a,b)})},html:function(a){return T(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if("string"==typeof a&&!Aa.test(a)&&!ma[(ka.exec(a)||["",""])[1].toLowerCase()]){a=r.htmlPrefilter(a);try{for(;c<d;c++)b=this[c]||{},1===b.nodeType&&(r.cleanData(na(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=[];return Ja(this,arguments,function(b){var c=this.parentNode;r.inArray(this,a)<0&&(r.cleanData(na(this)),c&&c.replaceChild(b,this))},a)}}),r.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){r.fn[a]=function(a){for(var c,d=[],e=r(a),f=e.length-1,g=0;g<=f;g++)c=g===f?this:this.clone(!0),r(e[g])[b](c),h.apply(d,c.get());return this.pushStack(d)}});var La=/^margin/,Ma=new RegExp("^("+aa+")(?!px)[a-z%]+$","i"),Na=function(b){var c=b.ownerDocument.defaultView;return c&&c.opener||(c=a),c.getComputedStyle(b)};!function(){function b(){if(i){i.style.cssText="box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%",i.innerHTML="",ra.appendChild(h);var b=a.getComputedStyle(i);c="1%"!==b.top,g="2px"===b.marginLeft,e="4px"===b.width,i.style.marginRight="50%",f="4px"===b.marginRight,ra.removeChild(h),i=null}}var c,e,f,g,h=d.createElement("div"),i=d.createElement("div");i.style&&(i.style.backgroundClip="content-box",i.cloneNode(!0).style.backgroundClip="",o.clearCloneStyle="content-box"===i.style.backgroundClip,h.style.cssText="border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute",h.appendChild(i),r.extend(o,{pixelPosition:function(){return b(),c},boxSizingReliable:function(){return b(),e},pixelMarginRight:function(){return b(),f},reliableMarginLeft:function(){return b(),g}}))}();function Oa(a,b,c){var d,e,f,g,h=a.style;return c=c||Na(a),c&&(g=c.getPropertyValue(b)||c[b],""!==g||r.contains(a.ownerDocument,a)||(g=r.style(a,b)),!o.pixelMarginRight()&&Ma.test(g)&&La.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0!==g?g+"":g}function Pa(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}var Qa=/^(none|table(?!-c[ea]).+)/,Ra=/^--/,Sa={position:"absolute",visibility:"hidden",display:"block"},Ta={letterSpacing:"0",fontWeight:"400"},Ua=["Webkit","Moz","ms"],Va=d.createElement("div").style;function Wa(a){if(a in Va)return a;var b=a[0].toUpperCase()+a.slice(1),c=Ua.length;while(c--)if(a=Ua[c]+b,a in Va)return a}function Xa(a){var b=r.cssProps[a];return b||(b=r.cssProps[a]=Wa(a)||a),b}function Ya(a,b,c){var d=ba.exec(b);return d?Math.max(0,d[2]-(c||0))+(d[3]||"px"):b}function Za(a,b,c,d,e){var f,g=0;for(f=c===(d?"border":"content")?4:"width"===b?1:0;f<4;f+=2)"margin"===c&&(g+=r.css(a,c+ca[f],!0,e)),d?("content"===c&&(g-=r.css(a,"padding"+ca[f],!0,e)),"margin"!==c&&(g-=r.css(a,"border"+ca[f]+"Width",!0,e))):(g+=r.css(a,"padding"+ca[f],!0,e),"padding"!==c&&(g+=r.css(a,"border"+ca[f]+"Width",!0,e)));return g}function $a(a,b,c){var d,e=Na(a),f=Oa(a,b,e),g="border-box"===r.css(a,"boxSizing",!1,e);return Ma.test(f)?f:(d=g&&(o.boxSizingReliable()||f===a.style[b]),"auto"===f&&(f=a["offset"+b[0].toUpperCase()+b.slice(1)]),f=parseFloat(f)||0,f+Za(a,b,c||(g?"border":"content"),d,e)+"px")}r.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Oa(a,"opacity");return""===c?"1":c}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=r.camelCase(b),i=Ra.test(b),j=a.style;return i||(b=Xa(h)),g=r.cssHooks[b]||r.cssHooks[h],void 0===c?g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:j[b]:(f=typeof c,"string"===f&&(e=ba.exec(c))&&e[1]&&(c=fa(a,b,e),f="number"),null!=c&&c===c&&("number"===f&&(c+=e&&e[3]||(r.cssNumber[h]?"":"px")),o.clearCloneStyle||""!==c||0!==b.indexOf("background")||(j[b]="inherit"),g&&"set"in g&&void 0===(c=g.set(a,c,d))||(i?j.setProperty(b,c):j[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=r.camelCase(b),i=Ra.test(b);return i||(b=Xa(h)),g=r.cssHooks[b]||r.cssHooks[h],g&&"get"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=Oa(a,b,d)),"normal"===e&&b in Ta&&(e=Ta[b]),""===c||c?(f=parseFloat(e),c===!0||isFinite(f)?f||0:e):e}}),r.each(["height","width"],function(a,b){r.cssHooks[b]={get:function(a,c,d){if(c)return!Qa.test(r.css(a,"display"))||a.getClientRects().length&&a.getBoundingClientRect().width?$a(a,b,d):ea(a,Sa,function(){return $a(a,b,d)})},set:function(a,c,d){var e,f=d&&Na(a),g=d&&Za(a,b,d,"border-box"===r.css(a,"boxSizing",!1,f),f);return g&&(e=ba.exec(c))&&"px"!==(e[3]||"px")&&(a.style[b]=c,c=r.css(a,b)),Ya(a,c,g)}}}),r.cssHooks.marginLeft=Pa(o.reliableMarginLeft,function(a,b){if(b)return(parseFloat(Oa(a,"marginLeft"))||a.getBoundingClientRect().left-ea(a,{marginLeft:0},function(){return a.getBoundingClientRect().left}))+"px"}),r.each({margin:"",padding:"",border:"Width"},function(a,b){r.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];d<4;d++)e[a+ca[d]+b]=f[d]||f[d-2]||f[0];return e}},La.test(a)||(r.cssHooks[a+b].set=Ya)}),r.fn.extend({css:function(a,b){return T(this,function(a,b,c){var d,e,f={},g=0;if(Array.isArray(b)){for(d=Na(a),e=b.length;g<e;g++)f[b[g]]=r.css(a,b[g],!1,d);return f}return void 0!==c?r.style(a,b,c):r.css(a,b)},a,b,arguments.length>1)}});function _a(a,b,c,d,e){return new _a.prototype.init(a,b,c,d,e)}r.Tween=_a,_a.prototype={constructor:_a,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||r.easing._default,this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(r.cssNumber[c]?"":"px")},cur:function(){var a=_a.propHooks[this.prop];return a&&a.get?a.get(this):_a.propHooks._default.get(this)},run:function(a){var b,c=_a.propHooks[this.prop];return this.options.duration?this.pos=b=r.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):_a.propHooks._default.set(this),this}},_a.prototype.init.prototype=_a.prototype,_a.propHooks={_default:{get:function(a){var b;return 1!==a.elem.nodeType||null!=a.elem[a.prop]&&null==a.elem.style[a.prop]?a.elem[a.prop]:(b=r.css(a.elem,a.prop,""),b&&"auto"!==b?b:0)},set:function(a){r.fx.step[a.prop]?r.fx.step[a.prop](a):1!==a.elem.nodeType||null==a.elem.style[r.cssProps[a.prop]]&&!r.cssHooks[a.prop]?a.elem[a.prop]=a.now:r.style(a.elem,a.prop,a.now+a.unit)}}},_a.propHooks.scrollTop=_a.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},r.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2},_default:"swing"},r.fx=_a.prototype.init,r.fx.step={};var ab,bb,cb=/^(?:toggle|show|hide)$/,db=/queueHooks$/;function eb(){bb&&(d.hidden===!1&&a.requestAnimationFrame?a.requestAnimationFrame(eb):a.setTimeout(eb,r.fx.interval),r.fx.tick())}function fb(){return a.setTimeout(function(){ab=void 0}),ab=r.now()}function gb(a,b){var c,d=0,e={height:a};for(b=b?1:0;d<4;d+=2-b)c=ca[d],e["margin"+c]=e["padding"+c]=a;return b&&(e.opacity=e.width=a),e}function hb(a,b,c){for(var d,e=(kb.tweeners[b]||[]).concat(kb.tweeners["*"]),f=0,g=e.length;f<g;f++)if(d=e[f].call(c,b,a))return d}function ib(a,b,c){var d,e,f,g,h,i,j,k,l="width"in b||"height"in b,m=this,n={},o=a.style,p=a.nodeType&&da(a),q=W.get(a,"fxshow");c.queue||(g=r._queueHooks(a,"fx"),null==g.unqueued&&(g.unqueued=0,h=g.empty.fire,g.empty.fire=function(){g.unqueued||h()}),g.unqueued++,m.always(function(){m.always(function(){g.unqueued--,r.queue(a,"fx").length||g.empty.fire()})}));for(d in b)if(e=b[d],cb.test(e)){if(delete b[d],f=f||"toggle"===e,e===(p?"hide":"show")){if("show"!==e||!q||void 0===q[d])continue;p=!0}n[d]=q&&q[d]||r.style(a,d)}if(i=!r.isEmptyObject(b),i||!r.isEmptyObject(n)){l&&1===a.nodeType&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=q&&q.display,null==j&&(j=W.get(a,"display")),k=r.css(a,"display"),"none"===k&&(j?k=j:(ia([a],!0),j=a.style.display||j,k=r.css(a,"display"),ia([a]))),("inline"===k||"inline-block"===k&&null!=j)&&"none"===r.css(a,"float")&&(i||(m.done(function(){o.display=j}),null==j&&(k=o.display,j="none"===k?"":k)),o.display="inline-block")),c.overflow&&(o.overflow="hidden",m.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]})),i=!1;for(d in n)i||(q?"hidden"in q&&(p=q.hidden):q=W.access(a,"fxshow",{display:j}),f&&(q.hidden=!p),p&&ia([a],!0),m.done(function(){p||ia([a]),W.remove(a,"fxshow");for(d in n)r.style(a,d,n[d])})),i=hb(p?q[d]:0,d,m),d in q||(q[d]=i.start,p&&(i.end=i.start,i.start=0))}}function jb(a,b){var c,d,e,f,g;for(c in a)if(d=r.camelCase(c),e=b[d],f=a[c],Array.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=r.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function kb(a,b,c){var d,e,f=0,g=kb.prefilters.length,h=r.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=ab||fb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;g<i;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),f<1&&i?c:(i||h.notifyWith(a,[j,1,0]),h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:r.extend({},b),opts:r.extend(!0,{specialEasing:{},easing:r.easing._default},c),originalProperties:b,originalOptions:c,startTime:ab||fb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=r.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;c<d;c++)j.tweens[c].run(1);return b?(h.notifyWith(a,[j,1,0]),h.resolveWith(a,[j,b])):h.rejectWith(a,[j,b]),this}}),k=j.props;for(jb(k,j.opts.specialEasing);f<g;f++)if(d=kb.prefilters[f].call(j,a,k,j.opts))return r.isFunction(d.stop)&&(r._queueHooks(j.elem,j.opts.queue).stop=r.proxy(d.stop,d)),d;return r.map(k,hb,j),r.isFunction(j.opts.start)&&j.opts.start.call(a,j),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always),r.fx.timer(r.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j}r.Animation=r.extend(kb,{tweeners:{"*":[function(a,b){var c=this.createTween(a,b);return fa(c.elem,a,ba.exec(b),c),c}]},tweener:function(a,b){r.isFunction(a)?(b=a,a=["*"]):a=a.match(L);for(var c,d=0,e=a.length;d<e;d++)c=a[d],kb.tweeners[c]=kb.tweeners[c]||[],kb.tweeners[c].unshift(b)},prefilters:[ib],prefilter:function(a,b){b?kb.prefilters.unshift(a):kb.prefilters.push(a)}}),r.speed=function(a,b,c){var d=a&&"object"==typeof a?r.extend({},a):{complete:c||!c&&b||r.isFunction(a)&&a,duration:a,easing:c&&b||b&&!r.isFunction(b)&&b};return r.fx.off?d.duration=0:"number"!=typeof d.duration&&(d.duration in r.fx.speeds?d.duration=r.fx.speeds[d.duration]:d.duration=r.fx.speeds._default),null!=d.queue&&d.queue!==!0||(d.queue="fx"),d.old=d.complete,d.complete=function(){r.isFunction(d.old)&&d.old.call(this),d.queue&&r.dequeue(this,d.queue)},d},r.fn.extend({fadeTo:function(a,b,c,d){return this.filter(da).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=r.isEmptyObject(a),f=r.speed(b,c,d),g=function(){var b=kb(this,r.extend({},a),f);(e||W.get(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=r.timers,g=W.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&db.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));!b&&c||r.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=W.get(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=r.timers,g=d?d.length:0;for(c.finish=!0,r.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;b<g;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),r.each(["toggle","show","hide"],function(a,b){var c=r.fn[b];r.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(gb(b,!0),a,d,e)}}),r.each({slideDown:gb("show"),slideUp:gb("hide"),slideToggle:gb("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){r.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),r.timers=[],r.fx.tick=function(){var a,b=0,c=r.timers;for(ab=r.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||r.fx.stop(),ab=void 0},r.fx.timer=function(a){r.timers.push(a),r.fx.start()},r.fx.interval=13,r.fx.start=function(){bb||(bb=!0,eb())},r.fx.stop=function(){bb=null},r.fx.speeds={slow:600,fast:200,_default:400},r.fn.delay=function(b,c){return b=r.fx?r.fx.speeds[b]||b:b,c=c||"fx",this.queue(c,function(c,d){var e=a.setTimeout(c,b);d.stop=function(){a.clearTimeout(e)}})},function(){var a=d.createElement("input"),b=d.createElement("select"),c=b.appendChild(d.createElement("option"));a.type="checkbox",o.checkOn=""!==a.value,o.optSelected=c.selected,a=d.createElement("input"),a.value="t",a.type="radio",o.radioValue="t"===a.value}();var lb,mb=r.expr.attrHandle;r.fn.extend({attr:function(a,b){return T(this,r.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){r.removeAttr(this,a)})}}),r.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return"undefined"==typeof a.getAttribute?r.prop(a,b,c):(1===f&&r.isXMLDoc(a)||(e=r.attrHooks[b.toLowerCase()]||(r.expr.match.bool.test(b)?lb:void 0)),void 0!==c?null===c?void r.removeAttr(a,b):e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:(a.setAttribute(b,c+""),c):e&&"get"in e&&null!==(d=e.get(a,b))?d:(d=r.find.attr(a,b),
null==d?void 0:d))},attrHooks:{type:{set:function(a,b){if(!o.radioValue&&"radio"===b&&B(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}},removeAttr:function(a,b){var c,d=0,e=b&&b.match(L);if(e&&1===a.nodeType)while(c=e[d++])a.removeAttribute(c)}}),lb={set:function(a,b,c){return b===!1?r.removeAttr(a,c):a.setAttribute(c,c),c}},r.each(r.expr.match.bool.source.match(/\w+/g),function(a,b){var c=mb[b]||r.find.attr;mb[b]=function(a,b,d){var e,f,g=b.toLowerCase();return d||(f=mb[g],mb[g]=e,e=null!=c(a,b,d)?g:null,mb[g]=f),e}});var nb=/^(?:input|select|textarea|button)$/i,ob=/^(?:a|area)$/i;r.fn.extend({prop:function(a,b){return T(this,r.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[r.propFix[a]||a]})}}),r.extend({prop:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return 1===f&&r.isXMLDoc(a)||(b=r.propFix[b]||b,e=r.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=r.find.attr(a,"tabindex");return b?parseInt(b,10):nb.test(a.nodeName)||ob.test(a.nodeName)&&a.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),o.optSelected||(r.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null},set:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex)}}),r.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){r.propFix[this.toLowerCase()]=this});function pb(a){var b=a.match(L)||[];return b.join(" ")}function qb(a){return a.getAttribute&&a.getAttribute("class")||""}r.fn.extend({addClass:function(a){var b,c,d,e,f,g,h,i=0;if(r.isFunction(a))return this.each(function(b){r(this).addClass(a.call(this,b,qb(this)))});if("string"==typeof a&&a){b=a.match(L)||[];while(c=this[i++])if(e=qb(c),d=1===c.nodeType&&" "+pb(e)+" "){g=0;while(f=b[g++])d.indexOf(" "+f+" ")<0&&(d+=f+" ");h=pb(d),e!==h&&c.setAttribute("class",h)}}return this},removeClass:function(a){var b,c,d,e,f,g,h,i=0;if(r.isFunction(a))return this.each(function(b){r(this).removeClass(a.call(this,b,qb(this)))});if(!arguments.length)return this.attr("class","");if("string"==typeof a&&a){b=a.match(L)||[];while(c=this[i++])if(e=qb(c),d=1===c.nodeType&&" "+pb(e)+" "){g=0;while(f=b[g++])while(d.indexOf(" "+f+" ")>-1)d=d.replace(" "+f+" "," ");h=pb(d),e!==h&&c.setAttribute("class",h)}}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):r.isFunction(a)?this.each(function(c){r(this).toggleClass(a.call(this,c,qb(this),b),b)}):this.each(function(){var b,d,e,f;if("string"===c){d=0,e=r(this),f=a.match(L)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else void 0!==a&&"boolean"!==c||(b=qb(this),b&&W.set(this,"__className__",b),this.setAttribute&&this.setAttribute("class",b||a===!1?"":W.get(this,"__className__")||""))})},hasClass:function(a){var b,c,d=0;b=" "+a+" ";while(c=this[d++])if(1===c.nodeType&&(" "+pb(qb(c))+" ").indexOf(b)>-1)return!0;return!1}});var rb=/\r/g;r.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=r.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,r(this).val()):a,null==e?e="":"number"==typeof e?e+="":Array.isArray(e)&&(e=r.map(e,function(a){return null==a?"":a+""})),b=r.valHooks[this.type]||r.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=r.valHooks[e.type]||r.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(rb,""):null==c?"":c)}}}),r.extend({valHooks:{option:{get:function(a){var b=r.find.attr(a,"value");return null!=b?b:pb(r.text(a))}},select:{get:function(a){var b,c,d,e=a.options,f=a.selectedIndex,g="select-one"===a.type,h=g?null:[],i=g?f+1:e.length;for(d=f<0?i:g?f:0;d<i;d++)if(c=e[d],(c.selected||d===f)&&!c.disabled&&(!c.parentNode.disabled||!B(c.parentNode,"optgroup"))){if(b=r(c).val(),g)return b;h.push(b)}return h},set:function(a,b){var c,d,e=a.options,f=r.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=r.inArray(r.valHooks.option.get(d),f)>-1)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),r.each(["radio","checkbox"],function(){r.valHooks[this]={set:function(a,b){if(Array.isArray(b))return a.checked=r.inArray(r(a).val(),b)>-1}},o.checkOn||(r.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})});var sb=/^(?:focusinfocus|focusoutblur)$/;r.extend(r.event,{trigger:function(b,c,e,f){var g,h,i,j,k,m,n,o=[e||d],p=l.call(b,"type")?b.type:b,q=l.call(b,"namespace")?b.namespace.split("."):[];if(h=i=e=e||d,3!==e.nodeType&&8!==e.nodeType&&!sb.test(p+r.event.triggered)&&(p.indexOf(".")>-1&&(q=p.split("."),p=q.shift(),q.sort()),k=p.indexOf(":")<0&&"on"+p,b=b[r.expando]?b:new r.Event(p,"object"==typeof b&&b),b.isTrigger=f?2:3,b.namespace=q.join("."),b.rnamespace=b.namespace?new RegExp("(^|\\.)"+q.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=e),c=null==c?[b]:r.makeArray(c,[b]),n=r.event.special[p]||{},f||!n.trigger||n.trigger.apply(e,c)!==!1)){if(!f&&!n.noBubble&&!r.isWindow(e)){for(j=n.delegateType||p,sb.test(j+p)||(h=h.parentNode);h;h=h.parentNode)o.push(h),i=h;i===(e.ownerDocument||d)&&o.push(i.defaultView||i.parentWindow||a)}g=0;while((h=o[g++])&&!b.isPropagationStopped())b.type=g>1?j:n.bindType||p,m=(W.get(h,"events")||{})[b.type]&&W.get(h,"handle"),m&&m.apply(h,c),m=k&&h[k],m&&m.apply&&U(h)&&(b.result=m.apply(h,c),b.result===!1&&b.preventDefault());return b.type=p,f||b.isDefaultPrevented()||n._default&&n._default.apply(o.pop(),c)!==!1||!U(e)||k&&r.isFunction(e[p])&&!r.isWindow(e)&&(i=e[k],i&&(e[k]=null),r.event.triggered=p,e[p](),r.event.triggered=void 0,i&&(e[k]=i)),b.result}},simulate:function(a,b,c){var d=r.extend(new r.Event,c,{type:a,isSimulated:!0});r.event.trigger(d,null,b)}}),r.fn.extend({trigger:function(a,b){return this.each(function(){r.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];if(c)return r.event.trigger(a,b,c,!0)}}),r.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(a,b){r.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),r.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),o.focusin="onfocusin"in a,o.focusin||r.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){r.event.simulate(b,a.target,r.event.fix(a))};r.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=W.access(d,b);e||d.addEventListener(a,c,!0),W.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=W.access(d,b)-1;e?W.access(d,b,e):(d.removeEventListener(a,c,!0),W.remove(d,b))}}});var tb=a.location,ub=r.now(),vb=/\?/;r.parseXML=function(b){var c;if(!b||"string"!=typeof b)return null;try{c=(new a.DOMParser).parseFromString(b,"text/xml")}catch(d){c=void 0}return c&&!c.getElementsByTagName("parsererror").length||r.error("Invalid XML: "+b),c};var wb=/\[\]$/,xb=/\r?\n/g,yb=/^(?:submit|button|image|reset|file)$/i,zb=/^(?:input|select|textarea|keygen)/i;function Ab(a,b,c,d){var e;if(Array.isArray(b))r.each(b,function(b,e){c||wb.test(a)?d(a,e):Ab(a+"["+("object"==typeof e&&null!=e?b:"")+"]",e,c,d)});else if(c||"object"!==r.type(b))d(a,b);else for(e in b)Ab(a+"["+e+"]",b[e],c,d)}r.param=function(a,b){var c,d=[],e=function(a,b){var c=r.isFunction(b)?b():b;d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(null==c?"":c)};if(Array.isArray(a)||a.jquery&&!r.isPlainObject(a))r.each(a,function(){e(this.name,this.value)});else for(c in a)Ab(c,a[c],b,e);return d.join("&")},r.fn.extend({serialize:function(){return r.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=r.prop(this,"elements");return a?r.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!r(this).is(":disabled")&&zb.test(this.nodeName)&&!yb.test(a)&&(this.checked||!ja.test(a))}).map(function(a,b){var c=r(this).val();return null==c?null:Array.isArray(c)?r.map(c,function(a){return{name:b.name,value:a.replace(xb,"\r\n")}}):{name:b.name,value:c.replace(xb,"\r\n")}}).get()}});var Bb=/%20/g,Cb=/#.*$/,Db=/([?&])_=[^&]*/,Eb=/^(.*?):[ \t]*([^\r\n]*)$/gm,Fb=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Gb=/^(?:GET|HEAD)$/,Hb=/^\/\//,Ib={},Jb={},Kb="*/".concat("*"),Lb=d.createElement("a");Lb.href=tb.href;function Mb(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(L)||[];if(r.isFunction(c))while(d=f[e++])"+"===d[0]?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function Nb(a,b,c,d){var e={},f=a===Jb;function g(h){var i;return e[h]=!0,r.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function Ob(a,b){var c,d,e=r.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&r.extend(!0,a,d),a}function Pb(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader("Content-Type"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+" "+i[0]]){f=e;break}g||(g=e)}f=f||g}if(f)return f!==i[0]&&i.unshift(f),c[f]}function Qb(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}r.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:tb.href,type:"GET",isLocal:Fb.test(tb.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Kb,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":r.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?Ob(Ob(a,r.ajaxSettings),b):Ob(r.ajaxSettings,a)},ajaxPrefilter:Mb(Ib),ajaxTransport:Mb(Jb),ajax:function(b,c){"object"==typeof b&&(c=b,b=void 0),c=c||{};var e,f,g,h,i,j,k,l,m,n,o=r.ajaxSetup({},c),p=o.context||o,q=o.context&&(p.nodeType||p.jquery)?r(p):r.event,s=r.Deferred(),t=r.Callbacks("once memory"),u=o.statusCode||{},v={},w={},x="canceled",y={readyState:0,getResponseHeader:function(a){var b;if(k){if(!h){h={};while(b=Eb.exec(g))h[b[1].toLowerCase()]=b[2]}b=h[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return k?g:null},setRequestHeader:function(a,b){return null==k&&(a=w[a.toLowerCase()]=w[a.toLowerCase()]||a,v[a]=b),this},overrideMimeType:function(a){return null==k&&(o.mimeType=a),this},statusCode:function(a){var b;if(a)if(k)y.always(a[y.status]);else for(b in a)u[b]=[u[b],a[b]];return this},abort:function(a){var b=a||x;return e&&e.abort(b),A(0,b),this}};if(s.promise(y),o.url=((b||o.url||tb.href)+"").replace(Hb,tb.protocol+"//"),o.type=c.method||c.type||o.method||o.type,o.dataTypes=(o.dataType||"*").toLowerCase().match(L)||[""],null==o.crossDomain){j=d.createElement("a");try{j.href=o.url,j.href=j.href,o.crossDomain=Lb.protocol+"//"+Lb.host!=j.protocol+"//"+j.host}catch(z){o.crossDomain=!0}}if(o.data&&o.processData&&"string"!=typeof o.data&&(o.data=r.param(o.data,o.traditional)),Nb(Ib,o,c,y),k)return y;l=r.event&&o.global,l&&0===r.active++&&r.event.trigger("ajaxStart"),o.type=o.type.toUpperCase(),o.hasContent=!Gb.test(o.type),f=o.url.replace(Cb,""),o.hasContent?o.data&&o.processData&&0===(o.contentType||"").indexOf("application/x-www-form-urlencoded")&&(o.data=o.data.replace(Bb,"+")):(n=o.url.slice(f.length),o.data&&(f+=(vb.test(f)?"&":"?")+o.data,delete o.data),o.cache===!1&&(f=f.replace(Db,"$1"),n=(vb.test(f)?"&":"?")+"_="+ub++ +n),o.url=f+n),o.ifModified&&(r.lastModified[f]&&y.setRequestHeader("If-Modified-Since",r.lastModified[f]),r.etag[f]&&y.setRequestHeader("If-None-Match",r.etag[f])),(o.data&&o.hasContent&&o.contentType!==!1||c.contentType)&&y.setRequestHeader("Content-Type",o.contentType),y.setRequestHeader("Accept",o.dataTypes[0]&&o.accepts[o.dataTypes[0]]?o.accepts[o.dataTypes[0]]+("*"!==o.dataTypes[0]?", "+Kb+"; q=0.01":""):o.accepts["*"]);for(m in o.headers)y.setRequestHeader(m,o.headers[m]);if(o.beforeSend&&(o.beforeSend.call(p,y,o)===!1||k))return y.abort();if(x="abort",t.add(o.complete),y.done(o.success),y.fail(o.error),e=Nb(Jb,o,c,y)){if(y.readyState=1,l&&q.trigger("ajaxSend",[y,o]),k)return y;o.async&&o.timeout>0&&(i=a.setTimeout(function(){y.abort("timeout")},o.timeout));try{k=!1,e.send(v,A)}catch(z){if(k)throw z;A(-1,z)}}else A(-1,"No Transport");function A(b,c,d,h){var j,m,n,v,w,x=c;k||(k=!0,i&&a.clearTimeout(i),e=void 0,g=h||"",y.readyState=b>0?4:0,j=b>=200&&b<300||304===b,d&&(v=Pb(o,y,d)),v=Qb(o,v,y,j),j?(o.ifModified&&(w=y.getResponseHeader("Last-Modified"),w&&(r.lastModified[f]=w),w=y.getResponseHeader("etag"),w&&(r.etag[f]=w)),204===b||"HEAD"===o.type?x="nocontent":304===b?x="notmodified":(x=v.state,m=v.data,n=v.error,j=!n)):(n=x,!b&&x||(x="error",b<0&&(b=0))),y.status=b,y.statusText=(c||x)+"",j?s.resolveWith(p,[m,x,y]):s.rejectWith(p,[y,x,n]),y.statusCode(u),u=void 0,l&&q.trigger(j?"ajaxSuccess":"ajaxError",[y,o,j?m:n]),t.fireWith(p,[y,x]),l&&(q.trigger("ajaxComplete",[y,o]),--r.active||r.event.trigger("ajaxStop")))}return y},getJSON:function(a,b,c){return r.get(a,b,c,"json")},getScript:function(a,b){return r.get(a,void 0,b,"script")}}),r.each(["get","post"],function(a,b){r[b]=function(a,c,d,e){return r.isFunction(c)&&(e=e||d,d=c,c=void 0),r.ajax(r.extend({url:a,type:b,dataType:e,data:c,success:d},r.isPlainObject(a)&&a))}}),r._evalUrl=function(a){return r.ajax({url:a,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,"throws":!0})},r.fn.extend({wrapAll:function(a){var b;return this[0]&&(r.isFunction(a)&&(a=a.call(this[0])),b=r(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this},wrapInner:function(a){return r.isFunction(a)?this.each(function(b){r(this).wrapInner(a.call(this,b))}):this.each(function(){var b=r(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=r.isFunction(a);return this.each(function(c){r(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(a){return this.parent(a).not("body").each(function(){r(this).replaceWith(this.childNodes)}),this}}),r.expr.pseudos.hidden=function(a){return!r.expr.pseudos.visible(a)},r.expr.pseudos.visible=function(a){return!!(a.offsetWidth||a.offsetHeight||a.getClientRects().length)},r.ajaxSettings.xhr=function(){try{return new a.XMLHttpRequest}catch(b){}};var Rb={0:200,1223:204},Sb=r.ajaxSettings.xhr();o.cors=!!Sb&&"withCredentials"in Sb,o.ajax=Sb=!!Sb,r.ajaxTransport(function(b){var c,d;if(o.cors||Sb&&!b.crossDomain)return{send:function(e,f){var g,h=b.xhr();if(h.open(b.type,b.url,b.async,b.username,b.password),b.xhrFields)for(g in b.xhrFields)h[g]=b.xhrFields[g];b.mimeType&&h.overrideMimeType&&h.overrideMimeType(b.mimeType),b.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest");for(g in e)h.setRequestHeader(g,e[g]);c=function(a){return function(){c&&(c=d=h.onload=h.onerror=h.onabort=h.onreadystatechange=null,"abort"===a?h.abort():"error"===a?"number"!=typeof h.status?f(0,"error"):f(h.status,h.statusText):f(Rb[h.status]||h.status,h.statusText,"text"!==(h.responseType||"text")||"string"!=typeof h.responseText?{binary:h.response}:{text:h.responseText},h.getAllResponseHeaders()))}},h.onload=c(),d=h.onerror=c("error"),void 0!==h.onabort?h.onabort=d:h.onreadystatechange=function(){4===h.readyState&&a.setTimeout(function(){c&&d()})},c=c("abort");try{h.send(b.hasContent&&b.data||null)}catch(i){if(c)throw i}},abort:function(){c&&c()}}}),r.ajaxPrefilter(function(a){a.crossDomain&&(a.contents.script=!1)}),r.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(a){return r.globalEval(a),a}}}),r.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET")}),r.ajaxTransport("script",function(a){if(a.crossDomain){var b,c;return{send:function(e,f){b=r("<script>").prop({charset:a.scriptCharset,src:a.url}).on("load error",c=function(a){b.remove(),c=null,a&&f("error"===a.type?404:200,a.type)}),d.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Tb=[],Ub=/(=)\?(?=&|$)|\?\?/;r.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=Tb.pop()||r.expando+"_"+ub++;return this[a]=!0,a}}),r.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Ub.test(b.url)?"url":"string"==typeof b.data&&0===(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&Ub.test(b.data)&&"data");if(h||"jsonp"===b.dataTypes[0])return e=b.jsonpCallback=r.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Ub,"$1"+e):b.jsonp!==!1&&(b.url+=(vb.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||r.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){void 0===f?r(a).removeProp(e):a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Tb.push(e)),g&&r.isFunction(f)&&f(g[0]),g=f=void 0}),"script"}),o.createHTMLDocument=function(){var a=d.implementation.createHTMLDocument("").body;return a.innerHTML="<form></form><form></form>",2===a.childNodes.length}(),r.parseHTML=function(a,b,c){if("string"!=typeof a)return[];"boolean"==typeof b&&(c=b,b=!1);var e,f,g;return b||(o.createHTMLDocument?(b=d.implementation.createHTMLDocument(""),e=b.createElement("base"),e.href=d.location.href,b.head.appendChild(e)):b=d),f=C.exec(a),g=!c&&[],f?[b.createElement(f[1])]:(f=qa([a],b,g),g&&g.length&&r(g).remove(),r.merge([],f.childNodes))},r.fn.load=function(a,b,c){var d,e,f,g=this,h=a.indexOf(" ");return h>-1&&(d=pb(a.slice(h)),a=a.slice(0,h)),r.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(e="POST"),g.length>0&&r.ajax({url:a,type:e||"GET",dataType:"html",data:b}).done(function(a){f=arguments,g.html(d?r("<div>").append(r.parseHTML(a)).find(d):a)}).always(c&&function(a,b){g.each(function(){c.apply(this,f||[a.responseText,b,a])})}),this},r.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){r.fn[b]=function(a){return this.on(b,a)}}),r.expr.pseudos.animated=function(a){return r.grep(r.timers,function(b){return a===b.elem}).length},r.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=r.css(a,"position"),l=r(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=r.css(a,"top"),i=r.css(a,"left"),j=("absolute"===k||"fixed"===k)&&(f+i).indexOf("auto")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),r.isFunction(b)&&(b=b.call(a,c,r.extend({},h))),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},r.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){r.offset.setOffset(this,a,b)});var b,c,d,e,f=this[0];if(f)return f.getClientRects().length?(d=f.getBoundingClientRect(),b=f.ownerDocument,c=b.documentElement,e=b.defaultView,{top:d.top+e.pageYOffset-c.clientTop,left:d.left+e.pageXOffset-c.clientLeft}):{top:0,left:0}},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return"fixed"===r.css(c,"position")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),B(a[0],"html")||(d=a.offset()),d={top:d.top+r.css(a[0],"borderTopWidth",!0),left:d.left+r.css(a[0],"borderLeftWidth",!0)}),{top:b.top-d.top-r.css(c,"marginTop",!0),left:b.left-d.left-r.css(c,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent;while(a&&"static"===r.css(a,"position"))a=a.offsetParent;return a||ra})}}),r.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,b){var c="pageYOffset"===b;r.fn[a]=function(d){return T(this,function(a,d,e){var f;return r.isWindow(a)?f=a:9===a.nodeType&&(f=a.defaultView),void 0===e?f?f[b]:a[d]:void(f?f.scrollTo(c?f.pageXOffset:e,c?e:f.pageYOffset):a[d]=e)},a,d,arguments.length)}}),r.each(["top","left"],function(a,b){r.cssHooks[b]=Pa(o.pixelPosition,function(a,c){if(c)return c=Oa(a,b),Ma.test(c)?r(a).position()[b]+"px":c})}),r.each({Height:"height",Width:"width"},function(a,b){r.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){r.fn[d]=function(e,f){var g=arguments.length&&(c||"boolean"!=typeof e),h=c||(e===!0||f===!0?"margin":"border");return T(this,function(b,c,e){var f;return r.isWindow(b)?0===d.indexOf("outer")?b["inner"+a]:b.document.documentElement["client"+a]:9===b.nodeType?(f=b.documentElement,Math.max(b.body["scroll"+a],f["scroll"+a],b.body["offset"+a],f["offset"+a],f["client"+a])):void 0===e?r.css(b,c,h):r.style(b,c,e,h)},b,g?e:void 0,g)}})}),r.fn.extend({bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}}),r.holdReady=function(a){a?r.readyWait++:r.ready(!0)},r.isArray=Array.isArray,r.parseJSON=JSON.parse,r.nodeName=B,"function"==typeof define&&define.amd&&define("jquery",[],function(){return r});var Vb=a.jQuery,Wb=a.$;return r.noConflict=function(b){return a.$===r&&(a.$=Wb),b&&a.jQuery===r&&(a.jQuery=Vb),r},b||(a.jQuery=a.$=r),r});

/*! jQuery UI - v1.12.1 - 2016-09-14
* http://jqueryui.com
* Includes: widget.js, position.js, data.js, disable-selection.js, effect.js, effects/effect-blind.js, effects/effect-bounce.js, effects/effect-clip.js, effects/effect-drop.js, effects/effect-explode.js, effects/effect-fade.js, effects/effect-fold.js, effects/effect-highlight.js, effects/effect-puff.js, effects/effect-pulsate.js, effects/effect-scale.js, effects/effect-shake.js, effects/effect-size.js, effects/effect-slide.js, effects/effect-transfer.js, focusable.js, form-reset-mixin.js, jquery-1-7.js, keycode.js, labels.js, scroll-parent.js, tabbable.js, unique-id.js, widgets/accordion.js, widgets/autocomplete.js, widgets/button.js, widgets/checkboxradio.js, widgets/controlgroup.js, widgets/datepicker.js, widgets/dialog.js, widgets/draggable.js, widgets/droppable.js, widgets/menu.js, widgets/mouse.js, widgets/progressbar.js, widgets/resizable.js, widgets/selectable.js, widgets/selectmenu.js, widgets/slider.js, widgets/sortable.js, widgets/spinner.js, widgets/tabs.js, widgets/tooltip.js
* Copyright jQuery Foundation and other contributors; Licensed MIT */

(function(t){"function"==typeof define&&define.amd?define(["jquery"],t):t(jQuery)})(function(t){function e(t){for(var e=t.css("visibility");"inherit"===e;)t=t.parent(),e=t.css("visibility");return"hidden"!==e}function i(t){for(var e,i;t.length&&t[0]!==document;){if(e=t.css("position"),("absolute"===e||"relative"===e||"fixed"===e)&&(i=parseInt(t.css("zIndex"),10),!isNaN(i)&&0!==i))return i;t=t.parent()}return 0}function s(){this._curInst=null,this._keyEvent=!1,this._disabledInputs=[],this._datepickerShowing=!1,this._inDialog=!1,this._mainDivId="ui-datepicker-div",this._inlineClass="ui-datepicker-inline",this._appendClass="ui-datepicker-append",this._triggerClass="ui-datepicker-trigger",this._dialogClass="ui-datepicker-dialog",this._disableClass="ui-datepicker-disabled",this._unselectableClass="ui-datepicker-unselectable",this._currentClass="ui-datepicker-current-day",this._dayOverClass="ui-datepicker-days-cell-over",this.regional=[],this.regional[""]={closeText:"Done",prevText:"Prev",nextText:"Next",currentText:"Today",monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],monthNamesShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],dayNamesShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],dayNamesMin:["Su","Mo","Tu","We","Th","Fr","Sa"],weekHeader:"Wk",dateFormat:"mm/dd/yy",firstDay:0,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""},this._defaults={showOn:"focus",showAnim:"fadeIn",showOptions:{},defaultDate:null,appendText:"",buttonText:"...",buttonImage:"",buttonImageOnly:!1,hideIfNoPrevNext:!1,navigationAsDateFormat:!1,gotoCurrent:!1,changeMonth:!1,changeYear:!1,yearRange:"c-10:c+10",showOtherMonths:!1,selectOtherMonths:!1,showWeek:!1,calculateWeek:this.iso8601Week,shortYearCutoff:"+10",minDate:null,maxDate:null,duration:"fast",beforeShowDay:null,beforeShow:null,onSelect:null,onChangeMonthYear:null,onClose:null,numberOfMonths:1,showCurrentAtPos:0,stepMonths:1,stepBigMonths:12,altField:"",altFormat:"",constrainInput:!0,showButtonPanel:!1,autoSize:!1,disabled:!1},t.extend(this._defaults,this.regional[""]),this.regional.en=t.extend(!0,{},this.regional[""]),this.regional["en-US"]=t.extend(!0,{},this.regional.en),this.dpDiv=n(t("<div id='"+this._mainDivId+"' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"))}function n(e){var i="button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";return e.on("mouseout",i,function(){t(this).removeClass("ui-state-hover"),-1!==this.className.indexOf("ui-datepicker-prev")&&t(this).removeClass("ui-datepicker-prev-hover"),-1!==this.className.indexOf("ui-datepicker-next")&&t(this).removeClass("ui-datepicker-next-hover")}).on("mouseover",i,o)}function o(){t.datepicker._isDisabledDatepicker(m.inline?m.dpDiv.parent()[0]:m.input[0])||(t(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover"),t(this).addClass("ui-state-hover"),-1!==this.className.indexOf("ui-datepicker-prev")&&t(this).addClass("ui-datepicker-prev-hover"),-1!==this.className.indexOf("ui-datepicker-next")&&t(this).addClass("ui-datepicker-next-hover"))}function a(e,i){t.extend(e,i);for(var s in i)null==i[s]&&(e[s]=i[s]);return e}function r(t){return function(){var e=this.element.val();t.apply(this,arguments),this._refresh(),e!==this.element.val()&&this._trigger("change")}}t.ui=t.ui||{},t.ui.version="1.12.1";var h=0,l=Array.prototype.slice;t.cleanData=function(e){return function(i){var s,n,o;for(o=0;null!=(n=i[o]);o++)try{s=t._data(n,"events"),s&&s.remove&&t(n).triggerHandler("remove")}catch(a){}e(i)}}(t.cleanData),t.widget=function(e,i,s){var n,o,a,r={},h=e.split(".")[0];e=e.split(".")[1];var l=h+"-"+e;return s||(s=i,i=t.Widget),t.isArray(s)&&(s=t.extend.apply(null,[{}].concat(s))),t.expr[":"][l.toLowerCase()]=function(e){return!!t.data(e,l)},t[h]=t[h]||{},n=t[h][e],o=t[h][e]=function(t,e){return this._createWidget?(arguments.length&&this._createWidget(t,e),void 0):new o(t,e)},t.extend(o,n,{version:s.version,_proto:t.extend({},s),_childConstructors:[]}),a=new i,a.options=t.widget.extend({},a.options),t.each(s,function(e,s){return t.isFunction(s)?(r[e]=function(){function t(){return i.prototype[e].apply(this,arguments)}function n(t){return i.prototype[e].apply(this,t)}return function(){var e,i=this._super,o=this._superApply;return this._super=t,this._superApply=n,e=s.apply(this,arguments),this._super=i,this._superApply=o,e}}(),void 0):(r[e]=s,void 0)}),o.prototype=t.widget.extend(a,{widgetEventPrefix:n?a.widgetEventPrefix||e:e},r,{constructor:o,namespace:h,widgetName:e,widgetFullName:l}),n?(t.each(n._childConstructors,function(e,i){var s=i.prototype;t.widget(s.namespace+"."+s.widgetName,o,i._proto)}),delete n._childConstructors):i._childConstructors.push(o),t.widget.bridge(e,o),o},t.widget.extend=function(e){for(var i,s,n=l.call(arguments,1),o=0,a=n.length;a>o;o++)for(i in n[o])s=n[o][i],n[o].hasOwnProperty(i)&&void 0!==s&&(e[i]=t.isPlainObject(s)?t.isPlainObject(e[i])?t.widget.extend({},e[i],s):t.widget.extend({},s):s);return e},t.widget.bridge=function(e,i){var s=i.prototype.widgetFullName||e;t.fn[e]=function(n){var o="string"==typeof n,a=l.call(arguments,1),r=this;return o?this.length||"instance"!==n?this.each(function(){var i,o=t.data(this,s);return"instance"===n?(r=o,!1):o?t.isFunction(o[n])&&"_"!==n.charAt(0)?(i=o[n].apply(o,a),i!==o&&void 0!==i?(r=i&&i.jquery?r.pushStack(i.get()):i,!1):void 0):t.error("no such method '"+n+"' for "+e+" widget instance"):t.error("cannot call methods on "+e+" prior to initialization; "+"attempted to call method '"+n+"'")}):r=void 0:(a.length&&(n=t.widget.extend.apply(null,[n].concat(a))),this.each(function(){var e=t.data(this,s);e?(e.option(n||{}),e._init&&e._init()):t.data(this,s,new i(n,this))})),r}},t.Widget=function(){},t.Widget._childConstructors=[],t.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{classes:{},disabled:!1,create:null},_createWidget:function(e,i){i=t(i||this.defaultElement||this)[0],this.element=t(i),this.uuid=h++,this.eventNamespace="."+this.widgetName+this.uuid,this.bindings=t(),this.hoverable=t(),this.focusable=t(),this.classesElementLookup={},i!==this&&(t.data(i,this.widgetFullName,this),this._on(!0,this.element,{remove:function(t){t.target===i&&this.destroy()}}),this.document=t(i.style?i.ownerDocument:i.document||i),this.window=t(this.document[0].defaultView||this.document[0].parentWindow)),this.options=t.widget.extend({},this.options,this._getCreateOptions(),e),this._create(),this.options.disabled&&this._setOptionDisabled(this.options.disabled),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:function(){return{}},_getCreateEventData:t.noop,_create:t.noop,_init:t.noop,destroy:function(){var e=this;this._destroy(),t.each(this.classesElementLookup,function(t,i){e._removeClass(i,t)}),this.element.off(this.eventNamespace).removeData(this.widgetFullName),this.widget().off(this.eventNamespace).removeAttr("aria-disabled"),this.bindings.off(this.eventNamespace)},_destroy:t.noop,widget:function(){return this.element},option:function(e,i){var s,n,o,a=e;if(0===arguments.length)return t.widget.extend({},this.options);if("string"==typeof e)if(a={},s=e.split("."),e=s.shift(),s.length){for(n=a[e]=t.widget.extend({},this.options[e]),o=0;s.length-1>o;o++)n[s[o]]=n[s[o]]||{},n=n[s[o]];if(e=s.pop(),1===arguments.length)return void 0===n[e]?null:n[e];n[e]=i}else{if(1===arguments.length)return void 0===this.options[e]?null:this.options[e];a[e]=i}return this._setOptions(a),this},_setOptions:function(t){var e;for(e in t)this._setOption(e,t[e]);return this},_setOption:function(t,e){return"classes"===t&&this._setOptionClasses(e),this.options[t]=e,"disabled"===t&&this._setOptionDisabled(e),this},_setOptionClasses:function(e){var i,s,n;for(i in e)n=this.classesElementLookup[i],e[i]!==this.options.classes[i]&&n&&n.length&&(s=t(n.get()),this._removeClass(n,i),s.addClass(this._classes({element:s,keys:i,classes:e,add:!0})))},_setOptionDisabled:function(t){this._toggleClass(this.widget(),this.widgetFullName+"-disabled",null,!!t),t&&(this._removeClass(this.hoverable,null,"ui-state-hover"),this._removeClass(this.focusable,null,"ui-state-focus"))},enable:function(){return this._setOptions({disabled:!1})},disable:function(){return this._setOptions({disabled:!0})},_classes:function(e){function i(i,o){var a,r;for(r=0;i.length>r;r++)a=n.classesElementLookup[i[r]]||t(),a=e.add?t(t.unique(a.get().concat(e.element.get()))):t(a.not(e.element).get()),n.classesElementLookup[i[r]]=a,s.push(i[r]),o&&e.classes[i[r]]&&s.push(e.classes[i[r]])}var s=[],n=this;return e=t.extend({element:this.element,classes:this.options.classes||{}},e),this._on(e.element,{remove:"_untrackClassesElement"}),e.keys&&i(e.keys.match(/\S+/g)||[],!0),e.extra&&i(e.extra.match(/\S+/g)||[]),s.join(" ")},_untrackClassesElement:function(e){var i=this;t.each(i.classesElementLookup,function(s,n){-1!==t.inArray(e.target,n)&&(i.classesElementLookup[s]=t(n.not(e.target).get()))})},_removeClass:function(t,e,i){return this._toggleClass(t,e,i,!1)},_addClass:function(t,e,i){return this._toggleClass(t,e,i,!0)},_toggleClass:function(t,e,i,s){s="boolean"==typeof s?s:i;var n="string"==typeof t||null===t,o={extra:n?e:i,keys:n?t:e,element:n?this.element:t,add:s};return o.element.toggleClass(this._classes(o),s),this},_on:function(e,i,s){var n,o=this;"boolean"!=typeof e&&(s=i,i=e,e=!1),s?(i=n=t(i),this.bindings=this.bindings.add(i)):(s=i,i=this.element,n=this.widget()),t.each(s,function(s,a){function r(){return e||o.options.disabled!==!0&&!t(this).hasClass("ui-state-disabled")?("string"==typeof a?o[a]:a).apply(o,arguments):void 0}"string"!=typeof a&&(r.guid=a.guid=a.guid||r.guid||t.guid++);var h=s.match(/^([\w:-]*)\s*(.*)$/),l=h[1]+o.eventNamespace,c=h[2];c?n.on(l,c,r):i.on(l,r)})},_off:function(e,i){i=(i||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,e.off(i).off(i),this.bindings=t(this.bindings.not(e).get()),this.focusable=t(this.focusable.not(e).get()),this.hoverable=t(this.hoverable.not(e).get())},_delay:function(t,e){function i(){return("string"==typeof t?s[t]:t).apply(s,arguments)}var s=this;return setTimeout(i,e||0)},_hoverable:function(e){this.hoverable=this.hoverable.add(e),this._on(e,{mouseenter:function(e){this._addClass(t(e.currentTarget),null,"ui-state-hover")},mouseleave:function(e){this._removeClass(t(e.currentTarget),null,"ui-state-hover")}})},_focusable:function(e){this.focusable=this.focusable.add(e),this._on(e,{focusin:function(e){this._addClass(t(e.currentTarget),null,"ui-state-focus")},focusout:function(e){this._removeClass(t(e.currentTarget),null,"ui-state-focus")}})},_trigger:function(e,i,s){var n,o,a=this.options[e];if(s=s||{},i=t.Event(i),i.type=(e===this.widgetEventPrefix?e:this.widgetEventPrefix+e).toLowerCase(),i.target=this.element[0],o=i.originalEvent)for(n in o)n in i||(i[n]=o[n]);return this.element.trigger(i,s),!(t.isFunction(a)&&a.apply(this.element[0],[i].concat(s))===!1||i.isDefaultPrevented())}},t.each({show:"fadeIn",hide:"fadeOut"},function(e,i){t.Widget.prototype["_"+e]=function(s,n,o){"string"==typeof n&&(n={effect:n});var a,r=n?n===!0||"number"==typeof n?i:n.effect||i:e;n=n||{},"number"==typeof n&&(n={duration:n}),a=!t.isEmptyObject(n),n.complete=o,n.delay&&s.delay(n.delay),a&&t.effects&&t.effects.effect[r]?s[e](n):r!==e&&s[r]?s[r](n.duration,n.easing,o):s.queue(function(i){t(this)[e](),o&&o.call(s[0]),i()})}}),t.widget,function(){function e(t,e,i){return[parseFloat(t[0])*(u.test(t[0])?e/100:1),parseFloat(t[1])*(u.test(t[1])?i/100:1)]}function i(e,i){return parseInt(t.css(e,i),10)||0}function s(e){var i=e[0];return 9===i.nodeType?{width:e.width(),height:e.height(),offset:{top:0,left:0}}:t.isWindow(i)?{width:e.width(),height:e.height(),offset:{top:e.scrollTop(),left:e.scrollLeft()}}:i.preventDefault?{width:0,height:0,offset:{top:i.pageY,left:i.pageX}}:{width:e.outerWidth(),height:e.outerHeight(),offset:e.offset()}}var n,o=Math.max,a=Math.abs,r=/left|center|right/,h=/top|center|bottom/,l=/[\+\-]\d+(\.[\d]+)?%?/,c=/^\w+/,u=/%$/,d=t.fn.position;t.position={scrollbarWidth:function(){if(void 0!==n)return n;var e,i,s=t("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),o=s.children()[0];return t("body").append(s),e=o.offsetWidth,s.css("overflow","scroll"),i=o.offsetWidth,e===i&&(i=s[0].clientWidth),s.remove(),n=e-i},getScrollInfo:function(e){var i=e.isWindow||e.isDocument?"":e.element.css("overflow-x"),s=e.isWindow||e.isDocument?"":e.element.css("overflow-y"),n="scroll"===i||"auto"===i&&e.width<e.element[0].scrollWidth,o="scroll"===s||"auto"===s&&e.height<e.element[0].scrollHeight;return{width:o?t.position.scrollbarWidth():0,height:n?t.position.scrollbarWidth():0}},getWithinInfo:function(e){var i=t(e||window),s=t.isWindow(i[0]),n=!!i[0]&&9===i[0].nodeType,o=!s&&!n;return{element:i,isWindow:s,isDocument:n,offset:o?t(e).offset():{left:0,top:0},scrollLeft:i.scrollLeft(),scrollTop:i.scrollTop(),width:i.outerWidth(),height:i.outerHeight()}}},t.fn.position=function(n){if(!n||!n.of)return d.apply(this,arguments);n=t.extend({},n);var u,p,f,g,m,_,v=t(n.of),b=t.position.getWithinInfo(n.within),y=t.position.getScrollInfo(b),w=(n.collision||"flip").split(" "),k={};return _=s(v),v[0].preventDefault&&(n.at="left top"),p=_.width,f=_.height,g=_.offset,m=t.extend({},g),t.each(["my","at"],function(){var t,e,i=(n[this]||"").split(" ");1===i.length&&(i=r.test(i[0])?i.concat(["center"]):h.test(i[0])?["center"].concat(i):["center","center"]),i[0]=r.test(i[0])?i[0]:"center",i[1]=h.test(i[1])?i[1]:"center",t=l.exec(i[0]),e=l.exec(i[1]),k[this]=[t?t[0]:0,e?e[0]:0],n[this]=[c.exec(i[0])[0],c.exec(i[1])[0]]}),1===w.length&&(w[1]=w[0]),"right"===n.at[0]?m.left+=p:"center"===n.at[0]&&(m.left+=p/2),"bottom"===n.at[1]?m.top+=f:"center"===n.at[1]&&(m.top+=f/2),u=e(k.at,p,f),m.left+=u[0],m.top+=u[1],this.each(function(){var s,r,h=t(this),l=h.outerWidth(),c=h.outerHeight(),d=i(this,"marginLeft"),_=i(this,"marginTop"),x=l+d+i(this,"marginRight")+y.width,C=c+_+i(this,"marginBottom")+y.height,D=t.extend({},m),I=e(k.my,h.outerWidth(),h.outerHeight());"right"===n.my[0]?D.left-=l:"center"===n.my[0]&&(D.left-=l/2),"bottom"===n.my[1]?D.top-=c:"center"===n.my[1]&&(D.top-=c/2),D.left+=I[0],D.top+=I[1],s={marginLeft:d,marginTop:_},t.each(["left","top"],function(e,i){t.ui.position[w[e]]&&t.ui.position[w[e]][i](D,{targetWidth:p,targetHeight:f,elemWidth:l,elemHeight:c,collisionPosition:s,collisionWidth:x,collisionHeight:C,offset:[u[0]+I[0],u[1]+I[1]],my:n.my,at:n.at,within:b,elem:h})}),n.using&&(r=function(t){var e=g.left-D.left,i=e+p-l,s=g.top-D.top,r=s+f-c,u={target:{element:v,left:g.left,top:g.top,width:p,height:f},element:{element:h,left:D.left,top:D.top,width:l,height:c},horizontal:0>i?"left":e>0?"right":"center",vertical:0>r?"top":s>0?"bottom":"middle"};l>p&&p>a(e+i)&&(u.horizontal="center"),c>f&&f>a(s+r)&&(u.vertical="middle"),u.important=o(a(e),a(i))>o(a(s),a(r))?"horizontal":"vertical",n.using.call(this,t,u)}),h.offset(t.extend(D,{using:r}))})},t.ui.position={fit:{left:function(t,e){var i,s=e.within,n=s.isWindow?s.scrollLeft:s.offset.left,a=s.width,r=t.left-e.collisionPosition.marginLeft,h=n-r,l=r+e.collisionWidth-a-n;e.collisionWidth>a?h>0&&0>=l?(i=t.left+h+e.collisionWidth-a-n,t.left+=h-i):t.left=l>0&&0>=h?n:h>l?n+a-e.collisionWidth:n:h>0?t.left+=h:l>0?t.left-=l:t.left=o(t.left-r,t.left)},top:function(t,e){var i,s=e.within,n=s.isWindow?s.scrollTop:s.offset.top,a=e.within.height,r=t.top-e.collisionPosition.marginTop,h=n-r,l=r+e.collisionHeight-a-n;e.collisionHeight>a?h>0&&0>=l?(i=t.top+h+e.collisionHeight-a-n,t.top+=h-i):t.top=l>0&&0>=h?n:h>l?n+a-e.collisionHeight:n:h>0?t.top+=h:l>0?t.top-=l:t.top=o(t.top-r,t.top)}},flip:{left:function(t,e){var i,s,n=e.within,o=n.offset.left+n.scrollLeft,r=n.width,h=n.isWindow?n.scrollLeft:n.offset.left,l=t.left-e.collisionPosition.marginLeft,c=l-h,u=l+e.collisionWidth-r-h,d="left"===e.my[0]?-e.elemWidth:"right"===e.my[0]?e.elemWidth:0,p="left"===e.at[0]?e.targetWidth:"right"===e.at[0]?-e.targetWidth:0,f=-2*e.offset[0];0>c?(i=t.left+d+p+f+e.collisionWidth-r-o,(0>i||a(c)>i)&&(t.left+=d+p+f)):u>0&&(s=t.left-e.collisionPosition.marginLeft+d+p+f-h,(s>0||u>a(s))&&(t.left+=d+p+f))},top:function(t,e){var i,s,n=e.within,o=n.offset.top+n.scrollTop,r=n.height,h=n.isWindow?n.scrollTop:n.offset.top,l=t.top-e.collisionPosition.marginTop,c=l-h,u=l+e.collisionHeight-r-h,d="top"===e.my[1],p=d?-e.elemHeight:"bottom"===e.my[1]?e.elemHeight:0,f="top"===e.at[1]?e.targetHeight:"bottom"===e.at[1]?-e.targetHeight:0,g=-2*e.offset[1];0>c?(s=t.top+p+f+g+e.collisionHeight-r-o,(0>s||a(c)>s)&&(t.top+=p+f+g)):u>0&&(i=t.top-e.collisionPosition.marginTop+p+f+g-h,(i>0||u>a(i))&&(t.top+=p+f+g))}},flipfit:{left:function(){t.ui.position.flip.left.apply(this,arguments),t.ui.position.fit.left.apply(this,arguments)},top:function(){t.ui.position.flip.top.apply(this,arguments),t.ui.position.fit.top.apply(this,arguments)}}}}(),t.ui.position,t.extend(t.expr[":"],{data:t.expr.createPseudo?t.expr.createPseudo(function(e){return function(i){return!!t.data(i,e)}}):function(e,i,s){return!!t.data(e,s[3])}}),t.fn.extend({disableSelection:function(){var t="onselectstart"in document.createElement("div")?"selectstart":"mousedown";return function(){return this.on(t+".ui-disableSelection",function(t){t.preventDefault()})}}(),enableSelection:function(){return this.off(".ui-disableSelection")}});var c="ui-effects-",u="ui-effects-style",d="ui-effects-animated",p=t;t.effects={effect:{}},function(t,e){function i(t,e,i){var s=u[e.type]||{};return null==t?i||!e.def?null:e.def:(t=s.floor?~~t:parseFloat(t),isNaN(t)?e.def:s.mod?(t+s.mod)%s.mod:0>t?0:t>s.max?s.max:t)}function s(i){var s=l(),n=s._rgba=[];return i=i.toLowerCase(),f(h,function(t,o){var a,r=o.re.exec(i),h=r&&o.parse(r),l=o.space||"rgba";return h?(a=s[l](h),s[c[l].cache]=a[c[l].cache],n=s._rgba=a._rgba,!1):e}),n.length?("0,0,0,0"===n.join()&&t.extend(n,o.transparent),s):o[i]}function n(t,e,i){return i=(i+1)%1,1>6*i?t+6*(e-t)*i:1>2*i?e:2>3*i?t+6*(e-t)*(2/3-i):t}var o,a="backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",r=/^([\-+])=\s*(\d+\.?\d*)/,h=[{re:/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,parse:function(t){return[t[1],t[2],t[3],t[4]]}},{re:/rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,parse:function(t){return[2.55*t[1],2.55*t[2],2.55*t[3],t[4]]}},{re:/#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,parse:function(t){return[parseInt(t[1],16),parseInt(t[2],16),parseInt(t[3],16)]}},{re:/#([a-f0-9])([a-f0-9])([a-f0-9])/,parse:function(t){return[parseInt(t[1]+t[1],16),parseInt(t[2]+t[2],16),parseInt(t[3]+t[3],16)]}},{re:/hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,space:"hsla",parse:function(t){return[t[1],t[2]/100,t[3]/100,t[4]]}}],l=t.Color=function(e,i,s,n){return new t.Color.fn.parse(e,i,s,n)},c={rgba:{props:{red:{idx:0,type:"byte"},green:{idx:1,type:"byte"},blue:{idx:2,type:"byte"}}},hsla:{props:{hue:{idx:0,type:"degrees"},saturation:{idx:1,type:"percent"},lightness:{idx:2,type:"percent"}}}},u={"byte":{floor:!0,max:255},percent:{max:1},degrees:{mod:360,floor:!0}},d=l.support={},p=t("<p>")[0],f=t.each;p.style.cssText="background-color:rgba(1,1,1,.5)",d.rgba=p.style.backgroundColor.indexOf("rgba")>-1,f(c,function(t,e){e.cache="_"+t,e.props.alpha={idx:3,type:"percent",def:1}}),l.fn=t.extend(l.prototype,{parse:function(n,a,r,h){if(n===e)return this._rgba=[null,null,null,null],this;(n.jquery||n.nodeType)&&(n=t(n).css(a),a=e);var u=this,d=t.type(n),p=this._rgba=[];return a!==e&&(n=[n,a,r,h],d="array"),"string"===d?this.parse(s(n)||o._default):"array"===d?(f(c.rgba.props,function(t,e){p[e.idx]=i(n[e.idx],e)}),this):"object"===d?(n instanceof l?f(c,function(t,e){n[e.cache]&&(u[e.cache]=n[e.cache].slice())}):f(c,function(e,s){var o=s.cache;f(s.props,function(t,e){if(!u[o]&&s.to){if("alpha"===t||null==n[t])return;u[o]=s.to(u._rgba)}u[o][e.idx]=i(n[t],e,!0)}),u[o]&&0>t.inArray(null,u[o].slice(0,3))&&(u[o][3]=1,s.from&&(u._rgba=s.from(u[o])))}),this):e},is:function(t){var i=l(t),s=!0,n=this;return f(c,function(t,o){var a,r=i[o.cache];return r&&(a=n[o.cache]||o.to&&o.to(n._rgba)||[],f(o.props,function(t,i){return null!=r[i.idx]?s=r[i.idx]===a[i.idx]:e})),s}),s},_space:function(){var t=[],e=this;return f(c,function(i,s){e[s.cache]&&t.push(i)}),t.pop()},transition:function(t,e){var s=l(t),n=s._space(),o=c[n],a=0===this.alpha()?l("transparent"):this,r=a[o.cache]||o.to(a._rgba),h=r.slice();return s=s[o.cache],f(o.props,function(t,n){var o=n.idx,a=r[o],l=s[o],c=u[n.type]||{};null!==l&&(null===a?h[o]=l:(c.mod&&(l-a>c.mod/2?a+=c.mod:a-l>c.mod/2&&(a-=c.mod)),h[o]=i((l-a)*e+a,n)))}),this[n](h)},blend:function(e){if(1===this._rgba[3])return this;var i=this._rgba.slice(),s=i.pop(),n=l(e)._rgba;return l(t.map(i,function(t,e){return(1-s)*n[e]+s*t}))},toRgbaString:function(){var e="rgba(",i=t.map(this._rgba,function(t,e){return null==t?e>2?1:0:t});return 1===i[3]&&(i.pop(),e="rgb("),e+i.join()+")"},toHslaString:function(){var e="hsla(",i=t.map(this.hsla(),function(t,e){return null==t&&(t=e>2?1:0),e&&3>e&&(t=Math.round(100*t)+"%"),t});return 1===i[3]&&(i.pop(),e="hsl("),e+i.join()+")"},toHexString:function(e){var i=this._rgba.slice(),s=i.pop();return e&&i.push(~~(255*s)),"#"+t.map(i,function(t){return t=(t||0).toString(16),1===t.length?"0"+t:t}).join("")},toString:function(){return 0===this._rgba[3]?"transparent":this.toRgbaString()}}),l.fn.parse.prototype=l.fn,c.hsla.to=function(t){if(null==t[0]||null==t[1]||null==t[2])return[null,null,null,t[3]];var e,i,s=t[0]/255,n=t[1]/255,o=t[2]/255,a=t[3],r=Math.max(s,n,o),h=Math.min(s,n,o),l=r-h,c=r+h,u=.5*c;return e=h===r?0:s===r?60*(n-o)/l+360:n===r?60*(o-s)/l+120:60*(s-n)/l+240,i=0===l?0:.5>=u?l/c:l/(2-c),[Math.round(e)%360,i,u,null==a?1:a]},c.hsla.from=function(t){if(null==t[0]||null==t[1]||null==t[2])return[null,null,null,t[3]];var e=t[0]/360,i=t[1],s=t[2],o=t[3],a=.5>=s?s*(1+i):s+i-s*i,r=2*s-a;return[Math.round(255*n(r,a,e+1/3)),Math.round(255*n(r,a,e)),Math.round(255*n(r,a,e-1/3)),o]},f(c,function(s,n){var o=n.props,a=n.cache,h=n.to,c=n.from;l.fn[s]=function(s){if(h&&!this[a]&&(this[a]=h(this._rgba)),s===e)return this[a].slice();var n,r=t.type(s),u="array"===r||"object"===r?s:arguments,d=this[a].slice();return f(o,function(t,e){var s=u["object"===r?t:e.idx];null==s&&(s=d[e.idx]),d[e.idx]=i(s,e)}),c?(n=l(c(d)),n[a]=d,n):l(d)},f(o,function(e,i){l.fn[e]||(l.fn[e]=function(n){var o,a=t.type(n),h="alpha"===e?this._hsla?"hsla":"rgba":s,l=this[h](),c=l[i.idx];return"undefined"===a?c:("function"===a&&(n=n.call(this,c),a=t.type(n)),null==n&&i.empty?this:("string"===a&&(o=r.exec(n),o&&(n=c+parseFloat(o[2])*("+"===o[1]?1:-1))),l[i.idx]=n,this[h](l)))})})}),l.hook=function(e){var i=e.split(" ");f(i,function(e,i){t.cssHooks[i]={set:function(e,n){var o,a,r="";if("transparent"!==n&&("string"!==t.type(n)||(o=s(n)))){if(n=l(o||n),!d.rgba&&1!==n._rgba[3]){for(a="backgroundColor"===i?e.parentNode:e;(""===r||"transparent"===r)&&a&&a.style;)try{r=t.css(a,"backgroundColor"),a=a.parentNode}catch(h){}n=n.blend(r&&"transparent"!==r?r:"_default")}n=n.toRgbaString()}try{e.style[i]=n}catch(h){}}},t.fx.step[i]=function(e){e.colorInit||(e.start=l(e.elem,i),e.end=l(e.end),e.colorInit=!0),t.cssHooks[i].set(e.elem,e.start.transition(e.end,e.pos))}})},l.hook(a),t.cssHooks.borderColor={expand:function(t){var e={};return f(["Top","Right","Bottom","Left"],function(i,s){e["border"+s+"Color"]=t}),e}},o=t.Color.names={aqua:"#00ffff",black:"#000000",blue:"#0000ff",fuchsia:"#ff00ff",gray:"#808080",green:"#008000",lime:"#00ff00",maroon:"#800000",navy:"#000080",olive:"#808000",purple:"#800080",red:"#ff0000",silver:"#c0c0c0",teal:"#008080",white:"#ffffff",yellow:"#ffff00",transparent:[null,null,null,0],_default:"#ffffff"}}(p),function(){function e(e){var i,s,n=e.ownerDocument.defaultView?e.ownerDocument.defaultView.getComputedStyle(e,null):e.currentStyle,o={};if(n&&n.length&&n[0]&&n[n[0]])for(s=n.length;s--;)i=n[s],"string"==typeof n[i]&&(o[t.camelCase(i)]=n[i]);else for(i in n)"string"==typeof n[i]&&(o[i]=n[i]);return o}function i(e,i){var s,o,a={};for(s in i)o=i[s],e[s]!==o&&(n[s]||(t.fx.step[s]||!isNaN(parseFloat(o)))&&(a[s]=o));return a}var s=["add","remove","toggle"],n={border:1,borderBottom:1,borderColor:1,borderLeft:1,borderRight:1,borderTop:1,borderWidth:1,margin:1,padding:1};t.each(["borderLeftStyle","borderRightStyle","borderBottomStyle","borderTopStyle"],function(e,i){t.fx.step[i]=function(t){("none"!==t.end&&!t.setAttr||1===t.pos&&!t.setAttr)&&(p.style(t.elem,i,t.end),t.setAttr=!0)}}),t.fn.addBack||(t.fn.addBack=function(t){return this.add(null==t?this.prevObject:this.prevObject.filter(t))}),t.effects.animateClass=function(n,o,a,r){var h=t.speed(o,a,r);return this.queue(function(){var o,a=t(this),r=a.attr("class")||"",l=h.children?a.find("*").addBack():a;l=l.map(function(){var i=t(this);return{el:i,start:e(this)}}),o=function(){t.each(s,function(t,e){n[e]&&a[e+"Class"](n[e])})},o(),l=l.map(function(){return this.end=e(this.el[0]),this.diff=i(this.start,this.end),this}),a.attr("class",r),l=l.map(function(){var e=this,i=t.Deferred(),s=t.extend({},h,{queue:!1,complete:function(){i.resolve(e)}});return this.el.animate(this.diff,s),i.promise()}),t.when.apply(t,l.get()).done(function(){o(),t.each(arguments,function(){var e=this.el;t.each(this.diff,function(t){e.css(t,"")})}),h.complete.call(a[0])})})},t.fn.extend({addClass:function(e){return function(i,s,n,o){return s?t.effects.animateClass.call(this,{add:i},s,n,o):e.apply(this,arguments)}}(t.fn.addClass),removeClass:function(e){return function(i,s,n,o){return arguments.length>1?t.effects.animateClass.call(this,{remove:i},s,n,o):e.apply(this,arguments)}}(t.fn.removeClass),toggleClass:function(e){return function(i,s,n,o,a){return"boolean"==typeof s||void 0===s?n?t.effects.animateClass.call(this,s?{add:i}:{remove:i},n,o,a):e.apply(this,arguments):t.effects.animateClass.call(this,{toggle:i},s,n,o)}}(t.fn.toggleClass),switchClass:function(e,i,s,n,o){return t.effects.animateClass.call(this,{add:i,remove:e},s,n,o)}})}(),function(){function e(e,i,s,n){return t.isPlainObject(e)&&(i=e,e=e.effect),e={effect:e},null==i&&(i={}),t.isFunction(i)&&(n=i,s=null,i={}),("number"==typeof i||t.fx.speeds[i])&&(n=s,s=i,i={}),t.isFunction(s)&&(n=s,s=null),i&&t.extend(e,i),s=s||i.duration,e.duration=t.fx.off?0:"number"==typeof s?s:s in t.fx.speeds?t.fx.speeds[s]:t.fx.speeds._default,e.complete=n||i.complete,e}function i(e){return!e||"number"==typeof e||t.fx.speeds[e]?!0:"string"!=typeof e||t.effects.effect[e]?t.isFunction(e)?!0:"object"!=typeof e||e.effect?!1:!0:!0}function s(t,e){var i=e.outerWidth(),s=e.outerHeight(),n=/^rect\((-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto)\)$/,o=n.exec(t)||["",0,i,s,0];return{top:parseFloat(o[1])||0,right:"auto"===o[2]?i:parseFloat(o[2]),bottom:"auto"===o[3]?s:parseFloat(o[3]),left:parseFloat(o[4])||0}}t.expr&&t.expr.filters&&t.expr.filters.animated&&(t.expr.filters.animated=function(e){return function(i){return!!t(i).data(d)||e(i)}}(t.expr.filters.animated)),t.uiBackCompat!==!1&&t.extend(t.effects,{save:function(t,e){for(var i=0,s=e.length;s>i;i++)null!==e[i]&&t.data(c+e[i],t[0].style[e[i]])},restore:function(t,e){for(var i,s=0,n=e.length;n>s;s++)null!==e[s]&&(i=t.data(c+e[s]),t.css(e[s],i))},setMode:function(t,e){return"toggle"===e&&(e=t.is(":hidden")?"show":"hide"),e},createWrapper:function(e){if(e.parent().is(".ui-effects-wrapper"))return e.parent();var i={width:e.outerWidth(!0),height:e.outerHeight(!0),"float":e.css("float")},s=t("<div></div>").addClass("ui-effects-wrapper").css({fontSize:"100%",background:"transparent",border:"none",margin:0,padding:0}),n={width:e.width(),height:e.height()},o=document.activeElement;try{o.id}catch(a){o=document.body}return e.wrap(s),(e[0]===o||t.contains(e[0],o))&&t(o).trigger("focus"),s=e.parent(),"static"===e.css("position")?(s.css({position:"relative"}),e.css({position:"relative"})):(t.extend(i,{position:e.css("position"),zIndex:e.css("z-index")}),t.each(["top","left","bottom","right"],function(t,s){i[s]=e.css(s),isNaN(parseInt(i[s],10))&&(i[s]="auto")}),e.css({position:"relative",top:0,left:0,right:"auto",bottom:"auto"})),e.css(n),s.css(i).show()},removeWrapper:function(e){var i=document.activeElement;return e.parent().is(".ui-effects-wrapper")&&(e.parent().replaceWith(e),(e[0]===i||t.contains(e[0],i))&&t(i).trigger("focus")),e}}),t.extend(t.effects,{version:"1.12.1",define:function(e,i,s){return s||(s=i,i="effect"),t.effects.effect[e]=s,t.effects.effect[e].mode=i,s},scaledDimensions:function(t,e,i){if(0===e)return{height:0,width:0,outerHeight:0,outerWidth:0};var s="horizontal"!==i?(e||100)/100:1,n="vertical"!==i?(e||100)/100:1;return{height:t.height()*n,width:t.width()*s,outerHeight:t.outerHeight()*n,outerWidth:t.outerWidth()*s}},clipToBox:function(t){return{width:t.clip.right-t.clip.left,height:t.clip.bottom-t.clip.top,left:t.clip.left,top:t.clip.top}},unshift:function(t,e,i){var s=t.queue();e>1&&s.splice.apply(s,[1,0].concat(s.splice(e,i))),t.dequeue()},saveStyle:function(t){t.data(u,t[0].style.cssText)},restoreStyle:function(t){t[0].style.cssText=t.data(u)||"",t.removeData(u)},mode:function(t,e){var i=t.is(":hidden");return"toggle"===e&&(e=i?"show":"hide"),(i?"hide"===e:"show"===e)&&(e="none"),e},getBaseline:function(t,e){var i,s;switch(t[0]){case"top":i=0;break;case"middle":i=.5;break;case"bottom":i=1;break;default:i=t[0]/e.height}switch(t[1]){case"left":s=0;break;case"center":s=.5;break;case"right":s=1;break;default:s=t[1]/e.width}return{x:s,y:i}},createPlaceholder:function(e){var i,s=e.css("position"),n=e.position();return e.css({marginTop:e.css("marginTop"),marginBottom:e.css("marginBottom"),marginLeft:e.css("marginLeft"),marginRight:e.css("marginRight")}).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()),/^(static|relative)/.test(s)&&(s="absolute",i=t("<"+e[0].nodeName+">").insertAfter(e).css({display:/^(inline|ruby)/.test(e.css("display"))?"inline-block":"block",visibility:"hidden",marginTop:e.css("marginTop"),marginBottom:e.css("marginBottom"),marginLeft:e.css("marginLeft"),marginRight:e.css("marginRight"),"float":e.css("float")}).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()).addClass("ui-effects-placeholder"),e.data(c+"placeholder",i)),e.css({position:s,left:n.left,top:n.top}),i},removePlaceholder:function(t){var e=c+"placeholder",i=t.data(e);i&&(i.remove(),t.removeData(e))},cleanUp:function(e){t.effects.restoreStyle(e),t.effects.removePlaceholder(e)},setTransition:function(e,i,s,n){return n=n||{},t.each(i,function(t,i){var o=e.cssUnit(i);o[0]>0&&(n[i]=o[0]*s+o[1])}),n}}),t.fn.extend({effect:function(){function i(e){function i(){r.removeData(d),t.effects.cleanUp(r),"hide"===s.mode&&r.hide(),a()}function a(){t.isFunction(h)&&h.call(r[0]),t.isFunction(e)&&e()}var r=t(this);s.mode=c.shift(),t.uiBackCompat===!1||o?"none"===s.mode?(r[l](),a()):n.call(r[0],s,i):(r.is(":hidden")?"hide"===l:"show"===l)?(r[l](),a()):n.call(r[0],s,a)}var s=e.apply(this,arguments),n=t.effects.effect[s.effect],o=n.mode,a=s.queue,r=a||"fx",h=s.complete,l=s.mode,c=[],u=function(e){var i=t(this),s=t.effects.mode(i,l)||o;i.data(d,!0),c.push(s),o&&("show"===s||s===o&&"hide"===s)&&i.show(),o&&"none"===s||t.effects.saveStyle(i),t.isFunction(e)&&e()};return t.fx.off||!n?l?this[l](s.duration,h):this.each(function(){h&&h.call(this)}):a===!1?this.each(u).each(i):this.queue(r,u).queue(r,i)},show:function(t){return function(s){if(i(s))return t.apply(this,arguments);var n=e.apply(this,arguments);return n.mode="show",this.effect.call(this,n)
}}(t.fn.show),hide:function(t){return function(s){if(i(s))return t.apply(this,arguments);var n=e.apply(this,arguments);return n.mode="hide",this.effect.call(this,n)}}(t.fn.hide),toggle:function(t){return function(s){if(i(s)||"boolean"==typeof s)return t.apply(this,arguments);var n=e.apply(this,arguments);return n.mode="toggle",this.effect.call(this,n)}}(t.fn.toggle),cssUnit:function(e){var i=this.css(e),s=[];return t.each(["em","px","%","pt"],function(t,e){i.indexOf(e)>0&&(s=[parseFloat(i),e])}),s},cssClip:function(t){return t?this.css("clip","rect("+t.top+"px "+t.right+"px "+t.bottom+"px "+t.left+"px)"):s(this.css("clip"),this)},transfer:function(e,i){var s=t(this),n=t(e.to),o="fixed"===n.css("position"),a=t("body"),r=o?a.scrollTop():0,h=o?a.scrollLeft():0,l=n.offset(),c={top:l.top-r,left:l.left-h,height:n.innerHeight(),width:n.innerWidth()},u=s.offset(),d=t("<div class='ui-effects-transfer'></div>").appendTo("body").addClass(e.className).css({top:u.top-r,left:u.left-h,height:s.innerHeight(),width:s.innerWidth(),position:o?"fixed":"absolute"}).animate(c,e.duration,e.easing,function(){d.remove(),t.isFunction(i)&&i()})}}),t.fx.step.clip=function(e){e.clipInit||(e.start=t(e.elem).cssClip(),"string"==typeof e.end&&(e.end=s(e.end,e.elem)),e.clipInit=!0),t(e.elem).cssClip({top:e.pos*(e.end.top-e.start.top)+e.start.top,right:e.pos*(e.end.right-e.start.right)+e.start.right,bottom:e.pos*(e.end.bottom-e.start.bottom)+e.start.bottom,left:e.pos*(e.end.left-e.start.left)+e.start.left})}}(),function(){var e={};t.each(["Quad","Cubic","Quart","Quint","Expo"],function(t,i){e[i]=function(e){return Math.pow(e,t+2)}}),t.extend(e,{Sine:function(t){return 1-Math.cos(t*Math.PI/2)},Circ:function(t){return 1-Math.sqrt(1-t*t)},Elastic:function(t){return 0===t||1===t?t:-Math.pow(2,8*(t-1))*Math.sin((80*(t-1)-7.5)*Math.PI/15)},Back:function(t){return t*t*(3*t-2)},Bounce:function(t){for(var e,i=4;((e=Math.pow(2,--i))-1)/11>t;);return 1/Math.pow(4,3-i)-7.5625*Math.pow((3*e-2)/22-t,2)}}),t.each(e,function(e,i){t.easing["easeIn"+e]=i,t.easing["easeOut"+e]=function(t){return 1-i(1-t)},t.easing["easeInOut"+e]=function(t){return.5>t?i(2*t)/2:1-i(-2*t+2)/2}})}();var f=t.effects;t.effects.define("blind","hide",function(e,i){var s={up:["bottom","top"],vertical:["bottom","top"],down:["top","bottom"],left:["right","left"],horizontal:["right","left"],right:["left","right"]},n=t(this),o=e.direction||"up",a=n.cssClip(),r={clip:t.extend({},a)},h=t.effects.createPlaceholder(n);r.clip[s[o][0]]=r.clip[s[o][1]],"show"===e.mode&&(n.cssClip(r.clip),h&&h.css(t.effects.clipToBox(r)),r.clip=a),h&&h.animate(t.effects.clipToBox(r),e.duration,e.easing),n.animate(r,{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("bounce",function(e,i){var s,n,o,a=t(this),r=e.mode,h="hide"===r,l="show"===r,c=e.direction||"up",u=e.distance,d=e.times||5,p=2*d+(l||h?1:0),f=e.duration/p,g=e.easing,m="up"===c||"down"===c?"top":"left",_="up"===c||"left"===c,v=0,b=a.queue().length;for(t.effects.createPlaceholder(a),o=a.css(m),u||(u=a["top"===m?"outerHeight":"outerWidth"]()/3),l&&(n={opacity:1},n[m]=o,a.css("opacity",0).css(m,_?2*-u:2*u).animate(n,f,g)),h&&(u/=Math.pow(2,d-1)),n={},n[m]=o;d>v;v++)s={},s[m]=(_?"-=":"+=")+u,a.animate(s,f,g).animate(n,f,g),u=h?2*u:u/2;h&&(s={opacity:0},s[m]=(_?"-=":"+=")+u,a.animate(s,f,g)),a.queue(i),t.effects.unshift(a,b,p+1)}),t.effects.define("clip","hide",function(e,i){var s,n={},o=t(this),a=e.direction||"vertical",r="both"===a,h=r||"horizontal"===a,l=r||"vertical"===a;s=o.cssClip(),n.clip={top:l?(s.bottom-s.top)/2:s.top,right:h?(s.right-s.left)/2:s.right,bottom:l?(s.bottom-s.top)/2:s.bottom,left:h?(s.right-s.left)/2:s.left},t.effects.createPlaceholder(o),"show"===e.mode&&(o.cssClip(n.clip),n.clip=s),o.animate(n,{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("drop","hide",function(e,i){var s,n=t(this),o=e.mode,a="show"===o,r=e.direction||"left",h="up"===r||"down"===r?"top":"left",l="up"===r||"left"===r?"-=":"+=",c="+="===l?"-=":"+=",u={opacity:0};t.effects.createPlaceholder(n),s=e.distance||n["top"===h?"outerHeight":"outerWidth"](!0)/2,u[h]=l+s,a&&(n.css(u),u[h]=c+s,u.opacity=1),n.animate(u,{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("explode","hide",function(e,i){function s(){b.push(this),b.length===u*d&&n()}function n(){p.css({visibility:"visible"}),t(b).remove(),i()}var o,a,r,h,l,c,u=e.pieces?Math.round(Math.sqrt(e.pieces)):3,d=u,p=t(this),f=e.mode,g="show"===f,m=p.show().css("visibility","hidden").offset(),_=Math.ceil(p.outerWidth()/d),v=Math.ceil(p.outerHeight()/u),b=[];for(o=0;u>o;o++)for(h=m.top+o*v,c=o-(u-1)/2,a=0;d>a;a++)r=m.left+a*_,l=a-(d-1)/2,p.clone().appendTo("body").wrap("<div></div>").css({position:"absolute",visibility:"visible",left:-a*_,top:-o*v}).parent().addClass("ui-effects-explode").css({position:"absolute",overflow:"hidden",width:_,height:v,left:r+(g?l*_:0),top:h+(g?c*v:0),opacity:g?0:1}).animate({left:r+(g?0:l*_),top:h+(g?0:c*v),opacity:g?1:0},e.duration||500,e.easing,s)}),t.effects.define("fade","toggle",function(e,i){var s="show"===e.mode;t(this).css("opacity",s?0:1).animate({opacity:s?1:0},{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("fold","hide",function(e,i){var s=t(this),n=e.mode,o="show"===n,a="hide"===n,r=e.size||15,h=/([0-9]+)%/.exec(r),l=!!e.horizFirst,c=l?["right","bottom"]:["bottom","right"],u=e.duration/2,d=t.effects.createPlaceholder(s),p=s.cssClip(),f={clip:t.extend({},p)},g={clip:t.extend({},p)},m=[p[c[0]],p[c[1]]],_=s.queue().length;h&&(r=parseInt(h[1],10)/100*m[a?0:1]),f.clip[c[0]]=r,g.clip[c[0]]=r,g.clip[c[1]]=0,o&&(s.cssClip(g.clip),d&&d.css(t.effects.clipToBox(g)),g.clip=p),s.queue(function(i){d&&d.animate(t.effects.clipToBox(f),u,e.easing).animate(t.effects.clipToBox(g),u,e.easing),i()}).animate(f,u,e.easing).animate(g,u,e.easing).queue(i),t.effects.unshift(s,_,4)}),t.effects.define("highlight","show",function(e,i){var s=t(this),n={backgroundColor:s.css("backgroundColor")};"hide"===e.mode&&(n.opacity=0),t.effects.saveStyle(s),s.css({backgroundImage:"none",backgroundColor:e.color||"#ffff99"}).animate(n,{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("size",function(e,i){var s,n,o,a=t(this),r=["fontSize"],h=["borderTopWidth","borderBottomWidth","paddingTop","paddingBottom"],l=["borderLeftWidth","borderRightWidth","paddingLeft","paddingRight"],c=e.mode,u="effect"!==c,d=e.scale||"both",p=e.origin||["middle","center"],f=a.css("position"),g=a.position(),m=t.effects.scaledDimensions(a),_=e.from||m,v=e.to||t.effects.scaledDimensions(a,0);t.effects.createPlaceholder(a),"show"===c&&(o=_,_=v,v=o),n={from:{y:_.height/m.height,x:_.width/m.width},to:{y:v.height/m.height,x:v.width/m.width}},("box"===d||"both"===d)&&(n.from.y!==n.to.y&&(_=t.effects.setTransition(a,h,n.from.y,_),v=t.effects.setTransition(a,h,n.to.y,v)),n.from.x!==n.to.x&&(_=t.effects.setTransition(a,l,n.from.x,_),v=t.effects.setTransition(a,l,n.to.x,v))),("content"===d||"both"===d)&&n.from.y!==n.to.y&&(_=t.effects.setTransition(a,r,n.from.y,_),v=t.effects.setTransition(a,r,n.to.y,v)),p&&(s=t.effects.getBaseline(p,m),_.top=(m.outerHeight-_.outerHeight)*s.y+g.top,_.left=(m.outerWidth-_.outerWidth)*s.x+g.left,v.top=(m.outerHeight-v.outerHeight)*s.y+g.top,v.left=(m.outerWidth-v.outerWidth)*s.x+g.left),a.css(_),("content"===d||"both"===d)&&(h=h.concat(["marginTop","marginBottom"]).concat(r),l=l.concat(["marginLeft","marginRight"]),a.find("*[width]").each(function(){var i=t(this),s=t.effects.scaledDimensions(i),o={height:s.height*n.from.y,width:s.width*n.from.x,outerHeight:s.outerHeight*n.from.y,outerWidth:s.outerWidth*n.from.x},a={height:s.height*n.to.y,width:s.width*n.to.x,outerHeight:s.height*n.to.y,outerWidth:s.width*n.to.x};n.from.y!==n.to.y&&(o=t.effects.setTransition(i,h,n.from.y,o),a=t.effects.setTransition(i,h,n.to.y,a)),n.from.x!==n.to.x&&(o=t.effects.setTransition(i,l,n.from.x,o),a=t.effects.setTransition(i,l,n.to.x,a)),u&&t.effects.saveStyle(i),i.css(o),i.animate(a,e.duration,e.easing,function(){u&&t.effects.restoreStyle(i)})})),a.animate(v,{queue:!1,duration:e.duration,easing:e.easing,complete:function(){var e=a.offset();0===v.opacity&&a.css("opacity",_.opacity),u||(a.css("position","static"===f?"relative":f).offset(e),t.effects.saveStyle(a)),i()}})}),t.effects.define("scale",function(e,i){var s=t(this),n=e.mode,o=parseInt(e.percent,10)||(0===parseInt(e.percent,10)?0:"effect"!==n?0:100),a=t.extend(!0,{from:t.effects.scaledDimensions(s),to:t.effects.scaledDimensions(s,o,e.direction||"both"),origin:e.origin||["middle","center"]},e);e.fade&&(a.from.opacity=1,a.to.opacity=0),t.effects.effect.size.call(this,a,i)}),t.effects.define("puff","hide",function(e,i){var s=t.extend(!0,{},e,{fade:!0,percent:parseInt(e.percent,10)||150});t.effects.effect.scale.call(this,s,i)}),t.effects.define("pulsate","show",function(e,i){var s=t(this),n=e.mode,o="show"===n,a="hide"===n,r=o||a,h=2*(e.times||5)+(r?1:0),l=e.duration/h,c=0,u=1,d=s.queue().length;for((o||!s.is(":visible"))&&(s.css("opacity",0).show(),c=1);h>u;u++)s.animate({opacity:c},l,e.easing),c=1-c;s.animate({opacity:c},l,e.easing),s.queue(i),t.effects.unshift(s,d,h+1)}),t.effects.define("shake",function(e,i){var s=1,n=t(this),o=e.direction||"left",a=e.distance||20,r=e.times||3,h=2*r+1,l=Math.round(e.duration/h),c="up"===o||"down"===o?"top":"left",u="up"===o||"left"===o,d={},p={},f={},g=n.queue().length;for(t.effects.createPlaceholder(n),d[c]=(u?"-=":"+=")+a,p[c]=(u?"+=":"-=")+2*a,f[c]=(u?"-=":"+=")+2*a,n.animate(d,l,e.easing);r>s;s++)n.animate(p,l,e.easing).animate(f,l,e.easing);n.animate(p,l,e.easing).animate(d,l/2,e.easing).queue(i),t.effects.unshift(n,g,h+1)}),t.effects.define("slide","show",function(e,i){var s,n,o=t(this),a={up:["bottom","top"],down:["top","bottom"],left:["right","left"],right:["left","right"]},r=e.mode,h=e.direction||"left",l="up"===h||"down"===h?"top":"left",c="up"===h||"left"===h,u=e.distance||o["top"===l?"outerHeight":"outerWidth"](!0),d={};t.effects.createPlaceholder(o),s=o.cssClip(),n=o.position()[l],d[l]=(c?-1:1)*u+n,d.clip=o.cssClip(),d.clip[a[h][1]]=d.clip[a[h][0]],"show"===r&&(o.cssClip(d.clip),o.css(l,d[l]),d.clip=s,d[l]=n),o.animate(d,{queue:!1,duration:e.duration,easing:e.easing,complete:i})});var f;t.uiBackCompat!==!1&&(f=t.effects.define("transfer",function(e,i){t(this).transfer(e,i)})),t.ui.focusable=function(i,s){var n,o,a,r,h,l=i.nodeName.toLowerCase();return"area"===l?(n=i.parentNode,o=n.name,i.href&&o&&"map"===n.nodeName.toLowerCase()?(a=t("img[usemap='#"+o+"']"),a.length>0&&a.is(":visible")):!1):(/^(input|select|textarea|button|object)$/.test(l)?(r=!i.disabled,r&&(h=t(i).closest("fieldset")[0],h&&(r=!h.disabled))):r="a"===l?i.href||s:s,r&&t(i).is(":visible")&&e(t(i)))},t.extend(t.expr[":"],{focusable:function(e){return t.ui.focusable(e,null!=t.attr(e,"tabindex"))}}),t.ui.focusable,t.fn.form=function(){return"string"==typeof this[0].form?this.closest("form"):t(this[0].form)},t.ui.formResetMixin={_formResetHandler:function(){var e=t(this);setTimeout(function(){var i=e.data("ui-form-reset-instances");t.each(i,function(){this.refresh()})})},_bindFormResetHandler:function(){if(this.form=this.element.form(),this.form.length){var t=this.form.data("ui-form-reset-instances")||[];t.length||this.form.on("reset.ui-form-reset",this._formResetHandler),t.push(this),this.form.data("ui-form-reset-instances",t)}},_unbindFormResetHandler:function(){if(this.form.length){var e=this.form.data("ui-form-reset-instances");e.splice(t.inArray(this,e),1),e.length?this.form.data("ui-form-reset-instances",e):this.form.removeData("ui-form-reset-instances").off("reset.ui-form-reset")}}},"1.7"===t.fn.jquery.substring(0,3)&&(t.each(["Width","Height"],function(e,i){function s(e,i,s,o){return t.each(n,function(){i-=parseFloat(t.css(e,"padding"+this))||0,s&&(i-=parseFloat(t.css(e,"border"+this+"Width"))||0),o&&(i-=parseFloat(t.css(e,"margin"+this))||0)}),i}var n="Width"===i?["Left","Right"]:["Top","Bottom"],o=i.toLowerCase(),a={innerWidth:t.fn.innerWidth,innerHeight:t.fn.innerHeight,outerWidth:t.fn.outerWidth,outerHeight:t.fn.outerHeight};t.fn["inner"+i]=function(e){return void 0===e?a["inner"+i].call(this):this.each(function(){t(this).css(o,s(this,e)+"px")})},t.fn["outer"+i]=function(e,n){return"number"!=typeof e?a["outer"+i].call(this,e):this.each(function(){t(this).css(o,s(this,e,!0,n)+"px")})}}),t.fn.addBack=function(t){return this.add(null==t?this.prevObject:this.prevObject.filter(t))}),t.ui.keyCode={BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38},t.ui.escapeSelector=function(){var t=/([!"#$%&'()*+,.\/:;<=>?@[\]^`{|}~])/g;return function(e){return e.replace(t,"\\$1")}}(),t.fn.labels=function(){var e,i,s,n,o;return this[0].labels&&this[0].labels.length?this.pushStack(this[0].labels):(n=this.eq(0).parents("label"),s=this.attr("id"),s&&(e=this.eq(0).parents().last(),o=e.add(e.length?e.siblings():this.siblings()),i="label[for='"+t.ui.escapeSelector(s)+"']",n=n.add(o.find(i).addBack(i))),this.pushStack(n))},t.fn.scrollParent=function(e){var i=this.css("position"),s="absolute"===i,n=e?/(auto|scroll|hidden)/:/(auto|scroll)/,o=this.parents().filter(function(){var e=t(this);return s&&"static"===e.css("position")?!1:n.test(e.css("overflow")+e.css("overflow-y")+e.css("overflow-x"))}).eq(0);return"fixed"!==i&&o.length?o:t(this[0].ownerDocument||document)},t.extend(t.expr[":"],{tabbable:function(e){var i=t.attr(e,"tabindex"),s=null!=i;return(!s||i>=0)&&t.ui.focusable(e,s)}}),t.fn.extend({uniqueId:function(){var t=0;return function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++t)})}}(),removeUniqueId:function(){return this.each(function(){/^ui-id-\d+$/.test(this.id)&&t(this).removeAttr("id")})}}),t.widget("ui.accordion",{version:"1.12.1",options:{active:0,animate:{},classes:{"ui-accordion-header":"ui-corner-top","ui-accordion-header-collapsed":"ui-corner-all","ui-accordion-content":"ui-corner-bottom"},collapsible:!1,event:"click",header:"> li > :first-child, > :not(li):even",heightStyle:"auto",icons:{activeHeader:"ui-icon-triangle-1-s",header:"ui-icon-triangle-1-e"},activate:null,beforeActivate:null},hideProps:{borderTopWidth:"hide",borderBottomWidth:"hide",paddingTop:"hide",paddingBottom:"hide",height:"hide"},showProps:{borderTopWidth:"show",borderBottomWidth:"show",paddingTop:"show",paddingBottom:"show",height:"show"},_create:function(){var e=this.options;this.prevShow=this.prevHide=t(),this._addClass("ui-accordion","ui-widget ui-helper-reset"),this.element.attr("role","tablist"),e.collapsible||e.active!==!1&&null!=e.active||(e.active=0),this._processPanels(),0>e.active&&(e.active+=this.headers.length),this._refresh()},_getCreateEventData:function(){return{header:this.active,panel:this.active.length?this.active.next():t()}},_createIcons:function(){var e,i,s=this.options.icons;s&&(e=t("<span>"),this._addClass(e,"ui-accordion-header-icon","ui-icon "+s.header),e.prependTo(this.headers),i=this.active.children(".ui-accordion-header-icon"),this._removeClass(i,s.header)._addClass(i,null,s.activeHeader)._addClass(this.headers,"ui-accordion-icons"))},_destroyIcons:function(){this._removeClass(this.headers,"ui-accordion-icons"),this.headers.children(".ui-accordion-header-icon").remove()},_destroy:function(){var t;this.element.removeAttr("role"),this.headers.removeAttr("role aria-expanded aria-selected aria-controls tabIndex").removeUniqueId(),this._destroyIcons(),t=this.headers.next().css("display","").removeAttr("role aria-hidden aria-labelledby").removeUniqueId(),"content"!==this.options.heightStyle&&t.css("height","")},_setOption:function(t,e){return"active"===t?(this._activate(e),void 0):("event"===t&&(this.options.event&&this._off(this.headers,this.options.event),this._setupEvents(e)),this._super(t,e),"collapsible"!==t||e||this.options.active!==!1||this._activate(0),"icons"===t&&(this._destroyIcons(),e&&this._createIcons()),void 0)},_setOptionDisabled:function(t){this._super(t),this.element.attr("aria-disabled",t),this._toggleClass(null,"ui-state-disabled",!!t),this._toggleClass(this.headers.add(this.headers.next()),null,"ui-state-disabled",!!t)},_keydown:function(e){if(!e.altKey&&!e.ctrlKey){var i=t.ui.keyCode,s=this.headers.length,n=this.headers.index(e.target),o=!1;switch(e.keyCode){case i.RIGHT:case i.DOWN:o=this.headers[(n+1)%s];break;case i.LEFT:case i.UP:o=this.headers[(n-1+s)%s];break;case i.SPACE:case i.ENTER:this._eventHandler(e);break;case i.HOME:o=this.headers[0];break;case i.END:o=this.headers[s-1]}o&&(t(e.target).attr("tabIndex",-1),t(o).attr("tabIndex",0),t(o).trigger("focus"),e.preventDefault())}},_panelKeyDown:function(e){e.keyCode===t.ui.keyCode.UP&&e.ctrlKey&&t(e.currentTarget).prev().trigger("focus")},refresh:function(){var e=this.options;this._processPanels(),e.active===!1&&e.collapsible===!0||!this.headers.length?(e.active=!1,this.active=t()):e.active===!1?this._activate(0):this.active.length&&!t.contains(this.element[0],this.active[0])?this.headers.length===this.headers.find(".ui-state-disabled").length?(e.active=!1,this.active=t()):this._activate(Math.max(0,e.active-1)):e.active=this.headers.index(this.active),this._destroyIcons(),this._refresh()},_processPanels:function(){var t=this.headers,e=this.panels;this.headers=this.element.find(this.options.header),this._addClass(this.headers,"ui-accordion-header ui-accordion-header-collapsed","ui-state-default"),this.panels=this.headers.next().filter(":not(.ui-accordion-content-active)").hide(),this._addClass(this.panels,"ui-accordion-content","ui-helper-reset ui-widget-content"),e&&(this._off(t.not(this.headers)),this._off(e.not(this.panels)))},_refresh:function(){var e,i=this.options,s=i.heightStyle,n=this.element.parent();this.active=this._findActive(i.active),this._addClass(this.active,"ui-accordion-header-active","ui-state-active")._removeClass(this.active,"ui-accordion-header-collapsed"),this._addClass(this.active.next(),"ui-accordion-content-active"),this.active.next().show(),this.headers.attr("role","tab").each(function(){var e=t(this),i=e.uniqueId().attr("id"),s=e.next(),n=s.uniqueId().attr("id");e.attr("aria-controls",n),s.attr("aria-labelledby",i)}).next().attr("role","tabpanel"),this.headers.not(this.active).attr({"aria-selected":"false","aria-expanded":"false",tabIndex:-1}).next().attr({"aria-hidden":"true"}).hide(),this.active.length?this.active.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0}).next().attr({"aria-hidden":"false"}):this.headers.eq(0).attr("tabIndex",0),this._createIcons(),this._setupEvents(i.event),"fill"===s?(e=n.height(),this.element.siblings(":visible").each(function(){var i=t(this),s=i.css("position");"absolute"!==s&&"fixed"!==s&&(e-=i.outerHeight(!0))}),this.headers.each(function(){e-=t(this).outerHeight(!0)}),this.headers.next().each(function(){t(this).height(Math.max(0,e-t(this).innerHeight()+t(this).height()))}).css("overflow","auto")):"auto"===s&&(e=0,this.headers.next().each(function(){var i=t(this).is(":visible");i||t(this).show(),e=Math.max(e,t(this).css("height","").height()),i||t(this).hide()}).height(e))},_activate:function(e){var i=this._findActive(e)[0];i!==this.active[0]&&(i=i||this.active[0],this._eventHandler({target:i,currentTarget:i,preventDefault:t.noop}))},_findActive:function(e){return"number"==typeof e?this.headers.eq(e):t()},_setupEvents:function(e){var i={keydown:"_keydown"};e&&t.each(e.split(" "),function(t,e){i[e]="_eventHandler"}),this._off(this.headers.add(this.headers.next())),this._on(this.headers,i),this._on(this.headers.next(),{keydown:"_panelKeyDown"}),this._hoverable(this.headers),this._focusable(this.headers)},_eventHandler:function(e){var i,s,n=this.options,o=this.active,a=t(e.currentTarget),r=a[0]===o[0],h=r&&n.collapsible,l=h?t():a.next(),c=o.next(),u={oldHeader:o,oldPanel:c,newHeader:h?t():a,newPanel:l};e.preventDefault(),r&&!n.collapsible||this._trigger("beforeActivate",e,u)===!1||(n.active=h?!1:this.headers.index(a),this.active=r?t():a,this._toggle(u),this._removeClass(o,"ui-accordion-header-active","ui-state-active"),n.icons&&(i=o.children(".ui-accordion-header-icon"),this._removeClass(i,null,n.icons.activeHeader)._addClass(i,null,n.icons.header)),r||(this._removeClass(a,"ui-accordion-header-collapsed")._addClass(a,"ui-accordion-header-active","ui-state-active"),n.icons&&(s=a.children(".ui-accordion-header-icon"),this._removeClass(s,null,n.icons.header)._addClass(s,null,n.icons.activeHeader)),this._addClass(a.next(),"ui-accordion-content-active")))},_toggle:function(e){var i=e.newPanel,s=this.prevShow.length?this.prevShow:e.oldPanel;this.prevShow.add(this.prevHide).stop(!0,!0),this.prevShow=i,this.prevHide=s,this.options.animate?this._animate(i,s,e):(s.hide(),i.show(),this._toggleComplete(e)),s.attr({"aria-hidden":"true"}),s.prev().attr({"aria-selected":"false","aria-expanded":"false"}),i.length&&s.length?s.prev().attr({tabIndex:-1,"aria-expanded":"false"}):i.length&&this.headers.filter(function(){return 0===parseInt(t(this).attr("tabIndex"),10)}).attr("tabIndex",-1),i.attr("aria-hidden","false").prev().attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0})},_animate:function(t,e,i){var s,n,o,a=this,r=0,h=t.css("box-sizing"),l=t.length&&(!e.length||t.index()<e.index()),c=this.options.animate||{},u=l&&c.down||c,d=function(){a._toggleComplete(i)};return"number"==typeof u&&(o=u),"string"==typeof u&&(n=u),n=n||u.easing||c.easing,o=o||u.duration||c.duration,e.length?t.length?(s=t.show().outerHeight(),e.animate(this.hideProps,{duration:o,easing:n,step:function(t,e){e.now=Math.round(t)}}),t.hide().animate(this.showProps,{duration:o,easing:n,complete:d,step:function(t,i){i.now=Math.round(t),"height"!==i.prop?"content-box"===h&&(r+=i.now):"content"!==a.options.heightStyle&&(i.now=Math.round(s-e.outerHeight()-r),r=0)}}),void 0):e.animate(this.hideProps,o,n,d):t.animate(this.showProps,o,n,d)},_toggleComplete:function(t){var e=t.oldPanel,i=e.prev();this._removeClass(e,"ui-accordion-content-active"),this._removeClass(i,"ui-accordion-header-active")._addClass(i,"ui-accordion-header-collapsed"),e.length&&(e.parent()[0].className=e.parent()[0].className),this._trigger("activate",null,t)}}),t.ui.safeActiveElement=function(t){var e;try{e=t.activeElement}catch(i){e=t.body}return e||(e=t.body),e.nodeName||(e=t.body),e},t.widget("ui.menu",{version:"1.12.1",defaultElement:"<ul>",delay:300,options:{icons:{submenu:"ui-icon-caret-1-e"},items:"> *",menus:"ul",position:{my:"left top",at:"right top"},role:"menu",blur:null,focus:null,select:null},_create:function(){this.activeMenu=this.element,this.mouseHandled=!1,this.element.uniqueId().attr({role:this.options.role,tabIndex:0}),this._addClass("ui-menu","ui-widget ui-widget-content"),this._on({"mousedown .ui-menu-item":function(t){t.preventDefault()},"click .ui-menu-item":function(e){var i=t(e.target),s=t(t.ui.safeActiveElement(this.document[0]));!this.mouseHandled&&i.not(".ui-state-disabled").length&&(this.select(e),e.isPropagationStopped()||(this.mouseHandled=!0),i.has(".ui-menu").length?this.expand(e):!this.element.is(":focus")&&s.closest(".ui-menu").length&&(this.element.trigger("focus",[!0]),this.active&&1===this.active.parents(".ui-menu").length&&clearTimeout(this.timer)))},"mouseenter .ui-menu-item":function(e){if(!this.previousFilter){var i=t(e.target).closest(".ui-menu-item"),s=t(e.currentTarget);i[0]===s[0]&&(this._removeClass(s.siblings().children(".ui-state-active"),null,"ui-state-active"),this.focus(e,s))}},mouseleave:"collapseAll","mouseleave .ui-menu":"collapseAll",focus:function(t,e){var i=this.active||this.element.find(this.options.items).eq(0);e||this.focus(t,i)},blur:function(e){this._delay(function(){var i=!t.contains(this.element[0],t.ui.safeActiveElement(this.document[0]));i&&this.collapseAll(e)})},keydown:"_keydown"}),this.refresh(),this._on(this.document,{click:function(t){this._closeOnDocumentClick(t)&&this.collapseAll(t),this.mouseHandled=!1}})},_destroy:function(){var e=this.element.find(".ui-menu-item").removeAttr("role aria-disabled"),i=e.children(".ui-menu-item-wrapper").removeUniqueId().removeAttr("tabIndex role aria-haspopup");this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeAttr("role aria-labelledby aria-expanded aria-hidden aria-disabled tabIndex").removeUniqueId().show(),i.children().each(function(){var e=t(this);e.data("ui-menu-submenu-caret")&&e.remove()})},_keydown:function(e){var i,s,n,o,a=!0;switch(e.keyCode){case t.ui.keyCode.PAGE_UP:this.previousPage(e);break;case t.ui.keyCode.PAGE_DOWN:this.nextPage(e);break;case t.ui.keyCode.HOME:this._move("first","first",e);break;case t.ui.keyCode.END:this._move("last","last",e);break;case t.ui.keyCode.UP:this.previous(e);break;case t.ui.keyCode.DOWN:this.next(e);break;case t.ui.keyCode.LEFT:this.collapse(e);break;case t.ui.keyCode.RIGHT:this.active&&!this.active.is(".ui-state-disabled")&&this.expand(e);break;case t.ui.keyCode.ENTER:case t.ui.keyCode.SPACE:this._activate(e);break;case t.ui.keyCode.ESCAPE:this.collapse(e);break;default:a=!1,s=this.previousFilter||"",o=!1,n=e.keyCode>=96&&105>=e.keyCode?""+(e.keyCode-96):String.fromCharCode(e.keyCode),clearTimeout(this.filterTimer),n===s?o=!0:n=s+n,i=this._filterMenuItems(n),i=o&&-1!==i.index(this.active.next())?this.active.nextAll(".ui-menu-item"):i,i.length||(n=String.fromCharCode(e.keyCode),i=this._filterMenuItems(n)),i.length?(this.focus(e,i),this.previousFilter=n,this.filterTimer=this._delay(function(){delete this.previousFilter},1e3)):delete this.previousFilter}a&&e.preventDefault()},_activate:function(t){this.active&&!this.active.is(".ui-state-disabled")&&(this.active.children("[aria-haspopup='true']").length?this.expand(t):this.select(t))},refresh:function(){var e,i,s,n,o,a=this,r=this.options.icons.submenu,h=this.element.find(this.options.menus);this._toggleClass("ui-menu-icons",null,!!this.element.find(".ui-icon").length),s=h.filter(":not(.ui-menu)").hide().attr({role:this.options.role,"aria-hidden":"true","aria-expanded":"false"}).each(function(){var e=t(this),i=e.prev(),s=t("<span>").data("ui-menu-submenu-caret",!0);a._addClass(s,"ui-menu-icon","ui-icon "+r),i.attr("aria-haspopup","true").prepend(s),e.attr("aria-labelledby",i.attr("id"))}),this._addClass(s,"ui-menu","ui-widget ui-widget-content ui-front"),e=h.add(this.element),i=e.find(this.options.items),i.not(".ui-menu-item").each(function(){var e=t(this);a._isDivider(e)&&a._addClass(e,"ui-menu-divider","ui-widget-content")}),n=i.not(".ui-menu-item, .ui-menu-divider"),o=n.children().not(".ui-menu").uniqueId().attr({tabIndex:-1,role:this._itemRole()}),this._addClass(n,"ui-menu-item")._addClass(o,"ui-menu-item-wrapper"),i.filter(".ui-state-disabled").attr("aria-disabled","true"),this.active&&!t.contains(this.element[0],this.active[0])&&this.blur()},_itemRole:function(){return{menu:"menuitem",listbox:"option"}[this.options.role]},_setOption:function(t,e){if("icons"===t){var i=this.element.find(".ui-menu-icon");this._removeClass(i,null,this.options.icons.submenu)._addClass(i,null,e.submenu)}this._super(t,e)},_setOptionDisabled:function(t){this._super(t),this.element.attr("aria-disabled",t+""),this._toggleClass(null,"ui-state-disabled",!!t)},focus:function(t,e){var i,s,n;this.blur(t,t&&"focus"===t.type),this._scrollIntoView(e),this.active=e.first(),s=this.active.children(".ui-menu-item-wrapper"),this._addClass(s,null,"ui-state-active"),this.options.role&&this.element.attr("aria-activedescendant",s.attr("id")),n=this.active.parent().closest(".ui-menu-item").children(".ui-menu-item-wrapper"),this._addClass(n,null,"ui-state-active"),t&&"keydown"===t.type?this._close():this.timer=this._delay(function(){this._close()},this.delay),i=e.children(".ui-menu"),i.length&&t&&/^mouse/.test(t.type)&&this._startOpening(i),this.activeMenu=e.parent(),this._trigger("focus",t,{item:e})},_scrollIntoView:function(e){var i,s,n,o,a,r;this._hasScroll()&&(i=parseFloat(t.css(this.activeMenu[0],"borderTopWidth"))||0,s=parseFloat(t.css(this.activeMenu[0],"paddingTop"))||0,n=e.offset().top-this.activeMenu.offset().top-i-s,o=this.activeMenu.scrollTop(),a=this.activeMenu.height(),r=e.outerHeight(),0>n?this.activeMenu.scrollTop(o+n):n+r>a&&this.activeMenu.scrollTop(o+n-a+r))},blur:function(t,e){e||clearTimeout(this.timer),this.active&&(this._removeClass(this.active.children(".ui-menu-item-wrapper"),null,"ui-state-active"),this._trigger("blur",t,{item:this.active}),this.active=null)},_startOpening:function(t){clearTimeout(this.timer),"true"===t.attr("aria-hidden")&&(this.timer=this._delay(function(){this._close(),this._open(t)},this.delay))},_open:function(e){var i=t.extend({of:this.active},this.options.position);clearTimeout(this.timer),this.element.find(".ui-menu").not(e.parents(".ui-menu")).hide().attr("aria-hidden","true"),e.show().removeAttr("aria-hidden").attr("aria-expanded","true").position(i)},collapseAll:function(e,i){clearTimeout(this.timer),this.timer=this._delay(function(){var s=i?this.element:t(e&&e.target).closest(this.element.find(".ui-menu"));s.length||(s=this.element),this._close(s),this.blur(e),this._removeClass(s.find(".ui-state-active"),null,"ui-state-active"),this.activeMenu=s},this.delay)},_close:function(t){t||(t=this.active?this.active.parent():this.element),t.find(".ui-menu").hide().attr("aria-hidden","true").attr("aria-expanded","false")},_closeOnDocumentClick:function(e){return!t(e.target).closest(".ui-menu").length},_isDivider:function(t){return!/[^\-\u2014\u2013\s]/.test(t.text())},collapse:function(t){var e=this.active&&this.active.parent().closest(".ui-menu-item",this.element);e&&e.length&&(this._close(),this.focus(t,e))},expand:function(t){var e=this.active&&this.active.children(".ui-menu ").find(this.options.items).first();e&&e.length&&(this._open(e.parent()),this._delay(function(){this.focus(t,e)}))},next:function(t){this._move("next","first",t)},previous:function(t){this._move("prev","last",t)},isFirstItem:function(){return this.active&&!this.active.prevAll(".ui-menu-item").length},isLastItem:function(){return this.active&&!this.active.nextAll(".ui-menu-item").length},_move:function(t,e,i){var s;this.active&&(s="first"===t||"last"===t?this.active["first"===t?"prevAll":"nextAll"](".ui-menu-item").eq(-1):this.active[t+"All"](".ui-menu-item").eq(0)),s&&s.length&&this.active||(s=this.activeMenu.find(this.options.items)[e]()),this.focus(i,s)},nextPage:function(e){var i,s,n;return this.active?(this.isLastItem()||(this._hasScroll()?(s=this.active.offset().top,n=this.element.height(),this.active.nextAll(".ui-menu-item").each(function(){return i=t(this),0>i.offset().top-s-n}),this.focus(e,i)):this.focus(e,this.activeMenu.find(this.options.items)[this.active?"last":"first"]())),void 0):(this.next(e),void 0)},previousPage:function(e){var i,s,n;return this.active?(this.isFirstItem()||(this._hasScroll()?(s=this.active.offset().top,n=this.element.height(),this.active.prevAll(".ui-menu-item").each(function(){return i=t(this),i.offset().top-s+n>0}),this.focus(e,i)):this.focus(e,this.activeMenu.find(this.options.items).first())),void 0):(this.next(e),void 0)},_hasScroll:function(){return this.element.outerHeight()<this.element.prop("scrollHeight")},select:function(e){this.active=this.active||t(e.target).closest(".ui-menu-item");var i={item:this.active};this.active.has(".ui-menu").length||this.collapseAll(e,!0),this._trigger("select",e,i)},_filterMenuItems:function(e){var i=e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&"),s=RegExp("^"+i,"i");return this.activeMenu.find(this.options.items).filter(".ui-menu-item").filter(function(){return s.test(t.trim(t(this).children(".ui-menu-item-wrapper").text()))})}}),t.widget("ui.autocomplete",{version:"1.12.1",defaultElement:"<input>",options:{appendTo:null,autoFocus:!1,delay:300,minLength:1,position:{my:"left top",at:"left bottom",collision:"none"},source:null,change:null,close:null,focus:null,open:null,response:null,search:null,select:null},requestIndex:0,pending:0,_create:function(){var e,i,s,n=this.element[0].nodeName.toLowerCase(),o="textarea"===n,a="input"===n;
this.isMultiLine=o||!a&&this._isContentEditable(this.element),this.valueMethod=this.element[o||a?"val":"text"],this.isNewMenu=!0,this._addClass("ui-autocomplete-input"),this.element.attr("autocomplete","off"),this._on(this.element,{keydown:function(n){if(this.element.prop("readOnly"))return e=!0,s=!0,i=!0,void 0;e=!1,s=!1,i=!1;var o=t.ui.keyCode;switch(n.keyCode){case o.PAGE_UP:e=!0,this._move("previousPage",n);break;case o.PAGE_DOWN:e=!0,this._move("nextPage",n);break;case o.UP:e=!0,this._keyEvent("previous",n);break;case o.DOWN:e=!0,this._keyEvent("next",n);break;case o.ENTER:this.menu.active&&(e=!0,n.preventDefault(),this.menu.select(n));break;case o.TAB:this.menu.active&&this.menu.select(n);break;case o.ESCAPE:this.menu.element.is(":visible")&&(this.isMultiLine||this._value(this.term),this.close(n),n.preventDefault());break;default:i=!0,this._searchTimeout(n)}},keypress:function(s){if(e)return e=!1,(!this.isMultiLine||this.menu.element.is(":visible"))&&s.preventDefault(),void 0;if(!i){var n=t.ui.keyCode;switch(s.keyCode){case n.PAGE_UP:this._move("previousPage",s);break;case n.PAGE_DOWN:this._move("nextPage",s);break;case n.UP:this._keyEvent("previous",s);break;case n.DOWN:this._keyEvent("next",s)}}},input:function(t){return s?(s=!1,t.preventDefault(),void 0):(this._searchTimeout(t),void 0)},focus:function(){this.selectedItem=null,this.previous=this._value()},blur:function(t){return this.cancelBlur?(delete this.cancelBlur,void 0):(clearTimeout(this.searching),this.close(t),this._change(t),void 0)}}),this._initSource(),this.menu=t("<ul>").appendTo(this._appendTo()).menu({role:null}).hide().menu("instance"),this._addClass(this.menu.element,"ui-autocomplete","ui-front"),this._on(this.menu.element,{mousedown:function(e){e.preventDefault(),this.cancelBlur=!0,this._delay(function(){delete this.cancelBlur,this.element[0]!==t.ui.safeActiveElement(this.document[0])&&this.element.trigger("focus")})},menufocus:function(e,i){var s,n;return this.isNewMenu&&(this.isNewMenu=!1,e.originalEvent&&/^mouse/.test(e.originalEvent.type))?(this.menu.blur(),this.document.one("mousemove",function(){t(e.target).trigger(e.originalEvent)}),void 0):(n=i.item.data("ui-autocomplete-item"),!1!==this._trigger("focus",e,{item:n})&&e.originalEvent&&/^key/.test(e.originalEvent.type)&&this._value(n.value),s=i.item.attr("aria-label")||n.value,s&&t.trim(s).length&&(this.liveRegion.children().hide(),t("<div>").text(s).appendTo(this.liveRegion)),void 0)},menuselect:function(e,i){var s=i.item.data("ui-autocomplete-item"),n=this.previous;this.element[0]!==t.ui.safeActiveElement(this.document[0])&&(this.element.trigger("focus"),this.previous=n,this._delay(function(){this.previous=n,this.selectedItem=s})),!1!==this._trigger("select",e,{item:s})&&this._value(s.value),this.term=this._value(),this.close(e),this.selectedItem=s}}),this.liveRegion=t("<div>",{role:"status","aria-live":"assertive","aria-relevant":"additions"}).appendTo(this.document[0].body),this._addClass(this.liveRegion,null,"ui-helper-hidden-accessible"),this._on(this.window,{beforeunload:function(){this.element.removeAttr("autocomplete")}})},_destroy:function(){clearTimeout(this.searching),this.element.removeAttr("autocomplete"),this.menu.element.remove(),this.liveRegion.remove()},_setOption:function(t,e){this._super(t,e),"source"===t&&this._initSource(),"appendTo"===t&&this.menu.element.appendTo(this._appendTo()),"disabled"===t&&e&&this.xhr&&this.xhr.abort()},_isEventTargetInWidget:function(e){var i=this.menu.element[0];return e.target===this.element[0]||e.target===i||t.contains(i,e.target)},_closeOnClickOutside:function(t){this._isEventTargetInWidget(t)||this.close()},_appendTo:function(){var e=this.options.appendTo;return e&&(e=e.jquery||e.nodeType?t(e):this.document.find(e).eq(0)),e&&e[0]||(e=this.element.closest(".ui-front, dialog")),e.length||(e=this.document[0].body),e},_initSource:function(){var e,i,s=this;t.isArray(this.options.source)?(e=this.options.source,this.source=function(i,s){s(t.ui.autocomplete.filter(e,i.term))}):"string"==typeof this.options.source?(i=this.options.source,this.source=function(e,n){s.xhr&&s.xhr.abort(),s.xhr=t.ajax({url:i,data:e,dataType:"json",success:function(t){n(t)},error:function(){n([])}})}):this.source=this.options.source},_searchTimeout:function(t){clearTimeout(this.searching),this.searching=this._delay(function(){var e=this.term===this._value(),i=this.menu.element.is(":visible"),s=t.altKey||t.ctrlKey||t.metaKey||t.shiftKey;(!e||e&&!i&&!s)&&(this.selectedItem=null,this.search(null,t))},this.options.delay)},search:function(t,e){return t=null!=t?t:this._value(),this.term=this._value(),t.length<this.options.minLength?this.close(e):this._trigger("search",e)!==!1?this._search(t):void 0},_search:function(t){this.pending++,this._addClass("ui-autocomplete-loading"),this.cancelSearch=!1,this.source({term:t},this._response())},_response:function(){var e=++this.requestIndex;return t.proxy(function(t){e===this.requestIndex&&this.__response(t),this.pending--,this.pending||this._removeClass("ui-autocomplete-loading")},this)},__response:function(t){t&&(t=this._normalize(t)),this._trigger("response",null,{content:t}),!this.options.disabled&&t&&t.length&&!this.cancelSearch?(this._suggest(t),this._trigger("open")):this._close()},close:function(t){this.cancelSearch=!0,this._close(t)},_close:function(t){this._off(this.document,"mousedown"),this.menu.element.is(":visible")&&(this.menu.element.hide(),this.menu.blur(),this.isNewMenu=!0,this._trigger("close",t))},_change:function(t){this.previous!==this._value()&&this._trigger("change",t,{item:this.selectedItem})},_normalize:function(e){return e.length&&e[0].label&&e[0].value?e:t.map(e,function(e){return"string"==typeof e?{label:e,value:e}:t.extend({},e,{label:e.label||e.value,value:e.value||e.label})})},_suggest:function(e){var i=this.menu.element.empty();this._renderMenu(i,e),this.isNewMenu=!0,this.menu.refresh(),i.show(),this._resizeMenu(),i.position(t.extend({of:this.element},this.options.position)),this.options.autoFocus&&this.menu.next(),this._on(this.document,{mousedown:"_closeOnClickOutside"})},_resizeMenu:function(){var t=this.menu.element;t.outerWidth(Math.max(t.width("").outerWidth()+1,this.element.outerWidth()))},_renderMenu:function(e,i){var s=this;t.each(i,function(t,i){s._renderItemData(e,i)})},_renderItemData:function(t,e){return this._renderItem(t,e).data("ui-autocomplete-item",e)},_renderItem:function(e,i){return t("<li>").append(t("<div>").text(i.label)).appendTo(e)},_move:function(t,e){return this.menu.element.is(":visible")?this.menu.isFirstItem()&&/^previous/.test(t)||this.menu.isLastItem()&&/^next/.test(t)?(this.isMultiLine||this._value(this.term),this.menu.blur(),void 0):(this.menu[t](e),void 0):(this.search(null,e),void 0)},widget:function(){return this.menu.element},_value:function(){return this.valueMethod.apply(this.element,arguments)},_keyEvent:function(t,e){(!this.isMultiLine||this.menu.element.is(":visible"))&&(this._move(t,e),e.preventDefault())},_isContentEditable:function(t){if(!t.length)return!1;var e=t.prop("contentEditable");return"inherit"===e?this._isContentEditable(t.parent()):"true"===e}}),t.extend(t.ui.autocomplete,{escapeRegex:function(t){return t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&")},filter:function(e,i){var s=RegExp(t.ui.autocomplete.escapeRegex(i),"i");return t.grep(e,function(t){return s.test(t.label||t.value||t)})}}),t.widget("ui.autocomplete",t.ui.autocomplete,{options:{messages:{noResults:"No search results.",results:function(t){return t+(t>1?" results are":" result is")+" available, use up and down arrow keys to navigate."}}},__response:function(e){var i;this._superApply(arguments),this.options.disabled||this.cancelSearch||(i=e&&e.length?this.options.messages.results(e.length):this.options.messages.noResults,this.liveRegion.children().hide(),t("<div>").text(i).appendTo(this.liveRegion))}}),t.ui.autocomplete;var g=/ui-corner-([a-z]){2,6}/g;t.widget("ui.controlgroup",{version:"1.12.1",defaultElement:"<div>",options:{direction:"horizontal",disabled:null,onlyVisible:!0,items:{button:"input[type=button], input[type=submit], input[type=reset], button, a",controlgroupLabel:".ui-controlgroup-label",checkboxradio:"input[type='checkbox'], input[type='radio']",selectmenu:"select",spinner:".ui-spinner-input"}},_create:function(){this._enhance()},_enhance:function(){this.element.attr("role","toolbar"),this.refresh()},_destroy:function(){this._callChildMethod("destroy"),this.childWidgets.removeData("ui-controlgroup-data"),this.element.removeAttr("role"),this.options.items.controlgroupLabel&&this.element.find(this.options.items.controlgroupLabel).find(".ui-controlgroup-label-contents").contents().unwrap()},_initWidgets:function(){var e=this,i=[];t.each(this.options.items,function(s,n){var o,a={};return n?"controlgroupLabel"===s?(o=e.element.find(n),o.each(function(){var e=t(this);e.children(".ui-controlgroup-label-contents").length||e.contents().wrapAll("<span class='ui-controlgroup-label-contents'></span>")}),e._addClass(o,null,"ui-widget ui-widget-content ui-state-default"),i=i.concat(o.get()),void 0):(t.fn[s]&&(a=e["_"+s+"Options"]?e["_"+s+"Options"]("middle"):{classes:{}},e.element.find(n).each(function(){var n=t(this),o=n[s]("instance"),r=t.widget.extend({},a);if("button"!==s||!n.parent(".ui-spinner").length){o||(o=n[s]()[s]("instance")),o&&(r.classes=e._resolveClassesValues(r.classes,o)),n[s](r);var h=n[s]("widget");t.data(h[0],"ui-controlgroup-data",o?o:n[s]("instance")),i.push(h[0])}})),void 0):void 0}),this.childWidgets=t(t.unique(i)),this._addClass(this.childWidgets,"ui-controlgroup-item")},_callChildMethod:function(e){this.childWidgets.each(function(){var i=t(this),s=i.data("ui-controlgroup-data");s&&s[e]&&s[e]()})},_updateCornerClass:function(t,e){var i="ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all",s=this._buildSimpleOptions(e,"label").classes.label;this._removeClass(t,null,i),this._addClass(t,null,s)},_buildSimpleOptions:function(t,e){var i="vertical"===this.options.direction,s={classes:{}};return s.classes[e]={middle:"",first:"ui-corner-"+(i?"top":"left"),last:"ui-corner-"+(i?"bottom":"right"),only:"ui-corner-all"}[t],s},_spinnerOptions:function(t){var e=this._buildSimpleOptions(t,"ui-spinner");return e.classes["ui-spinner-up"]="",e.classes["ui-spinner-down"]="",e},_buttonOptions:function(t){return this._buildSimpleOptions(t,"ui-button")},_checkboxradioOptions:function(t){return this._buildSimpleOptions(t,"ui-checkboxradio-label")},_selectmenuOptions:function(t){var e="vertical"===this.options.direction;return{width:e?"auto":!1,classes:{middle:{"ui-selectmenu-button-open":"","ui-selectmenu-button-closed":""},first:{"ui-selectmenu-button-open":"ui-corner-"+(e?"top":"tl"),"ui-selectmenu-button-closed":"ui-corner-"+(e?"top":"left")},last:{"ui-selectmenu-button-open":e?"":"ui-corner-tr","ui-selectmenu-button-closed":"ui-corner-"+(e?"bottom":"right")},only:{"ui-selectmenu-button-open":"ui-corner-top","ui-selectmenu-button-closed":"ui-corner-all"}}[t]}},_resolveClassesValues:function(e,i){var s={};return t.each(e,function(n){var o=i.options.classes[n]||"";o=t.trim(o.replace(g,"")),s[n]=(o+" "+e[n]).replace(/\s+/g," ")}),s},_setOption:function(t,e){return"direction"===t&&this._removeClass("ui-controlgroup-"+this.options.direction),this._super(t,e),"disabled"===t?(this._callChildMethod(e?"disable":"enable"),void 0):(this.refresh(),void 0)},refresh:function(){var e,i=this;this._addClass("ui-controlgroup ui-controlgroup-"+this.options.direction),"horizontal"===this.options.direction&&this._addClass(null,"ui-helper-clearfix"),this._initWidgets(),e=this.childWidgets,this.options.onlyVisible&&(e=e.filter(":visible")),e.length&&(t.each(["first","last"],function(t,s){var n=e[s]().data("ui-controlgroup-data");if(n&&i["_"+n.widgetName+"Options"]){var o=i["_"+n.widgetName+"Options"](1===e.length?"only":s);o.classes=i._resolveClassesValues(o.classes,n),n.element[n.widgetName](o)}else i._updateCornerClass(e[s](),s)}),this._callChildMethod("refresh"))}}),t.widget("ui.checkboxradio",[t.ui.formResetMixin,{version:"1.12.1",options:{disabled:null,label:null,icon:!0,classes:{"ui-checkboxradio-label":"ui-corner-all","ui-checkboxradio-icon":"ui-corner-all"}},_getCreateOptions:function(){var e,i,s=this,n=this._super()||{};return this._readType(),i=this.element.labels(),this.label=t(i[i.length-1]),this.label.length||t.error("No label found for checkboxradio widget"),this.originalLabel="",this.label.contents().not(this.element[0]).each(function(){s.originalLabel+=3===this.nodeType?t(this).text():this.outerHTML}),this.originalLabel&&(n.label=this.originalLabel),e=this.element[0].disabled,null!=e&&(n.disabled=e),n},_create:function(){var t=this.element[0].checked;this._bindFormResetHandler(),null==this.options.disabled&&(this.options.disabled=this.element[0].disabled),this._setOption("disabled",this.options.disabled),this._addClass("ui-checkboxradio","ui-helper-hidden-accessible"),this._addClass(this.label,"ui-checkboxradio-label","ui-button ui-widget"),"radio"===this.type&&this._addClass(this.label,"ui-checkboxradio-radio-label"),this.options.label&&this.options.label!==this.originalLabel?this._updateLabel():this.originalLabel&&(this.options.label=this.originalLabel),this._enhance(),t&&(this._addClass(this.label,"ui-checkboxradio-checked","ui-state-active"),this.icon&&this._addClass(this.icon,null,"ui-state-hover")),this._on({change:"_toggleClasses",focus:function(){this._addClass(this.label,null,"ui-state-focus ui-visual-focus")},blur:function(){this._removeClass(this.label,null,"ui-state-focus ui-visual-focus")}})},_readType:function(){var e=this.element[0].nodeName.toLowerCase();this.type=this.element[0].type,"input"===e&&/radio|checkbox/.test(this.type)||t.error("Can't create checkboxradio on element.nodeName="+e+" and element.type="+this.type)},_enhance:function(){this._updateIcon(this.element[0].checked)},widget:function(){return this.label},_getRadioGroup:function(){var e,i=this.element[0].name,s="input[name='"+t.ui.escapeSelector(i)+"']";return i?(e=this.form.length?t(this.form[0].elements).filter(s):t(s).filter(function(){return 0===t(this).form().length}),e.not(this.element)):t([])},_toggleClasses:function(){var e=this.element[0].checked;this._toggleClass(this.label,"ui-checkboxradio-checked","ui-state-active",e),this.options.icon&&"checkbox"===this.type&&this._toggleClass(this.icon,null,"ui-icon-check ui-state-checked",e)._toggleClass(this.icon,null,"ui-icon-blank",!e),"radio"===this.type&&this._getRadioGroup().each(function(){var e=t(this).checkboxradio("instance");e&&e._removeClass(e.label,"ui-checkboxradio-checked","ui-state-active")})},_destroy:function(){this._unbindFormResetHandler(),this.icon&&(this.icon.remove(),this.iconSpace.remove())},_setOption:function(t,e){return"label"!==t||e?(this._super(t,e),"disabled"===t?(this._toggleClass(this.label,null,"ui-state-disabled",e),this.element[0].disabled=e,void 0):(this.refresh(),void 0)):void 0},_updateIcon:function(e){var i="ui-icon ui-icon-background ";this.options.icon?(this.icon||(this.icon=t("<span>"),this.iconSpace=t("<span> </span>"),this._addClass(this.iconSpace,"ui-checkboxradio-icon-space")),"checkbox"===this.type?(i+=e?"ui-icon-check ui-state-checked":"ui-icon-blank",this._removeClass(this.icon,null,e?"ui-icon-blank":"ui-icon-check")):i+="ui-icon-blank",this._addClass(this.icon,"ui-checkboxradio-icon",i),e||this._removeClass(this.icon,null,"ui-icon-check ui-state-checked"),this.icon.prependTo(this.label).after(this.iconSpace)):void 0!==this.icon&&(this.icon.remove(),this.iconSpace.remove(),delete this.icon)},_updateLabel:function(){var t=this.label.contents().not(this.element[0]);this.icon&&(t=t.not(this.icon[0])),this.iconSpace&&(t=t.not(this.iconSpace[0])),t.remove(),this.label.append(this.options.label)},refresh:function(){var t=this.element[0].checked,e=this.element[0].disabled;this._updateIcon(t),this._toggleClass(this.label,"ui-checkboxradio-checked","ui-state-active",t),null!==this.options.label&&this._updateLabel(),e!==this.options.disabled&&this._setOptions({disabled:e})}}]),t.ui.checkboxradio,t.widget("ui.button",{version:"1.12.1",defaultElement:"<button>",options:{classes:{"ui-button":"ui-corner-all"},disabled:null,icon:null,iconPosition:"beginning",label:null,showLabel:!0},_getCreateOptions:function(){var t,e=this._super()||{};return this.isInput=this.element.is("input"),t=this.element[0].disabled,null!=t&&(e.disabled=t),this.originalLabel=this.isInput?this.element.val():this.element.html(),this.originalLabel&&(e.label=this.originalLabel),e},_create:function(){!this.option.showLabel&!this.options.icon&&(this.options.showLabel=!0),null==this.options.disabled&&(this.options.disabled=this.element[0].disabled||!1),this.hasTitle=!!this.element.attr("title"),this.options.label&&this.options.label!==this.originalLabel&&(this.isInput?this.element.val(this.options.label):this.element.html(this.options.label)),this._addClass("ui-button","ui-widget"),this._setOption("disabled",this.options.disabled),this._enhance(),this.element.is("a")&&this._on({keyup:function(e){e.keyCode===t.ui.keyCode.SPACE&&(e.preventDefault(),this.element[0].click?this.element[0].click():this.element.trigger("click"))}})},_enhance:function(){this.element.is("button")||this.element.attr("role","button"),this.options.icon&&(this._updateIcon("icon",this.options.icon),this._updateTooltip())},_updateTooltip:function(){this.title=this.element.attr("title"),this.options.showLabel||this.title||this.element.attr("title",this.options.label)},_updateIcon:function(e,i){var s="iconPosition"!==e,n=s?this.options.iconPosition:i,o="top"===n||"bottom"===n;this.icon?s&&this._removeClass(this.icon,null,this.options.icon):(this.icon=t("<span>"),this._addClass(this.icon,"ui-button-icon","ui-icon"),this.options.showLabel||this._addClass("ui-button-icon-only")),s&&this._addClass(this.icon,null,i),this._attachIcon(n),o?(this._addClass(this.icon,null,"ui-widget-icon-block"),this.iconSpace&&this.iconSpace.remove()):(this.iconSpace||(this.iconSpace=t("<span> </span>"),this._addClass(this.iconSpace,"ui-button-icon-space")),this._removeClass(this.icon,null,"ui-wiget-icon-block"),this._attachIconSpace(n))},_destroy:function(){this.element.removeAttr("role"),this.icon&&this.icon.remove(),this.iconSpace&&this.iconSpace.remove(),this.hasTitle||this.element.removeAttr("title")},_attachIconSpace:function(t){this.icon[/^(?:end|bottom)/.test(t)?"before":"after"](this.iconSpace)},_attachIcon:function(t){this.element[/^(?:end|bottom)/.test(t)?"append":"prepend"](this.icon)},_setOptions:function(t){var e=void 0===t.showLabel?this.options.showLabel:t.showLabel,i=void 0===t.icon?this.options.icon:t.icon;e||i||(t.showLabel=!0),this._super(t)},_setOption:function(t,e){"icon"===t&&(e?this._updateIcon(t,e):this.icon&&(this.icon.remove(),this.iconSpace&&this.iconSpace.remove())),"iconPosition"===t&&this._updateIcon(t,e),"showLabel"===t&&(this._toggleClass("ui-button-icon-only",null,!e),this._updateTooltip()),"label"===t&&(this.isInput?this.element.val(e):(this.element.html(e),this.icon&&(this._attachIcon(this.options.iconPosition),this._attachIconSpace(this.options.iconPosition)))),this._super(t,e),"disabled"===t&&(this._toggleClass(null,"ui-state-disabled",e),this.element[0].disabled=e,e&&this.element.blur())},refresh:function(){var t=this.element.is("input, button")?this.element[0].disabled:this.element.hasClass("ui-button-disabled");t!==this.options.disabled&&this._setOptions({disabled:t}),this._updateTooltip()}}),t.uiBackCompat!==!1&&(t.widget("ui.button",t.ui.button,{options:{text:!0,icons:{primary:null,secondary:null}},_create:function(){this.options.showLabel&&!this.options.text&&(this.options.showLabel=this.options.text),!this.options.showLabel&&this.options.text&&(this.options.text=this.options.showLabel),this.options.icon||!this.options.icons.primary&&!this.options.icons.secondary?this.options.icon&&(this.options.icons.primary=this.options.icon):this.options.icons.primary?this.options.icon=this.options.icons.primary:(this.options.icon=this.options.icons.secondary,this.options.iconPosition="end"),this._super()},_setOption:function(t,e){return"text"===t?(this._super("showLabel",e),void 0):("showLabel"===t&&(this.options.text=e),"icon"===t&&(this.options.icons.primary=e),"icons"===t&&(e.primary?(this._super("icon",e.primary),this._super("iconPosition","beginning")):e.secondary&&(this._super("icon",e.secondary),this._super("iconPosition","end"))),this._superApply(arguments),void 0)}}),t.fn.button=function(e){return function(){return!this.length||this.length&&"INPUT"!==this[0].tagName||this.length&&"INPUT"===this[0].tagName&&"checkbox"!==this.attr("type")&&"radio"!==this.attr("type")?e.apply(this,arguments):(t.ui.checkboxradio||t.error("Checkboxradio widget missing"),0===arguments.length?this.checkboxradio({icon:!1}):this.checkboxradio.apply(this,arguments))}}(t.fn.button),t.fn.buttonset=function(){return t.ui.controlgroup||t.error("Controlgroup widget missing"),"option"===arguments[0]&&"items"===arguments[1]&&arguments[2]?this.controlgroup.apply(this,[arguments[0],"items.button",arguments[2]]):"option"===arguments[0]&&"items"===arguments[1]?this.controlgroup.apply(this,[arguments[0],"items.button"]):("object"==typeof arguments[0]&&arguments[0].items&&(arguments[0].items={button:arguments[0].items}),this.controlgroup.apply(this,arguments))}),t.ui.button,t.extend(t.ui,{datepicker:{version:"1.12.1"}});var m;t.extend(s.prototype,{markerClassName:"hasDatepicker",maxRows:4,_widgetDatepicker:function(){return this.dpDiv},setDefaults:function(t){return a(this._defaults,t||{}),this},_attachDatepicker:function(e,i){var s,n,o;s=e.nodeName.toLowerCase(),n="div"===s||"span"===s,e.id||(this.uuid+=1,e.id="dp"+this.uuid),o=this._newInst(t(e),n),o.settings=t.extend({},i||{}),"input"===s?this._connectDatepicker(e,o):n&&this._inlineDatepicker(e,o)},_newInst:function(e,i){var s=e[0].id.replace(/([^A-Za-z0-9_\-])/g,"\\\\$1");return{id:s,input:e,selectedDay:0,selectedMonth:0,selectedYear:0,drawMonth:0,drawYear:0,inline:i,dpDiv:i?n(t("<div class='"+this._inlineClass+" ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")):this.dpDiv}},_connectDatepicker:function(e,i){var s=t(e);i.append=t([]),i.trigger=t([]),s.hasClass(this.markerClassName)||(this._attachments(s,i),s.addClass(this.markerClassName).on("keydown",this._doKeyDown).on("keypress",this._doKeyPress).on("keyup",this._doKeyUp),this._autoSize(i),t.data(e,"datepicker",i),i.settings.disabled&&this._disableDatepicker(e))},_attachments:function(e,i){var s,n,o,a=this._get(i,"appendText"),r=this._get(i,"isRTL");i.append&&i.append.remove(),a&&(i.append=t("<span class='"+this._appendClass+"'>"+a+"</span>"),e[r?"before":"after"](i.append)),e.off("focus",this._showDatepicker),i.trigger&&i.trigger.remove(),s=this._get(i,"showOn"),("focus"===s||"both"===s)&&e.on("focus",this._showDatepicker),("button"===s||"both"===s)&&(n=this._get(i,"buttonText"),o=this._get(i,"buttonImage"),i.trigger=t(this._get(i,"buttonImageOnly")?t("<img/>").addClass(this._triggerClass).attr({src:o,alt:n,title:n}):t("<button type='button'></button>").addClass(this._triggerClass).html(o?t("<img/>").attr({src:o,alt:n,title:n}):n)),e[r?"before":"after"](i.trigger),i.trigger.on("click",function(){return t.datepicker._datepickerShowing&&t.datepicker._lastInput===e[0]?t.datepicker._hideDatepicker():t.datepicker._datepickerShowing&&t.datepicker._lastInput!==e[0]?(t.datepicker._hideDatepicker(),t.datepicker._showDatepicker(e[0])):t.datepicker._showDatepicker(e[0]),!1}))},_autoSize:function(t){if(this._get(t,"autoSize")&&!t.inline){var e,i,s,n,o=new Date(2009,11,20),a=this._get(t,"dateFormat");a.match(/[DM]/)&&(e=function(t){for(i=0,s=0,n=0;t.length>n;n++)t[n].length>i&&(i=t[n].length,s=n);return s},o.setMonth(e(this._get(t,a.match(/MM/)?"monthNames":"monthNamesShort"))),o.setDate(e(this._get(t,a.match(/DD/)?"dayNames":"dayNamesShort"))+20-o.getDay())),t.input.attr("size",this._formatDate(t,o).length)}},_inlineDatepicker:function(e,i){var s=t(e);s.hasClass(this.markerClassName)||(s.addClass(this.markerClassName).append(i.dpDiv),t.data(e,"datepicker",i),this._setDate(i,this._getDefaultDate(i),!0),this._updateDatepicker(i),this._updateAlternate(i),i.settings.disabled&&this._disableDatepicker(e),i.dpDiv.css("display","block"))},_dialogDatepicker:function(e,i,s,n,o){var r,h,l,c,u,d=this._dialogInst;return d||(this.uuid+=1,r="dp"+this.uuid,this._dialogInput=t("<input type='text' id='"+r+"' style='position: absolute; top: -100px; width: 0px;'/>"),this._dialogInput.on("keydown",this._doKeyDown),t("body").append(this._dialogInput),d=this._dialogInst=this._newInst(this._dialogInput,!1),d.settings={},t.data(this._dialogInput[0],"datepicker",d)),a(d.settings,n||{}),i=i&&i.constructor===Date?this._formatDate(d,i):i,this._dialogInput.val(i),this._pos=o?o.length?o:[o.pageX,o.pageY]:null,this._pos||(h=document.documentElement.clientWidth,l=document.documentElement.clientHeight,c=document.documentElement.scrollLeft||document.body.scrollLeft,u=document.documentElement.scrollTop||document.body.scrollTop,this._pos=[h/2-100+c,l/2-150+u]),this._dialogInput.css("left",this._pos[0]+20+"px").css("top",this._pos[1]+"px"),d.settings.onSelect=s,this._inDialog=!0,this.dpDiv.addClass(this._dialogClass),this._showDatepicker(this._dialogInput[0]),t.blockUI&&t.blockUI(this.dpDiv),t.data(this._dialogInput[0],"datepicker",d),this},_destroyDatepicker:function(e){var i,s=t(e),n=t.data(e,"datepicker");s.hasClass(this.markerClassName)&&(i=e.nodeName.toLowerCase(),t.removeData(e,"datepicker"),"input"===i?(n.append.remove(),n.trigger.remove(),s.removeClass(this.markerClassName).off("focus",this._showDatepicker).off("keydown",this._doKeyDown).off("keypress",this._doKeyPress).off("keyup",this._doKeyUp)):("div"===i||"span"===i)&&s.removeClass(this.markerClassName).empty(),m===n&&(m=null))},_enableDatepicker:function(e){var i,s,n=t(e),o=t.data(e,"datepicker");n.hasClass(this.markerClassName)&&(i=e.nodeName.toLowerCase(),"input"===i?(e.disabled=!1,o.trigger.filter("button").each(function(){this.disabled=!1}).end().filter("img").css({opacity:"1.0",cursor:""})):("div"===i||"span"===i)&&(s=n.children("."+this._inlineClass),s.children().removeClass("ui-state-disabled"),s.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled",!1)),this._disabledInputs=t.map(this._disabledInputs,function(t){return t===e?null:t}))},_disableDatepicker:function(e){var i,s,n=t(e),o=t.data(e,"datepicker");n.hasClass(this.markerClassName)&&(i=e.nodeName.toLowerCase(),"input"===i?(e.disabled=!0,o.trigger.filter("button").each(function(){this.disabled=!0}).end().filter("img").css({opacity:"0.5",cursor:"default"})):("div"===i||"span"===i)&&(s=n.children("."+this._inlineClass),s.children().addClass("ui-state-disabled"),s.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled",!0)),this._disabledInputs=t.map(this._disabledInputs,function(t){return t===e?null:t}),this._disabledInputs[this._disabledInputs.length]=e)},_isDisabledDatepicker:function(t){if(!t)return!1;for(var e=0;this._disabledInputs.length>e;e++)if(this._disabledInputs[e]===t)return!0;return!1},_getInst:function(e){try{return t.data(e,"datepicker")}catch(i){throw"Missing instance data for this datepicker"}},_optionDatepicker:function(e,i,s){var n,o,r,h,l=this._getInst(e);return 2===arguments.length&&"string"==typeof i?"defaults"===i?t.extend({},t.datepicker._defaults):l?"all"===i?t.extend({},l.settings):this._get(l,i):null:(n=i||{},"string"==typeof i&&(n={},n[i]=s),l&&(this._curInst===l&&this._hideDatepicker(),o=this._getDateDatepicker(e,!0),r=this._getMinMaxDate(l,"min"),h=this._getMinMaxDate(l,"max"),a(l.settings,n),null!==r&&void 0!==n.dateFormat&&void 0===n.minDate&&(l.settings.minDate=this._formatDate(l,r)),null!==h&&void 0!==n.dateFormat&&void 0===n.maxDate&&(l.settings.maxDate=this._formatDate(l,h)),"disabled"in n&&(n.disabled?this._disableDatepicker(e):this._enableDatepicker(e)),this._attachments(t(e),l),this._autoSize(l),this._setDate(l,o),this._updateAlternate(l),this._updateDatepicker(l)),void 0)},_changeDatepicker:function(t,e,i){this._optionDatepicker(t,e,i)},_refreshDatepicker:function(t){var e=this._getInst(t);e&&this._updateDatepicker(e)},_setDateDatepicker:function(t,e){var i=this._getInst(t);i&&(this._setDate(i,e),this._updateDatepicker(i),this._updateAlternate(i))},_getDateDatepicker:function(t,e){var i=this._getInst(t);return i&&!i.inline&&this._setDateFromField(i,e),i?this._getDate(i):null},_doKeyDown:function(e){var i,s,n,o=t.datepicker._getInst(e.target),a=!0,r=o.dpDiv.is(".ui-datepicker-rtl");if(o._keyEvent=!0,t.datepicker._datepickerShowing)switch(e.keyCode){case 9:t.datepicker._hideDatepicker(),a=!1;break;case 13:return n=t("td."+t.datepicker._dayOverClass+":not(."+t.datepicker._currentClass+")",o.dpDiv),n[0]&&t.datepicker._selectDay(e.target,o.selectedMonth,o.selectedYear,n[0]),i=t.datepicker._get(o,"onSelect"),i?(s=t.datepicker._formatDate(o),i.apply(o.input?o.input[0]:null,[s,o])):t.datepicker._hideDatepicker(),!1;case 27:t.datepicker._hideDatepicker();break;case 33:t.datepicker._adjustDate(e.target,e.ctrlKey?-t.datepicker._get(o,"stepBigMonths"):-t.datepicker._get(o,"stepMonths"),"M");break;case 34:t.datepicker._adjustDate(e.target,e.ctrlKey?+t.datepicker._get(o,"stepBigMonths"):+t.datepicker._get(o,"stepMonths"),"M");break;case 35:(e.ctrlKey||e.metaKey)&&t.datepicker._clearDate(e.target),a=e.ctrlKey||e.metaKey;break;case 36:(e.ctrlKey||e.metaKey)&&t.datepicker._gotoToday(e.target),a=e.ctrlKey||e.metaKey;break;case 37:(e.ctrlKey||e.metaKey)&&t.datepicker._adjustDate(e.target,r?1:-1,"D"),a=e.ctrlKey||e.metaKey,e.originalEvent.altKey&&t.datepicker._adjustDate(e.target,e.ctrlKey?-t.datepicker._get(o,"stepBigMonths"):-t.datepicker._get(o,"stepMonths"),"M");break;case 38:(e.ctrlKey||e.metaKey)&&t.datepicker._adjustDate(e.target,-7,"D"),a=e.ctrlKey||e.metaKey;break;case 39:(e.ctrlKey||e.metaKey)&&t.datepicker._adjustDate(e.target,r?-1:1,"D"),a=e.ctrlKey||e.metaKey,e.originalEvent.altKey&&t.datepicker._adjustDate(e.target,e.ctrlKey?+t.datepicker._get(o,"stepBigMonths"):+t.datepicker._get(o,"stepMonths"),"M");break;case 40:(e.ctrlKey||e.metaKey)&&t.datepicker._adjustDate(e.target,7,"D"),a=e.ctrlKey||e.metaKey;break;default:a=!1}else 36===e.keyCode&&e.ctrlKey?t.datepicker._showDatepicker(this):a=!1;a&&(e.preventDefault(),e.stopPropagation())},_doKeyPress:function(e){var i,s,n=t.datepicker._getInst(e.target);return t.datepicker._get(n,"constrainInput")?(i=t.datepicker._possibleChars(t.datepicker._get(n,"dateFormat")),s=String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),e.ctrlKey||e.metaKey||" ">s||!i||i.indexOf(s)>-1):void 0},_doKeyUp:function(e){var i,s=t.datepicker._getInst(e.target);if(s.input.val()!==s.lastVal)try{i=t.datepicker.parseDate(t.datepicker._get(s,"dateFormat"),s.input?s.input.val():null,t.datepicker._getFormatConfig(s)),i&&(t.datepicker._setDateFromField(s),t.datepicker._updateAlternate(s),t.datepicker._updateDatepicker(s))}catch(n){}return!0},_showDatepicker:function(e){if(e=e.target||e,"input"!==e.nodeName.toLowerCase()&&(e=t("input",e.parentNode)[0]),!t.datepicker._isDisabledDatepicker(e)&&t.datepicker._lastInput!==e){var s,n,o,r,h,l,c;s=t.datepicker._getInst(e),t.datepicker._curInst&&t.datepicker._curInst!==s&&(t.datepicker._curInst.dpDiv.stop(!0,!0),s&&t.datepicker._datepickerShowing&&t.datepicker._hideDatepicker(t.datepicker._curInst.input[0])),n=t.datepicker._get(s,"beforeShow"),o=n?n.apply(e,[e,s]):{},o!==!1&&(a(s.settings,o),s.lastVal=null,t.datepicker._lastInput=e,t.datepicker._setDateFromField(s),t.datepicker._inDialog&&(e.value=""),t.datepicker._pos||(t.datepicker._pos=t.datepicker._findPos(e),t.datepicker._pos[1]+=e.offsetHeight),r=!1,t(e).parents().each(function(){return r|="fixed"===t(this).css("position"),!r}),h={left:t.datepicker._pos[0],top:t.datepicker._pos[1]},t.datepicker._pos=null,s.dpDiv.empty(),s.dpDiv.css({position:"absolute",display:"block",top:"-1000px"}),t.datepicker._updateDatepicker(s),h=t.datepicker._checkOffset(s,h,r),s.dpDiv.css({position:t.datepicker._inDialog&&t.blockUI?"static":r?"fixed":"absolute",display:"none",left:h.left+"px",top:h.top+"px"}),s.inline||(l=t.datepicker._get(s,"showAnim"),c=t.datepicker._get(s,"duration"),s.dpDiv.css("z-index",i(t(e))+1),t.datepicker._datepickerShowing=!0,t.effects&&t.effects.effect[l]?s.dpDiv.show(l,t.datepicker._get(s,"showOptions"),c):s.dpDiv[l||"show"](l?c:null),t.datepicker._shouldFocusInput(s)&&s.input.trigger("focus"),t.datepicker._curInst=s))
}},_updateDatepicker:function(e){this.maxRows=4,m=e,e.dpDiv.empty().append(this._generateHTML(e)),this._attachHandlers(e);var i,s=this._getNumberOfMonths(e),n=s[1],a=17,r=e.dpDiv.find("."+this._dayOverClass+" a");r.length>0&&o.apply(r.get(0)),e.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width(""),n>1&&e.dpDiv.addClass("ui-datepicker-multi-"+n).css("width",a*n+"em"),e.dpDiv[(1!==s[0]||1!==s[1]?"add":"remove")+"Class"]("ui-datepicker-multi"),e.dpDiv[(this._get(e,"isRTL")?"add":"remove")+"Class"]("ui-datepicker-rtl"),e===t.datepicker._curInst&&t.datepicker._datepickerShowing&&t.datepicker._shouldFocusInput(e)&&e.input.trigger("focus"),e.yearshtml&&(i=e.yearshtml,setTimeout(function(){i===e.yearshtml&&e.yearshtml&&e.dpDiv.find("select.ui-datepicker-year:first").replaceWith(e.yearshtml),i=e.yearshtml=null},0))},_shouldFocusInput:function(t){return t.input&&t.input.is(":visible")&&!t.input.is(":disabled")&&!t.input.is(":focus")},_checkOffset:function(e,i,s){var n=e.dpDiv.outerWidth(),o=e.dpDiv.outerHeight(),a=e.input?e.input.outerWidth():0,r=e.input?e.input.outerHeight():0,h=document.documentElement.clientWidth+(s?0:t(document).scrollLeft()),l=document.documentElement.clientHeight+(s?0:t(document).scrollTop());return i.left-=this._get(e,"isRTL")?n-a:0,i.left-=s&&i.left===e.input.offset().left?t(document).scrollLeft():0,i.top-=s&&i.top===e.input.offset().top+r?t(document).scrollTop():0,i.left-=Math.min(i.left,i.left+n>h&&h>n?Math.abs(i.left+n-h):0),i.top-=Math.min(i.top,i.top+o>l&&l>o?Math.abs(o+r):0),i},_findPos:function(e){for(var i,s=this._getInst(e),n=this._get(s,"isRTL");e&&("hidden"===e.type||1!==e.nodeType||t.expr.filters.hidden(e));)e=e[n?"previousSibling":"nextSibling"];return i=t(e).offset(),[i.left,i.top]},_hideDatepicker:function(e){var i,s,n,o,a=this._curInst;!a||e&&a!==t.data(e,"datepicker")||this._datepickerShowing&&(i=this._get(a,"showAnim"),s=this._get(a,"duration"),n=function(){t.datepicker._tidyDialog(a)},t.effects&&(t.effects.effect[i]||t.effects[i])?a.dpDiv.hide(i,t.datepicker._get(a,"showOptions"),s,n):a.dpDiv["slideDown"===i?"slideUp":"fadeIn"===i?"fadeOut":"hide"](i?s:null,n),i||n(),this._datepickerShowing=!1,o=this._get(a,"onClose"),o&&o.apply(a.input?a.input[0]:null,[a.input?a.input.val():"",a]),this._lastInput=null,this._inDialog&&(this._dialogInput.css({position:"absolute",left:"0",top:"-100px"}),t.blockUI&&(t.unblockUI(),t("body").append(this.dpDiv))),this._inDialog=!1)},_tidyDialog:function(t){t.dpDiv.removeClass(this._dialogClass).off(".ui-datepicker-calendar")},_checkExternalClick:function(e){if(t.datepicker._curInst){var i=t(e.target),s=t.datepicker._getInst(i[0]);(i[0].id!==t.datepicker._mainDivId&&0===i.parents("#"+t.datepicker._mainDivId).length&&!i.hasClass(t.datepicker.markerClassName)&&!i.closest("."+t.datepicker._triggerClass).length&&t.datepicker._datepickerShowing&&(!t.datepicker._inDialog||!t.blockUI)||i.hasClass(t.datepicker.markerClassName)&&t.datepicker._curInst!==s)&&t.datepicker._hideDatepicker()}},_adjustDate:function(e,i,s){var n=t(e),o=this._getInst(n[0]);this._isDisabledDatepicker(n[0])||(this._adjustInstDate(o,i+("M"===s?this._get(o,"showCurrentAtPos"):0),s),this._updateDatepicker(o))},_gotoToday:function(e){var i,s=t(e),n=this._getInst(s[0]);this._get(n,"gotoCurrent")&&n.currentDay?(n.selectedDay=n.currentDay,n.drawMonth=n.selectedMonth=n.currentMonth,n.drawYear=n.selectedYear=n.currentYear):(i=new Date,n.selectedDay=i.getDate(),n.drawMonth=n.selectedMonth=i.getMonth(),n.drawYear=n.selectedYear=i.getFullYear()),this._notifyChange(n),this._adjustDate(s)},_selectMonthYear:function(e,i,s){var n=t(e),o=this._getInst(n[0]);o["selected"+("M"===s?"Month":"Year")]=o["draw"+("M"===s?"Month":"Year")]=parseInt(i.options[i.selectedIndex].value,10),this._notifyChange(o),this._adjustDate(n)},_selectDay:function(e,i,s,n){var o,a=t(e);t(n).hasClass(this._unselectableClass)||this._isDisabledDatepicker(a[0])||(o=this._getInst(a[0]),o.selectedDay=o.currentDay=t("a",n).html(),o.selectedMonth=o.currentMonth=i,o.selectedYear=o.currentYear=s,this._selectDate(e,this._formatDate(o,o.currentDay,o.currentMonth,o.currentYear)))},_clearDate:function(e){var i=t(e);this._selectDate(i,"")},_selectDate:function(e,i){var s,n=t(e),o=this._getInst(n[0]);i=null!=i?i:this._formatDate(o),o.input&&o.input.val(i),this._updateAlternate(o),s=this._get(o,"onSelect"),s?s.apply(o.input?o.input[0]:null,[i,o]):o.input&&o.input.trigger("change"),o.inline?this._updateDatepicker(o):(this._hideDatepicker(),this._lastInput=o.input[0],"object"!=typeof o.input[0]&&o.input.trigger("focus"),this._lastInput=null)},_updateAlternate:function(e){var i,s,n,o=this._get(e,"altField");o&&(i=this._get(e,"altFormat")||this._get(e,"dateFormat"),s=this._getDate(e),n=this.formatDate(i,s,this._getFormatConfig(e)),t(o).val(n))},noWeekends:function(t){var e=t.getDay();return[e>0&&6>e,""]},iso8601Week:function(t){var e,i=new Date(t.getTime());return i.setDate(i.getDate()+4-(i.getDay()||7)),e=i.getTime(),i.setMonth(0),i.setDate(1),Math.floor(Math.round((e-i)/864e5)/7)+1},parseDate:function(e,i,s){if(null==e||null==i)throw"Invalid arguments";if(i="object"==typeof i?""+i:i+"",""===i)return null;var n,o,a,r,h=0,l=(s?s.shortYearCutoff:null)||this._defaults.shortYearCutoff,c="string"!=typeof l?l:(new Date).getFullYear()%100+parseInt(l,10),u=(s?s.dayNamesShort:null)||this._defaults.dayNamesShort,d=(s?s.dayNames:null)||this._defaults.dayNames,p=(s?s.monthNamesShort:null)||this._defaults.monthNamesShort,f=(s?s.monthNames:null)||this._defaults.monthNames,g=-1,m=-1,_=-1,v=-1,b=!1,y=function(t){var i=e.length>n+1&&e.charAt(n+1)===t;return i&&n++,i},w=function(t){var e=y(t),s="@"===t?14:"!"===t?20:"y"===t&&e?4:"o"===t?3:2,n="y"===t?s:1,o=RegExp("^\\d{"+n+","+s+"}"),a=i.substring(h).match(o);if(!a)throw"Missing number at position "+h;return h+=a[0].length,parseInt(a[0],10)},k=function(e,s,n){var o=-1,a=t.map(y(e)?n:s,function(t,e){return[[e,t]]}).sort(function(t,e){return-(t[1].length-e[1].length)});if(t.each(a,function(t,e){var s=e[1];return i.substr(h,s.length).toLowerCase()===s.toLowerCase()?(o=e[0],h+=s.length,!1):void 0}),-1!==o)return o+1;throw"Unknown name at position "+h},x=function(){if(i.charAt(h)!==e.charAt(n))throw"Unexpected literal at position "+h;h++};for(n=0;e.length>n;n++)if(b)"'"!==e.charAt(n)||y("'")?x():b=!1;else switch(e.charAt(n)){case"d":_=w("d");break;case"D":k("D",u,d);break;case"o":v=w("o");break;case"m":m=w("m");break;case"M":m=k("M",p,f);break;case"y":g=w("y");break;case"@":r=new Date(w("@")),g=r.getFullYear(),m=r.getMonth()+1,_=r.getDate();break;case"!":r=new Date((w("!")-this._ticksTo1970)/1e4),g=r.getFullYear(),m=r.getMonth()+1,_=r.getDate();break;case"'":y("'")?x():b=!0;break;default:x()}if(i.length>h&&(a=i.substr(h),!/^\s+/.test(a)))throw"Extra/unparsed characters found in date: "+a;if(-1===g?g=(new Date).getFullYear():100>g&&(g+=(new Date).getFullYear()-(new Date).getFullYear()%100+(c>=g?0:-100)),v>-1)for(m=1,_=v;;){if(o=this._getDaysInMonth(g,m-1),o>=_)break;m++,_-=o}if(r=this._daylightSavingAdjust(new Date(g,m-1,_)),r.getFullYear()!==g||r.getMonth()+1!==m||r.getDate()!==_)throw"Invalid date";return r},ATOM:"yy-mm-dd",COOKIE:"D, dd M yy",ISO_8601:"yy-mm-dd",RFC_822:"D, d M y",RFC_850:"DD, dd-M-y",RFC_1036:"D, d M y",RFC_1123:"D, d M yy",RFC_2822:"D, d M yy",RSS:"D, d M y",TICKS:"!",TIMESTAMP:"@",W3C:"yy-mm-dd",_ticksTo1970:1e7*60*60*24*(718685+Math.floor(492.5)-Math.floor(19.7)+Math.floor(4.925)),formatDate:function(t,e,i){if(!e)return"";var s,n=(i?i.dayNamesShort:null)||this._defaults.dayNamesShort,o=(i?i.dayNames:null)||this._defaults.dayNames,a=(i?i.monthNamesShort:null)||this._defaults.monthNamesShort,r=(i?i.monthNames:null)||this._defaults.monthNames,h=function(e){var i=t.length>s+1&&t.charAt(s+1)===e;return i&&s++,i},l=function(t,e,i){var s=""+e;if(h(t))for(;i>s.length;)s="0"+s;return s},c=function(t,e,i,s){return h(t)?s[e]:i[e]},u="",d=!1;if(e)for(s=0;t.length>s;s++)if(d)"'"!==t.charAt(s)||h("'")?u+=t.charAt(s):d=!1;else switch(t.charAt(s)){case"d":u+=l("d",e.getDate(),2);break;case"D":u+=c("D",e.getDay(),n,o);break;case"o":u+=l("o",Math.round((new Date(e.getFullYear(),e.getMonth(),e.getDate()).getTime()-new Date(e.getFullYear(),0,0).getTime())/864e5),3);break;case"m":u+=l("m",e.getMonth()+1,2);break;case"M":u+=c("M",e.getMonth(),a,r);break;case"y":u+=h("y")?e.getFullYear():(10>e.getFullYear()%100?"0":"")+e.getFullYear()%100;break;case"@":u+=e.getTime();break;case"!":u+=1e4*e.getTime()+this._ticksTo1970;break;case"'":h("'")?u+="'":d=!0;break;default:u+=t.charAt(s)}return u},_possibleChars:function(t){var e,i="",s=!1,n=function(i){var s=t.length>e+1&&t.charAt(e+1)===i;return s&&e++,s};for(e=0;t.length>e;e++)if(s)"'"!==t.charAt(e)||n("'")?i+=t.charAt(e):s=!1;else switch(t.charAt(e)){case"d":case"m":case"y":case"@":i+="0123456789";break;case"D":case"M":return null;case"'":n("'")?i+="'":s=!0;break;default:i+=t.charAt(e)}return i},_get:function(t,e){return void 0!==t.settings[e]?t.settings[e]:this._defaults[e]},_setDateFromField:function(t,e){if(t.input.val()!==t.lastVal){var i=this._get(t,"dateFormat"),s=t.lastVal=t.input?t.input.val():null,n=this._getDefaultDate(t),o=n,a=this._getFormatConfig(t);try{o=this.parseDate(i,s,a)||n}catch(r){s=e?"":s}t.selectedDay=o.getDate(),t.drawMonth=t.selectedMonth=o.getMonth(),t.drawYear=t.selectedYear=o.getFullYear(),t.currentDay=s?o.getDate():0,t.currentMonth=s?o.getMonth():0,t.currentYear=s?o.getFullYear():0,this._adjustInstDate(t)}},_getDefaultDate:function(t){return this._restrictMinMax(t,this._determineDate(t,this._get(t,"defaultDate"),new Date))},_determineDate:function(e,i,s){var n=function(t){var e=new Date;return e.setDate(e.getDate()+t),e},o=function(i){try{return t.datepicker.parseDate(t.datepicker._get(e,"dateFormat"),i,t.datepicker._getFormatConfig(e))}catch(s){}for(var n=(i.toLowerCase().match(/^c/)?t.datepicker._getDate(e):null)||new Date,o=n.getFullYear(),a=n.getMonth(),r=n.getDate(),h=/([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,l=h.exec(i);l;){switch(l[2]||"d"){case"d":case"D":r+=parseInt(l[1],10);break;case"w":case"W":r+=7*parseInt(l[1],10);break;case"m":case"M":a+=parseInt(l[1],10),r=Math.min(r,t.datepicker._getDaysInMonth(o,a));break;case"y":case"Y":o+=parseInt(l[1],10),r=Math.min(r,t.datepicker._getDaysInMonth(o,a))}l=h.exec(i)}return new Date(o,a,r)},a=null==i||""===i?s:"string"==typeof i?o(i):"number"==typeof i?isNaN(i)?s:n(i):new Date(i.getTime());return a=a&&"Invalid Date"==""+a?s:a,a&&(a.setHours(0),a.setMinutes(0),a.setSeconds(0),a.setMilliseconds(0)),this._daylightSavingAdjust(a)},_daylightSavingAdjust:function(t){return t?(t.setHours(t.getHours()>12?t.getHours()+2:0),t):null},_setDate:function(t,e,i){var s=!e,n=t.selectedMonth,o=t.selectedYear,a=this._restrictMinMax(t,this._determineDate(t,e,new Date));t.selectedDay=t.currentDay=a.getDate(),t.drawMonth=t.selectedMonth=t.currentMonth=a.getMonth(),t.drawYear=t.selectedYear=t.currentYear=a.getFullYear(),n===t.selectedMonth&&o===t.selectedYear||i||this._notifyChange(t),this._adjustInstDate(t),t.input&&t.input.val(s?"":this._formatDate(t))},_getDate:function(t){var e=!t.currentYear||t.input&&""===t.input.val()?null:this._daylightSavingAdjust(new Date(t.currentYear,t.currentMonth,t.currentDay));return e},_attachHandlers:function(e){var i=this._get(e,"stepMonths"),s="#"+e.id.replace(/\\\\/g,"\\");e.dpDiv.find("[data-handler]").map(function(){var e={prev:function(){t.datepicker._adjustDate(s,-i,"M")},next:function(){t.datepicker._adjustDate(s,+i,"M")},hide:function(){t.datepicker._hideDatepicker()},today:function(){t.datepicker._gotoToday(s)},selectDay:function(){return t.datepicker._selectDay(s,+this.getAttribute("data-month"),+this.getAttribute("data-year"),this),!1},selectMonth:function(){return t.datepicker._selectMonthYear(s,this,"M"),!1},selectYear:function(){return t.datepicker._selectMonthYear(s,this,"Y"),!1}};t(this).on(this.getAttribute("data-event"),e[this.getAttribute("data-handler")])})},_generateHTML:function(t){var e,i,s,n,o,a,r,h,l,c,u,d,p,f,g,m,_,v,b,y,w,k,x,C,D,I,T,P,M,S,H,z,O,A,N,W,E,F,L,R=new Date,B=this._daylightSavingAdjust(new Date(R.getFullYear(),R.getMonth(),R.getDate())),Y=this._get(t,"isRTL"),j=this._get(t,"showButtonPanel"),q=this._get(t,"hideIfNoPrevNext"),K=this._get(t,"navigationAsDateFormat"),U=this._getNumberOfMonths(t),V=this._get(t,"showCurrentAtPos"),$=this._get(t,"stepMonths"),X=1!==U[0]||1!==U[1],G=this._daylightSavingAdjust(t.currentDay?new Date(t.currentYear,t.currentMonth,t.currentDay):new Date(9999,9,9)),Q=this._getMinMaxDate(t,"min"),J=this._getMinMaxDate(t,"max"),Z=t.drawMonth-V,te=t.drawYear;if(0>Z&&(Z+=12,te--),J)for(e=this._daylightSavingAdjust(new Date(J.getFullYear(),J.getMonth()-U[0]*U[1]+1,J.getDate())),e=Q&&Q>e?Q:e;this._daylightSavingAdjust(new Date(te,Z,1))>e;)Z--,0>Z&&(Z=11,te--);for(t.drawMonth=Z,t.drawYear=te,i=this._get(t,"prevText"),i=K?this.formatDate(i,this._daylightSavingAdjust(new Date(te,Z-$,1)),this._getFormatConfig(t)):i,s=this._canAdjustMonth(t,-1,te,Z)?"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click' title='"+i+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"e":"w")+"'>"+i+"</span></a>":q?"":"<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='"+i+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"e":"w")+"'>"+i+"</span></a>",n=this._get(t,"nextText"),n=K?this.formatDate(n,this._daylightSavingAdjust(new Date(te,Z+$,1)),this._getFormatConfig(t)):n,o=this._canAdjustMonth(t,1,te,Z)?"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click' title='"+n+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"w":"e")+"'>"+n+"</span></a>":q?"":"<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='"+n+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"w":"e")+"'>"+n+"</span></a>",a=this._get(t,"currentText"),r=this._get(t,"gotoCurrent")&&t.currentDay?G:B,a=K?this.formatDate(a,r,this._getFormatConfig(t)):a,h=t.inline?"":"<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>"+this._get(t,"closeText")+"</button>",l=j?"<div class='ui-datepicker-buttonpane ui-widget-content'>"+(Y?h:"")+(this._isInRange(t,r)?"<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'>"+a+"</button>":"")+(Y?"":h)+"</div>":"",c=parseInt(this._get(t,"firstDay"),10),c=isNaN(c)?0:c,u=this._get(t,"showWeek"),d=this._get(t,"dayNames"),p=this._get(t,"dayNamesMin"),f=this._get(t,"monthNames"),g=this._get(t,"monthNamesShort"),m=this._get(t,"beforeShowDay"),_=this._get(t,"showOtherMonths"),v=this._get(t,"selectOtherMonths"),b=this._getDefaultDate(t),y="",k=0;U[0]>k;k++){for(x="",this.maxRows=4,C=0;U[1]>C;C++){if(D=this._daylightSavingAdjust(new Date(te,Z,t.selectedDay)),I=" ui-corner-all",T="",X){if(T+="<div class='ui-datepicker-group",U[1]>1)switch(C){case 0:T+=" ui-datepicker-group-first",I=" ui-corner-"+(Y?"right":"left");break;case U[1]-1:T+=" ui-datepicker-group-last",I=" ui-corner-"+(Y?"left":"right");break;default:T+=" ui-datepicker-group-middle",I=""}T+="'>"}for(T+="<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix"+I+"'>"+(/all|left/.test(I)&&0===k?Y?o:s:"")+(/all|right/.test(I)&&0===k?Y?s:o:"")+this._generateMonthYearHeader(t,Z,te,Q,J,k>0||C>0,f,g)+"</div><table class='ui-datepicker-calendar'><thead>"+"<tr>",P=u?"<th class='ui-datepicker-week-col'>"+this._get(t,"weekHeader")+"</th>":"",w=0;7>w;w++)M=(w+c)%7,P+="<th scope='col'"+((w+c+6)%7>=5?" class='ui-datepicker-week-end'":"")+">"+"<span title='"+d[M]+"'>"+p[M]+"</span></th>";for(T+=P+"</tr></thead><tbody>",S=this._getDaysInMonth(te,Z),te===t.selectedYear&&Z===t.selectedMonth&&(t.selectedDay=Math.min(t.selectedDay,S)),H=(this._getFirstDayOfMonth(te,Z)-c+7)%7,z=Math.ceil((H+S)/7),O=X?this.maxRows>z?this.maxRows:z:z,this.maxRows=O,A=this._daylightSavingAdjust(new Date(te,Z,1-H)),N=0;O>N;N++){for(T+="<tr>",W=u?"<td class='ui-datepicker-week-col'>"+this._get(t,"calculateWeek")(A)+"</td>":"",w=0;7>w;w++)E=m?m.apply(t.input?t.input[0]:null,[A]):[!0,""],F=A.getMonth()!==Z,L=F&&!v||!E[0]||Q&&Q>A||J&&A>J,W+="<td class='"+((w+c+6)%7>=5?" ui-datepicker-week-end":"")+(F?" ui-datepicker-other-month":"")+(A.getTime()===D.getTime()&&Z===t.selectedMonth&&t._keyEvent||b.getTime()===A.getTime()&&b.getTime()===D.getTime()?" "+this._dayOverClass:"")+(L?" "+this._unselectableClass+" ui-state-disabled":"")+(F&&!_?"":" "+E[1]+(A.getTime()===G.getTime()?" "+this._currentClass:"")+(A.getTime()===B.getTime()?" ui-datepicker-today":""))+"'"+(F&&!_||!E[2]?"":" title='"+E[2].replace(/'/g,"&#39;")+"'")+(L?"":" data-handler='selectDay' data-event='click' data-month='"+A.getMonth()+"' data-year='"+A.getFullYear()+"'")+">"+(F&&!_?"&#xa0;":L?"<span class='ui-state-default'>"+A.getDate()+"</span>":"<a class='ui-state-default"+(A.getTime()===B.getTime()?" ui-state-highlight":"")+(A.getTime()===G.getTime()?" ui-state-active":"")+(F?" ui-priority-secondary":"")+"' href='#'>"+A.getDate()+"</a>")+"</td>",A.setDate(A.getDate()+1),A=this._daylightSavingAdjust(A);T+=W+"</tr>"}Z++,Z>11&&(Z=0,te++),T+="</tbody></table>"+(X?"</div>"+(U[0]>0&&C===U[1]-1?"<div class='ui-datepicker-row-break'></div>":""):""),x+=T}y+=x}return y+=l,t._keyEvent=!1,y},_generateMonthYearHeader:function(t,e,i,s,n,o,a,r){var h,l,c,u,d,p,f,g,m=this._get(t,"changeMonth"),_=this._get(t,"changeYear"),v=this._get(t,"showMonthAfterYear"),b="<div class='ui-datepicker-title'>",y="";if(o||!m)y+="<span class='ui-datepicker-month'>"+a[e]+"</span>";else{for(h=s&&s.getFullYear()===i,l=n&&n.getFullYear()===i,y+="<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>",c=0;12>c;c++)(!h||c>=s.getMonth())&&(!l||n.getMonth()>=c)&&(y+="<option value='"+c+"'"+(c===e?" selected='selected'":"")+">"+r[c]+"</option>");y+="</select>"}if(v||(b+=y+(!o&&m&&_?"":"&#xa0;")),!t.yearshtml)if(t.yearshtml="",o||!_)b+="<span class='ui-datepicker-year'>"+i+"</span>";else{for(u=this._get(t,"yearRange").split(":"),d=(new Date).getFullYear(),p=function(t){var e=t.match(/c[+\-].*/)?i+parseInt(t.substring(1),10):t.match(/[+\-].*/)?d+parseInt(t,10):parseInt(t,10);return isNaN(e)?d:e},f=p(u[0]),g=Math.max(f,p(u[1]||"")),f=s?Math.max(f,s.getFullYear()):f,g=n?Math.min(g,n.getFullYear()):g,t.yearshtml+="<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";g>=f;f++)t.yearshtml+="<option value='"+f+"'"+(f===i?" selected='selected'":"")+">"+f+"</option>";t.yearshtml+="</select>",b+=t.yearshtml,t.yearshtml=null}return b+=this._get(t,"yearSuffix"),v&&(b+=(!o&&m&&_?"":"&#xa0;")+y),b+="</div>"},_adjustInstDate:function(t,e,i){var s=t.selectedYear+("Y"===i?e:0),n=t.selectedMonth+("M"===i?e:0),o=Math.min(t.selectedDay,this._getDaysInMonth(s,n))+("D"===i?e:0),a=this._restrictMinMax(t,this._daylightSavingAdjust(new Date(s,n,o)));t.selectedDay=a.getDate(),t.drawMonth=t.selectedMonth=a.getMonth(),t.drawYear=t.selectedYear=a.getFullYear(),("M"===i||"Y"===i)&&this._notifyChange(t)},_restrictMinMax:function(t,e){var i=this._getMinMaxDate(t,"min"),s=this._getMinMaxDate(t,"max"),n=i&&i>e?i:e;return s&&n>s?s:n},_notifyChange:function(t){var e=this._get(t,"onChangeMonthYear");e&&e.apply(t.input?t.input[0]:null,[t.selectedYear,t.selectedMonth+1,t])},_getNumberOfMonths:function(t){var e=this._get(t,"numberOfMonths");return null==e?[1,1]:"number"==typeof e?[1,e]:e},_getMinMaxDate:function(t,e){return this._determineDate(t,this._get(t,e+"Date"),null)},_getDaysInMonth:function(t,e){return 32-this._daylightSavingAdjust(new Date(t,e,32)).getDate()},_getFirstDayOfMonth:function(t,e){return new Date(t,e,1).getDay()},_canAdjustMonth:function(t,e,i,s){var n=this._getNumberOfMonths(t),o=this._daylightSavingAdjust(new Date(i,s+(0>e?e:n[0]*n[1]),1));return 0>e&&o.setDate(this._getDaysInMonth(o.getFullYear(),o.getMonth())),this._isInRange(t,o)},_isInRange:function(t,e){var i,s,n=this._getMinMaxDate(t,"min"),o=this._getMinMaxDate(t,"max"),a=null,r=null,h=this._get(t,"yearRange");return h&&(i=h.split(":"),s=(new Date).getFullYear(),a=parseInt(i[0],10),r=parseInt(i[1],10),i[0].match(/[+\-].*/)&&(a+=s),i[1].match(/[+\-].*/)&&(r+=s)),(!n||e.getTime()>=n.getTime())&&(!o||e.getTime()<=o.getTime())&&(!a||e.getFullYear()>=a)&&(!r||r>=e.getFullYear())},_getFormatConfig:function(t){var e=this._get(t,"shortYearCutoff");return e="string"!=typeof e?e:(new Date).getFullYear()%100+parseInt(e,10),{shortYearCutoff:e,dayNamesShort:this._get(t,"dayNamesShort"),dayNames:this._get(t,"dayNames"),monthNamesShort:this._get(t,"monthNamesShort"),monthNames:this._get(t,"monthNames")}},_formatDate:function(t,e,i,s){e||(t.currentDay=t.selectedDay,t.currentMonth=t.selectedMonth,t.currentYear=t.selectedYear);var n=e?"object"==typeof e?e:this._daylightSavingAdjust(new Date(s,i,e)):this._daylightSavingAdjust(new Date(t.currentYear,t.currentMonth,t.currentDay));return this.formatDate(this._get(t,"dateFormat"),n,this._getFormatConfig(t))}}),t.fn.datepicker=function(e){if(!this.length)return this;t.datepicker.initialized||(t(document).on("mousedown",t.datepicker._checkExternalClick),t.datepicker.initialized=!0),0===t("#"+t.datepicker._mainDivId).length&&t("body").append(t.datepicker.dpDiv);var i=Array.prototype.slice.call(arguments,1);return"string"!=typeof e||"isDisabled"!==e&&"getDate"!==e&&"widget"!==e?"option"===e&&2===arguments.length&&"string"==typeof arguments[1]?t.datepicker["_"+e+"Datepicker"].apply(t.datepicker,[this[0]].concat(i)):this.each(function(){"string"==typeof e?t.datepicker["_"+e+"Datepicker"].apply(t.datepicker,[this].concat(i)):t.datepicker._attachDatepicker(this,e)}):t.datepicker["_"+e+"Datepicker"].apply(t.datepicker,[this[0]].concat(i))},t.datepicker=new s,t.datepicker.initialized=!1,t.datepicker.uuid=(new Date).getTime(),t.datepicker.version="1.12.1",t.datepicker,t.ui.ie=!!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());var _=!1;t(document).on("mouseup",function(){_=!1}),t.widget("ui.mouse",{version:"1.12.1",options:{cancel:"input, textarea, button, select, option",distance:1,delay:0},_mouseInit:function(){var e=this;this.element.on("mousedown."+this.widgetName,function(t){return e._mouseDown(t)}).on("click."+this.widgetName,function(i){return!0===t.data(i.target,e.widgetName+".preventClickEvent")?(t.removeData(i.target,e.widgetName+".preventClickEvent"),i.stopImmediatePropagation(),!1):void 0}),this.started=!1},_mouseDestroy:function(){this.element.off("."+this.widgetName),this._mouseMoveDelegate&&this.document.off("mousemove."+this.widgetName,this._mouseMoveDelegate).off("mouseup."+this.widgetName,this._mouseUpDelegate)},_mouseDown:function(e){if(!_){this._mouseMoved=!1,this._mouseStarted&&this._mouseUp(e),this._mouseDownEvent=e;var i=this,s=1===e.which,n="string"==typeof this.options.cancel&&e.target.nodeName?t(e.target).closest(this.options.cancel).length:!1;return s&&!n&&this._mouseCapture(e)?(this.mouseDelayMet=!this.options.delay,this.mouseDelayMet||(this._mouseDelayTimer=setTimeout(function(){i.mouseDelayMet=!0},this.options.delay)),this._mouseDistanceMet(e)&&this._mouseDelayMet(e)&&(this._mouseStarted=this._mouseStart(e)!==!1,!this._mouseStarted)?(e.preventDefault(),!0):(!0===t.data(e.target,this.widgetName+".preventClickEvent")&&t.removeData(e.target,this.widgetName+".preventClickEvent"),this._mouseMoveDelegate=function(t){return i._mouseMove(t)},this._mouseUpDelegate=function(t){return i._mouseUp(t)},this.document.on("mousemove."+this.widgetName,this._mouseMoveDelegate).on("mouseup."+this.widgetName,this._mouseUpDelegate),e.preventDefault(),_=!0,!0)):!0}},_mouseMove:function(e){if(this._mouseMoved){if(t.ui.ie&&(!document.documentMode||9>document.documentMode)&&!e.button)return this._mouseUp(e);if(!e.which)if(e.originalEvent.altKey||e.originalEvent.ctrlKey||e.originalEvent.metaKey||e.originalEvent.shiftKey)this.ignoreMissingWhich=!0;else if(!this.ignoreMissingWhich)return this._mouseUp(e)}return(e.which||e.button)&&(this._mouseMoved=!0),this._mouseStarted?(this._mouseDrag(e),e.preventDefault()):(this._mouseDistanceMet(e)&&this._mouseDelayMet(e)&&(this._mouseStarted=this._mouseStart(this._mouseDownEvent,e)!==!1,this._mouseStarted?this._mouseDrag(e):this._mouseUp(e)),!this._mouseStarted)},_mouseUp:function(e){this.document.off("mousemove."+this.widgetName,this._mouseMoveDelegate).off("mouseup."+this.widgetName,this._mouseUpDelegate),this._mouseStarted&&(this._mouseStarted=!1,e.target===this._mouseDownEvent.target&&t.data(e.target,this.widgetName+".preventClickEvent",!0),this._mouseStop(e)),this._mouseDelayTimer&&(clearTimeout(this._mouseDelayTimer),delete this._mouseDelayTimer),this.ignoreMissingWhich=!1,_=!1,e.preventDefault()},_mouseDistanceMet:function(t){return Math.max(Math.abs(this._mouseDownEvent.pageX-t.pageX),Math.abs(this._mouseDownEvent.pageY-t.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return!0}}),t.ui.plugin={add:function(e,i,s){var n,o=t.ui[e].prototype;for(n in s)o.plugins[n]=o.plugins[n]||[],o.plugins[n].push([i,s[n]])},call:function(t,e,i,s){var n,o=t.plugins[e];if(o&&(s||t.element[0].parentNode&&11!==t.element[0].parentNode.nodeType))for(n=0;o.length>n;n++)t.options[o[n][0]]&&o[n][1].apply(t.element,i)}},t.ui.safeBlur=function(e){e&&"body"!==e.nodeName.toLowerCase()&&t(e).trigger("blur")},t.widget("ui.draggable",t.ui.mouse,{version:"1.12.1",widgetEventPrefix:"drag",options:{addClasses:!0,appendTo:"parent",axis:!1,connectToSortable:!1,containment:!1,cursor:"auto",cursorAt:!1,grid:!1,handle:!1,helper:"original",iframeFix:!1,opacity:!1,refreshPositions:!1,revert:!1,revertDuration:500,scope:"default",scroll:!0,scrollSensitivity:20,scrollSpeed:20,snap:!1,snapMode:"both",snapTolerance:20,stack:!1,zIndex:!1,drag:null,start:null,stop:null},_create:function(){"original"===this.options.helper&&this._setPositionRelative(),this.options.addClasses&&this._addClass("ui-draggable"),this._setHandleClassName(),this._mouseInit()},_setOption:function(t,e){this._super(t,e),"handle"===t&&(this._removeHandleClassName(),this._setHandleClassName())},_destroy:function(){return(this.helper||this.element).is(".ui-draggable-dragging")?(this.destroyOnClear=!0,void 0):(this._removeHandleClassName(),this._mouseDestroy(),void 0)},_mouseCapture:function(e){var i=this.options;return this.helper||i.disabled||t(e.target).closest(".ui-resizable-handle").length>0?!1:(this.handle=this._getHandle(e),this.handle?(this._blurActiveElement(e),this._blockFrames(i.iframeFix===!0?"iframe":i.iframeFix),!0):!1)},_blockFrames:function(e){this.iframeBlocks=this.document.find(e).map(function(){var e=t(this);return t("<div>").css("position","absolute").appendTo(e.parent()).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()).offset(e.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_blurActiveElement:function(e){var i=t.ui.safeActiveElement(this.document[0]),s=t(e.target);s.closest(i).length||t.ui.safeBlur(i)},_mouseStart:function(e){var i=this.options;return this.helper=this._createHelper(e),this._addClass(this.helper,"ui-draggable-dragging"),this._cacheHelperProportions(),t.ui.ddmanager&&(t.ui.ddmanager.current=this),this._cacheMargins(),this.cssPosition=this.helper.css("position"),this.scrollParent=this.helper.scrollParent(!0),this.offsetParent=this.helper.offsetParent(),this.hasFixedAncestor=this.helper.parents().filter(function(){return"fixed"===t(this).css("position")}).length>0,this.positionAbs=this.element.offset(),this._refreshOffsets(e),this.originalPosition=this.position=this._generatePosition(e,!1),this.originalPageX=e.pageX,this.originalPageY=e.pageY,i.cursorAt&&this._adjustOffsetFromHelper(i.cursorAt),this._setContainment(),this._trigger("start",e)===!1?(this._clear(),!1):(this._cacheHelperProportions(),t.ui.ddmanager&&!i.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e),this._mouseDrag(e,!0),t.ui.ddmanager&&t.ui.ddmanager.dragStart(this,e),!0)},_refreshOffsets:function(t){this.offset={top:this.positionAbs.top-this.margins.top,left:this.positionAbs.left-this.margins.left,scroll:!1,parent:this._getParentOffset(),relative:this._getRelativeOffset()},this.offset.click={left:t.pageX-this.offset.left,top:t.pageY-this.offset.top}},_mouseDrag:function(e,i){if(this.hasFixedAncestor&&(this.offset.parent=this._getParentOffset()),this.position=this._generatePosition(e,!0),this.positionAbs=this._convertPositionTo("absolute"),!i){var s=this._uiHash();if(this._trigger("drag",e,s)===!1)return this._mouseUp(new t.Event("mouseup",e)),!1;this.position=s.position}return this.helper[0].style.left=this.position.left+"px",this.helper[0].style.top=this.position.top+"px",t.ui.ddmanager&&t.ui.ddmanager.drag(this,e),!1},_mouseStop:function(e){var i=this,s=!1;return t.ui.ddmanager&&!this.options.dropBehaviour&&(s=t.ui.ddmanager.drop(this,e)),this.dropped&&(s=this.dropped,this.dropped=!1),"invalid"===this.options.revert&&!s||"valid"===this.options.revert&&s||this.options.revert===!0||t.isFunction(this.options.revert)&&this.options.revert.call(this.element,s)?t(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,10),function(){i._trigger("stop",e)!==!1&&i._clear()}):this._trigger("stop",e)!==!1&&this._clear(),!1},_mouseUp:function(e){return this._unblockFrames(),t.ui.ddmanager&&t.ui.ddmanager.dragStop(this,e),this.handleElement.is(e.target)&&this.element.trigger("focus"),t.ui.mouse.prototype._mouseUp.call(this,e)},cancel:function(){return this.helper.is(".ui-draggable-dragging")?this._mouseUp(new t.Event("mouseup",{target:this.element[0]})):this._clear(),this},_getHandle:function(e){return this.options.handle?!!t(e.target).closest(this.element.find(this.options.handle)).length:!0},_setHandleClassName:function(){this.handleElement=this.options.handle?this.element.find(this.options.handle):this.element,this._addClass(this.handleElement,"ui-draggable-handle")},_removeHandleClassName:function(){this._removeClass(this.handleElement,"ui-draggable-handle")},_createHelper:function(e){var i=this.options,s=t.isFunction(i.helper),n=s?t(i.helper.apply(this.element[0],[e])):"clone"===i.helper?this.element.clone().removeAttr("id"):this.element;return n.parents("body").length||n.appendTo("parent"===i.appendTo?this.element[0].parentNode:i.appendTo),s&&n[0]===this.element[0]&&this._setPositionRelative(),n[0]===this.element[0]||/(fixed|absolute)/.test(n.css("position"))||n.css("position","absolute"),n},_setPositionRelative:function(){/^(?:r|a|f)/.test(this.element.css("position"))||(this.element[0].style.position="relative")},_adjustOffsetFromHelper:function(e){"string"==typeof e&&(e=e.split(" ")),t.isArray(e)&&(e={left:+e[0],top:+e[1]||0}),"left"in e&&(this.offset.click.left=e.left+this.margins.left),"right"in e&&(this.offset.click.left=this.helperProportions.width-e.right+this.margins.left),"top"in e&&(this.offset.click.top=e.top+this.margins.top),"bottom"in e&&(this.offset.click.top=this.helperProportions.height-e.bottom+this.margins.top)},_isRootNode:function(t){return/(html|body)/i.test(t.tagName)||t===this.document[0]},_getParentOffset:function(){var e=this.offsetParent.offset(),i=this.document[0];return"absolute"===this.cssPosition&&this.scrollParent[0]!==i&&t.contains(this.scrollParent[0],this.offsetParent[0])&&(e.left+=this.scrollParent.scrollLeft(),e.top+=this.scrollParent.scrollTop()),this._isRootNode(this.offsetParent[0])&&(e={top:0,left:0}),{top:e.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:e.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"!==this.cssPosition)return{top:0,left:0};var t=this.element.position(),e=this._isRootNode(this.scrollParent[0]);return{top:t.top-(parseInt(this.helper.css("top"),10)||0)+(e?0:this.scrollParent.scrollTop()),left:t.left-(parseInt(this.helper.css("left"),10)||0)+(e?0:this.scrollParent.scrollLeft())}
},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var e,i,s,n=this.options,o=this.document[0];return this.relativeContainer=null,n.containment?"window"===n.containment?(this.containment=[t(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,t(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,t(window).scrollLeft()+t(window).width()-this.helperProportions.width-this.margins.left,t(window).scrollTop()+(t(window).height()||o.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):"document"===n.containment?(this.containment=[0,0,t(o).width()-this.helperProportions.width-this.margins.left,(t(o).height()||o.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):n.containment.constructor===Array?(this.containment=n.containment,void 0):("parent"===n.containment&&(n.containment=this.helper[0].parentNode),i=t(n.containment),s=i[0],s&&(e=/(scroll|auto)/.test(i.css("overflow")),this.containment=[(parseInt(i.css("borderLeftWidth"),10)||0)+(parseInt(i.css("paddingLeft"),10)||0),(parseInt(i.css("borderTopWidth"),10)||0)+(parseInt(i.css("paddingTop"),10)||0),(e?Math.max(s.scrollWidth,s.offsetWidth):s.offsetWidth)-(parseInt(i.css("borderRightWidth"),10)||0)-(parseInt(i.css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(e?Math.max(s.scrollHeight,s.offsetHeight):s.offsetHeight)-(parseInt(i.css("borderBottomWidth"),10)||0)-(parseInt(i.css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom],this.relativeContainer=i),void 0):(this.containment=null,void 0)},_convertPositionTo:function(t,e){e||(e=this.position);var i="absolute"===t?1:-1,s=this._isRootNode(this.scrollParent[0]);return{top:e.top+this.offset.relative.top*i+this.offset.parent.top*i-("fixed"===this.cssPosition?-this.offset.scroll.top:s?0:this.offset.scroll.top)*i,left:e.left+this.offset.relative.left*i+this.offset.parent.left*i-("fixed"===this.cssPosition?-this.offset.scroll.left:s?0:this.offset.scroll.left)*i}},_generatePosition:function(t,e){var i,s,n,o,a=this.options,r=this._isRootNode(this.scrollParent[0]),h=t.pageX,l=t.pageY;return r&&this.offset.scroll||(this.offset.scroll={top:this.scrollParent.scrollTop(),left:this.scrollParent.scrollLeft()}),e&&(this.containment&&(this.relativeContainer?(s=this.relativeContainer.offset(),i=[this.containment[0]+s.left,this.containment[1]+s.top,this.containment[2]+s.left,this.containment[3]+s.top]):i=this.containment,t.pageX-this.offset.click.left<i[0]&&(h=i[0]+this.offset.click.left),t.pageY-this.offset.click.top<i[1]&&(l=i[1]+this.offset.click.top),t.pageX-this.offset.click.left>i[2]&&(h=i[2]+this.offset.click.left),t.pageY-this.offset.click.top>i[3]&&(l=i[3]+this.offset.click.top)),a.grid&&(n=a.grid[1]?this.originalPageY+Math.round((l-this.originalPageY)/a.grid[1])*a.grid[1]:this.originalPageY,l=i?n-this.offset.click.top>=i[1]||n-this.offset.click.top>i[3]?n:n-this.offset.click.top>=i[1]?n-a.grid[1]:n+a.grid[1]:n,o=a.grid[0]?this.originalPageX+Math.round((h-this.originalPageX)/a.grid[0])*a.grid[0]:this.originalPageX,h=i?o-this.offset.click.left>=i[0]||o-this.offset.click.left>i[2]?o:o-this.offset.click.left>=i[0]?o-a.grid[0]:o+a.grid[0]:o),"y"===a.axis&&(h=this.originalPageX),"x"===a.axis&&(l=this.originalPageY)),{top:l-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.offset.scroll.top:r?0:this.offset.scroll.top),left:h-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.offset.scroll.left:r?0:this.offset.scroll.left)}},_clear:function(){this._removeClass(this.helper,"ui-draggable-dragging"),this.helper[0]===this.element[0]||this.cancelHelperRemoval||this.helper.remove(),this.helper=null,this.cancelHelperRemoval=!1,this.destroyOnClear&&this.destroy()},_trigger:function(e,i,s){return s=s||this._uiHash(),t.ui.plugin.call(this,e,[i,s,this],!0),/^(drag|start|stop)/.test(e)&&(this.positionAbs=this._convertPositionTo("absolute"),s.offset=this.positionAbs),t.Widget.prototype._trigger.call(this,e,i,s)},plugins:{},_uiHash:function(){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}}),t.ui.plugin.add("draggable","connectToSortable",{start:function(e,i,s){var n=t.extend({},i,{item:s.element});s.sortables=[],t(s.options.connectToSortable).each(function(){var i=t(this).sortable("instance");i&&!i.options.disabled&&(s.sortables.push(i),i.refreshPositions(),i._trigger("activate",e,n))})},stop:function(e,i,s){var n=t.extend({},i,{item:s.element});s.cancelHelperRemoval=!1,t.each(s.sortables,function(){var t=this;t.isOver?(t.isOver=0,s.cancelHelperRemoval=!0,t.cancelHelperRemoval=!1,t._storedCSS={position:t.placeholder.css("position"),top:t.placeholder.css("top"),left:t.placeholder.css("left")},t._mouseStop(e),t.options.helper=t.options._helper):(t.cancelHelperRemoval=!0,t._trigger("deactivate",e,n))})},drag:function(e,i,s){t.each(s.sortables,function(){var n=!1,o=this;o.positionAbs=s.positionAbs,o.helperProportions=s.helperProportions,o.offset.click=s.offset.click,o._intersectsWith(o.containerCache)&&(n=!0,t.each(s.sortables,function(){return this.positionAbs=s.positionAbs,this.helperProportions=s.helperProportions,this.offset.click=s.offset.click,this!==o&&this._intersectsWith(this.containerCache)&&t.contains(o.element[0],this.element[0])&&(n=!1),n})),n?(o.isOver||(o.isOver=1,s._parent=i.helper.parent(),o.currentItem=i.helper.appendTo(o.element).data("ui-sortable-item",!0),o.options._helper=o.options.helper,o.options.helper=function(){return i.helper[0]},e.target=o.currentItem[0],o._mouseCapture(e,!0),o._mouseStart(e,!0,!0),o.offset.click.top=s.offset.click.top,o.offset.click.left=s.offset.click.left,o.offset.parent.left-=s.offset.parent.left-o.offset.parent.left,o.offset.parent.top-=s.offset.parent.top-o.offset.parent.top,s._trigger("toSortable",e),s.dropped=o.element,t.each(s.sortables,function(){this.refreshPositions()}),s.currentItem=s.element,o.fromOutside=s),o.currentItem&&(o._mouseDrag(e),i.position=o.position)):o.isOver&&(o.isOver=0,o.cancelHelperRemoval=!0,o.options._revert=o.options.revert,o.options.revert=!1,o._trigger("out",e,o._uiHash(o)),o._mouseStop(e,!0),o.options.revert=o.options._revert,o.options.helper=o.options._helper,o.placeholder&&o.placeholder.remove(),i.helper.appendTo(s._parent),s._refreshOffsets(e),i.position=s._generatePosition(e,!0),s._trigger("fromSortable",e),s.dropped=!1,t.each(s.sortables,function(){this.refreshPositions()}))})}}),t.ui.plugin.add("draggable","cursor",{start:function(e,i,s){var n=t("body"),o=s.options;n.css("cursor")&&(o._cursor=n.css("cursor")),n.css("cursor",o.cursor)},stop:function(e,i,s){var n=s.options;n._cursor&&t("body").css("cursor",n._cursor)}}),t.ui.plugin.add("draggable","opacity",{start:function(e,i,s){var n=t(i.helper),o=s.options;n.css("opacity")&&(o._opacity=n.css("opacity")),n.css("opacity",o.opacity)},stop:function(e,i,s){var n=s.options;n._opacity&&t(i.helper).css("opacity",n._opacity)}}),t.ui.plugin.add("draggable","scroll",{start:function(t,e,i){i.scrollParentNotHidden||(i.scrollParentNotHidden=i.helper.scrollParent(!1)),i.scrollParentNotHidden[0]!==i.document[0]&&"HTML"!==i.scrollParentNotHidden[0].tagName&&(i.overflowOffset=i.scrollParentNotHidden.offset())},drag:function(e,i,s){var n=s.options,o=!1,a=s.scrollParentNotHidden[0],r=s.document[0];a!==r&&"HTML"!==a.tagName?(n.axis&&"x"===n.axis||(s.overflowOffset.top+a.offsetHeight-e.pageY<n.scrollSensitivity?a.scrollTop=o=a.scrollTop+n.scrollSpeed:e.pageY-s.overflowOffset.top<n.scrollSensitivity&&(a.scrollTop=o=a.scrollTop-n.scrollSpeed)),n.axis&&"y"===n.axis||(s.overflowOffset.left+a.offsetWidth-e.pageX<n.scrollSensitivity?a.scrollLeft=o=a.scrollLeft+n.scrollSpeed:e.pageX-s.overflowOffset.left<n.scrollSensitivity&&(a.scrollLeft=o=a.scrollLeft-n.scrollSpeed))):(n.axis&&"x"===n.axis||(e.pageY-t(r).scrollTop()<n.scrollSensitivity?o=t(r).scrollTop(t(r).scrollTop()-n.scrollSpeed):t(window).height()-(e.pageY-t(r).scrollTop())<n.scrollSensitivity&&(o=t(r).scrollTop(t(r).scrollTop()+n.scrollSpeed))),n.axis&&"y"===n.axis||(e.pageX-t(r).scrollLeft()<n.scrollSensitivity?o=t(r).scrollLeft(t(r).scrollLeft()-n.scrollSpeed):t(window).width()-(e.pageX-t(r).scrollLeft())<n.scrollSensitivity&&(o=t(r).scrollLeft(t(r).scrollLeft()+n.scrollSpeed)))),o!==!1&&t.ui.ddmanager&&!n.dropBehaviour&&t.ui.ddmanager.prepareOffsets(s,e)}}),t.ui.plugin.add("draggable","snap",{start:function(e,i,s){var n=s.options;s.snapElements=[],t(n.snap.constructor!==String?n.snap.items||":data(ui-draggable)":n.snap).each(function(){var e=t(this),i=e.offset();this!==s.element[0]&&s.snapElements.push({item:this,width:e.outerWidth(),height:e.outerHeight(),top:i.top,left:i.left})})},drag:function(e,i,s){var n,o,a,r,h,l,c,u,d,p,f=s.options,g=f.snapTolerance,m=i.offset.left,_=m+s.helperProportions.width,v=i.offset.top,b=v+s.helperProportions.height;for(d=s.snapElements.length-1;d>=0;d--)h=s.snapElements[d].left-s.margins.left,l=h+s.snapElements[d].width,c=s.snapElements[d].top-s.margins.top,u=c+s.snapElements[d].height,h-g>_||m>l+g||c-g>b||v>u+g||!t.contains(s.snapElements[d].item.ownerDocument,s.snapElements[d].item)?(s.snapElements[d].snapping&&s.options.snap.release&&s.options.snap.release.call(s.element,e,t.extend(s._uiHash(),{snapItem:s.snapElements[d].item})),s.snapElements[d].snapping=!1):("inner"!==f.snapMode&&(n=g>=Math.abs(c-b),o=g>=Math.abs(u-v),a=g>=Math.abs(h-_),r=g>=Math.abs(l-m),n&&(i.position.top=s._convertPositionTo("relative",{top:c-s.helperProportions.height,left:0}).top),o&&(i.position.top=s._convertPositionTo("relative",{top:u,left:0}).top),a&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h-s.helperProportions.width}).left),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l}).left)),p=n||o||a||r,"outer"!==f.snapMode&&(n=g>=Math.abs(c-v),o=g>=Math.abs(u-b),a=g>=Math.abs(h-m),r=g>=Math.abs(l-_),n&&(i.position.top=s._convertPositionTo("relative",{top:c,left:0}).top),o&&(i.position.top=s._convertPositionTo("relative",{top:u-s.helperProportions.height,left:0}).top),a&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h}).left),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l-s.helperProportions.width}).left)),!s.snapElements[d].snapping&&(n||o||a||r||p)&&s.options.snap.snap&&s.options.snap.snap.call(s.element,e,t.extend(s._uiHash(),{snapItem:s.snapElements[d].item})),s.snapElements[d].snapping=n||o||a||r||p)}}),t.ui.plugin.add("draggable","stack",{start:function(e,i,s){var n,o=s.options,a=t.makeArray(t(o.stack)).sort(function(e,i){return(parseInt(t(e).css("zIndex"),10)||0)-(parseInt(t(i).css("zIndex"),10)||0)});a.length&&(n=parseInt(t(a[0]).css("zIndex"),10)||0,t(a).each(function(e){t(this).css("zIndex",n+e)}),this.css("zIndex",n+a.length))}}),t.ui.plugin.add("draggable","zIndex",{start:function(e,i,s){var n=t(i.helper),o=s.options;n.css("zIndex")&&(o._zIndex=n.css("zIndex")),n.css("zIndex",o.zIndex)},stop:function(e,i,s){var n=s.options;n._zIndex&&t(i.helper).css("zIndex",n._zIndex)}}),t.ui.draggable,t.widget("ui.resizable",t.ui.mouse,{version:"1.12.1",widgetEventPrefix:"resize",options:{alsoResize:!1,animate:!1,animateDuration:"slow",animateEasing:"swing",aspectRatio:!1,autoHide:!1,classes:{"ui-resizable-se":"ui-icon ui-icon-gripsmall-diagonal-se"},containment:!1,ghost:!1,grid:!1,handles:"e,s,se",helper:!1,maxHeight:null,maxWidth:null,minHeight:10,minWidth:10,zIndex:90,resize:null,start:null,stop:null},_num:function(t){return parseFloat(t)||0},_isNumber:function(t){return!isNaN(parseFloat(t))},_hasScroll:function(e,i){if("hidden"===t(e).css("overflow"))return!1;var s=i&&"left"===i?"scrollLeft":"scrollTop",n=!1;return e[s]>0?!0:(e[s]=1,n=e[s]>0,e[s]=0,n)},_create:function(){var e,i=this.options,s=this;this._addClass("ui-resizable"),t.extend(this,{_aspectRatio:!!i.aspectRatio,aspectRatio:i.aspectRatio,originalElement:this.element,_proportionallyResizeElements:[],_helper:i.helper||i.ghost||i.animate?i.helper||"ui-resizable-helper":null}),this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)&&(this.element.wrap(t("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({position:this.element.css("position"),width:this.element.outerWidth(),height:this.element.outerHeight(),top:this.element.css("top"),left:this.element.css("left")})),this.element=this.element.parent().data("ui-resizable",this.element.resizable("instance")),this.elementIsWrapper=!0,e={marginTop:this.originalElement.css("marginTop"),marginRight:this.originalElement.css("marginRight"),marginBottom:this.originalElement.css("marginBottom"),marginLeft:this.originalElement.css("marginLeft")},this.element.css(e),this.originalElement.css("margin",0),this.originalResizeStyle=this.originalElement.css("resize"),this.originalElement.css("resize","none"),this._proportionallyResizeElements.push(this.originalElement.css({position:"static",zoom:1,display:"block"})),this.originalElement.css(e),this._proportionallyResize()),this._setupHandles(),i.autoHide&&t(this.element).on("mouseenter",function(){i.disabled||(s._removeClass("ui-resizable-autohide"),s._handles.show())}).on("mouseleave",function(){i.disabled||s.resizing||(s._addClass("ui-resizable-autohide"),s._handles.hide())}),this._mouseInit()},_destroy:function(){this._mouseDestroy();var e,i=function(e){t(e).removeData("resizable").removeData("ui-resizable").off(".resizable").find(".ui-resizable-handle").remove()};return this.elementIsWrapper&&(i(this.element),e=this.element,this.originalElement.css({position:e.css("position"),width:e.outerWidth(),height:e.outerHeight(),top:e.css("top"),left:e.css("left")}).insertAfter(e),e.remove()),this.originalElement.css("resize",this.originalResizeStyle),i(this.originalElement),this},_setOption:function(t,e){switch(this._super(t,e),t){case"handles":this._removeHandles(),this._setupHandles();break;default:}},_setupHandles:function(){var e,i,s,n,o,a=this.options,r=this;if(this.handles=a.handles||(t(".ui-resizable-handle",this.element).length?{n:".ui-resizable-n",e:".ui-resizable-e",s:".ui-resizable-s",w:".ui-resizable-w",se:".ui-resizable-se",sw:".ui-resizable-sw",ne:".ui-resizable-ne",nw:".ui-resizable-nw"}:"e,s,se"),this._handles=t(),this.handles.constructor===String)for("all"===this.handles&&(this.handles="n,e,s,w,se,sw,ne,nw"),s=this.handles.split(","),this.handles={},i=0;s.length>i;i++)e=t.trim(s[i]),n="ui-resizable-"+e,o=t("<div>"),this._addClass(o,"ui-resizable-handle "+n),o.css({zIndex:a.zIndex}),this.handles[e]=".ui-resizable-"+e,this.element.append(o);this._renderAxis=function(e){var i,s,n,o;e=e||this.element;for(i in this.handles)this.handles[i].constructor===String?this.handles[i]=this.element.children(this.handles[i]).first().show():(this.handles[i].jquery||this.handles[i].nodeType)&&(this.handles[i]=t(this.handles[i]),this._on(this.handles[i],{mousedown:r._mouseDown})),this.elementIsWrapper&&this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)&&(s=t(this.handles[i],this.element),o=/sw|ne|nw|se|n|s/.test(i)?s.outerHeight():s.outerWidth(),n=["padding",/ne|nw|n/.test(i)?"Top":/se|sw|s/.test(i)?"Bottom":/^e$/.test(i)?"Right":"Left"].join(""),e.css(n,o),this._proportionallyResize()),this._handles=this._handles.add(this.handles[i])},this._renderAxis(this.element),this._handles=this._handles.add(this.element.find(".ui-resizable-handle")),this._handles.disableSelection(),this._handles.on("mouseover",function(){r.resizing||(this.className&&(o=this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)),r.axis=o&&o[1]?o[1]:"se")}),a.autoHide&&(this._handles.hide(),this._addClass("ui-resizable-autohide"))},_removeHandles:function(){this._handles.remove()},_mouseCapture:function(e){var i,s,n=!1;for(i in this.handles)s=t(this.handles[i])[0],(s===e.target||t.contains(s,e.target))&&(n=!0);return!this.options.disabled&&n},_mouseStart:function(e){var i,s,n,o=this.options,a=this.element;return this.resizing=!0,this._renderProxy(),i=this._num(this.helper.css("left")),s=this._num(this.helper.css("top")),o.containment&&(i+=t(o.containment).scrollLeft()||0,s+=t(o.containment).scrollTop()||0),this.offset=this.helper.offset(),this.position={left:i,top:s},this.size=this._helper?{width:this.helper.width(),height:this.helper.height()}:{width:a.width(),height:a.height()},this.originalSize=this._helper?{width:a.outerWidth(),height:a.outerHeight()}:{width:a.width(),height:a.height()},this.sizeDiff={width:a.outerWidth()-a.width(),height:a.outerHeight()-a.height()},this.originalPosition={left:i,top:s},this.originalMousePosition={left:e.pageX,top:e.pageY},this.aspectRatio="number"==typeof o.aspectRatio?o.aspectRatio:this.originalSize.width/this.originalSize.height||1,n=t(".ui-resizable-"+this.axis).css("cursor"),t("body").css("cursor","auto"===n?this.axis+"-resize":n),this._addClass("ui-resizable-resizing"),this._propagate("start",e),!0},_mouseDrag:function(e){var i,s,n=this.originalMousePosition,o=this.axis,a=e.pageX-n.left||0,r=e.pageY-n.top||0,h=this._change[o];return this._updatePrevProperties(),h?(i=h.apply(this,[e,a,r]),this._updateVirtualBoundaries(e.shiftKey),(this._aspectRatio||e.shiftKey)&&(i=this._updateRatio(i,e)),i=this._respectSize(i,e),this._updateCache(i),this._propagate("resize",e),s=this._applyChanges(),!this._helper&&this._proportionallyResizeElements.length&&this._proportionallyResize(),t.isEmptyObject(s)||(this._updatePrevProperties(),this._trigger("resize",e,this.ui()),this._applyChanges()),!1):!1},_mouseStop:function(e){this.resizing=!1;var i,s,n,o,a,r,h,l=this.options,c=this;return this._helper&&(i=this._proportionallyResizeElements,s=i.length&&/textarea/i.test(i[0].nodeName),n=s&&this._hasScroll(i[0],"left")?0:c.sizeDiff.height,o=s?0:c.sizeDiff.width,a={width:c.helper.width()-o,height:c.helper.height()-n},r=parseFloat(c.element.css("left"))+(c.position.left-c.originalPosition.left)||null,h=parseFloat(c.element.css("top"))+(c.position.top-c.originalPosition.top)||null,l.animate||this.element.css(t.extend(a,{top:h,left:r})),c.helper.height(c.size.height),c.helper.width(c.size.width),this._helper&&!l.animate&&this._proportionallyResize()),t("body").css("cursor","auto"),this._removeClass("ui-resizable-resizing"),this._propagate("stop",e),this._helper&&this.helper.remove(),!1},_updatePrevProperties:function(){this.prevPosition={top:this.position.top,left:this.position.left},this.prevSize={width:this.size.width,height:this.size.height}},_applyChanges:function(){var t={};return this.position.top!==this.prevPosition.top&&(t.top=this.position.top+"px"),this.position.left!==this.prevPosition.left&&(t.left=this.position.left+"px"),this.size.width!==this.prevSize.width&&(t.width=this.size.width+"px"),this.size.height!==this.prevSize.height&&(t.height=this.size.height+"px"),this.helper.css(t),t},_updateVirtualBoundaries:function(t){var e,i,s,n,o,a=this.options;o={minWidth:this._isNumber(a.minWidth)?a.minWidth:0,maxWidth:this._isNumber(a.maxWidth)?a.maxWidth:1/0,minHeight:this._isNumber(a.minHeight)?a.minHeight:0,maxHeight:this._isNumber(a.maxHeight)?a.maxHeight:1/0},(this._aspectRatio||t)&&(e=o.minHeight*this.aspectRatio,s=o.minWidth/this.aspectRatio,i=o.maxHeight*this.aspectRatio,n=o.maxWidth/this.aspectRatio,e>o.minWidth&&(o.minWidth=e),s>o.minHeight&&(o.minHeight=s),o.maxWidth>i&&(o.maxWidth=i),o.maxHeight>n&&(o.maxHeight=n)),this._vBoundaries=o},_updateCache:function(t){this.offset=this.helper.offset(),this._isNumber(t.left)&&(this.position.left=t.left),this._isNumber(t.top)&&(this.position.top=t.top),this._isNumber(t.height)&&(this.size.height=t.height),this._isNumber(t.width)&&(this.size.width=t.width)},_updateRatio:function(t){var e=this.position,i=this.size,s=this.axis;return this._isNumber(t.height)?t.width=t.height*this.aspectRatio:this._isNumber(t.width)&&(t.height=t.width/this.aspectRatio),"sw"===s&&(t.left=e.left+(i.width-t.width),t.top=null),"nw"===s&&(t.top=e.top+(i.height-t.height),t.left=e.left+(i.width-t.width)),t},_respectSize:function(t){var e=this._vBoundaries,i=this.axis,s=this._isNumber(t.width)&&e.maxWidth&&e.maxWidth<t.width,n=this._isNumber(t.height)&&e.maxHeight&&e.maxHeight<t.height,o=this._isNumber(t.width)&&e.minWidth&&e.minWidth>t.width,a=this._isNumber(t.height)&&e.minHeight&&e.minHeight>t.height,r=this.originalPosition.left+this.originalSize.width,h=this.originalPosition.top+this.originalSize.height,l=/sw|nw|w/.test(i),c=/nw|ne|n/.test(i);return o&&(t.width=e.minWidth),a&&(t.height=e.minHeight),s&&(t.width=e.maxWidth),n&&(t.height=e.maxHeight),o&&l&&(t.left=r-e.minWidth),s&&l&&(t.left=r-e.maxWidth),a&&c&&(t.top=h-e.minHeight),n&&c&&(t.top=h-e.maxHeight),t.width||t.height||t.left||!t.top?t.width||t.height||t.top||!t.left||(t.left=null):t.top=null,t},_getPaddingPlusBorderDimensions:function(t){for(var e=0,i=[],s=[t.css("borderTopWidth"),t.css("borderRightWidth"),t.css("borderBottomWidth"),t.css("borderLeftWidth")],n=[t.css("paddingTop"),t.css("paddingRight"),t.css("paddingBottom"),t.css("paddingLeft")];4>e;e++)i[e]=parseFloat(s[e])||0,i[e]+=parseFloat(n[e])||0;return{height:i[0]+i[2],width:i[1]+i[3]}},_proportionallyResize:function(){if(this._proportionallyResizeElements.length)for(var t,e=0,i=this.helper||this.element;this._proportionallyResizeElements.length>e;e++)t=this._proportionallyResizeElements[e],this.outerDimensions||(this.outerDimensions=this._getPaddingPlusBorderDimensions(t)),t.css({height:i.height()-this.outerDimensions.height||0,width:i.width()-this.outerDimensions.width||0})},_renderProxy:function(){var e=this.element,i=this.options;this.elementOffset=e.offset(),this._helper?(this.helper=this.helper||t("<div style='overflow:hidden;'></div>"),this._addClass(this.helper,this._helper),this.helper.css({width:this.element.outerWidth(),height:this.element.outerHeight(),position:"absolute",left:this.elementOffset.left+"px",top:this.elementOffset.top+"px",zIndex:++i.zIndex}),this.helper.appendTo("body").disableSelection()):this.helper=this.element},_change:{e:function(t,e){return{width:this.originalSize.width+e}},w:function(t,e){var i=this.originalSize,s=this.originalPosition;return{left:s.left+e,width:i.width-e}},n:function(t,e,i){var s=this.originalSize,n=this.originalPosition;return{top:n.top+i,height:s.height-i}},s:function(t,e,i){return{height:this.originalSize.height+i}},se:function(e,i,s){return t.extend(this._change.s.apply(this,arguments),this._change.e.apply(this,[e,i,s]))},sw:function(e,i,s){return t.extend(this._change.s.apply(this,arguments),this._change.w.apply(this,[e,i,s]))},ne:function(e,i,s){return t.extend(this._change.n.apply(this,arguments),this._change.e.apply(this,[e,i,s]))},nw:function(e,i,s){return t.extend(this._change.n.apply(this,arguments),this._change.w.apply(this,[e,i,s]))}},_propagate:function(e,i){t.ui.plugin.call(this,e,[i,this.ui()]),"resize"!==e&&this._trigger(e,i,this.ui())},plugins:{},ui:function(){return{originalElement:this.originalElement,element:this.element,helper:this.helper,position:this.position,size:this.size,originalSize:this.originalSize,originalPosition:this.originalPosition}}}),t.ui.plugin.add("resizable","animate",{stop:function(e){var i=t(this).resizable("instance"),s=i.options,n=i._proportionallyResizeElements,o=n.length&&/textarea/i.test(n[0].nodeName),a=o&&i._hasScroll(n[0],"left")?0:i.sizeDiff.height,r=o?0:i.sizeDiff.width,h={width:i.size.width-r,height:i.size.height-a},l=parseFloat(i.element.css("left"))+(i.position.left-i.originalPosition.left)||null,c=parseFloat(i.element.css("top"))+(i.position.top-i.originalPosition.top)||null;i.element.animate(t.extend(h,c&&l?{top:c,left:l}:{}),{duration:s.animateDuration,easing:s.animateEasing,step:function(){var s={width:parseFloat(i.element.css("width")),height:parseFloat(i.element.css("height")),top:parseFloat(i.element.css("top")),left:parseFloat(i.element.css("left"))};n&&n.length&&t(n[0]).css({width:s.width,height:s.height}),i._updateCache(s),i._propagate("resize",e)}})}}),t.ui.plugin.add("resizable","containment",{start:function(){var e,i,s,n,o,a,r,h=t(this).resizable("instance"),l=h.options,c=h.element,u=l.containment,d=u instanceof t?u.get(0):/parent/.test(u)?c.parent().get(0):u;d&&(h.containerElement=t(d),/document/.test(u)||u===document?(h.containerOffset={left:0,top:0},h.containerPosition={left:0,top:0},h.parentData={element:t(document),left:0,top:0,width:t(document).width(),height:t(document).height()||document.body.parentNode.scrollHeight}):(e=t(d),i=[],t(["Top","Right","Left","Bottom"]).each(function(t,s){i[t]=h._num(e.css("padding"+s))}),h.containerOffset=e.offset(),h.containerPosition=e.position(),h.containerSize={height:e.innerHeight()-i[3],width:e.innerWidth()-i[1]},s=h.containerOffset,n=h.containerSize.height,o=h.containerSize.width,a=h._hasScroll(d,"left")?d.scrollWidth:o,r=h._hasScroll(d)?d.scrollHeight:n,h.parentData={element:d,left:s.left,top:s.top,width:a,height:r}))},resize:function(e){var i,s,n,o,a=t(this).resizable("instance"),r=a.options,h=a.containerOffset,l=a.position,c=a._aspectRatio||e.shiftKey,u={top:0,left:0},d=a.containerElement,p=!0;d[0]!==document&&/static/.test(d.css("position"))&&(u=h),l.left<(a._helper?h.left:0)&&(a.size.width=a.size.width+(a._helper?a.position.left-h.left:a.position.left-u.left),c&&(a.size.height=a.size.width/a.aspectRatio,p=!1),a.position.left=r.helper?h.left:0),l.top<(a._helper?h.top:0)&&(a.size.height=a.size.height+(a._helper?a.position.top-h.top:a.position.top),c&&(a.size.width=a.size.height*a.aspectRatio,p=!1),a.position.top=a._helper?h.top:0),n=a.containerElement.get(0)===a.element.parent().get(0),o=/relative|absolute/.test(a.containerElement.css("position")),n&&o?(a.offset.left=a.parentData.left+a.position.left,a.offset.top=a.parentData.top+a.position.top):(a.offset.left=a.element.offset().left,a.offset.top=a.element.offset().top),i=Math.abs(a.sizeDiff.width+(a._helper?a.offset.left-u.left:a.offset.left-h.left)),s=Math.abs(a.sizeDiff.height+(a._helper?a.offset.top-u.top:a.offset.top-h.top)),i+a.size.width>=a.parentData.width&&(a.size.width=a.parentData.width-i,c&&(a.size.height=a.size.width/a.aspectRatio,p=!1)),s+a.size.height>=a.parentData.height&&(a.size.height=a.parentData.height-s,c&&(a.size.width=a.size.height*a.aspectRatio,p=!1)),p||(a.position.left=a.prevPosition.left,a.position.top=a.prevPosition.top,a.size.width=a.prevSize.width,a.size.height=a.prevSize.height)},stop:function(){var e=t(this).resizable("instance"),i=e.options,s=e.containerOffset,n=e.containerPosition,o=e.containerElement,a=t(e.helper),r=a.offset(),h=a.outerWidth()-e.sizeDiff.width,l=a.outerHeight()-e.sizeDiff.height;e._helper&&!i.animate&&/relative/.test(o.css("position"))&&t(this).css({left:r.left-n.left-s.left,width:h,height:l}),e._helper&&!i.animate&&/static/.test(o.css("position"))&&t(this).css({left:r.left-n.left-s.left,width:h,height:l})}}),t.ui.plugin.add("resizable","alsoResize",{start:function(){var e=t(this).resizable("instance"),i=e.options;t(i.alsoResize).each(function(){var e=t(this);e.data("ui-resizable-alsoresize",{width:parseFloat(e.width()),height:parseFloat(e.height()),left:parseFloat(e.css("left")),top:parseFloat(e.css("top"))})})},resize:function(e,i){var s=t(this).resizable("instance"),n=s.options,o=s.originalSize,a=s.originalPosition,r={height:s.size.height-o.height||0,width:s.size.width-o.width||0,top:s.position.top-a.top||0,left:s.position.left-a.left||0};t(n.alsoResize).each(function(){var e=t(this),s=t(this).data("ui-resizable-alsoresize"),n={},o=e.parents(i.originalElement[0]).length?["width","height"]:["width","height","top","left"];t.each(o,function(t,e){var i=(s[e]||0)+(r[e]||0);i&&i>=0&&(n[e]=i||null)}),e.css(n)})},stop:function(){t(this).removeData("ui-resizable-alsoresize")}}),t.ui.plugin.add("resizable","ghost",{start:function(){var e=t(this).resizable("instance"),i=e.size;e.ghost=e.originalElement.clone(),e.ghost.css({opacity:.25,display:"block",position:"relative",height:i.height,width:i.width,margin:0,left:0,top:0}),e._addClass(e.ghost,"ui-resizable-ghost"),t.uiBackCompat!==!1&&"string"==typeof e.options.ghost&&e.ghost.addClass(this.options.ghost),e.ghost.appendTo(e.helper)},resize:function(){var e=t(this).resizable("instance");e.ghost&&e.ghost.css({position:"relative",height:e.size.height,width:e.size.width})},stop:function(){var e=t(this).resizable("instance");e.ghost&&e.helper&&e.helper.get(0).removeChild(e.ghost.get(0))}}),t.ui.plugin.add("resizable","grid",{resize:function(){var e,i=t(this).resizable("instance"),s=i.options,n=i.size,o=i.originalSize,a=i.originalPosition,r=i.axis,h="number"==typeof s.grid?[s.grid,s.grid]:s.grid,l=h[0]||1,c=h[1]||1,u=Math.round((n.width-o.width)/l)*l,d=Math.round((n.height-o.height)/c)*c,p=o.width+u,f=o.height+d,g=s.maxWidth&&p>s.maxWidth,m=s.maxHeight&&f>s.maxHeight,_=s.minWidth&&s.minWidth>p,v=s.minHeight&&s.minHeight>f;s.grid=h,_&&(p+=l),v&&(f+=c),g&&(p-=l),m&&(f-=c),/^(se|s|e)$/.test(r)?(i.size.width=p,i.size.height=f):/^(ne)$/.test(r)?(i.size.width=p,i.size.height=f,i.position.top=a.top-d):/^(sw)$/.test(r)?(i.size.width=p,i.size.height=f,i.position.left=a.left-u):((0>=f-c||0>=p-l)&&(e=i._getPaddingPlusBorderDimensions(this)),f-c>0?(i.size.height=f,i.position.top=a.top-d):(f=c-e.height,i.size.height=f,i.position.top=a.top+o.height-f),p-l>0?(i.size.width=p,i.position.left=a.left-u):(p=l-e.width,i.size.width=p,i.position.left=a.left+o.width-p))}}),t.ui.resizable,t.widget("ui.dialog",{version:"1.12.1",options:{appendTo:"body",autoOpen:!0,buttons:[],classes:{"ui-dialog":"ui-corner-all","ui-dialog-titlebar":"ui-corner-all"},closeOnEscape:!0,closeText:"Close",draggable:!0,hide:null,height:"auto",maxHeight:null,maxWidth:null,minHeight:150,minWidth:150,modal:!1,position:{my:"center",at:"center",of:window,collision:"fit",using:function(e){var i=t(this).css(e).offset().top;0>i&&t(this).css("top",e.top-i)}},resizable:!0,show:null,title:null,width:300,beforeClose:null,close:null,drag:null,dragStart:null,dragStop:null,focus:null,open:null,resize:null,resizeStart:null,resizeStop:null},sizeRelatedOptions:{buttons:!0,height:!0,maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0,width:!0},resizableRelatedOptions:{maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0},_create:function(){this.originalCss={display:this.element[0].style.display,width:this.element[0].style.width,minHeight:this.element[0].style.minHeight,maxHeight:this.element[0].style.maxHeight,height:this.element[0].style.height},this.originalPosition={parent:this.element.parent(),index:this.element.parent().children().index(this.element)},this.originalTitle=this.element.attr("title"),null==this.options.title&&null!=this.originalTitle&&(this.options.title=this.originalTitle),this.options.disabled&&(this.options.disabled=!1),this._createWrapper(),this.element.show().removeAttr("title").appendTo(this.uiDialog),this._addClass("ui-dialog-content","ui-widget-content"),this._createTitlebar(),this._createButtonPane(),this.options.draggable&&t.fn.draggable&&this._makeDraggable(),this.options.resizable&&t.fn.resizable&&this._makeResizable(),this._isOpen=!1,this._trackFocus()},_init:function(){this.options.autoOpen&&this.open()},_appendTo:function(){var e=this.options.appendTo;return e&&(e.jquery||e.nodeType)?t(e):this.document.find(e||"body").eq(0)},_destroy:function(){var t,e=this.originalPosition;this._untrackInstance(),this._destroyOverlay(),this.element.removeUniqueId().css(this.originalCss).detach(),this.uiDialog.remove(),this.originalTitle&&this.element.attr("title",this.originalTitle),t=e.parent.children().eq(e.index),t.length&&t[0]!==this.element[0]?t.before(this.element):e.parent.append(this.element)},widget:function(){return this.uiDialog
},disable:t.noop,enable:t.noop,close:function(e){var i=this;this._isOpen&&this._trigger("beforeClose",e)!==!1&&(this._isOpen=!1,this._focusedElement=null,this._destroyOverlay(),this._untrackInstance(),this.opener.filter(":focusable").trigger("focus").length||t.ui.safeBlur(t.ui.safeActiveElement(this.document[0])),this._hide(this.uiDialog,this.options.hide,function(){i._trigger("close",e)}))},isOpen:function(){return this._isOpen},moveToTop:function(){this._moveToTop()},_moveToTop:function(e,i){var s=!1,n=this.uiDialog.siblings(".ui-front:visible").map(function(){return+t(this).css("z-index")}).get(),o=Math.max.apply(null,n);return o>=+this.uiDialog.css("z-index")&&(this.uiDialog.css("z-index",o+1),s=!0),s&&!i&&this._trigger("focus",e),s},open:function(){var e=this;return this._isOpen?(this._moveToTop()&&this._focusTabbable(),void 0):(this._isOpen=!0,this.opener=t(t.ui.safeActiveElement(this.document[0])),this._size(),this._position(),this._createOverlay(),this._moveToTop(null,!0),this.overlay&&this.overlay.css("z-index",this.uiDialog.css("z-index")-1),this._show(this.uiDialog,this.options.show,function(){e._focusTabbable(),e._trigger("focus")}),this._makeFocusTarget(),this._trigger("open"),void 0)},_focusTabbable:function(){var t=this._focusedElement;t||(t=this.element.find("[autofocus]")),t.length||(t=this.element.find(":tabbable")),t.length||(t=this.uiDialogButtonPane.find(":tabbable")),t.length||(t=this.uiDialogTitlebarClose.filter(":tabbable")),t.length||(t=this.uiDialog),t.eq(0).trigger("focus")},_keepFocus:function(e){function i(){var e=t.ui.safeActiveElement(this.document[0]),i=this.uiDialog[0]===e||t.contains(this.uiDialog[0],e);i||this._focusTabbable()}e.preventDefault(),i.call(this),this._delay(i)},_createWrapper:function(){this.uiDialog=t("<div>").hide().attr({tabIndex:-1,role:"dialog"}).appendTo(this._appendTo()),this._addClass(this.uiDialog,"ui-dialog","ui-widget ui-widget-content ui-front"),this._on(this.uiDialog,{keydown:function(e){if(this.options.closeOnEscape&&!e.isDefaultPrevented()&&e.keyCode&&e.keyCode===t.ui.keyCode.ESCAPE)return e.preventDefault(),this.close(e),void 0;if(e.keyCode===t.ui.keyCode.TAB&&!e.isDefaultPrevented()){var i=this.uiDialog.find(":tabbable"),s=i.filter(":first"),n=i.filter(":last");e.target!==n[0]&&e.target!==this.uiDialog[0]||e.shiftKey?e.target!==s[0]&&e.target!==this.uiDialog[0]||!e.shiftKey||(this._delay(function(){n.trigger("focus")}),e.preventDefault()):(this._delay(function(){s.trigger("focus")}),e.preventDefault())}},mousedown:function(t){this._moveToTop(t)&&this._focusTabbable()}}),this.element.find("[aria-describedby]").length||this.uiDialog.attr({"aria-describedby":this.element.uniqueId().attr("id")})},_createTitlebar:function(){var e;this.uiDialogTitlebar=t("<div>"),this._addClass(this.uiDialogTitlebar,"ui-dialog-titlebar","ui-widget-header ui-helper-clearfix"),this._on(this.uiDialogTitlebar,{mousedown:function(e){t(e.target).closest(".ui-dialog-titlebar-close")||this.uiDialog.trigger("focus")}}),this.uiDialogTitlebarClose=t("<button type='button'></button>").button({label:t("<a>").text(this.options.closeText).html(),icon:"ui-icon-closethick",showLabel:!1}).appendTo(this.uiDialogTitlebar),this._addClass(this.uiDialogTitlebarClose,"ui-dialog-titlebar-close"),this._on(this.uiDialogTitlebarClose,{click:function(t){t.preventDefault(),this.close(t)}}),e=t("<span>").uniqueId().prependTo(this.uiDialogTitlebar),this._addClass(e,"ui-dialog-title"),this._title(e),this.uiDialogTitlebar.prependTo(this.uiDialog),this.uiDialog.attr({"aria-labelledby":e.attr("id")})},_title:function(t){this.options.title?t.text(this.options.title):t.html("&#160;")},_createButtonPane:function(){this.uiDialogButtonPane=t("<div>"),this._addClass(this.uiDialogButtonPane,"ui-dialog-buttonpane","ui-widget-content ui-helper-clearfix"),this.uiButtonSet=t("<div>").appendTo(this.uiDialogButtonPane),this._addClass(this.uiButtonSet,"ui-dialog-buttonset"),this._createButtons()},_createButtons:function(){var e=this,i=this.options.buttons;return this.uiDialogButtonPane.remove(),this.uiButtonSet.empty(),t.isEmptyObject(i)||t.isArray(i)&&!i.length?(this._removeClass(this.uiDialog,"ui-dialog-buttons"),void 0):(t.each(i,function(i,s){var n,o;s=t.isFunction(s)?{click:s,text:i}:s,s=t.extend({type:"button"},s),n=s.click,o={icon:s.icon,iconPosition:s.iconPosition,showLabel:s.showLabel,icons:s.icons,text:s.text},delete s.click,delete s.icon,delete s.iconPosition,delete s.showLabel,delete s.icons,"boolean"==typeof s.text&&delete s.text,t("<button></button>",s).button(o).appendTo(e.uiButtonSet).on("click",function(){n.apply(e.element[0],arguments)})}),this._addClass(this.uiDialog,"ui-dialog-buttons"),this.uiDialogButtonPane.appendTo(this.uiDialog),void 0)},_makeDraggable:function(){function e(t){return{position:t.position,offset:t.offset}}var i=this,s=this.options;this.uiDialog.draggable({cancel:".ui-dialog-content, .ui-dialog-titlebar-close",handle:".ui-dialog-titlebar",containment:"document",start:function(s,n){i._addClass(t(this),"ui-dialog-dragging"),i._blockFrames(),i._trigger("dragStart",s,e(n))},drag:function(t,s){i._trigger("drag",t,e(s))},stop:function(n,o){var a=o.offset.left-i.document.scrollLeft(),r=o.offset.top-i.document.scrollTop();s.position={my:"left top",at:"left"+(a>=0?"+":"")+a+" "+"top"+(r>=0?"+":"")+r,of:i.window},i._removeClass(t(this),"ui-dialog-dragging"),i._unblockFrames(),i._trigger("dragStop",n,e(o))}})},_makeResizable:function(){function e(t){return{originalPosition:t.originalPosition,originalSize:t.originalSize,position:t.position,size:t.size}}var i=this,s=this.options,n=s.resizable,o=this.uiDialog.css("position"),a="string"==typeof n?n:"n,e,s,w,se,sw,ne,nw";this.uiDialog.resizable({cancel:".ui-dialog-content",containment:"document",alsoResize:this.element,maxWidth:s.maxWidth,maxHeight:s.maxHeight,minWidth:s.minWidth,minHeight:this._minHeight(),handles:a,start:function(s,n){i._addClass(t(this),"ui-dialog-resizing"),i._blockFrames(),i._trigger("resizeStart",s,e(n))},resize:function(t,s){i._trigger("resize",t,e(s))},stop:function(n,o){var a=i.uiDialog.offset(),r=a.left-i.document.scrollLeft(),h=a.top-i.document.scrollTop();s.height=i.uiDialog.height(),s.width=i.uiDialog.width(),s.position={my:"left top",at:"left"+(r>=0?"+":"")+r+" "+"top"+(h>=0?"+":"")+h,of:i.window},i._removeClass(t(this),"ui-dialog-resizing"),i._unblockFrames(),i._trigger("resizeStop",n,e(o))}}).css("position",o)},_trackFocus:function(){this._on(this.widget(),{focusin:function(e){this._makeFocusTarget(),this._focusedElement=t(e.target)}})},_makeFocusTarget:function(){this._untrackInstance(),this._trackingInstances().unshift(this)},_untrackInstance:function(){var e=this._trackingInstances(),i=t.inArray(this,e);-1!==i&&e.splice(i,1)},_trackingInstances:function(){var t=this.document.data("ui-dialog-instances");return t||(t=[],this.document.data("ui-dialog-instances",t)),t},_minHeight:function(){var t=this.options;return"auto"===t.height?t.minHeight:Math.min(t.minHeight,t.height)},_position:function(){var t=this.uiDialog.is(":visible");t||this.uiDialog.show(),this.uiDialog.position(this.options.position),t||this.uiDialog.hide()},_setOptions:function(e){var i=this,s=!1,n={};t.each(e,function(t,e){i._setOption(t,e),t in i.sizeRelatedOptions&&(s=!0),t in i.resizableRelatedOptions&&(n[t]=e)}),s&&(this._size(),this._position()),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option",n)},_setOption:function(e,i){var s,n,o=this.uiDialog;"disabled"!==e&&(this._super(e,i),"appendTo"===e&&this.uiDialog.appendTo(this._appendTo()),"buttons"===e&&this._createButtons(),"closeText"===e&&this.uiDialogTitlebarClose.button({label:t("<a>").text(""+this.options.closeText).html()}),"draggable"===e&&(s=o.is(":data(ui-draggable)"),s&&!i&&o.draggable("destroy"),!s&&i&&this._makeDraggable()),"position"===e&&this._position(),"resizable"===e&&(n=o.is(":data(ui-resizable)"),n&&!i&&o.resizable("destroy"),n&&"string"==typeof i&&o.resizable("option","handles",i),n||i===!1||this._makeResizable()),"title"===e&&this._title(this.uiDialogTitlebar.find(".ui-dialog-title")))},_size:function(){var t,e,i,s=this.options;this.element.show().css({width:"auto",minHeight:0,maxHeight:"none",height:0}),s.minWidth>s.width&&(s.width=s.minWidth),t=this.uiDialog.css({height:"auto",width:s.width}).outerHeight(),e=Math.max(0,s.minHeight-t),i="number"==typeof s.maxHeight?Math.max(0,s.maxHeight-t):"none","auto"===s.height?this.element.css({minHeight:e,maxHeight:i,height:"auto"}):this.element.height(Math.max(0,s.height-t)),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option","minHeight",this._minHeight())},_blockFrames:function(){this.iframeBlocks=this.document.find("iframe").map(function(){var e=t(this);return t("<div>").css({position:"absolute",width:e.outerWidth(),height:e.outerHeight()}).appendTo(e.parent()).offset(e.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_allowInteraction:function(e){return t(e.target).closest(".ui-dialog").length?!0:!!t(e.target).closest(".ui-datepicker").length},_createOverlay:function(){if(this.options.modal){var e=!0;this._delay(function(){e=!1}),this.document.data("ui-dialog-overlays")||this._on(this.document,{focusin:function(t){e||this._allowInteraction(t)||(t.preventDefault(),this._trackingInstances()[0]._focusTabbable())}}),this.overlay=t("<div>").appendTo(this._appendTo()),this._addClass(this.overlay,null,"ui-widget-overlay ui-front"),this._on(this.overlay,{mousedown:"_keepFocus"}),this.document.data("ui-dialog-overlays",(this.document.data("ui-dialog-overlays")||0)+1)}},_destroyOverlay:function(){if(this.options.modal&&this.overlay){var t=this.document.data("ui-dialog-overlays")-1;t?this.document.data("ui-dialog-overlays",t):(this._off(this.document,"focusin"),this.document.removeData("ui-dialog-overlays")),this.overlay.remove(),this.overlay=null}}}),t.uiBackCompat!==!1&&t.widget("ui.dialog",t.ui.dialog,{options:{dialogClass:""},_createWrapper:function(){this._super(),this.uiDialog.addClass(this.options.dialogClass)},_setOption:function(t,e){"dialogClass"===t&&this.uiDialog.removeClass(this.options.dialogClass).addClass(e),this._superApply(arguments)}}),t.ui.dialog,t.widget("ui.droppable",{version:"1.12.1",widgetEventPrefix:"drop",options:{accept:"*",addClasses:!0,greedy:!1,scope:"default",tolerance:"intersect",activate:null,deactivate:null,drop:null,out:null,over:null},_create:function(){var e,i=this.options,s=i.accept;this.isover=!1,this.isout=!0,this.accept=t.isFunction(s)?s:function(t){return t.is(s)},this.proportions=function(){return arguments.length?(e=arguments[0],void 0):e?e:e={width:this.element[0].offsetWidth,height:this.element[0].offsetHeight}},this._addToManager(i.scope),i.addClasses&&this._addClass("ui-droppable")},_addToManager:function(e){t.ui.ddmanager.droppables[e]=t.ui.ddmanager.droppables[e]||[],t.ui.ddmanager.droppables[e].push(this)},_splice:function(t){for(var e=0;t.length>e;e++)t[e]===this&&t.splice(e,1)},_destroy:function(){var e=t.ui.ddmanager.droppables[this.options.scope];this._splice(e)},_setOption:function(e,i){if("accept"===e)this.accept=t.isFunction(i)?i:function(t){return t.is(i)};else if("scope"===e){var s=t.ui.ddmanager.droppables[this.options.scope];this._splice(s),this._addToManager(i)}this._super(e,i)},_activate:function(e){var i=t.ui.ddmanager.current;this._addActiveClass(),i&&this._trigger("activate",e,this.ui(i))},_deactivate:function(e){var i=t.ui.ddmanager.current;this._removeActiveClass(),i&&this._trigger("deactivate",e,this.ui(i))},_over:function(e){var i=t.ui.ddmanager.current;i&&(i.currentItem||i.element)[0]!==this.element[0]&&this.accept.call(this.element[0],i.currentItem||i.element)&&(this._addHoverClass(),this._trigger("over",e,this.ui(i)))},_out:function(e){var i=t.ui.ddmanager.current;i&&(i.currentItem||i.element)[0]!==this.element[0]&&this.accept.call(this.element[0],i.currentItem||i.element)&&(this._removeHoverClass(),this._trigger("out",e,this.ui(i)))},_drop:function(e,i){var s=i||t.ui.ddmanager.current,n=!1;return s&&(s.currentItem||s.element)[0]!==this.element[0]?(this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function(){var i=t(this).droppable("instance");return i.options.greedy&&!i.options.disabled&&i.options.scope===s.options.scope&&i.accept.call(i.element[0],s.currentItem||s.element)&&v(s,t.extend(i,{offset:i.element.offset()}),i.options.tolerance,e)?(n=!0,!1):void 0}),n?!1:this.accept.call(this.element[0],s.currentItem||s.element)?(this._removeActiveClass(),this._removeHoverClass(),this._trigger("drop",e,this.ui(s)),this.element):!1):!1},ui:function(t){return{draggable:t.currentItem||t.element,helper:t.helper,position:t.position,offset:t.positionAbs}},_addHoverClass:function(){this._addClass("ui-droppable-hover")},_removeHoverClass:function(){this._removeClass("ui-droppable-hover")},_addActiveClass:function(){this._addClass("ui-droppable-active")},_removeActiveClass:function(){this._removeClass("ui-droppable-active")}});var v=t.ui.intersect=function(){function t(t,e,i){return t>=e&&e+i>t}return function(e,i,s,n){if(!i.offset)return!1;var o=(e.positionAbs||e.position.absolute).left+e.margins.left,a=(e.positionAbs||e.position.absolute).top+e.margins.top,r=o+e.helperProportions.width,h=a+e.helperProportions.height,l=i.offset.left,c=i.offset.top,u=l+i.proportions().width,d=c+i.proportions().height;switch(s){case"fit":return o>=l&&u>=r&&a>=c&&d>=h;case"intersect":return o+e.helperProportions.width/2>l&&u>r-e.helperProportions.width/2&&a+e.helperProportions.height/2>c&&d>h-e.helperProportions.height/2;case"pointer":return t(n.pageY,c,i.proportions().height)&&t(n.pageX,l,i.proportions().width);case"touch":return(a>=c&&d>=a||h>=c&&d>=h||c>a&&h>d)&&(o>=l&&u>=o||r>=l&&u>=r||l>o&&r>u);default:return!1}}}();t.ui.ddmanager={current:null,droppables:{"default":[]},prepareOffsets:function(e,i){var s,n,o=t.ui.ddmanager.droppables[e.options.scope]||[],a=i?i.type:null,r=(e.currentItem||e.element).find(":data(ui-droppable)").addBack();t:for(s=0;o.length>s;s++)if(!(o[s].options.disabled||e&&!o[s].accept.call(o[s].element[0],e.currentItem||e.element))){for(n=0;r.length>n;n++)if(r[n]===o[s].element[0]){o[s].proportions().height=0;continue t}o[s].visible="none"!==o[s].element.css("display"),o[s].visible&&("mousedown"===a&&o[s]._activate.call(o[s],i),o[s].offset=o[s].element.offset(),o[s].proportions({width:o[s].element[0].offsetWidth,height:o[s].element[0].offsetHeight}))}},drop:function(e,i){var s=!1;return t.each((t.ui.ddmanager.droppables[e.options.scope]||[]).slice(),function(){this.options&&(!this.options.disabled&&this.visible&&v(e,this,this.options.tolerance,i)&&(s=this._drop.call(this,i)||s),!this.options.disabled&&this.visible&&this.accept.call(this.element[0],e.currentItem||e.element)&&(this.isout=!0,this.isover=!1,this._deactivate.call(this,i)))}),s},dragStart:function(e,i){e.element.parentsUntil("body").on("scroll.droppable",function(){e.options.refreshPositions||t.ui.ddmanager.prepareOffsets(e,i)})},drag:function(e,i){e.options.refreshPositions&&t.ui.ddmanager.prepareOffsets(e,i),t.each(t.ui.ddmanager.droppables[e.options.scope]||[],function(){if(!this.options.disabled&&!this.greedyChild&&this.visible){var s,n,o,a=v(e,this,this.options.tolerance,i),r=!a&&this.isover?"isout":a&&!this.isover?"isover":null;r&&(this.options.greedy&&(n=this.options.scope,o=this.element.parents(":data(ui-droppable)").filter(function(){return t(this).droppable("instance").options.scope===n}),o.length&&(s=t(o[0]).droppable("instance"),s.greedyChild="isover"===r)),s&&"isover"===r&&(s.isover=!1,s.isout=!0,s._out.call(s,i)),this[r]=!0,this["isout"===r?"isover":"isout"]=!1,this["isover"===r?"_over":"_out"].call(this,i),s&&"isout"===r&&(s.isout=!1,s.isover=!0,s._over.call(s,i)))}})},dragStop:function(e,i){e.element.parentsUntil("body").off("scroll.droppable"),e.options.refreshPositions||t.ui.ddmanager.prepareOffsets(e,i)}},t.uiBackCompat!==!1&&t.widget("ui.droppable",t.ui.droppable,{options:{hoverClass:!1,activeClass:!1},_addActiveClass:function(){this._super(),this.options.activeClass&&this.element.addClass(this.options.activeClass)},_removeActiveClass:function(){this._super(),this.options.activeClass&&this.element.removeClass(this.options.activeClass)},_addHoverClass:function(){this._super(),this.options.hoverClass&&this.element.addClass(this.options.hoverClass)},_removeHoverClass:function(){this._super(),this.options.hoverClass&&this.element.removeClass(this.options.hoverClass)}}),t.ui.droppable,t.widget("ui.progressbar",{version:"1.12.1",options:{classes:{"ui-progressbar":"ui-corner-all","ui-progressbar-value":"ui-corner-left","ui-progressbar-complete":"ui-corner-right"},max:100,value:0,change:null,complete:null},min:0,_create:function(){this.oldValue=this.options.value=this._constrainedValue(),this.element.attr({role:"progressbar","aria-valuemin":this.min}),this._addClass("ui-progressbar","ui-widget ui-widget-content"),this.valueDiv=t("<div>").appendTo(this.element),this._addClass(this.valueDiv,"ui-progressbar-value","ui-widget-header"),this._refreshValue()},_destroy:function(){this.element.removeAttr("role aria-valuemin aria-valuemax aria-valuenow"),this.valueDiv.remove()},value:function(t){return void 0===t?this.options.value:(this.options.value=this._constrainedValue(t),this._refreshValue(),void 0)},_constrainedValue:function(t){return void 0===t&&(t=this.options.value),this.indeterminate=t===!1,"number"!=typeof t&&(t=0),this.indeterminate?!1:Math.min(this.options.max,Math.max(this.min,t))},_setOptions:function(t){var e=t.value;delete t.value,this._super(t),this.options.value=this._constrainedValue(e),this._refreshValue()},_setOption:function(t,e){"max"===t&&(e=Math.max(this.min,e)),this._super(t,e)},_setOptionDisabled:function(t){this._super(t),this.element.attr("aria-disabled",t),this._toggleClass(null,"ui-state-disabled",!!t)},_percentage:function(){return this.indeterminate?100:100*(this.options.value-this.min)/(this.options.max-this.min)},_refreshValue:function(){var e=this.options.value,i=this._percentage();this.valueDiv.toggle(this.indeterminate||e>this.min).width(i.toFixed(0)+"%"),this._toggleClass(this.valueDiv,"ui-progressbar-complete",null,e===this.options.max)._toggleClass("ui-progressbar-indeterminate",null,this.indeterminate),this.indeterminate?(this.element.removeAttr("aria-valuenow"),this.overlayDiv||(this.overlayDiv=t("<div>").appendTo(this.valueDiv),this._addClass(this.overlayDiv,"ui-progressbar-overlay"))):(this.element.attr({"aria-valuemax":this.options.max,"aria-valuenow":e}),this.overlayDiv&&(this.overlayDiv.remove(),this.overlayDiv=null)),this.oldValue!==e&&(this.oldValue=e,this._trigger("change")),e===this.options.max&&this._trigger("complete")}}),t.widget("ui.selectable",t.ui.mouse,{version:"1.12.1",options:{appendTo:"body",autoRefresh:!0,distance:0,filter:"*",tolerance:"touch",selected:null,selecting:null,start:null,stop:null,unselected:null,unselecting:null},_create:function(){var e=this;this._addClass("ui-selectable"),this.dragged=!1,this.refresh=function(){e.elementPos=t(e.element[0]).offset(),e.selectees=t(e.options.filter,e.element[0]),e._addClass(e.selectees,"ui-selectee"),e.selectees.each(function(){var i=t(this),s=i.offset(),n={left:s.left-e.elementPos.left,top:s.top-e.elementPos.top};t.data(this,"selectable-item",{element:this,$element:i,left:n.left,top:n.top,right:n.left+i.outerWidth(),bottom:n.top+i.outerHeight(),startselected:!1,selected:i.hasClass("ui-selected"),selecting:i.hasClass("ui-selecting"),unselecting:i.hasClass("ui-unselecting")})})},this.refresh(),this._mouseInit(),this.helper=t("<div>"),this._addClass(this.helper,"ui-selectable-helper")},_destroy:function(){this.selectees.removeData("selectable-item"),this._mouseDestroy()},_mouseStart:function(e){var i=this,s=this.options;this.opos=[e.pageX,e.pageY],this.elementPos=t(this.element[0]).offset(),this.options.disabled||(this.selectees=t(s.filter,this.element[0]),this._trigger("start",e),t(s.appendTo).append(this.helper),this.helper.css({left:e.pageX,top:e.pageY,width:0,height:0}),s.autoRefresh&&this.refresh(),this.selectees.filter(".ui-selected").each(function(){var s=t.data(this,"selectable-item");s.startselected=!0,e.metaKey||e.ctrlKey||(i._removeClass(s.$element,"ui-selected"),s.selected=!1,i._addClass(s.$element,"ui-unselecting"),s.unselecting=!0,i._trigger("unselecting",e,{unselecting:s.element}))}),t(e.target).parents().addBack().each(function(){var s,n=t.data(this,"selectable-item");return n?(s=!e.metaKey&&!e.ctrlKey||!n.$element.hasClass("ui-selected"),i._removeClass(n.$element,s?"ui-unselecting":"ui-selected")._addClass(n.$element,s?"ui-selecting":"ui-unselecting"),n.unselecting=!s,n.selecting=s,n.selected=s,s?i._trigger("selecting",e,{selecting:n.element}):i._trigger("unselecting",e,{unselecting:n.element}),!1):void 0}))},_mouseDrag:function(e){if(this.dragged=!0,!this.options.disabled){var i,s=this,n=this.options,o=this.opos[0],a=this.opos[1],r=e.pageX,h=e.pageY;return o>r&&(i=r,r=o,o=i),a>h&&(i=h,h=a,a=i),this.helper.css({left:o,top:a,width:r-o,height:h-a}),this.selectees.each(function(){var i=t.data(this,"selectable-item"),l=!1,c={};i&&i.element!==s.element[0]&&(c.left=i.left+s.elementPos.left,c.right=i.right+s.elementPos.left,c.top=i.top+s.elementPos.top,c.bottom=i.bottom+s.elementPos.top,"touch"===n.tolerance?l=!(c.left>r||o>c.right||c.top>h||a>c.bottom):"fit"===n.tolerance&&(l=c.left>o&&r>c.right&&c.top>a&&h>c.bottom),l?(i.selected&&(s._removeClass(i.$element,"ui-selected"),i.selected=!1),i.unselecting&&(s._removeClass(i.$element,"ui-unselecting"),i.unselecting=!1),i.selecting||(s._addClass(i.$element,"ui-selecting"),i.selecting=!0,s._trigger("selecting",e,{selecting:i.element}))):(i.selecting&&((e.metaKey||e.ctrlKey)&&i.startselected?(s._removeClass(i.$element,"ui-selecting"),i.selecting=!1,s._addClass(i.$element,"ui-selected"),i.selected=!0):(s._removeClass(i.$element,"ui-selecting"),i.selecting=!1,i.startselected&&(s._addClass(i.$element,"ui-unselecting"),i.unselecting=!0),s._trigger("unselecting",e,{unselecting:i.element}))),i.selected&&(e.metaKey||e.ctrlKey||i.startselected||(s._removeClass(i.$element,"ui-selected"),i.selected=!1,s._addClass(i.$element,"ui-unselecting"),i.unselecting=!0,s._trigger("unselecting",e,{unselecting:i.element})))))}),!1}},_mouseStop:function(e){var i=this;return this.dragged=!1,t(".ui-unselecting",this.element[0]).each(function(){var s=t.data(this,"selectable-item");i._removeClass(s.$element,"ui-unselecting"),s.unselecting=!1,s.startselected=!1,i._trigger("unselected",e,{unselected:s.element})}),t(".ui-selecting",this.element[0]).each(function(){var s=t.data(this,"selectable-item");i._removeClass(s.$element,"ui-selecting")._addClass(s.$element,"ui-selected"),s.selecting=!1,s.selected=!0,s.startselected=!0,i._trigger("selected",e,{selected:s.element})}),this._trigger("stop",e),this.helper.remove(),!1}}),t.widget("ui.selectmenu",[t.ui.formResetMixin,{version:"1.12.1",defaultElement:"<select>",options:{appendTo:null,classes:{"ui-selectmenu-button-open":"ui-corner-top","ui-selectmenu-button-closed":"ui-corner-all"},disabled:null,icons:{button:"ui-icon-triangle-1-s"},position:{my:"left top",at:"left bottom",collision:"none"},width:!1,change:null,close:null,focus:null,open:null,select:null},_create:function(){var e=this.element.uniqueId().attr("id");this.ids={element:e,button:e+"-button",menu:e+"-menu"},this._drawButton(),this._drawMenu(),this._bindFormResetHandler(),this._rendered=!1,this.menuItems=t()},_drawButton:function(){var e,i=this,s=this._parseOption(this.element.find("option:selected"),this.element[0].selectedIndex);this.labels=this.element.labels().attr("for",this.ids.button),this._on(this.labels,{click:function(t){this.button.focus(),t.preventDefault()}}),this.element.hide(),this.button=t("<span>",{tabindex:this.options.disabled?-1:0,id:this.ids.button,role:"combobox","aria-expanded":"false","aria-autocomplete":"list","aria-owns":this.ids.menu,"aria-haspopup":"true",title:this.element.attr("title")}).insertAfter(this.element),this._addClass(this.button,"ui-selectmenu-button ui-selectmenu-button-closed","ui-button ui-widget"),e=t("<span>").appendTo(this.button),this._addClass(e,"ui-selectmenu-icon","ui-icon "+this.options.icons.button),this.buttonItem=this._renderButtonItem(s).appendTo(this.button),this.options.width!==!1&&this._resizeButton(),this._on(this.button,this._buttonEvents),this.button.one("focusin",function(){i._rendered||i._refreshMenu()})},_drawMenu:function(){var e=this;this.menu=t("<ul>",{"aria-hidden":"true","aria-labelledby":this.ids.button,id:this.ids.menu}),this.menuWrap=t("<div>").append(this.menu),this._addClass(this.menuWrap,"ui-selectmenu-menu","ui-front"),this.menuWrap.appendTo(this._appendTo()),this.menuInstance=this.menu.menu({classes:{"ui-menu":"ui-corner-bottom"},role:"listbox",select:function(t,i){t.preventDefault(),e._setSelection(),e._select(i.item.data("ui-selectmenu-item"),t)},focus:function(t,i){var s=i.item.data("ui-selectmenu-item");null!=e.focusIndex&&s.index!==e.focusIndex&&(e._trigger("focus",t,{item:s}),e.isOpen||e._select(s,t)),e.focusIndex=s.index,e.button.attr("aria-activedescendant",e.menuItems.eq(s.index).attr("id"))}}).menu("instance"),this.menuInstance._off(this.menu,"mouseleave"),this.menuInstance._closeOnDocumentClick=function(){return!1},this.menuInstance._isDivider=function(){return!1}},refresh:function(){this._refreshMenu(),this.buttonItem.replaceWith(this.buttonItem=this._renderButtonItem(this._getSelectedItem().data("ui-selectmenu-item")||{})),null===this.options.width&&this._resizeButton()},_refreshMenu:function(){var t,e=this.element.find("option");this.menu.empty(),this._parseOptions(e),this._renderMenu(this.menu,this.items),this.menuInstance.refresh(),this.menuItems=this.menu.find("li").not(".ui-selectmenu-optgroup").find(".ui-menu-item-wrapper"),this._rendered=!0,e.length&&(t=this._getSelectedItem(),this.menuInstance.focus(null,t),this._setAria(t.data("ui-selectmenu-item")),this._setOption("disabled",this.element.prop("disabled")))},open:function(t){this.options.disabled||(this._rendered?(this._removeClass(this.menu.find(".ui-state-active"),null,"ui-state-active"),this.menuInstance.focus(null,this._getSelectedItem())):this._refreshMenu(),this.menuItems.length&&(this.isOpen=!0,this._toggleAttr(),this._resizeMenu(),this._position(),this._on(this.document,this._documentClick),this._trigger("open",t)))},_position:function(){this.menuWrap.position(t.extend({of:this.button},this.options.position))},close:function(t){this.isOpen&&(this.isOpen=!1,this._toggleAttr(),this.range=null,this._off(this.document),this._trigger("close",t))},widget:function(){return this.button},menuWidget:function(){return this.menu},_renderButtonItem:function(e){var i=t("<span>");return this._setText(i,e.label),this._addClass(i,"ui-selectmenu-text"),i},_renderMenu:function(e,i){var s=this,n="";t.each(i,function(i,o){var a;o.optgroup!==n&&(a=t("<li>",{text:o.optgroup}),s._addClass(a,"ui-selectmenu-optgroup","ui-menu-divider"+(o.element.parent("optgroup").prop("disabled")?" ui-state-disabled":"")),a.appendTo(e),n=o.optgroup),s._renderItemData(e,o)})},_renderItemData:function(t,e){return this._renderItem(t,e).data("ui-selectmenu-item",e)},_renderItem:function(e,i){var s=t("<li>"),n=t("<div>",{title:i.element.attr("title")});return i.disabled&&this._addClass(s,null,"ui-state-disabled"),this._setText(n,i.label),s.append(n).appendTo(e)},_setText:function(t,e){e?t.text(e):t.html("&#160;")},_move:function(t,e){var i,s,n=".ui-menu-item";this.isOpen?i=this.menuItems.eq(this.focusIndex).parent("li"):(i=this.menuItems.eq(this.element[0].selectedIndex).parent("li"),n+=":not(.ui-state-disabled)"),s="first"===t||"last"===t?i["first"===t?"prevAll":"nextAll"](n).eq(-1):i[t+"All"](n).eq(0),s.length&&this.menuInstance.focus(e,s)},_getSelectedItem:function(){return this.menuItems.eq(this.element[0].selectedIndex).parent("li")},_toggle:function(t){this[this.isOpen?"close":"open"](t)},_setSelection:function(){var t;this.range&&(window.getSelection?(t=window.getSelection(),t.removeAllRanges(),t.addRange(this.range)):this.range.select(),this.button.focus())},_documentClick:{mousedown:function(e){this.isOpen&&(t(e.target).closest(".ui-selectmenu-menu, #"+t.ui.escapeSelector(this.ids.button)).length||this.close(e))}},_buttonEvents:{mousedown:function(){var t;window.getSelection?(t=window.getSelection(),t.rangeCount&&(this.range=t.getRangeAt(0))):this.range=document.selection.createRange()},click:function(t){this._setSelection(),this._toggle(t)},keydown:function(e){var i=!0;switch(e.keyCode){case t.ui.keyCode.TAB:case t.ui.keyCode.ESCAPE:this.close(e),i=!1;break;case t.ui.keyCode.ENTER:this.isOpen&&this._selectFocusedItem(e);break;case t.ui.keyCode.UP:e.altKey?this._toggle(e):this._move("prev",e);break;case t.ui.keyCode.DOWN:e.altKey?this._toggle(e):this._move("next",e);break;case t.ui.keyCode.SPACE:this.isOpen?this._selectFocusedItem(e):this._toggle(e);break;case t.ui.keyCode.LEFT:this._move("prev",e);break;case t.ui.keyCode.RIGHT:this._move("next",e);break;case t.ui.keyCode.HOME:case t.ui.keyCode.PAGE_UP:this._move("first",e);break;case t.ui.keyCode.END:case t.ui.keyCode.PAGE_DOWN:this._move("last",e);break;default:this.menu.trigger(e),i=!1}i&&e.preventDefault()}},_selectFocusedItem:function(t){var e=this.menuItems.eq(this.focusIndex).parent("li");e.hasClass("ui-state-disabled")||this._select(e.data("ui-selectmenu-item"),t)},_select:function(t,e){var i=this.element[0].selectedIndex;this.element[0].selectedIndex=t.index,this.buttonItem.replaceWith(this.buttonItem=this._renderButtonItem(t)),this._setAria(t),this._trigger("select",e,{item:t}),t.index!==i&&this._trigger("change",e,{item:t}),this.close(e)},_setAria:function(t){var e=this.menuItems.eq(t.index).attr("id");this.button.attr({"aria-labelledby":e,"aria-activedescendant":e}),this.menu.attr("aria-activedescendant",e)},_setOption:function(t,e){if("icons"===t){var i=this.button.find("span.ui-icon");this._removeClass(i,null,this.options.icons.button)._addClass(i,null,e.button)}this._super(t,e),"appendTo"===t&&this.menuWrap.appendTo(this._appendTo()),"width"===t&&this._resizeButton()},_setOptionDisabled:function(t){this._super(t),this.menuInstance.option("disabled",t),this.button.attr("aria-disabled",t),this._toggleClass(this.button,null,"ui-state-disabled",t),this.element.prop("disabled",t),t?(this.button.attr("tabindex",-1),this.close()):this.button.attr("tabindex",0)},_appendTo:function(){var e=this.options.appendTo;return e&&(e=e.jquery||e.nodeType?t(e):this.document.find(e).eq(0)),e&&e[0]||(e=this.element.closest(".ui-front, dialog")),e.length||(e=this.document[0].body),e},_toggleAttr:function(){this.button.attr("aria-expanded",this.isOpen),this._removeClass(this.button,"ui-selectmenu-button-"+(this.isOpen?"closed":"open"))._addClass(this.button,"ui-selectmenu-button-"+(this.isOpen?"open":"closed"))._toggleClass(this.menuWrap,"ui-selectmenu-open",null,this.isOpen),this.menu.attr("aria-hidden",!this.isOpen)},_resizeButton:function(){var t=this.options.width;return t===!1?(this.button.css("width",""),void 0):(null===t&&(t=this.element.show().outerWidth(),this.element.hide()),this.button.outerWidth(t),void 0)},_resizeMenu:function(){this.menu.outerWidth(Math.max(this.button.outerWidth(),this.menu.width("").outerWidth()+1))},_getCreateOptions:function(){var t=this._super();return t.disabled=this.element.prop("disabled"),t},_parseOptions:function(e){var i=this,s=[];e.each(function(e,n){s.push(i._parseOption(t(n),e))}),this.items=s},_parseOption:function(t,e){var i=t.parent("optgroup");return{element:t,index:e,value:t.val(),label:t.text(),optgroup:i.attr("label")||"",disabled:i.prop("disabled")||t.prop("disabled")}},_destroy:function(){this._unbindFormResetHandler(),this.menuWrap.remove(),this.button.remove(),this.element.show(),this.element.removeUniqueId(),this.labels.attr("for",this.ids.element)}}]),t.widget("ui.slider",t.ui.mouse,{version:"1.12.1",widgetEventPrefix:"slide",options:{animate:!1,classes:{"ui-slider":"ui-corner-all","ui-slider-handle":"ui-corner-all","ui-slider-range":"ui-corner-all ui-widget-header"},distance:0,max:100,min:0,orientation:"horizontal",range:!1,step:1,value:0,values:null,change:null,slide:null,start:null,stop:null},numPages:5,_create:function(){this._keySliding=!1,this._mouseSliding=!1,this._animateOff=!0,this._handleIndex=null,this._detectOrientation(),this._mouseInit(),this._calculateNewMax(),this._addClass("ui-slider ui-slider-"+this.orientation,"ui-widget ui-widget-content"),this._refresh(),this._animateOff=!1
},_refresh:function(){this._createRange(),this._createHandles(),this._setupEvents(),this._refreshValue()},_createHandles:function(){var e,i,s=this.options,n=this.element.find(".ui-slider-handle"),o="<span tabindex='0'></span>",a=[];for(i=s.values&&s.values.length||1,n.length>i&&(n.slice(i).remove(),n=n.slice(0,i)),e=n.length;i>e;e++)a.push(o);this.handles=n.add(t(a.join("")).appendTo(this.element)),this._addClass(this.handles,"ui-slider-handle","ui-state-default"),this.handle=this.handles.eq(0),this.handles.each(function(e){t(this).data("ui-slider-handle-index",e).attr("tabIndex",0)})},_createRange:function(){var e=this.options;e.range?(e.range===!0&&(e.values?e.values.length&&2!==e.values.length?e.values=[e.values[0],e.values[0]]:t.isArray(e.values)&&(e.values=e.values.slice(0)):e.values=[this._valueMin(),this._valueMin()]),this.range&&this.range.length?(this._removeClass(this.range,"ui-slider-range-min ui-slider-range-max"),this.range.css({left:"",bottom:""})):(this.range=t("<div>").appendTo(this.element),this._addClass(this.range,"ui-slider-range")),("min"===e.range||"max"===e.range)&&this._addClass(this.range,"ui-slider-range-"+e.range)):(this.range&&this.range.remove(),this.range=null)},_setupEvents:function(){this._off(this.handles),this._on(this.handles,this._handleEvents),this._hoverable(this.handles),this._focusable(this.handles)},_destroy:function(){this.handles.remove(),this.range&&this.range.remove(),this._mouseDestroy()},_mouseCapture:function(e){var i,s,n,o,a,r,h,l,c=this,u=this.options;return u.disabled?!1:(this.elementSize={width:this.element.outerWidth(),height:this.element.outerHeight()},this.elementOffset=this.element.offset(),i={x:e.pageX,y:e.pageY},s=this._normValueFromMouse(i),n=this._valueMax()-this._valueMin()+1,this.handles.each(function(e){var i=Math.abs(s-c.values(e));(n>i||n===i&&(e===c._lastChangedValue||c.values(e)===u.min))&&(n=i,o=t(this),a=e)}),r=this._start(e,a),r===!1?!1:(this._mouseSliding=!0,this._handleIndex=a,this._addClass(o,null,"ui-state-active"),o.trigger("focus"),h=o.offset(),l=!t(e.target).parents().addBack().is(".ui-slider-handle"),this._clickOffset=l?{left:0,top:0}:{left:e.pageX-h.left-o.width()/2,top:e.pageY-h.top-o.height()/2-(parseInt(o.css("borderTopWidth"),10)||0)-(parseInt(o.css("borderBottomWidth"),10)||0)+(parseInt(o.css("marginTop"),10)||0)},this.handles.hasClass("ui-state-hover")||this._slide(e,a,s),this._animateOff=!0,!0))},_mouseStart:function(){return!0},_mouseDrag:function(t){var e={x:t.pageX,y:t.pageY},i=this._normValueFromMouse(e);return this._slide(t,this._handleIndex,i),!1},_mouseStop:function(t){return this._removeClass(this.handles,null,"ui-state-active"),this._mouseSliding=!1,this._stop(t,this._handleIndex),this._change(t,this._handleIndex),this._handleIndex=null,this._clickOffset=null,this._animateOff=!1,!1},_detectOrientation:function(){this.orientation="vertical"===this.options.orientation?"vertical":"horizontal"},_normValueFromMouse:function(t){var e,i,s,n,o;return"horizontal"===this.orientation?(e=this.elementSize.width,i=t.x-this.elementOffset.left-(this._clickOffset?this._clickOffset.left:0)):(e=this.elementSize.height,i=t.y-this.elementOffset.top-(this._clickOffset?this._clickOffset.top:0)),s=i/e,s>1&&(s=1),0>s&&(s=0),"vertical"===this.orientation&&(s=1-s),n=this._valueMax()-this._valueMin(),o=this._valueMin()+s*n,this._trimAlignValue(o)},_uiHash:function(t,e,i){var s={handle:this.handles[t],handleIndex:t,value:void 0!==e?e:this.value()};return this._hasMultipleValues()&&(s.value=void 0!==e?e:this.values(t),s.values=i||this.values()),s},_hasMultipleValues:function(){return this.options.values&&this.options.values.length},_start:function(t,e){return this._trigger("start",t,this._uiHash(e))},_slide:function(t,e,i){var s,n,o=this.value(),a=this.values();this._hasMultipleValues()&&(n=this.values(e?0:1),o=this.values(e),2===this.options.values.length&&this.options.range===!0&&(i=0===e?Math.min(n,i):Math.max(n,i)),a[e]=i),i!==o&&(s=this._trigger("slide",t,this._uiHash(e,i,a)),s!==!1&&(this._hasMultipleValues()?this.values(e,i):this.value(i)))},_stop:function(t,e){this._trigger("stop",t,this._uiHash(e))},_change:function(t,e){this._keySliding||this._mouseSliding||(this._lastChangedValue=e,this._trigger("change",t,this._uiHash(e)))},value:function(t){return arguments.length?(this.options.value=this._trimAlignValue(t),this._refreshValue(),this._change(null,0),void 0):this._value()},values:function(e,i){var s,n,o;if(arguments.length>1)return this.options.values[e]=this._trimAlignValue(i),this._refreshValue(),this._change(null,e),void 0;if(!arguments.length)return this._values();if(!t.isArray(arguments[0]))return this._hasMultipleValues()?this._values(e):this.value();for(s=this.options.values,n=arguments[0],o=0;s.length>o;o+=1)s[o]=this._trimAlignValue(n[o]),this._change(null,o);this._refreshValue()},_setOption:function(e,i){var s,n=0;switch("range"===e&&this.options.range===!0&&("min"===i?(this.options.value=this._values(0),this.options.values=null):"max"===i&&(this.options.value=this._values(this.options.values.length-1),this.options.values=null)),t.isArray(this.options.values)&&(n=this.options.values.length),this._super(e,i),e){case"orientation":this._detectOrientation(),this._removeClass("ui-slider-horizontal ui-slider-vertical")._addClass("ui-slider-"+this.orientation),this._refreshValue(),this.options.range&&this._refreshRange(i),this.handles.css("horizontal"===i?"bottom":"left","");break;case"value":this._animateOff=!0,this._refreshValue(),this._change(null,0),this._animateOff=!1;break;case"values":for(this._animateOff=!0,this._refreshValue(),s=n-1;s>=0;s--)this._change(null,s);this._animateOff=!1;break;case"step":case"min":case"max":this._animateOff=!0,this._calculateNewMax(),this._refreshValue(),this._animateOff=!1;break;case"range":this._animateOff=!0,this._refresh(),this._animateOff=!1}},_setOptionDisabled:function(t){this._super(t),this._toggleClass(null,"ui-state-disabled",!!t)},_value:function(){var t=this.options.value;return t=this._trimAlignValue(t)},_values:function(t){var e,i,s;if(arguments.length)return e=this.options.values[t],e=this._trimAlignValue(e);if(this._hasMultipleValues()){for(i=this.options.values.slice(),s=0;i.length>s;s+=1)i[s]=this._trimAlignValue(i[s]);return i}return[]},_trimAlignValue:function(t){if(this._valueMin()>=t)return this._valueMin();if(t>=this._valueMax())return this._valueMax();var e=this.options.step>0?this.options.step:1,i=(t-this._valueMin())%e,s=t-i;return 2*Math.abs(i)>=e&&(s+=i>0?e:-e),parseFloat(s.toFixed(5))},_calculateNewMax:function(){var t=this.options.max,e=this._valueMin(),i=this.options.step,s=Math.round((t-e)/i)*i;t=s+e,t>this.options.max&&(t-=i),this.max=parseFloat(t.toFixed(this._precision()))},_precision:function(){var t=this._precisionOf(this.options.step);return null!==this.options.min&&(t=Math.max(t,this._precisionOf(this.options.min))),t},_precisionOf:function(t){var e=""+t,i=e.indexOf(".");return-1===i?0:e.length-i-1},_valueMin:function(){return this.options.min},_valueMax:function(){return this.max},_refreshRange:function(t){"vertical"===t&&this.range.css({width:"",left:""}),"horizontal"===t&&this.range.css({height:"",bottom:""})},_refreshValue:function(){var e,i,s,n,o,a=this.options.range,r=this.options,h=this,l=this._animateOff?!1:r.animate,c={};this._hasMultipleValues()?this.handles.each(function(s){i=100*((h.values(s)-h._valueMin())/(h._valueMax()-h._valueMin())),c["horizontal"===h.orientation?"left":"bottom"]=i+"%",t(this).stop(1,1)[l?"animate":"css"](c,r.animate),h.options.range===!0&&("horizontal"===h.orientation?(0===s&&h.range.stop(1,1)[l?"animate":"css"]({left:i+"%"},r.animate),1===s&&h.range[l?"animate":"css"]({width:i-e+"%"},{queue:!1,duration:r.animate})):(0===s&&h.range.stop(1,1)[l?"animate":"css"]({bottom:i+"%"},r.animate),1===s&&h.range[l?"animate":"css"]({height:i-e+"%"},{queue:!1,duration:r.animate}))),e=i}):(s=this.value(),n=this._valueMin(),o=this._valueMax(),i=o!==n?100*((s-n)/(o-n)):0,c["horizontal"===this.orientation?"left":"bottom"]=i+"%",this.handle.stop(1,1)[l?"animate":"css"](c,r.animate),"min"===a&&"horizontal"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({width:i+"%"},r.animate),"max"===a&&"horizontal"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({width:100-i+"%"},r.animate),"min"===a&&"vertical"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({height:i+"%"},r.animate),"max"===a&&"vertical"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({height:100-i+"%"},r.animate))},_handleEvents:{keydown:function(e){var i,s,n,o,a=t(e.target).data("ui-slider-handle-index");switch(e.keyCode){case t.ui.keyCode.HOME:case t.ui.keyCode.END:case t.ui.keyCode.PAGE_UP:case t.ui.keyCode.PAGE_DOWN:case t.ui.keyCode.UP:case t.ui.keyCode.RIGHT:case t.ui.keyCode.DOWN:case t.ui.keyCode.LEFT:if(e.preventDefault(),!this._keySliding&&(this._keySliding=!0,this._addClass(t(e.target),null,"ui-state-active"),i=this._start(e,a),i===!1))return}switch(o=this.options.step,s=n=this._hasMultipleValues()?this.values(a):this.value(),e.keyCode){case t.ui.keyCode.HOME:n=this._valueMin();break;case t.ui.keyCode.END:n=this._valueMax();break;case t.ui.keyCode.PAGE_UP:n=this._trimAlignValue(s+(this._valueMax()-this._valueMin())/this.numPages);break;case t.ui.keyCode.PAGE_DOWN:n=this._trimAlignValue(s-(this._valueMax()-this._valueMin())/this.numPages);break;case t.ui.keyCode.UP:case t.ui.keyCode.RIGHT:if(s===this._valueMax())return;n=this._trimAlignValue(s+o);break;case t.ui.keyCode.DOWN:case t.ui.keyCode.LEFT:if(s===this._valueMin())return;n=this._trimAlignValue(s-o)}this._slide(e,a,n)},keyup:function(e){var i=t(e.target).data("ui-slider-handle-index");this._keySliding&&(this._keySliding=!1,this._stop(e,i),this._change(e,i),this._removeClass(t(e.target),null,"ui-state-active"))}}}),t.widget("ui.sortable",t.ui.mouse,{version:"1.12.1",widgetEventPrefix:"sort",ready:!1,options:{appendTo:"parent",axis:!1,connectWith:!1,containment:!1,cursor:"auto",cursorAt:!1,dropOnEmpty:!0,forcePlaceholderSize:!1,forceHelperSize:!1,grid:!1,handle:!1,helper:"original",items:"> *",opacity:!1,placeholder:!1,revert:!1,scroll:!0,scrollSensitivity:20,scrollSpeed:20,scope:"default",tolerance:"intersect",zIndex:1e3,activate:null,beforeStop:null,change:null,deactivate:null,out:null,over:null,receive:null,remove:null,sort:null,start:null,stop:null,update:null},_isOverAxis:function(t,e,i){return t>=e&&e+i>t},_isFloating:function(t){return/left|right/.test(t.css("float"))||/inline|table-cell/.test(t.css("display"))},_create:function(){this.containerCache={},this._addClass("ui-sortable"),this.refresh(),this.offset=this.element.offset(),this._mouseInit(),this._setHandleClassName(),this.ready=!0},_setOption:function(t,e){this._super(t,e),"handle"===t&&this._setHandleClassName()},_setHandleClassName:function(){var e=this;this._removeClass(this.element.find(".ui-sortable-handle"),"ui-sortable-handle"),t.each(this.items,function(){e._addClass(this.instance.options.handle?this.item.find(this.instance.options.handle):this.item,"ui-sortable-handle")})},_destroy:function(){this._mouseDestroy();for(var t=this.items.length-1;t>=0;t--)this.items[t].item.removeData(this.widgetName+"-item");return this},_mouseCapture:function(e,i){var s=null,n=!1,o=this;return this.reverting?!1:this.options.disabled||"static"===this.options.type?!1:(this._refreshItems(e),t(e.target).parents().each(function(){return t.data(this,o.widgetName+"-item")===o?(s=t(this),!1):void 0}),t.data(e.target,o.widgetName+"-item")===o&&(s=t(e.target)),s?!this.options.handle||i||(t(this.options.handle,s).find("*").addBack().each(function(){this===e.target&&(n=!0)}),n)?(this.currentItem=s,this._removeCurrentsFromItems(),!0):!1:!1)},_mouseStart:function(e,i,s){var n,o,a=this.options;if(this.currentContainer=this,this.refreshPositions(),this.helper=this._createHelper(e),this._cacheHelperProportions(),this._cacheMargins(),this.scrollParent=this.helper.scrollParent(),this.offset=this.currentItem.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},t.extend(this.offset,{click:{left:e.pageX-this.offset.left,top:e.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.helper.css("position","absolute"),this.cssPosition=this.helper.css("position"),this.originalPosition=this._generatePosition(e),this.originalPageX=e.pageX,this.originalPageY=e.pageY,a.cursorAt&&this._adjustOffsetFromHelper(a.cursorAt),this.domPosition={prev:this.currentItem.prev()[0],parent:this.currentItem.parent()[0]},this.helper[0]!==this.currentItem[0]&&this.currentItem.hide(),this._createPlaceholder(),a.containment&&this._setContainment(),a.cursor&&"auto"!==a.cursor&&(o=this.document.find("body"),this.storedCursor=o.css("cursor"),o.css("cursor",a.cursor),this.storedStylesheet=t("<style>*{ cursor: "+a.cursor+" !important; }</style>").appendTo(o)),a.opacity&&(this.helper.css("opacity")&&(this._storedOpacity=this.helper.css("opacity")),this.helper.css("opacity",a.opacity)),a.zIndex&&(this.helper.css("zIndex")&&(this._storedZIndex=this.helper.css("zIndex")),this.helper.css("zIndex",a.zIndex)),this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName&&(this.overflowOffset=this.scrollParent.offset()),this._trigger("start",e,this._uiHash()),this._preserveHelperProportions||this._cacheHelperProportions(),!s)for(n=this.containers.length-1;n>=0;n--)this.containers[n]._trigger("activate",e,this._uiHash(this));return t.ui.ddmanager&&(t.ui.ddmanager.current=this),t.ui.ddmanager&&!a.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e),this.dragging=!0,this._addClass(this.helper,"ui-sortable-helper"),this._mouseDrag(e),!0},_mouseDrag:function(e){var i,s,n,o,a=this.options,r=!1;for(this.position=this._generatePosition(e),this.positionAbs=this._convertPositionTo("absolute"),this.lastPositionAbs||(this.lastPositionAbs=this.positionAbs),this.options.scroll&&(this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName?(this.overflowOffset.top+this.scrollParent[0].offsetHeight-e.pageY<a.scrollSensitivity?this.scrollParent[0].scrollTop=r=this.scrollParent[0].scrollTop+a.scrollSpeed:e.pageY-this.overflowOffset.top<a.scrollSensitivity&&(this.scrollParent[0].scrollTop=r=this.scrollParent[0].scrollTop-a.scrollSpeed),this.overflowOffset.left+this.scrollParent[0].offsetWidth-e.pageX<a.scrollSensitivity?this.scrollParent[0].scrollLeft=r=this.scrollParent[0].scrollLeft+a.scrollSpeed:e.pageX-this.overflowOffset.left<a.scrollSensitivity&&(this.scrollParent[0].scrollLeft=r=this.scrollParent[0].scrollLeft-a.scrollSpeed)):(e.pageY-this.document.scrollTop()<a.scrollSensitivity?r=this.document.scrollTop(this.document.scrollTop()-a.scrollSpeed):this.window.height()-(e.pageY-this.document.scrollTop())<a.scrollSensitivity&&(r=this.document.scrollTop(this.document.scrollTop()+a.scrollSpeed)),e.pageX-this.document.scrollLeft()<a.scrollSensitivity?r=this.document.scrollLeft(this.document.scrollLeft()-a.scrollSpeed):this.window.width()-(e.pageX-this.document.scrollLeft())<a.scrollSensitivity&&(r=this.document.scrollLeft(this.document.scrollLeft()+a.scrollSpeed))),r!==!1&&t.ui.ddmanager&&!a.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e)),this.positionAbs=this._convertPositionTo("absolute"),this.options.axis&&"y"===this.options.axis||(this.helper[0].style.left=this.position.left+"px"),this.options.axis&&"x"===this.options.axis||(this.helper[0].style.top=this.position.top+"px"),i=this.items.length-1;i>=0;i--)if(s=this.items[i],n=s.item[0],o=this._intersectsWithPointer(s),o&&s.instance===this.currentContainer&&n!==this.currentItem[0]&&this.placeholder[1===o?"next":"prev"]()[0]!==n&&!t.contains(this.placeholder[0],n)&&("semi-dynamic"===this.options.type?!t.contains(this.element[0],n):!0)){if(this.direction=1===o?"down":"up","pointer"!==this.options.tolerance&&!this._intersectsWithSides(s))break;this._rearrange(e,s),this._trigger("change",e,this._uiHash());break}return this._contactContainers(e),t.ui.ddmanager&&t.ui.ddmanager.drag(this,e),this._trigger("sort",e,this._uiHash()),this.lastPositionAbs=this.positionAbs,!1},_mouseStop:function(e,i){if(e){if(t.ui.ddmanager&&!this.options.dropBehaviour&&t.ui.ddmanager.drop(this,e),this.options.revert){var s=this,n=this.placeholder.offset(),o=this.options.axis,a={};o&&"x"!==o||(a.left=n.left-this.offset.parent.left-this.margins.left+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollLeft)),o&&"y"!==o||(a.top=n.top-this.offset.parent.top-this.margins.top+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollTop)),this.reverting=!0,t(this.helper).animate(a,parseInt(this.options.revert,10)||500,function(){s._clear(e)})}else this._clear(e,i);return!1}},cancel:function(){if(this.dragging){this._mouseUp(new t.Event("mouseup",{target:null})),"original"===this.options.helper?(this.currentItem.css(this._storedCSS),this._removeClass(this.currentItem,"ui-sortable-helper")):this.currentItem.show();for(var e=this.containers.length-1;e>=0;e--)this.containers[e]._trigger("deactivate",null,this._uiHash(this)),this.containers[e].containerCache.over&&(this.containers[e]._trigger("out",null,this._uiHash(this)),this.containers[e].containerCache.over=0)}return this.placeholder&&(this.placeholder[0].parentNode&&this.placeholder[0].parentNode.removeChild(this.placeholder[0]),"original"!==this.options.helper&&this.helper&&this.helper[0].parentNode&&this.helper.remove(),t.extend(this,{helper:null,dragging:!1,reverting:!1,_noFinalSort:null}),this.domPosition.prev?t(this.domPosition.prev).after(this.currentItem):t(this.domPosition.parent).prepend(this.currentItem)),this},serialize:function(e){var i=this._getItemsAsjQuery(e&&e.connected),s=[];return e=e||{},t(i).each(function(){var i=(t(e.item||this).attr(e.attribute||"id")||"").match(e.expression||/(.+)[\-=_](.+)/);i&&s.push((e.key||i[1]+"[]")+"="+(e.key&&e.expression?i[1]:i[2]))}),!s.length&&e.key&&s.push(e.key+"="),s.join("&")},toArray:function(e){var i=this._getItemsAsjQuery(e&&e.connected),s=[];return e=e||{},i.each(function(){s.push(t(e.item||this).attr(e.attribute||"id")||"")}),s},_intersectsWith:function(t){var e=this.positionAbs.left,i=e+this.helperProportions.width,s=this.positionAbs.top,n=s+this.helperProportions.height,o=t.left,a=o+t.width,r=t.top,h=r+t.height,l=this.offset.click.top,c=this.offset.click.left,u="x"===this.options.axis||s+l>r&&h>s+l,d="y"===this.options.axis||e+c>o&&a>e+c,p=u&&d;return"pointer"===this.options.tolerance||this.options.forcePointerForContainers||"pointer"!==this.options.tolerance&&this.helperProportions[this.floating?"width":"height"]>t[this.floating?"width":"height"]?p:e+this.helperProportions.width/2>o&&a>i-this.helperProportions.width/2&&s+this.helperProportions.height/2>r&&h>n-this.helperProportions.height/2},_intersectsWithPointer:function(t){var e,i,s="x"===this.options.axis||this._isOverAxis(this.positionAbs.top+this.offset.click.top,t.top,t.height),n="y"===this.options.axis||this._isOverAxis(this.positionAbs.left+this.offset.click.left,t.left,t.width),o=s&&n;return o?(e=this._getDragVerticalDirection(),i=this._getDragHorizontalDirection(),this.floating?"right"===i||"down"===e?2:1:e&&("down"===e?2:1)):!1},_intersectsWithSides:function(t){var e=this._isOverAxis(this.positionAbs.top+this.offset.click.top,t.top+t.height/2,t.height),i=this._isOverAxis(this.positionAbs.left+this.offset.click.left,t.left+t.width/2,t.width),s=this._getDragVerticalDirection(),n=this._getDragHorizontalDirection();return this.floating&&n?"right"===n&&i||"left"===n&&!i:s&&("down"===s&&e||"up"===s&&!e)},_getDragVerticalDirection:function(){var t=this.positionAbs.top-this.lastPositionAbs.top;return 0!==t&&(t>0?"down":"up")},_getDragHorizontalDirection:function(){var t=this.positionAbs.left-this.lastPositionAbs.left;return 0!==t&&(t>0?"right":"left")},refresh:function(t){return this._refreshItems(t),this._setHandleClassName(),this.refreshPositions(),this},_connectWith:function(){var t=this.options;return t.connectWith.constructor===String?[t.connectWith]:t.connectWith},_getItemsAsjQuery:function(e){function i(){r.push(this)}var s,n,o,a,r=[],h=[],l=this._connectWith();if(l&&e)for(s=l.length-1;s>=0;s--)for(o=t(l[s],this.document[0]),n=o.length-1;n>=0;n--)a=t.data(o[n],this.widgetFullName),a&&a!==this&&!a.options.disabled&&h.push([t.isFunction(a.options.items)?a.options.items.call(a.element):t(a.options.items,a.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),a]);for(h.push([t.isFunction(this.options.items)?this.options.items.call(this.element,null,{options:this.options,item:this.currentItem}):t(this.options.items,this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),this]),s=h.length-1;s>=0;s--)h[s][0].each(i);return t(r)},_removeCurrentsFromItems:function(){var e=this.currentItem.find(":data("+this.widgetName+"-item)");this.items=t.grep(this.items,function(t){for(var i=0;e.length>i;i++)if(e[i]===t.item[0])return!1;return!0})},_refreshItems:function(e){this.items=[],this.containers=[this];var i,s,n,o,a,r,h,l,c=this.items,u=[[t.isFunction(this.options.items)?this.options.items.call(this.element[0],e,{item:this.currentItem}):t(this.options.items,this.element),this]],d=this._connectWith();if(d&&this.ready)for(i=d.length-1;i>=0;i--)for(n=t(d[i],this.document[0]),s=n.length-1;s>=0;s--)o=t.data(n[s],this.widgetFullName),o&&o!==this&&!o.options.disabled&&(u.push([t.isFunction(o.options.items)?o.options.items.call(o.element[0],e,{item:this.currentItem}):t(o.options.items,o.element),o]),this.containers.push(o));for(i=u.length-1;i>=0;i--)for(a=u[i][1],r=u[i][0],s=0,l=r.length;l>s;s++)h=t(r[s]),h.data(this.widgetName+"-item",a),c.push({item:h,instance:a,width:0,height:0,left:0,top:0})},refreshPositions:function(e){this.floating=this.items.length?"x"===this.options.axis||this._isFloating(this.items[0].item):!1,this.offsetParent&&this.helper&&(this.offset.parent=this._getParentOffset());var i,s,n,o;for(i=this.items.length-1;i>=0;i--)s=this.items[i],s.instance!==this.currentContainer&&this.currentContainer&&s.item[0]!==this.currentItem[0]||(n=this.options.toleranceElement?t(this.options.toleranceElement,s.item):s.item,e||(s.width=n.outerWidth(),s.height=n.outerHeight()),o=n.offset(),s.left=o.left,s.top=o.top);if(this.options.custom&&this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this);else for(i=this.containers.length-1;i>=0;i--)o=this.containers[i].element.offset(),this.containers[i].containerCache.left=o.left,this.containers[i].containerCache.top=o.top,this.containers[i].containerCache.width=this.containers[i].element.outerWidth(),this.containers[i].containerCache.height=this.containers[i].element.outerHeight();return this},_createPlaceholder:function(e){e=e||this;var i,s=e.options;s.placeholder&&s.placeholder.constructor!==String||(i=s.placeholder,s.placeholder={element:function(){var s=e.currentItem[0].nodeName.toLowerCase(),n=t("<"+s+">",e.document[0]);return e._addClass(n,"ui-sortable-placeholder",i||e.currentItem[0].className)._removeClass(n,"ui-sortable-helper"),"tbody"===s?e._createTrPlaceholder(e.currentItem.find("tr").eq(0),t("<tr>",e.document[0]).appendTo(n)):"tr"===s?e._createTrPlaceholder(e.currentItem,n):"img"===s&&n.attr("src",e.currentItem.attr("src")),i||n.css("visibility","hidden"),n},update:function(t,n){(!i||s.forcePlaceholderSize)&&(n.height()||n.height(e.currentItem.innerHeight()-parseInt(e.currentItem.css("paddingTop")||0,10)-parseInt(e.currentItem.css("paddingBottom")||0,10)),n.width()||n.width(e.currentItem.innerWidth()-parseInt(e.currentItem.css("paddingLeft")||0,10)-parseInt(e.currentItem.css("paddingRight")||0,10)))}}),e.placeholder=t(s.placeholder.element.call(e.element,e.currentItem)),e.currentItem.after(e.placeholder),s.placeholder.update(e,e.placeholder)},_createTrPlaceholder:function(e,i){var s=this;e.children().each(function(){t("<td>&#160;</td>",s.document[0]).attr("colspan",t(this).attr("colspan")||1).appendTo(i)})},_contactContainers:function(e){var i,s,n,o,a,r,h,l,c,u,d=null,p=null;for(i=this.containers.length-1;i>=0;i--)if(!t.contains(this.currentItem[0],this.containers[i].element[0]))if(this._intersectsWith(this.containers[i].containerCache)){if(d&&t.contains(this.containers[i].element[0],d.element[0]))continue;d=this.containers[i],p=i}else this.containers[i].containerCache.over&&(this.containers[i]._trigger("out",e,this._uiHash(this)),this.containers[i].containerCache.over=0);if(d)if(1===this.containers.length)this.containers[p].containerCache.over||(this.containers[p]._trigger("over",e,this._uiHash(this)),this.containers[p].containerCache.over=1);else{for(n=1e4,o=null,c=d.floating||this._isFloating(this.currentItem),a=c?"left":"top",r=c?"width":"height",u=c?"pageX":"pageY",s=this.items.length-1;s>=0;s--)t.contains(this.containers[p].element[0],this.items[s].item[0])&&this.items[s].item[0]!==this.currentItem[0]&&(h=this.items[s].item.offset()[a],l=!1,e[u]-h>this.items[s][r]/2&&(l=!0),n>Math.abs(e[u]-h)&&(n=Math.abs(e[u]-h),o=this.items[s],this.direction=l?"up":"down"));if(!o&&!this.options.dropOnEmpty)return;if(this.currentContainer===this.containers[p])return this.currentContainer.containerCache.over||(this.containers[p]._trigger("over",e,this._uiHash()),this.currentContainer.containerCache.over=1),void 0;o?this._rearrange(e,o,null,!0):this._rearrange(e,null,this.containers[p].element,!0),this._trigger("change",e,this._uiHash()),this.containers[p]._trigger("change",e,this._uiHash(this)),this.currentContainer=this.containers[p],this.options.placeholder.update(this.currentContainer,this.placeholder),this.containers[p]._trigger("over",e,this._uiHash(this)),this.containers[p].containerCache.over=1}},_createHelper:function(e){var i=this.options,s=t.isFunction(i.helper)?t(i.helper.apply(this.element[0],[e,this.currentItem])):"clone"===i.helper?this.currentItem.clone():this.currentItem;return s.parents("body").length||t("parent"!==i.appendTo?i.appendTo:this.currentItem[0].parentNode)[0].appendChild(s[0]),s[0]===this.currentItem[0]&&(this._storedCSS={width:this.currentItem[0].style.width,height:this.currentItem[0].style.height,position:this.currentItem.css("position"),top:this.currentItem.css("top"),left:this.currentItem.css("left")}),(!s[0].style.width||i.forceHelperSize)&&s.width(this.currentItem.width()),(!s[0].style.height||i.forceHelperSize)&&s.height(this.currentItem.height()),s},_adjustOffsetFromHelper:function(e){"string"==typeof e&&(e=e.split(" ")),t.isArray(e)&&(e={left:+e[0],top:+e[1]||0}),"left"in e&&(this.offset.click.left=e.left+this.margins.left),"right"in e&&(this.offset.click.left=this.helperProportions.width-e.right+this.margins.left),"top"in e&&(this.offset.click.top=e.top+this.margins.top),"bottom"in e&&(this.offset.click.top=this.helperProportions.height-e.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var e=this.offsetParent.offset();return"absolute"===this.cssPosition&&this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])&&(e.left+=this.scrollParent.scrollLeft(),e.top+=this.scrollParent.scrollTop()),(this.offsetParent[0]===this.document[0].body||this.offsetParent[0].tagName&&"html"===this.offsetParent[0].tagName.toLowerCase()&&t.ui.ie)&&(e={top:0,left:0}),{top:e.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:e.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"===this.cssPosition){var t=this.currentItem.position();return{top:t.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:t.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.currentItem.css("marginLeft"),10)||0,top:parseInt(this.currentItem.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var e,i,s,n=this.options;"parent"===n.containment&&(n.containment=this.helper[0].parentNode),("document"===n.containment||"window"===n.containment)&&(this.containment=[0-this.offset.relative.left-this.offset.parent.left,0-this.offset.relative.top-this.offset.parent.top,"document"===n.containment?this.document.width():this.window.width()-this.helperProportions.width-this.margins.left,("document"===n.containment?this.document.height()||document.body.parentNode.scrollHeight:this.window.height()||this.document[0].body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]),/^(document|window|parent)$/.test(n.containment)||(e=t(n.containment)[0],i=t(n.containment).offset(),s="hidden"!==t(e).css("overflow"),this.containment=[i.left+(parseInt(t(e).css("borderLeftWidth"),10)||0)+(parseInt(t(e).css("paddingLeft"),10)||0)-this.margins.left,i.top+(parseInt(t(e).css("borderTopWidth"),10)||0)+(parseInt(t(e).css("paddingTop"),10)||0)-this.margins.top,i.left+(s?Math.max(e.scrollWidth,e.offsetWidth):e.offsetWidth)-(parseInt(t(e).css("borderLeftWidth"),10)||0)-(parseInt(t(e).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,i.top+(s?Math.max(e.scrollHeight,e.offsetHeight):e.offsetHeight)-(parseInt(t(e).css("borderTopWidth"),10)||0)-(parseInt(t(e).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top])},_convertPositionTo:function(e,i){i||(i=this.position);var s="absolute"===e?1:-1,n="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,o=/(html|body)/i.test(n[0].tagName);return{top:i.top+this.offset.relative.top*s+this.offset.parent.top*s-("fixed"===this.cssPosition?-this.scrollParent.scrollTop():o?0:n.scrollTop())*s,left:i.left+this.offset.relative.left*s+this.offset.parent.left*s-("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():o?0:n.scrollLeft())*s}},_generatePosition:function(e){var i,s,n=this.options,o=e.pageX,a=e.pageY,r="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,h=/(html|body)/i.test(r[0].tagName);return"relative"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&this.scrollParent[0]!==this.offsetParent[0]||(this.offset.relative=this._getRelativeOffset()),this.originalPosition&&(this.containment&&(e.pageX-this.offset.click.left<this.containment[0]&&(o=this.containment[0]+this.offset.click.left),e.pageY-this.offset.click.top<this.containment[1]&&(a=this.containment[1]+this.offset.click.top),e.pageX-this.offset.click.left>this.containment[2]&&(o=this.containment[2]+this.offset.click.left),e.pageY-this.offset.click.top>this.containment[3]&&(a=this.containment[3]+this.offset.click.top)),n.grid&&(i=this.originalPageY+Math.round((a-this.originalPageY)/n.grid[1])*n.grid[1],a=this.containment?i-this.offset.click.top>=this.containment[1]&&i-this.offset.click.top<=this.containment[3]?i:i-this.offset.click.top>=this.containment[1]?i-n.grid[1]:i+n.grid[1]:i,s=this.originalPageX+Math.round((o-this.originalPageX)/n.grid[0])*n.grid[0],o=this.containment?s-this.offset.click.left>=this.containment[0]&&s-this.offset.click.left<=this.containment[2]?s:s-this.offset.click.left>=this.containment[0]?s-n.grid[0]:s+n.grid[0]:s)),{top:a-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.scrollParent.scrollTop():h?0:r.scrollTop()),left:o-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():h?0:r.scrollLeft())}},_rearrange:function(t,e,i,s){i?i[0].appendChild(this.placeholder[0]):e.item[0].parentNode.insertBefore(this.placeholder[0],"down"===this.direction?e.item[0]:e.item[0].nextSibling),this.counter=this.counter?++this.counter:1;var n=this.counter;
this._delay(function(){n===this.counter&&this.refreshPositions(!s)})},_clear:function(t,e){function i(t,e,i){return function(s){i._trigger(t,s,e._uiHash(e))}}this.reverting=!1;var s,n=[];if(!this._noFinalSort&&this.currentItem.parent().length&&this.placeholder.before(this.currentItem),this._noFinalSort=null,this.helper[0]===this.currentItem[0]){for(s in this._storedCSS)("auto"===this._storedCSS[s]||"static"===this._storedCSS[s])&&(this._storedCSS[s]="");this.currentItem.css(this._storedCSS),this._removeClass(this.currentItem,"ui-sortable-helper")}else this.currentItem.show();for(this.fromOutside&&!e&&n.push(function(t){this._trigger("receive",t,this._uiHash(this.fromOutside))}),!this.fromOutside&&this.domPosition.prev===this.currentItem.prev().not(".ui-sortable-helper")[0]&&this.domPosition.parent===this.currentItem.parent()[0]||e||n.push(function(t){this._trigger("update",t,this._uiHash())}),this!==this.currentContainer&&(e||(n.push(function(t){this._trigger("remove",t,this._uiHash())}),n.push(function(t){return function(e){t._trigger("receive",e,this._uiHash(this))}}.call(this,this.currentContainer)),n.push(function(t){return function(e){t._trigger("update",e,this._uiHash(this))}}.call(this,this.currentContainer)))),s=this.containers.length-1;s>=0;s--)e||n.push(i("deactivate",this,this.containers[s])),this.containers[s].containerCache.over&&(n.push(i("out",this,this.containers[s])),this.containers[s].containerCache.over=0);if(this.storedCursor&&(this.document.find("body").css("cursor",this.storedCursor),this.storedStylesheet.remove()),this._storedOpacity&&this.helper.css("opacity",this._storedOpacity),this._storedZIndex&&this.helper.css("zIndex","auto"===this._storedZIndex?"":this._storedZIndex),this.dragging=!1,e||this._trigger("beforeStop",t,this._uiHash()),this.placeholder[0].parentNode.removeChild(this.placeholder[0]),this.cancelHelperRemoval||(this.helper[0]!==this.currentItem[0]&&this.helper.remove(),this.helper=null),!e){for(s=0;n.length>s;s++)n[s].call(this,t);this._trigger("stop",t,this._uiHash())}return this.fromOutside=!1,!this.cancelHelperRemoval},_trigger:function(){t.Widget.prototype._trigger.apply(this,arguments)===!1&&this.cancel()},_uiHash:function(e){var i=e||this;return{helper:i.helper,placeholder:i.placeholder||t([]),position:i.position,originalPosition:i.originalPosition,offset:i.positionAbs,item:i.currentItem,sender:e?e.element:null}}}),t.widget("ui.spinner",{version:"1.12.1",defaultElement:"<input>",widgetEventPrefix:"spin",options:{classes:{"ui-spinner":"ui-corner-all","ui-spinner-down":"ui-corner-br","ui-spinner-up":"ui-corner-tr"},culture:null,icons:{down:"ui-icon-triangle-1-s",up:"ui-icon-triangle-1-n"},incremental:!0,max:null,min:null,numberFormat:null,page:10,step:1,change:null,spin:null,start:null,stop:null},_create:function(){this._setOption("max",this.options.max),this._setOption("min",this.options.min),this._setOption("step",this.options.step),""!==this.value()&&this._value(this.element.val(),!0),this._draw(),this._on(this._events),this._refresh(),this._on(this.window,{beforeunload:function(){this.element.removeAttr("autocomplete")}})},_getCreateOptions:function(){var e=this._super(),i=this.element;return t.each(["min","max","step"],function(t,s){var n=i.attr(s);null!=n&&n.length&&(e[s]=n)}),e},_events:{keydown:function(t){this._start(t)&&this._keydown(t)&&t.preventDefault()},keyup:"_stop",focus:function(){this.previous=this.element.val()},blur:function(t){return this.cancelBlur?(delete this.cancelBlur,void 0):(this._stop(),this._refresh(),this.previous!==this.element.val()&&this._trigger("change",t),void 0)},mousewheel:function(t,e){if(e){if(!this.spinning&&!this._start(t))return!1;this._spin((e>0?1:-1)*this.options.step,t),clearTimeout(this.mousewheelTimer),this.mousewheelTimer=this._delay(function(){this.spinning&&this._stop(t)},100),t.preventDefault()}},"mousedown .ui-spinner-button":function(e){function i(){var e=this.element[0]===t.ui.safeActiveElement(this.document[0]);e||(this.element.trigger("focus"),this.previous=s,this._delay(function(){this.previous=s}))}var s;s=this.element[0]===t.ui.safeActiveElement(this.document[0])?this.previous:this.element.val(),e.preventDefault(),i.call(this),this.cancelBlur=!0,this._delay(function(){delete this.cancelBlur,i.call(this)}),this._start(e)!==!1&&this._repeat(null,t(e.currentTarget).hasClass("ui-spinner-up")?1:-1,e)},"mouseup .ui-spinner-button":"_stop","mouseenter .ui-spinner-button":function(e){return t(e.currentTarget).hasClass("ui-state-active")?this._start(e)===!1?!1:(this._repeat(null,t(e.currentTarget).hasClass("ui-spinner-up")?1:-1,e),void 0):void 0},"mouseleave .ui-spinner-button":"_stop"},_enhance:function(){this.uiSpinner=this.element.attr("autocomplete","off").wrap("<span>").parent().append("<a></a><a></a>")},_draw:function(){this._enhance(),this._addClass(this.uiSpinner,"ui-spinner","ui-widget ui-widget-content"),this._addClass("ui-spinner-input"),this.element.attr("role","spinbutton"),this.buttons=this.uiSpinner.children("a").attr("tabIndex",-1).attr("aria-hidden",!0).button({classes:{"ui-button":""}}),this._removeClass(this.buttons,"ui-corner-all"),this._addClass(this.buttons.first(),"ui-spinner-button ui-spinner-up"),this._addClass(this.buttons.last(),"ui-spinner-button ui-spinner-down"),this.buttons.first().button({icon:this.options.icons.up,showLabel:!1}),this.buttons.last().button({icon:this.options.icons.down,showLabel:!1}),this.buttons.height()>Math.ceil(.5*this.uiSpinner.height())&&this.uiSpinner.height()>0&&this.uiSpinner.height(this.uiSpinner.height())},_keydown:function(e){var i=this.options,s=t.ui.keyCode;switch(e.keyCode){case s.UP:return this._repeat(null,1,e),!0;case s.DOWN:return this._repeat(null,-1,e),!0;case s.PAGE_UP:return this._repeat(null,i.page,e),!0;case s.PAGE_DOWN:return this._repeat(null,-i.page,e),!0}return!1},_start:function(t){return this.spinning||this._trigger("start",t)!==!1?(this.counter||(this.counter=1),this.spinning=!0,!0):!1},_repeat:function(t,e,i){t=t||500,clearTimeout(this.timer),this.timer=this._delay(function(){this._repeat(40,e,i)},t),this._spin(e*this.options.step,i)},_spin:function(t,e){var i=this.value()||0;this.counter||(this.counter=1),i=this._adjustValue(i+t*this._increment(this.counter)),this.spinning&&this._trigger("spin",e,{value:i})===!1||(this._value(i),this.counter++)},_increment:function(e){var i=this.options.incremental;return i?t.isFunction(i)?i(e):Math.floor(e*e*e/5e4-e*e/500+17*e/200+1):1},_precision:function(){var t=this._precisionOf(this.options.step);return null!==this.options.min&&(t=Math.max(t,this._precisionOf(this.options.min))),t},_precisionOf:function(t){var e=""+t,i=e.indexOf(".");return-1===i?0:e.length-i-1},_adjustValue:function(t){var e,i,s=this.options;return e=null!==s.min?s.min:0,i=t-e,i=Math.round(i/s.step)*s.step,t=e+i,t=parseFloat(t.toFixed(this._precision())),null!==s.max&&t>s.max?s.max:null!==s.min&&s.min>t?s.min:t},_stop:function(t){this.spinning&&(clearTimeout(this.timer),clearTimeout(this.mousewheelTimer),this.counter=0,this.spinning=!1,this._trigger("stop",t))},_setOption:function(t,e){var i,s,n;return"culture"===t||"numberFormat"===t?(i=this._parse(this.element.val()),this.options[t]=e,this.element.val(this._format(i)),void 0):(("max"===t||"min"===t||"step"===t)&&"string"==typeof e&&(e=this._parse(e)),"icons"===t&&(s=this.buttons.first().find(".ui-icon"),this._removeClass(s,null,this.options.icons.up),this._addClass(s,null,e.up),n=this.buttons.last().find(".ui-icon"),this._removeClass(n,null,this.options.icons.down),this._addClass(n,null,e.down)),this._super(t,e),void 0)},_setOptionDisabled:function(t){this._super(t),this._toggleClass(this.uiSpinner,null,"ui-state-disabled",!!t),this.element.prop("disabled",!!t),this.buttons.button(t?"disable":"enable")},_setOptions:r(function(t){this._super(t)}),_parse:function(t){return"string"==typeof t&&""!==t&&(t=window.Globalize&&this.options.numberFormat?Globalize.parseFloat(t,10,this.options.culture):+t),""===t||isNaN(t)?null:t},_format:function(t){return""===t?"":window.Globalize&&this.options.numberFormat?Globalize.format(t,this.options.numberFormat,this.options.culture):t},_refresh:function(){this.element.attr({"aria-valuemin":this.options.min,"aria-valuemax":this.options.max,"aria-valuenow":this._parse(this.element.val())})},isValid:function(){var t=this.value();return null===t?!1:t===this._adjustValue(t)},_value:function(t,e){var i;""!==t&&(i=this._parse(t),null!==i&&(e||(i=this._adjustValue(i)),t=this._format(i))),this.element.val(t),this._refresh()},_destroy:function(){this.element.prop("disabled",!1).removeAttr("autocomplete role aria-valuemin aria-valuemax aria-valuenow"),this.uiSpinner.replaceWith(this.element)},stepUp:r(function(t){this._stepUp(t)}),_stepUp:function(t){this._start()&&(this._spin((t||1)*this.options.step),this._stop())},stepDown:r(function(t){this._stepDown(t)}),_stepDown:function(t){this._start()&&(this._spin((t||1)*-this.options.step),this._stop())},pageUp:r(function(t){this._stepUp((t||1)*this.options.page)}),pageDown:r(function(t){this._stepDown((t||1)*this.options.page)}),value:function(t){return arguments.length?(r(this._value).call(this,t),void 0):this._parse(this.element.val())},widget:function(){return this.uiSpinner}}),t.uiBackCompat!==!1&&t.widget("ui.spinner",t.ui.spinner,{_enhance:function(){this.uiSpinner=this.element.attr("autocomplete","off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml())},_uiSpinnerHtml:function(){return"<span>"},_buttonHtml:function(){return"<a></a><a></a>"}}),t.ui.spinner,t.widget("ui.tabs",{version:"1.12.1",delay:300,options:{active:null,classes:{"ui-tabs":"ui-corner-all","ui-tabs-nav":"ui-corner-all","ui-tabs-panel":"ui-corner-bottom","ui-tabs-tab":"ui-corner-top"},collapsible:!1,event:"click",heightStyle:"content",hide:null,show:null,activate:null,beforeActivate:null,beforeLoad:null,load:null},_isLocal:function(){var t=/#.*$/;return function(e){var i,s;i=e.href.replace(t,""),s=location.href.replace(t,"");try{i=decodeURIComponent(i)}catch(n){}try{s=decodeURIComponent(s)}catch(n){}return e.hash.length>1&&i===s}}(),_create:function(){var e=this,i=this.options;this.running=!1,this._addClass("ui-tabs","ui-widget ui-widget-content"),this._toggleClass("ui-tabs-collapsible",null,i.collapsible),this._processTabs(),i.active=this._initialActive(),t.isArray(i.disabled)&&(i.disabled=t.unique(i.disabled.concat(t.map(this.tabs.filter(".ui-state-disabled"),function(t){return e.tabs.index(t)}))).sort()),this.active=this.options.active!==!1&&this.anchors.length?this._findActive(i.active):t(),this._refresh(),this.active.length&&this.load(i.active)},_initialActive:function(){var e=this.options.active,i=this.options.collapsible,s=location.hash.substring(1);return null===e&&(s&&this.tabs.each(function(i,n){return t(n).attr("aria-controls")===s?(e=i,!1):void 0}),null===e&&(e=this.tabs.index(this.tabs.filter(".ui-tabs-active"))),(null===e||-1===e)&&(e=this.tabs.length?0:!1)),e!==!1&&(e=this.tabs.index(this.tabs.eq(e)),-1===e&&(e=i?!1:0)),!i&&e===!1&&this.anchors.length&&(e=0),e},_getCreateEventData:function(){return{tab:this.active,panel:this.active.length?this._getPanelForTab(this.active):t()}},_tabKeydown:function(e){var i=t(t.ui.safeActiveElement(this.document[0])).closest("li"),s=this.tabs.index(i),n=!0;if(!this._handlePageNav(e)){switch(e.keyCode){case t.ui.keyCode.RIGHT:case t.ui.keyCode.DOWN:s++;break;case t.ui.keyCode.UP:case t.ui.keyCode.LEFT:n=!1,s--;break;case t.ui.keyCode.END:s=this.anchors.length-1;break;case t.ui.keyCode.HOME:s=0;break;case t.ui.keyCode.SPACE:return e.preventDefault(),clearTimeout(this.activating),this._activate(s),void 0;case t.ui.keyCode.ENTER:return e.preventDefault(),clearTimeout(this.activating),this._activate(s===this.options.active?!1:s),void 0;default:return}e.preventDefault(),clearTimeout(this.activating),s=this._focusNextTab(s,n),e.ctrlKey||e.metaKey||(i.attr("aria-selected","false"),this.tabs.eq(s).attr("aria-selected","true"),this.activating=this._delay(function(){this.option("active",s)},this.delay))}},_panelKeydown:function(e){this._handlePageNav(e)||e.ctrlKey&&e.keyCode===t.ui.keyCode.UP&&(e.preventDefault(),this.active.trigger("focus"))},_handlePageNav:function(e){return e.altKey&&e.keyCode===t.ui.keyCode.PAGE_UP?(this._activate(this._focusNextTab(this.options.active-1,!1)),!0):e.altKey&&e.keyCode===t.ui.keyCode.PAGE_DOWN?(this._activate(this._focusNextTab(this.options.active+1,!0)),!0):void 0},_findNextTab:function(e,i){function s(){return e>n&&(e=0),0>e&&(e=n),e}for(var n=this.tabs.length-1;-1!==t.inArray(s(),this.options.disabled);)e=i?e+1:e-1;return e},_focusNextTab:function(t,e){return t=this._findNextTab(t,e),this.tabs.eq(t).trigger("focus"),t},_setOption:function(t,e){return"active"===t?(this._activate(e),void 0):(this._super(t,e),"collapsible"===t&&(this._toggleClass("ui-tabs-collapsible",null,e),e||this.options.active!==!1||this._activate(0)),"event"===t&&this._setupEvents(e),"heightStyle"===t&&this._setupHeightStyle(e),void 0)},_sanitizeSelector:function(t){return t?t.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g,"\\$&"):""},refresh:function(){var e=this.options,i=this.tablist.children(":has(a[href])");e.disabled=t.map(i.filter(".ui-state-disabled"),function(t){return i.index(t)}),this._processTabs(),e.active!==!1&&this.anchors.length?this.active.length&&!t.contains(this.tablist[0],this.active[0])?this.tabs.length===e.disabled.length?(e.active=!1,this.active=t()):this._activate(this._findNextTab(Math.max(0,e.active-1),!1)):e.active=this.tabs.index(this.active):(e.active=!1,this.active=t()),this._refresh()},_refresh:function(){this._setOptionDisabled(this.options.disabled),this._setupEvents(this.options.event),this._setupHeightStyle(this.options.heightStyle),this.tabs.not(this.active).attr({"aria-selected":"false","aria-expanded":"false",tabIndex:-1}),this.panels.not(this._getPanelForTab(this.active)).hide().attr({"aria-hidden":"true"}),this.active.length?(this.active.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0}),this._addClass(this.active,"ui-tabs-active","ui-state-active"),this._getPanelForTab(this.active).show().attr({"aria-hidden":"false"})):this.tabs.eq(0).attr("tabIndex",0)},_processTabs:function(){var e=this,i=this.tabs,s=this.anchors,n=this.panels;this.tablist=this._getList().attr("role","tablist"),this._addClass(this.tablist,"ui-tabs-nav","ui-helper-reset ui-helper-clearfix ui-widget-header"),this.tablist.on("mousedown"+this.eventNamespace,"> li",function(e){t(this).is(".ui-state-disabled")&&e.preventDefault()}).on("focus"+this.eventNamespace,".ui-tabs-anchor",function(){t(this).closest("li").is(".ui-state-disabled")&&this.blur()}),this.tabs=this.tablist.find("> li:has(a[href])").attr({role:"tab",tabIndex:-1}),this._addClass(this.tabs,"ui-tabs-tab","ui-state-default"),this.anchors=this.tabs.map(function(){return t("a",this)[0]}).attr({role:"presentation",tabIndex:-1}),this._addClass(this.anchors,"ui-tabs-anchor"),this.panels=t(),this.anchors.each(function(i,s){var n,o,a,r=t(s).uniqueId().attr("id"),h=t(s).closest("li"),l=h.attr("aria-controls");e._isLocal(s)?(n=s.hash,a=n.substring(1),o=e.element.find(e._sanitizeSelector(n))):(a=h.attr("aria-controls")||t({}).uniqueId()[0].id,n="#"+a,o=e.element.find(n),o.length||(o=e._createPanel(a),o.insertAfter(e.panels[i-1]||e.tablist)),o.attr("aria-live","polite")),o.length&&(e.panels=e.panels.add(o)),l&&h.data("ui-tabs-aria-controls",l),h.attr({"aria-controls":a,"aria-labelledby":r}),o.attr("aria-labelledby",r)}),this.panels.attr("role","tabpanel"),this._addClass(this.panels,"ui-tabs-panel","ui-widget-content"),i&&(this._off(i.not(this.tabs)),this._off(s.not(this.anchors)),this._off(n.not(this.panels)))},_getList:function(){return this.tablist||this.element.find("ol, ul").eq(0)},_createPanel:function(e){return t("<div>").attr("id",e).data("ui-tabs-destroy",!0)},_setOptionDisabled:function(e){var i,s,n;for(t.isArray(e)&&(e.length?e.length===this.anchors.length&&(e=!0):e=!1),n=0;s=this.tabs[n];n++)i=t(s),e===!0||-1!==t.inArray(n,e)?(i.attr("aria-disabled","true"),this._addClass(i,null,"ui-state-disabled")):(i.removeAttr("aria-disabled"),this._removeClass(i,null,"ui-state-disabled"));this.options.disabled=e,this._toggleClass(this.widget(),this.widgetFullName+"-disabled",null,e===!0)},_setupEvents:function(e){var i={};e&&t.each(e.split(" "),function(t,e){i[e]="_eventHandler"}),this._off(this.anchors.add(this.tabs).add(this.panels)),this._on(!0,this.anchors,{click:function(t){t.preventDefault()}}),this._on(this.anchors,i),this._on(this.tabs,{keydown:"_tabKeydown"}),this._on(this.panels,{keydown:"_panelKeydown"}),this._focusable(this.tabs),this._hoverable(this.tabs)},_setupHeightStyle:function(e){var i,s=this.element.parent();"fill"===e?(i=s.height(),i-=this.element.outerHeight()-this.element.height(),this.element.siblings(":visible").each(function(){var e=t(this),s=e.css("position");"absolute"!==s&&"fixed"!==s&&(i-=e.outerHeight(!0))}),this.element.children().not(this.panels).each(function(){i-=t(this).outerHeight(!0)}),this.panels.each(function(){t(this).height(Math.max(0,i-t(this).innerHeight()+t(this).height()))}).css("overflow","auto")):"auto"===e&&(i=0,this.panels.each(function(){i=Math.max(i,t(this).height("").height())}).height(i))},_eventHandler:function(e){var i=this.options,s=this.active,n=t(e.currentTarget),o=n.closest("li"),a=o[0]===s[0],r=a&&i.collapsible,h=r?t():this._getPanelForTab(o),l=s.length?this._getPanelForTab(s):t(),c={oldTab:s,oldPanel:l,newTab:r?t():o,newPanel:h};e.preventDefault(),o.hasClass("ui-state-disabled")||o.hasClass("ui-tabs-loading")||this.running||a&&!i.collapsible||this._trigger("beforeActivate",e,c)===!1||(i.active=r?!1:this.tabs.index(o),this.active=a?t():o,this.xhr&&this.xhr.abort(),l.length||h.length||t.error("jQuery UI Tabs: Mismatching fragment identifier."),h.length&&this.load(this.tabs.index(o),e),this._toggle(e,c))},_toggle:function(e,i){function s(){o.running=!1,o._trigger("activate",e,i)}function n(){o._addClass(i.newTab.closest("li"),"ui-tabs-active","ui-state-active"),a.length&&o.options.show?o._show(a,o.options.show,s):(a.show(),s())}var o=this,a=i.newPanel,r=i.oldPanel;this.running=!0,r.length&&this.options.hide?this._hide(r,this.options.hide,function(){o._removeClass(i.oldTab.closest("li"),"ui-tabs-active","ui-state-active"),n()}):(this._removeClass(i.oldTab.closest("li"),"ui-tabs-active","ui-state-active"),r.hide(),n()),r.attr("aria-hidden","true"),i.oldTab.attr({"aria-selected":"false","aria-expanded":"false"}),a.length&&r.length?i.oldTab.attr("tabIndex",-1):a.length&&this.tabs.filter(function(){return 0===t(this).attr("tabIndex")}).attr("tabIndex",-1),a.attr("aria-hidden","false"),i.newTab.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0})},_activate:function(e){var i,s=this._findActive(e);s[0]!==this.active[0]&&(s.length||(s=this.active),i=s.find(".ui-tabs-anchor")[0],this._eventHandler({target:i,currentTarget:i,preventDefault:t.noop}))},_findActive:function(e){return e===!1?t():this.tabs.eq(e)},_getIndex:function(e){return"string"==typeof e&&(e=this.anchors.index(this.anchors.filter("[href$='"+t.ui.escapeSelector(e)+"']"))),e},_destroy:function(){this.xhr&&this.xhr.abort(),this.tablist.removeAttr("role").off(this.eventNamespace),this.anchors.removeAttr("role tabIndex").removeUniqueId(),this.tabs.add(this.panels).each(function(){t.data(this,"ui-tabs-destroy")?t(this).remove():t(this).removeAttr("role tabIndex aria-live aria-busy aria-selected aria-labelledby aria-hidden aria-expanded")}),this.tabs.each(function(){var e=t(this),i=e.data("ui-tabs-aria-controls");i?e.attr("aria-controls",i).removeData("ui-tabs-aria-controls"):e.removeAttr("aria-controls")}),this.panels.show(),"content"!==this.options.heightStyle&&this.panels.css("height","")},enable:function(e){var i=this.options.disabled;i!==!1&&(void 0===e?i=!1:(e=this._getIndex(e),i=t.isArray(i)?t.map(i,function(t){return t!==e?t:null}):t.map(this.tabs,function(t,i){return i!==e?i:null})),this._setOptionDisabled(i))},disable:function(e){var i=this.options.disabled;if(i!==!0){if(void 0===e)i=!0;else{if(e=this._getIndex(e),-1!==t.inArray(e,i))return;i=t.isArray(i)?t.merge([e],i).sort():[e]}this._setOptionDisabled(i)}},load:function(e,i){e=this._getIndex(e);var s=this,n=this.tabs.eq(e),o=n.find(".ui-tabs-anchor"),a=this._getPanelForTab(n),r={tab:n,panel:a},h=function(t,e){"abort"===e&&s.panels.stop(!1,!0),s._removeClass(n,"ui-tabs-loading"),a.removeAttr("aria-busy"),t===s.xhr&&delete s.xhr};this._isLocal(o[0])||(this.xhr=t.ajax(this._ajaxSettings(o,i,r)),this.xhr&&"canceled"!==this.xhr.statusText&&(this._addClass(n,"ui-tabs-loading"),a.attr("aria-busy","true"),this.xhr.done(function(t,e,n){setTimeout(function(){a.html(t),s._trigger("load",i,r),h(n,e)},1)}).fail(function(t,e){setTimeout(function(){h(t,e)},1)})))},_ajaxSettings:function(e,i,s){var n=this;return{url:e.attr("href").replace(/#.*$/,""),beforeSend:function(e,o){return n._trigger("beforeLoad",i,t.extend({jqXHR:e,ajaxSettings:o},s))}}},_getPanelForTab:function(e){var i=t(e).attr("aria-controls");return this.element.find(this._sanitizeSelector("#"+i))}}),t.uiBackCompat!==!1&&t.widget("ui.tabs",t.ui.tabs,{_processTabs:function(){this._superApply(arguments),this._addClass(this.tabs,"ui-tab")}}),t.ui.tabs,t.widget("ui.tooltip",{version:"1.12.1",options:{classes:{"ui-tooltip":"ui-corner-all ui-widget-shadow"},content:function(){var e=t(this).attr("title")||"";return t("<a>").text(e).html()},hide:!0,items:"[title]:not([disabled])",position:{my:"left top+15",at:"left bottom",collision:"flipfit flip"},show:!0,track:!1,close:null,open:null},_addDescribedBy:function(e,i){var s=(e.attr("aria-describedby")||"").split(/\s+/);s.push(i),e.data("ui-tooltip-id",i).attr("aria-describedby",t.trim(s.join(" ")))},_removeDescribedBy:function(e){var i=e.data("ui-tooltip-id"),s=(e.attr("aria-describedby")||"").split(/\s+/),n=t.inArray(i,s);-1!==n&&s.splice(n,1),e.removeData("ui-tooltip-id"),s=t.trim(s.join(" ")),s?e.attr("aria-describedby",s):e.removeAttr("aria-describedby")},_create:function(){this._on({mouseover:"open",focusin:"open"}),this.tooltips={},this.parents={},this.liveRegion=t("<div>").attr({role:"log","aria-live":"assertive","aria-relevant":"additions"}).appendTo(this.document[0].body),this._addClass(this.liveRegion,null,"ui-helper-hidden-accessible"),this.disabledTitles=t([])},_setOption:function(e,i){var s=this;this._super(e,i),"content"===e&&t.each(this.tooltips,function(t,e){s._updateContent(e.element)})},_setOptionDisabled:function(t){this[t?"_disable":"_enable"]()},_disable:function(){var e=this;t.each(this.tooltips,function(i,s){var n=t.Event("blur");n.target=n.currentTarget=s.element[0],e.close(n,!0)}),this.disabledTitles=this.disabledTitles.add(this.element.find(this.options.items).addBack().filter(function(){var e=t(this);return e.is("[title]")?e.data("ui-tooltip-title",e.attr("title")).removeAttr("title"):void 0}))},_enable:function(){this.disabledTitles.each(function(){var e=t(this);e.data("ui-tooltip-title")&&e.attr("title",e.data("ui-tooltip-title"))}),this.disabledTitles=t([])},open:function(e){var i=this,s=t(e?e.target:this.element).closest(this.options.items);s.length&&!s.data("ui-tooltip-id")&&(s.attr("title")&&s.data("ui-tooltip-title",s.attr("title")),s.data("ui-tooltip-open",!0),e&&"mouseover"===e.type&&s.parents().each(function(){var e,s=t(this);s.data("ui-tooltip-open")&&(e=t.Event("blur"),e.target=e.currentTarget=this,i.close(e,!0)),s.attr("title")&&(s.uniqueId(),i.parents[this.id]={element:this,title:s.attr("title")},s.attr("title",""))}),this._registerCloseHandlers(e,s),this._updateContent(s,e))},_updateContent:function(t,e){var i,s=this.options.content,n=this,o=e?e.type:null;return"string"==typeof s||s.nodeType||s.jquery?this._open(e,t,s):(i=s.call(t[0],function(i){n._delay(function(){t.data("ui-tooltip-open")&&(e&&(e.type=o),this._open(e,t,i))})}),i&&this._open(e,t,i),void 0)},_open:function(e,i,s){function n(t){l.of=t,a.is(":hidden")||a.position(l)}var o,a,r,h,l=t.extend({},this.options.position);if(s){if(o=this._find(i))return o.tooltip.find(".ui-tooltip-content").html(s),void 0;i.is("[title]")&&(e&&"mouseover"===e.type?i.attr("title",""):i.removeAttr("title")),o=this._tooltip(i),a=o.tooltip,this._addDescribedBy(i,a.attr("id")),a.find(".ui-tooltip-content").html(s),this.liveRegion.children().hide(),h=t("<div>").html(a.find(".ui-tooltip-content").html()),h.removeAttr("name").find("[name]").removeAttr("name"),h.removeAttr("id").find("[id]").removeAttr("id"),h.appendTo(this.liveRegion),this.options.track&&e&&/^mouse/.test(e.type)?(this._on(this.document,{mousemove:n}),n(e)):a.position(t.extend({of:i},this.options.position)),a.hide(),this._show(a,this.options.show),this.options.track&&this.options.show&&this.options.show.delay&&(r=this.delayedShow=setInterval(function(){a.is(":visible")&&(n(l.of),clearInterval(r))},t.fx.interval)),this._trigger("open",e,{tooltip:a})}},_registerCloseHandlers:function(e,i){var s={keyup:function(e){if(e.keyCode===t.ui.keyCode.ESCAPE){var s=t.Event(e);s.currentTarget=i[0],this.close(s,!0)}}};i[0]!==this.element[0]&&(s.remove=function(){this._removeTooltip(this._find(i).tooltip)}),e&&"mouseover"!==e.type||(s.mouseleave="close"),e&&"focusin"!==e.type||(s.focusout="close"),this._on(!0,i,s)},close:function(e){var i,s=this,n=t(e?e.currentTarget:this.element),o=this._find(n);return o?(i=o.tooltip,o.closing||(clearInterval(this.delayedShow),n.data("ui-tooltip-title")&&!n.attr("title")&&n.attr("title",n.data("ui-tooltip-title")),this._removeDescribedBy(n),o.hiding=!0,i.stop(!0),this._hide(i,this.options.hide,function(){s._removeTooltip(t(this))}),n.removeData("ui-tooltip-open"),this._off(n,"mouseleave focusout keyup"),n[0]!==this.element[0]&&this._off(n,"remove"),this._off(this.document,"mousemove"),e&&"mouseleave"===e.type&&t.each(this.parents,function(e,i){t(i.element).attr("title",i.title),delete s.parents[e]}),o.closing=!0,this._trigger("close",e,{tooltip:i}),o.hiding||(o.closing=!1)),void 0):(n.removeData("ui-tooltip-open"),void 0)},_tooltip:function(e){var i=t("<div>").attr("role","tooltip"),s=t("<div>").appendTo(i),n=i.uniqueId().attr("id");return this._addClass(s,"ui-tooltip-content"),this._addClass(i,"ui-tooltip","ui-widget ui-widget-content"),i.appendTo(this._appendTo(e)),this.tooltips[n]={element:e,tooltip:i}},_find:function(t){var e=t.data("ui-tooltip-id");return e?this.tooltips[e]:null},_removeTooltip:function(t){t.remove(),delete this.tooltips[t.attr("id")]},_appendTo:function(t){var e=t.closest(".ui-front, dialog");return e.length||(e=this.document[0].body),e},_destroy:function(){var e=this;t.each(this.tooltips,function(i,s){var n=t.Event("blur"),o=s.element;n.target=n.currentTarget=o[0],e.close(n,!0),t("#"+i).remove(),o.data("ui-tooltip-title")&&(o.attr("title")||o.attr("title",o.data("ui-tooltip-title")),o.removeData("ui-tooltip-title"))}),this.liveRegion.remove()}}),t.uiBackCompat!==!1&&t.widget("ui.tooltip",t.ui.tooltip,{options:{tooltipClass:null},_tooltip:function(){var t=this._superApply(arguments);return this.options.tooltipClass&&t.tooltip.addClass(this.options.tooltipClass),t}}),t.ui.tooltip});
// Spectrum Colorpicker v1.8.0
// https://github.com/bgrins/spectrum
// Author: Brian Grinstead
// License: MIT

(function (factory) {
    "use strict";

    if (typeof define === 'function' && define.amd) { // AMD
        define(['jquery'], factory);
    }
    else if (typeof exports == "object" && typeof module == "object") { // CommonJS
        module.exports = factory(require('jquery'));
    }
    else { // Browser
        factory(jQuery);
    }
})(function($, undefined) {
    "use strict";

    var defaultOpts = {

        // Callbacks
        beforeShow: noop,
        move: noop,
        change: noop,
        show: noop,
        hide: noop,

        // Options
        color: false,
        flat: false,
        showInput: false,
        allowEmpty: false,
        showButtons: true,
        clickoutFiresChange: true,
        showInitial: false,
        showPalette: false,
        showPaletteOnly: false,
        hideAfterPaletteSelect: false,
        togglePaletteOnly: false,
        showSelectionPalette: true,
        localStorageKey: false,
        appendTo: "body",
        maxSelectionSize: 7,
        cancelText: "cancel",
        chooseText: "choose",
        togglePaletteMoreText: "more",
        togglePaletteLessText: "less",
        clearText: "Clear Color Selection",
        noColorSelectedText: "No Color Selected",
        preferredFormat: false,
        className: "", // Deprecated - use containerClassName and replacerClassName instead.
        containerClassName: "",
        replacerClassName: "",
        showAlpha: false,
        theme: "sp-light",
        palette: [["#ffffff", "#000000", "#ff0000", "#ff8000", "#ffff00", "#008000", "#0000ff", "#4b0082", "#9400d3"]],
        selectionPalette: [],
        disabled: false,
        offset: null
    },
    spectrums = [],
    IE = !!/msie/i.exec( window.navigator.userAgent ),
    rgbaSupport = (function() {
        function contains( str, substr ) {
            return !!~('' + str).indexOf(substr);
        }

        var elem = document.createElement('div');
        var style = elem.style;
        style.cssText = 'background-color:rgba(0,0,0,.5)';
        return contains(style.backgroundColor, 'rgba') || contains(style.backgroundColor, 'hsla');
    })(),
    replaceInput = [
        "<div class='sp-replacer'>",
            "<div class='sp-preview'><div class='sp-preview-inner'></div></div>",
            "<div class='sp-dd'>&#9660;</div>",
        "</div>"
    ].join(''),
    markup = (function () {

        // IE does not support gradients with multiple stops, so we need to simulate
        //  that for the rainbow slider with 8 divs that each have a single gradient
        var gradientFix = "";
        if (IE) {
            for (var i = 1; i <= 6; i++) {
                gradientFix += "<div class='sp-" + i + "'></div>";
            }
        }

        return [
            "<div class='sp-container sp-hidden'>",
                "<div class='sp-palette-container'>",
                    "<div class='sp-palette sp-thumb sp-cf'></div>",
                    "<div class='sp-palette-button-container sp-cf'>",
                        "<button type='button' class='sp-palette-toggle'></button>",
                    "</div>",
                "</div>",
                "<div class='sp-picker-container'>",
                    "<div class='sp-top sp-cf'>",
                        "<div class='sp-fill'></div>",
                        "<div class='sp-top-inner'>",
                            "<div class='sp-color'>",
                                "<div class='sp-sat'>",
                                    "<div class='sp-val'>",
                                        "<div class='sp-dragger'></div>",
                                    "</div>",
                                "</div>",
                            "</div>",
                            "<div class='sp-clear sp-clear-display'>",
                            "</div>",
                            "<div class='sp-hue'>",
                                "<div class='sp-slider'></div>",
                                gradientFix,
                            "</div>",
                        "</div>",
                        "<div class='sp-alpha'><div class='sp-alpha-inner'><div class='sp-alpha-handle'></div></div></div>",
                    "</div>",
                    "<div class='sp-input-container sp-cf'>",
                        "<input class='sp-input' type='text' spellcheck='false'  />",
                    "</div>",
                    "<div class='sp-initial sp-thumb sp-cf'></div>",
                    "<div class='sp-button-container sp-cf'>",
                        "<a class='sp-cancel' href='#'></a>",
                        "<button type='button' class='sp-choose'></button>",
                    "</div>",
                "</div>",
            "</div>"
        ].join("");
    })();

    function paletteTemplate (p, color, className, opts) {
        var html = [];
        for (var i = 0; i < p.length; i++) {
            var current = p[i];
            if(current) {
                var tiny = tinycolor(current);
                var c = tiny.toHsl().l < 0.5 ? "sp-thumb-el sp-thumb-dark" : "sp-thumb-el sp-thumb-light";
                c += (tinycolor.equals(color, current)) ? " sp-thumb-active" : "";
                var formattedString = tiny.toString(opts.preferredFormat || "rgb");
                var swatchStyle = rgbaSupport ? ("background-color:" + tiny.toRgbString()) : "filter:" + tiny.toFilter();
                html.push('<span title="' + formattedString + '" data-color="' + tiny.toRgbString() + '" class="' + c + '"><span class="sp-thumb-inner" style="' + swatchStyle + ';" /></span>');
            } else {
                var cls = 'sp-clear-display';
                html.push($('<div />')
                    .append($('<span data-color="" style="background-color:transparent;" class="' + cls + '"></span>')
                        .attr('title', opts.noColorSelectedText)
                    )
                    .html()
                );
            }
        }
        return "<div class='sp-cf " + className + "'>" + html.join('') + "</div>";
    }

    function hideAll() {
        for (var i = 0; i < spectrums.length; i++) {
            if (spectrums[i]) {
                spectrums[i].hide();
            }
        }
    }

    function instanceOptions(o, callbackContext) {
        var opts = $.extend({}, defaultOpts, o);
        opts.callbacks = {
            'move': bind(opts.move, callbackContext),
            'change': bind(opts.change, callbackContext),
            'show': bind(opts.show, callbackContext),
            'hide': bind(opts.hide, callbackContext),
            'beforeShow': bind(opts.beforeShow, callbackContext)
        };

        return opts;
    }

    function spectrum(element, o) {

        var opts = instanceOptions(o, element),
            flat = opts.flat,
            showSelectionPalette = opts.showSelectionPalette,
            localStorageKey = opts.localStorageKey,
            theme = opts.theme,
            callbacks = opts.callbacks,
            resize = throttle(reflow, 10),
            visible = false,
            isDragging = false,
            dragWidth = 0,
            dragHeight = 0,
            dragHelperHeight = 0,
            slideHeight = 0,
            slideWidth = 0,
            alphaWidth = 0,
            alphaSlideHelperWidth = 0,
            slideHelperHeight = 0,
            currentHue = 0,
            currentSaturation = 0,
            currentValue = 0,
            currentAlpha = 1,
            palette = [],
            paletteArray = [],
            paletteLookup = {},
            selectionPalette = opts.selectionPalette.slice(0),
            maxSelectionSize = opts.maxSelectionSize,
            draggingClass = "sp-dragging",
            shiftMovementDirection = null;

        var doc = element.ownerDocument,
            body = doc.body,
            boundElement = $(element),
            disabled = false,
            container = $(markup, doc).addClass(theme),
            pickerContainer = container.find(".sp-picker-container"),
            dragger = container.find(".sp-color"),
            dragHelper = container.find(".sp-dragger"),
            slider = container.find(".sp-hue"),
            slideHelper = container.find(".sp-slider"),
            alphaSliderInner = container.find(".sp-alpha-inner"),
            alphaSlider = container.find(".sp-alpha"),
            alphaSlideHelper = container.find(".sp-alpha-handle"),
            textInput = container.find(".sp-input"),
            paletteContainer = container.find(".sp-palette"),
            initialColorContainer = container.find(".sp-initial"),
            cancelButton = container.find(".sp-cancel"),
            clearButton = container.find(".sp-clear"),
            chooseButton = container.find(".sp-choose"),
            toggleButton = container.find(".sp-palette-toggle"),
            isInput = boundElement.is("input"),
            isInputTypeColor = isInput && boundElement.attr("type") === "color" && inputTypeColorSupport(),
            shouldReplace = isInput && !flat,
            replacer = (shouldReplace) ? $(replaceInput).addClass(theme).addClass(opts.className).addClass(opts.replacerClassName) : $([]),
            offsetElement = (shouldReplace) ? replacer : boundElement,
            previewElement = replacer.find(".sp-preview-inner"),
            initialColor = opts.color || (isInput && boundElement.val()),
            colorOnShow = false,
            currentPreferredFormat = opts.preferredFormat,
            clickoutFiresChange = !opts.showButtons || opts.clickoutFiresChange,
            isEmpty = !initialColor,
            allowEmpty = opts.allowEmpty && !isInputTypeColor;

        function applyOptions() {

            if (opts.showPaletteOnly) {
                opts.showPalette = true;
            }

            toggleButton.text(opts.showPaletteOnly ? opts.togglePaletteMoreText : opts.togglePaletteLessText);

            if (opts.palette) {
                palette = opts.palette.slice(0);
                paletteArray = $.isArray(palette[0]) ? palette : [palette];
                paletteLookup = {};
                for (var i = 0; i < paletteArray.length; i++) {
                    for (var j = 0; j < paletteArray[i].length; j++) {
                        var rgb = tinycolor(paletteArray[i][j]).toRgbString();
                        paletteLookup[rgb] = true;
                    }
                }
            }

            container.toggleClass("sp-flat", flat);
            container.toggleClass("sp-input-disabled", !opts.showInput);
            container.toggleClass("sp-alpha-enabled", opts.showAlpha);
            container.toggleClass("sp-clear-enabled", allowEmpty);
            container.toggleClass("sp-buttons-disabled", !opts.showButtons);
            container.toggleClass("sp-palette-buttons-disabled", !opts.togglePaletteOnly);
            container.toggleClass("sp-palette-disabled", !opts.showPalette);
            container.toggleClass("sp-palette-only", opts.showPaletteOnly);
            container.toggleClass("sp-initial-disabled", !opts.showInitial);
            container.addClass(opts.className).addClass(opts.containerClassName);

            reflow();
        }

        function initialize() {

            if (IE) {
                container.find("*:not(input)").attr("unselectable", "on");
            }

            applyOptions();

            if (shouldReplace) {
                boundElement.after(replacer).hide();
            }

            if (!allowEmpty) {
                clearButton.hide();
            }

            if (flat) {
                boundElement.after(container).hide();
            }
            else {

                var appendTo = opts.appendTo === "parent" ? boundElement.parent() : $(opts.appendTo);
                if (appendTo.length !== 1) {
                    appendTo = $("body");
                }

                appendTo.append(container);
            }

            updateSelectionPaletteFromStorage();

            offsetElement.bind("click.spectrum touchstart.spectrum", function (e) {
                if (!disabled) {
                    toggle();
                }

                e.stopPropagation();

                if (!$(e.target).is("input")) {
                    e.preventDefault();
                }
            });

            if(boundElement.is(":disabled") || (opts.disabled === true)) {
                disable();
            }

            // Prevent clicks from bubbling up to document.  This would cause it to be hidden.
            container.click(stopPropagation);

            // Handle user typed input
            textInput.change(setFromTextInput);
            textInput.bind("paste", function () {
                setTimeout(setFromTextInput, 1);
            });
            textInput.keydown(function (e) { if (e.keyCode == 13) { setFromTextInput(); } });

            cancelButton.text(opts.cancelText);
            cancelButton.bind("click.spectrum", function (e) {
                e.stopPropagation();
                e.preventDefault();
                revert();
                hide();
            });

            clearButton.attr("title", opts.clearText);
            clearButton.bind("click.spectrum", function (e) {
                e.stopPropagation();
                e.preventDefault();
                isEmpty = true;
                move();

                if(flat) {
                    //for the flat style, this is a change event
                    updateOriginalInput(true);
                }
            });

            chooseButton.text(opts.chooseText);
            chooseButton.bind("click.spectrum", function (e) {
                e.stopPropagation();
                e.preventDefault();

                if (IE && textInput.is(":focus")) {
                    textInput.trigger('change');
                }

                if (isValid()) {
                    updateOriginalInput(true);
                    hide();
                }
            });

            toggleButton.text(opts.showPaletteOnly ? opts.togglePaletteMoreText : opts.togglePaletteLessText);
            toggleButton.bind("click.spectrum", function (e) {
                e.stopPropagation();
                e.preventDefault();

                opts.showPaletteOnly = !opts.showPaletteOnly;

                // To make sure the Picker area is drawn on the right, next to the
                // Palette area (and not below the palette), first move the Palette
                // to the left to make space for the picker, plus 5px extra.
                // The 'applyOptions' function puts the whole container back into place
                // and takes care of the button-text and the sp-palette-only CSS class.
                if (!opts.showPaletteOnly && !flat) {
                    container.css('left', '-=' + (pickerContainer.outerWidth(true) + 5));
                }
                applyOptions();
            });

            draggable(alphaSlider, function (dragX, dragY, e) {
                currentAlpha = (dragX / alphaWidth);
                isEmpty = false;
                if (e.shiftKey) {
                    currentAlpha = Math.round(currentAlpha * 10) / 10;
                }

                move();
            }, dragStart, dragStop);

            draggable(slider, function (dragX, dragY) {
                currentHue = parseFloat(dragY / slideHeight);
                isEmpty = false;
                if (!opts.showAlpha) {
                    currentAlpha = 1;
                }
                move();
            }, dragStart, dragStop);

            draggable(dragger, function (dragX, dragY, e) {

                // shift+drag should snap the movement to either the x or y axis.
                if (!e.shiftKey) {
                    shiftMovementDirection = null;
                }
                else if (!shiftMovementDirection) {
                    var oldDragX = currentSaturation * dragWidth;
                    var oldDragY = dragHeight - (currentValue * dragHeight);
                    var furtherFromX = Math.abs(dragX - oldDragX) > Math.abs(dragY - oldDragY);

                    shiftMovementDirection = furtherFromX ? "x" : "y";
                }

                var setSaturation = !shiftMovementDirection || shiftMovementDirection === "x";
                var setValue = !shiftMovementDirection || shiftMovementDirection === "y";

                if (setSaturation) {
                    currentSaturation = parseFloat(dragX / dragWidth);
                }
                if (setValue) {
                    currentValue = parseFloat((dragHeight - dragY) / dragHeight);
                }

                isEmpty = false;
                if (!opts.showAlpha) {
                    currentAlpha = 1;
                }

                move();

            }, dragStart, dragStop);

            if (!!initialColor) {
                set(initialColor);

                // In case color was black - update the preview UI and set the format
                // since the set function will not run (default color is black).
                updateUI();
                currentPreferredFormat = opts.preferredFormat || tinycolor(initialColor).format;

                addColorToSelectionPalette(initialColor);
            }
            else {
                updateUI();
            }

            if (flat) {
                show();
            }

            function paletteElementClick(e) {
                if (e.data && e.data.ignore) {
                    set($(e.target).closest(".sp-thumb-el").data("color"));
                    move();
                }
                else {
                    set($(e.target).closest(".sp-thumb-el").data("color"));
                    move();
                    updateOriginalInput(true);
                    if (opts.hideAfterPaletteSelect) {
                      hide();
                    }
                }

                return false;
            }

            var paletteEvent = IE ? "mousedown.spectrum" : "click.spectrum touchstart.spectrum";
            paletteContainer.delegate(".sp-thumb-el", paletteEvent, paletteElementClick);
            initialColorContainer.delegate(".sp-thumb-el:nth-child(1)", paletteEvent, { ignore: true }, paletteElementClick);
        }

        function updateSelectionPaletteFromStorage() {

            if (localStorageKey && window.localStorage) {

                // Migrate old palettes over to new format.  May want to remove this eventually.
                try {
                    var oldPalette = window.localStorage[localStorageKey].split(",#");
                    if (oldPalette.length > 1) {
                        delete window.localStorage[localStorageKey];
                        $.each(oldPalette, function(i, c) {
                             addColorToSelectionPalette(c);
                        });
                    }
                }
                catch(e) { }

                try {
                    selectionPalette = window.localStorage[localStorageKey].split(";");
                }
                catch (e) { }
            }
        }

        function addColorToSelectionPalette(color) {
            if (showSelectionPalette) {
                var rgb = tinycolor(color).toRgbString();
                if (!paletteLookup[rgb] && $.inArray(rgb, selectionPalette) === -1) {
                    selectionPalette.push(rgb);
                    while(selectionPalette.length > maxSelectionSize) {
                        selectionPalette.shift();
                    }
                }

                if (localStorageKey && window.localStorage) {
                    try {
                        window.localStorage[localStorageKey] = selectionPalette.join(";");
                    }
                    catch(e) { }
                }
            }
        }

        function getUniqueSelectionPalette() {
            var unique = [];
            if (opts.showPalette) {
                for (var i = 0; i < selectionPalette.length; i++) {
                    var rgb = tinycolor(selectionPalette[i]).toRgbString();

                    if (!paletteLookup[rgb]) {
                        unique.push(selectionPalette[i]);
                    }
                }
            }

            return unique.reverse().slice(0, opts.maxSelectionSize);
        }

        function drawPalette() {

            var currentColor = get();

            var html = $.map(paletteArray, function (palette, i) {
                return paletteTemplate(palette, currentColor, "sp-palette-row sp-palette-row-" + i, opts);
            });

            updateSelectionPaletteFromStorage();

            if (selectionPalette) {
                html.push(paletteTemplate(getUniqueSelectionPalette(), currentColor, "sp-palette-row sp-palette-row-selection", opts));
            }

            paletteContainer.html(html.join(""));
        }

        function drawInitial() {
            if (opts.showInitial) {
                var initial = colorOnShow;
                var current = get();
                initialColorContainer.html(paletteTemplate([initial, current], current, "sp-palette-row-initial", opts));
            }
        }

        function dragStart() {
            if (dragHeight <= 0 || dragWidth <= 0 || slideHeight <= 0) {
                reflow();
            }
            isDragging = true;
            container.addClass(draggingClass);
            shiftMovementDirection = null;
            boundElement.trigger('dragstart.spectrum', [ get() ]);
        }

        function dragStop() {
            isDragging = false;
            container.removeClass(draggingClass);
            boundElement.trigger('dragstop.spectrum', [ get() ]);
        }

        function setFromTextInput() {

            var value = textInput.val();

            if ((value === null || value === "") && allowEmpty) {
                set(null);
                updateOriginalInput(true);
            }
            else {
                var tiny = tinycolor(value);
                if (tiny.isValid()) {
                    set(tiny);
                    updateOriginalInput(true);
                }
                else {
                    textInput.addClass("sp-validation-error");
                }
            }
        }

        function toggle() {
            if (visible) {
                hide();
            }
            else {
                show();
            }
        }

        function show() {
            var event = $.Event('beforeShow.spectrum');

            if (visible) {
                reflow();
                return;
            }

            boundElement.trigger(event, [ get() ]);

            if (callbacks.beforeShow(get()) === false || event.isDefaultPrevented()) {
                return;
            }

            hideAll();
            visible = true;

            $(doc).bind("keydown.spectrum", onkeydown);
            $(doc).bind("click.spectrum", clickout);
            $(window).bind("resize.spectrum", resize);
            replacer.addClass("sp-active");
            container.removeClass("sp-hidden");

            reflow();
            updateUI();

            colorOnShow = get();

            drawInitial();
            callbacks.show(colorOnShow);
            boundElement.trigger('show.spectrum', [ colorOnShow ]);
        }

        function onkeydown(e) {
            // Close on ESC
            if (e.keyCode === 27) {
                hide();
            }
        }

        function clickout(e) {
            // Return on right click.
            if (e.button == 2) { return; }

            // If a drag event was happening during the mouseup, don't hide
            // on click.
            if (isDragging) { return; }

            if (clickoutFiresChange) {
                updateOriginalInput(true);
            }
            else {
                revert();
            }
            hide();
        }

        function hide() {
            // Return if hiding is unnecessary
            if (!visible || flat) { return; }
            visible = false;

            $(doc).unbind("keydown.spectrum", onkeydown);
            $(doc).unbind("click.spectrum", clickout);
            $(window).unbind("resize.spectrum", resize);

            replacer.removeClass("sp-active");
            container.addClass("sp-hidden");

            callbacks.hide(get());
            boundElement.trigger('hide.spectrum', [ get() ]);
        }

        function revert() {
            set(colorOnShow, true);
        }

        function set(color, ignoreFormatChange) {
            if (tinycolor.equals(color, get())) {
                // Update UI just in case a validation error needs
                // to be cleared.
                updateUI();
                return;
            }

            var newColor, newHsv;
            if (!color && allowEmpty) {
                isEmpty = true;
            } else {
                isEmpty = false;
                newColor = tinycolor(color);
                newHsv = newColor.toHsv();

                currentHue = (newHsv.h % 360) / 360;
                currentSaturation = newHsv.s;
                currentValue = newHsv.v;
                currentAlpha = newHsv.a;
            }
            updateUI();

            if (newColor && newColor.isValid() && !ignoreFormatChange) {
                currentPreferredFormat = opts.preferredFormat || newColor.getFormat();
            }
        }

        function get(opts) {
            opts = opts || { };

            if (allowEmpty && isEmpty) {
                return null;
            }

            return tinycolor.fromRatio({
                h: currentHue,
                s: currentSaturation,
                v: currentValue,
                a: Math.round(currentAlpha * 100) / 100
            }, { format: opts.format || currentPreferredFormat });
        }

        function isValid() {
            return !textInput.hasClass("sp-validation-error");
        }

        function move() {
            updateUI();

            callbacks.move(get());
            boundElement.trigger('move.spectrum', [ get() ]);
        }

        function updateUI() {

            textInput.removeClass("sp-validation-error");

            updateHelperLocations();

            // Update dragger background color (gradients take care of saturation and value).
            var flatColor = tinycolor.fromRatio({ h: currentHue, s: 1, v: 1 });
            dragger.css("background-color", flatColor.toHexString());

            // Get a format that alpha will be included in (hex and names ignore alpha)
            var format = currentPreferredFormat;
            if (currentAlpha < 1 && !(currentAlpha === 0 && format === "name")) {
                if (format === "hex" || format === "hex3" || format === "hex6" || format === "name") {
                    format = "rgb";
                }
            }

            var realColor = get({ format: format }),
                displayColor = '';

             //reset background info for preview element
            previewElement.removeClass("sp-clear-display");
            previewElement.css('background-color', 'transparent');

            if (!realColor && allowEmpty) {
                // Update the replaced elements background with icon indicating no color selection
                previewElement.addClass("sp-clear-display");
            }
            else {
                var realHex = realColor.toHexString(),
                    realRgb = realColor.toRgbString();

                // Update the replaced elements background color (with actual selected color)
                if (rgbaSupport || realColor.alpha === 1) {
                    previewElement.css("background-color", realRgb);
                }
                else {
                    previewElement.css("background-color", "transparent");
                    previewElement.css("filter", realColor.toFilter());
                }

                if (opts.showAlpha) {
                    var rgb = realColor.toRgb();
                    rgb.a = 0;
                    var realAlpha = tinycolor(rgb).toRgbString();
                    var gradient = "linear-gradient(left, " + realAlpha + ", " + realHex + ")";

                    if (IE) {
                        alphaSliderInner.css("filter", tinycolor(realAlpha).toFilter({ gradientType: 1 }, realHex));
                    }
                    else {
                        alphaSliderInner.css("background", "-webkit-" + gradient);
                        alphaSliderInner.css("background", "-moz-" + gradient);
                        alphaSliderInner.css("background", "-ms-" + gradient);
                        // Use current syntax gradient on unprefixed property.
                        alphaSliderInner.css("background",
                            "linear-gradient(to right, " + realAlpha + ", " + realHex + ")");
                    }
                }

                displayColor = realColor.toString(format);
            }

            // Update the text entry input as it changes happen
            if (opts.showInput) {
                textInput.val(displayColor);
            }

            if (opts.showPalette) {
                drawPalette();
            }

            drawInitial();
        }

        function updateHelperLocations() {
            var s = currentSaturation;
            var v = currentValue;

            if(allowEmpty && isEmpty) {
                //if selected color is empty, hide the helpers
                alphaSlideHelper.hide();
                slideHelper.hide();
                dragHelper.hide();
            }
            else {
                //make sure helpers are visible
                alphaSlideHelper.show();
                slideHelper.show();
                dragHelper.show();

                // Where to show the little circle in that displays your current selected color
                var dragX = s * dragWidth;
                var dragY = dragHeight - (v * dragHeight);
                dragX = Math.max(
                    -dragHelperHeight,
                    Math.min(dragWidth - dragHelperHeight, dragX - dragHelperHeight)
                );
                dragY = Math.max(
                    -dragHelperHeight,
                    Math.min(dragHeight - dragHelperHeight, dragY - dragHelperHeight)
                );
                dragHelper.css({
                    "top": dragY + "px",
                    "left": dragX + "px"
                });

                var alphaX = currentAlpha * alphaWidth;
                alphaSlideHelper.css({
                    "left": (alphaX - (alphaSlideHelperWidth / 2)) + "px"
                });

                // Where to show the bar that displays your current selected hue
                var slideY = (currentHue) * slideHeight;
                slideHelper.css({
                    "top": (slideY - slideHelperHeight) + "px"
                });
            }
        }

        function updateOriginalInput(fireCallback) {
            var color = get(),
                displayColor = '',
                hasChanged = !tinycolor.equals(color, colorOnShow);

            if (color) {
                displayColor = color.toString(currentPreferredFormat);
                // Update the selection palette with the current color
                addColorToSelectionPalette(color);
            }

            if (isInput) {
                boundElement.val(displayColor);
            }

            if (fireCallback && hasChanged) {
                callbacks.change(color);
                boundElement.trigger('change', [ color ]);
            }
        }

        function reflow() {
            if (!visible) {
                return; // Calculations would be useless and wouldn't be reliable anyways
            }
            dragWidth = dragger.width();
            dragHeight = dragger.height();
            dragHelperHeight = dragHelper.height();
            slideWidth = slider.width();
            slideHeight = slider.height();
            slideHelperHeight = slideHelper.height();
            alphaWidth = alphaSlider.width();
            alphaSlideHelperWidth = alphaSlideHelper.width();

            if (!flat) {
                container.css("position", "absolute");
                if (opts.offset) {
                    container.offset(opts.offset);
                } else {
                    container.offset(getOffset(container, offsetElement));
                }
            }

            updateHelperLocations();

            if (opts.showPalette) {
                drawPalette();
            }

            boundElement.trigger('reflow.spectrum');
        }

        function destroy() {
            boundElement.show();
            offsetElement.unbind("click.spectrum touchstart.spectrum");
            container.remove();
            replacer.remove();
            spectrums[spect.id] = null;
        }

        function option(optionName, optionValue) {
            if (optionName === undefined) {
                return $.extend({}, opts);
            }
            if (optionValue === undefined) {
                return opts[optionName];
            }

            opts[optionName] = optionValue;

            if (optionName === "preferredFormat") {
                currentPreferredFormat = opts.preferredFormat;
            }
            applyOptions();
        }

        function enable() {
            disabled = false;
            boundElement.attr("disabled", false);
            offsetElement.removeClass("sp-disabled");
        }

        function disable() {
            hide();
            disabled = true;
            boundElement.attr("disabled", true);
            offsetElement.addClass("sp-disabled");
        }

        function setOffset(coord) {
            opts.offset = coord;
            reflow();
        }

        initialize();

        var spect = {
            show: show,
            hide: hide,
            toggle: toggle,
            reflow: reflow,
            option: option,
            enable: enable,
            disable: disable,
            offset: setOffset,
            set: function (c) {
                set(c);
                updateOriginalInput();
            },
            get: get,
            destroy: destroy,
            container: container
        };

        spect.id = spectrums.push(spect) - 1;

        return spect;
    }

    /**
    * checkOffset - get the offset below/above and left/right element depending on screen position
    * Thanks https://github.com/jquery/jquery-ui/blob/master/ui/jquery.ui.datepicker.js
    */
    function getOffset(picker, input) {
        var extraY = 0;
        var dpWidth = picker.outerWidth();
        var dpHeight = picker.outerHeight();
        var inputHeight = input.outerHeight();
        var doc = picker[0].ownerDocument;
        var docElem = doc.documentElement;
        var viewWidth = docElem.clientWidth + $(doc).scrollLeft();
        var viewHeight = docElem.clientHeight + $(doc).scrollTop();
        var offset = input.offset();
        offset.top += inputHeight;

        offset.left -=
            Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
            Math.abs(offset.left + dpWidth - viewWidth) : 0);

        offset.top -=
            Math.min(offset.top, ((offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
            Math.abs(dpHeight + inputHeight - extraY) : extraY));

        return offset;
    }

    /**
    * noop - do nothing
    */
    function noop() {

    }

    /**
    * stopPropagation - makes the code only doing this a little easier to read in line
    */
    function stopPropagation(e) {
        e.stopPropagation();
    }

    /**
    * Create a function bound to a given object
    * Thanks to underscore.js
    */
    function bind(func, obj) {
        var slice = Array.prototype.slice;
        var args = slice.call(arguments, 2);
        return function () {
            return func.apply(obj, args.concat(slice.call(arguments)));
        };
    }

    /**
    * Lightweight drag helper.  Handles containment within the element, so that
    * when dragging, the x is within [0,element.width] and y is within [0,element.height]
    */
    function draggable(element, onmove, onstart, onstop) {
        onmove = onmove || function () { };
        onstart = onstart || function () { };
        onstop = onstop || function () { };
        var doc = document;
        var dragging = false;
        var offset = {};
        var maxHeight = 0;
        var maxWidth = 0;
        var hasTouch = ('ontouchstart' in window);

        var duringDragEvents = {};
        duringDragEvents["selectstart"] = prevent;
        duringDragEvents["dragstart"] = prevent;
        duringDragEvents["touchmove mousemove"] = move;
        duringDragEvents["touchend mouseup"] = stop;

        function prevent(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.returnValue = false;
        }

        function move(e) {
            if (dragging) {
                // Mouseup happened outside of window
                if (IE && doc.documentMode < 9 && !e.button) {
                    return stop();
                }

                var t0 = e.originalEvent && e.originalEvent.touches && e.originalEvent.touches[0];
                var pageX = t0 && t0.pageX || e.pageX;
                var pageY = t0 && t0.pageY || e.pageY;

                var dragX = Math.max(0, Math.min(pageX - offset.left, maxWidth));
                var dragY = Math.max(0, Math.min(pageY - offset.top, maxHeight));

                if (hasTouch) {
                    // Stop scrolling in iOS
                    prevent(e);
                }

                onmove.apply(element, [dragX, dragY, e]);
            }
        }

        function start(e) {
            var rightclick = (e.which) ? (e.which == 3) : (e.button == 2);

            if (!rightclick && !dragging) {
                if (onstart.apply(element, arguments) !== false) {
                    dragging = true;
                    maxHeight = $(element).height();
                    maxWidth = $(element).width();
                    offset = $(element).offset();

                    $(doc).bind(duringDragEvents);
                    $(doc.body).addClass("sp-dragging");

                    move(e);

                    prevent(e);
                }
            }
        }

        function stop() {
            if (dragging) {
                $(doc).unbind(duringDragEvents);
                $(doc.body).removeClass("sp-dragging");

                // Wait a tick before notifying observers to allow the click event
                // to fire in Chrome.
                setTimeout(function() {
                    onstop.apply(element, arguments);
                }, 0);
            }
            dragging = false;
        }

        $(element).bind("touchstart mousedown", start);
    }

    function throttle(func, wait, debounce) {
        var timeout;
        return function () {
            var context = this, args = arguments;
            var throttler = function () {
                timeout = null;
                func.apply(context, args);
            };
            if (debounce) clearTimeout(timeout);
            if (debounce || !timeout) timeout = setTimeout(throttler, wait);
        };
    }

    function inputTypeColorSupport() {
        return $.fn.spectrum.inputTypeColorSupport();
    }

    /**
    * Define a jQuery plugin
    */
    var dataID = "spectrum.id";
    $.fn.spectrum = function (opts, extra) {

        if (typeof opts == "string") {

            var returnValue = this;
            var args = Array.prototype.slice.call( arguments, 1 );

            this.each(function () {
                var spect = spectrums[$(this).data(dataID)];
                if (spect) {
                    var method = spect[opts];
                    if (!method) {
                        throw new Error( "Spectrum: no such method: '" + opts + "'" );
                    }

                    if (opts == "get") {
                        returnValue = spect.get();
                    }
                    else if (opts == "container") {
                        returnValue = spect.container;
                    }
                    else if (opts == "option") {
                        returnValue = spect.option.apply(spect, args);
                    }
                    else if (opts == "destroy") {
                        spect.destroy();
                        $(this).removeData(dataID);
                    }
                    else {
                        method.apply(spect, args);
                    }
                }
            });

            return returnValue;
        }

        // Initializing a new instance of spectrum
        return this.spectrum("destroy").each(function () {
            var options = $.extend({}, opts, $(this).data());
            var spect = spectrum(this, options);
            $(this).data(dataID, spect.id);
        });
    };

    $.fn.spectrum.load = true;
    $.fn.spectrum.loadOpts = {};
    $.fn.spectrum.draggable = draggable;
    $.fn.spectrum.defaults = defaultOpts;
    $.fn.spectrum.inputTypeColorSupport = function inputTypeColorSupport() {
        if (typeof inputTypeColorSupport._cachedResult === "undefined") {
            var colorInput = $("<input type='color'/>")[0]; // if color element is supported, value will default to not null
            inputTypeColorSupport._cachedResult = colorInput.type === "color" && colorInput.value !== "";
        }
        return inputTypeColorSupport._cachedResult;
    };

    $.spectrum = { };
    $.spectrum.localization = { };
    $.spectrum.palettes = { };

    $.fn.spectrum.processNativeColorInputs = function () {
        var colorInputs = $("input[type=color]");
        if (colorInputs.length && !inputTypeColorSupport()) {
            colorInputs.spectrum({
                preferredFormat: "hex6"
            });
        }
    };

    // TinyColor v1.1.2
    // https://github.com/bgrins/TinyColor
    // Brian Grinstead, MIT License

    (function() {

    var trimLeft = /^[\s,#]+/,
        trimRight = /\s+$/,
        tinyCounter = 0,
        math = Math,
        mathRound = math.round,
        mathMin = math.min,
        mathMax = math.max,
        mathRandom = math.random;

    var tinycolor = function(color, opts) {

        color = (color) ? color : '';
        opts = opts || { };

        // If input is already a tinycolor, return itself
        if (color instanceof tinycolor) {
           return color;
        }
        // If we are called as a function, call using new instead
        if (!(this instanceof tinycolor)) {
            return new tinycolor(color, opts);
        }

        var rgb = inputToRGB(color);
        this._originalInput = color,
        this._r = rgb.r,
        this._g = rgb.g,
        this._b = rgb.b,
        this._a = rgb.a,
        this._roundA = mathRound(100*this._a) / 100,
        this._format = opts.format || rgb.format;
        this._gradientType = opts.gradientType;

        // Don't let the range of [0,255] come back in [0,1].
        // Potentially lose a little bit of precision here, but will fix issues where
        // .5 gets interpreted as half of the total, instead of half of 1
        // If it was supposed to be 128, this was already taken care of by `inputToRgb`
        if (this._r < 1) { this._r = mathRound(this._r); }
        if (this._g < 1) { this._g = mathRound(this._g); }
        if (this._b < 1) { this._b = mathRound(this._b); }

        this._ok = rgb.ok;
        this._tc_id = tinyCounter++;
    };

    tinycolor.prototype = {
        isDark: function() {
            return this.getBrightness() < 128;
        },
        isLight: function() {
            return !this.isDark();
        },
        isValid: function() {
            return this._ok;
        },
        getOriginalInput: function() {
          return this._originalInput;
        },
        getFormat: function() {
            return this._format;
        },
        getAlpha: function() {
            return this._a;
        },
        getBrightness: function() {
            var rgb = this.toRgb();
            return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
        },
        setAlpha: function(value) {
            this._a = boundAlpha(value);
            this._roundA = mathRound(100*this._a) / 100;
            return this;
        },
        toHsv: function() {
            var hsv = rgbToHsv(this._r, this._g, this._b);
            return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
        },
        toHsvString: function() {
            var hsv = rgbToHsv(this._r, this._g, this._b);
            var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
            return (this._a == 1) ?
              "hsv("  + h + ", " + s + "%, " + v + "%)" :
              "hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
        },
        toHsl: function() {
            var hsl = rgbToHsl(this._r, this._g, this._b);
            return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
        },
        toHslString: function() {
            var hsl = rgbToHsl(this._r, this._g, this._b);
            var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
            return (this._a == 1) ?
              "hsl("  + h + ", " + s + "%, " + l + "%)" :
              "hsla(" + h + ", " + s + "%, " + l + "%, "+ this._roundA + ")";
        },
        toHex: function(allow3Char) {
            return rgbToHex(this._r, this._g, this._b, allow3Char);
        },
        toHexString: function(allow3Char) {
            return '#' + this.toHex(allow3Char);
        },
        toHex8: function() {
            return rgbaToHex(this._r, this._g, this._b, this._a);
        },
        toHex8String: function() {
            return '#' + this.toHex8();
        },
        toRgb: function() {
            return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
        },
        toRgbString: function() {
            return (this._a == 1) ?
              "rgb("  + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
              "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
        },
        toPercentageRgb: function() {
            return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
        },
        toPercentageRgbString: function() {
            return (this._a == 1) ?
              "rgb("  + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" :
              "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
        },
        toName: function() {
            if (this._a === 0) {
                return "transparent";
            }

            if (this._a < 1) {
                return false;
            }

            return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
        },
        toFilter: function(secondColor) {
            var hex8String = '#' + rgbaToHex(this._r, this._g, this._b, this._a);
            var secondHex8String = hex8String;
            var gradientType = this._gradientType ? "GradientType = 1, " : "";

            if (secondColor) {
                var s = tinycolor(secondColor);
                secondHex8String = s.toHex8String();
            }

            return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";
        },
        toString: function(format) {
            var formatSet = !!format;
            format = format || this._format;

            var formattedString = false;
            var hasAlpha = this._a < 1 && this._a >= 0;
            var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "name");

            if (needsAlphaFormat) {
                // Special case for "transparent", all other non-alpha formats
                // will return rgba when there is transparency.
                if (format === "name" && this._a === 0) {
                    return this.toName();
                }
                return this.toRgbString();
            }
            if (format === "rgb") {
                formattedString = this.toRgbString();
            }
            if (format === "prgb") {
                formattedString = this.toPercentageRgbString();
            }
            if (format === "hex" || format === "hex6") {
                formattedString = this.toHexString();
            }
            if (format === "hex3") {
                formattedString = this.toHexString(true);
            }
            if (format === "hex8") {
                formattedString = this.toHex8String();
            }
            if (format === "name") {
                formattedString = this.toName();
            }
            if (format === "hsl") {
                formattedString = this.toHslString();
            }
            if (format === "hsv") {
                formattedString = this.toHsvString();
            }

            return formattedString || this.toHexString();
        },

        _applyModification: function(fn, args) {
            var color = fn.apply(null, [this].concat([].slice.call(args)));
            this._r = color._r;
            this._g = color._g;
            this._b = color._b;
            this.setAlpha(color._a);
            return this;
        },
        lighten: function() {
            return this._applyModification(lighten, arguments);
        },
        brighten: function() {
            return this._applyModification(brighten, arguments);
        },
        darken: function() {
            return this._applyModification(darken, arguments);
        },
        desaturate: function() {
            return this._applyModification(desaturate, arguments);
        },
        saturate: function() {
            return this._applyModification(saturate, arguments);
        },
        greyscale: function() {
            return this._applyModification(greyscale, arguments);
        },
        spin: function() {
            return this._applyModification(spin, arguments);
        },

        _applyCombination: function(fn, args) {
            return fn.apply(null, [this].concat([].slice.call(args)));
        },
        analogous: function() {
            return this._applyCombination(analogous, arguments);
        },
        complement: function() {
            return this._applyCombination(complement, arguments);
        },
        monochromatic: function() {
            return this._applyCombination(monochromatic, arguments);
        },
        splitcomplement: function() {
            return this._applyCombination(splitcomplement, arguments);
        },
        triad: function() {
            return this._applyCombination(triad, arguments);
        },
        tetrad: function() {
            return this._applyCombination(tetrad, arguments);
        }
    };

    // If input is an object, force 1 into "1.0" to handle ratios properly
    // String input requires "1.0" as input, so 1 will be treated as 1
    tinycolor.fromRatio = function(color, opts) {
        if (typeof color == "object") {
            var newColor = {};
            for (var i in color) {
                if (color.hasOwnProperty(i)) {
                    if (i === "a") {
                        newColor[i] = color[i];
                    }
                    else {
                        newColor[i] = convertToPercentage(color[i]);
                    }
                }
            }
            color = newColor;
        }

        return tinycolor(color, opts);
    };

    // Given a string or object, convert that input to RGB
    // Possible string inputs:
    //
    //     "red"
    //     "#f00" or "f00"
    //     "#ff0000" or "ff0000"
    //     "#ff000000" or "ff000000"
    //     "rgb 255 0 0" or "rgb (255, 0, 0)"
    //     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
    //     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
    //     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
    //     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
    //     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
    //     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
    //
    function inputToRGB(color) {

        var rgb = { r: 0, g: 0, b: 0 };
        var a = 1;
        var ok = false;
        var format = false;

        if (typeof color == "string") {
            color = stringInputToObject(color);
        }

        if (typeof color == "object") {
            if (color.hasOwnProperty("r") && color.hasOwnProperty("g") && color.hasOwnProperty("b")) {
                rgb = rgbToRgb(color.r, color.g, color.b);
                ok = true;
                format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
            }
            else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("v")) {
                color.s = convertToPercentage(color.s);
                color.v = convertToPercentage(color.v);
                rgb = hsvToRgb(color.h, color.s, color.v);
                ok = true;
                format = "hsv";
            }
            else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("l")) {
                color.s = convertToPercentage(color.s);
                color.l = convertToPercentage(color.l);
                rgb = hslToRgb(color.h, color.s, color.l);
                ok = true;
                format = "hsl";
            }

            if (color.hasOwnProperty("a")) {
                a = color.a;
            }
        }

        a = boundAlpha(a);

        return {
            ok: ok,
            format: color.format || format,
            r: mathMin(255, mathMax(rgb.r, 0)),
            g: mathMin(255, mathMax(rgb.g, 0)),
            b: mathMin(255, mathMax(rgb.b, 0)),
            a: a
        };
    }


    // Conversion Functions
    // --------------------

    // `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
    // <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

    // `rgbToRgb`
    // Handle bounds / percentage checking to conform to CSS color spec
    // <http://www.w3.org/TR/css3-color/>
    // *Assumes:* r, g, b in [0, 255] or [0, 1]
    // *Returns:* { r, g, b } in [0, 255]
    function rgbToRgb(r, g, b){
        return {
            r: bound01(r, 255) * 255,
            g: bound01(g, 255) * 255,
            b: bound01(b, 255) * 255
        };
    }

    // `rgbToHsl`
    // Converts an RGB color value to HSL.
    // *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
    // *Returns:* { h, s, l } in [0,1]
    function rgbToHsl(r, g, b) {

        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);

        var max = mathMax(r, g, b), min = mathMin(r, g, b);
        var h, s, l = (max + min) / 2;

        if(max == min) {
            h = s = 0; // achromatic
        }
        else {
            var d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch(max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }

            h /= 6;
        }

        return { h: h, s: s, l: l };
    }

    // `hslToRgb`
    // Converts an HSL color value to RGB.
    // *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
    // *Returns:* { r, g, b } in the set [0, 255]
    function hslToRgb(h, s, l) {
        var r, g, b;

        h = bound01(h, 360);
        s = bound01(s, 100);
        l = bound01(l, 100);

        function hue2rgb(p, q, t) {
            if(t < 0) t += 1;
            if(t > 1) t -= 1;
            if(t < 1/6) return p + (q - p) * 6 * t;
            if(t < 1/2) return q;
            if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
        }

        if(s === 0) {
            r = g = b = l; // achromatic
        }
        else {
            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }

        return { r: r * 255, g: g * 255, b: b * 255 };
    }

    // `rgbToHsv`
    // Converts an RGB color value to HSV
    // *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
    // *Returns:* { h, s, v } in [0,1]
    function rgbToHsv(r, g, b) {

        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);

        var max = mathMax(r, g, b), min = mathMin(r, g, b);
        var h, s, v = max;

        var d = max - min;
        s = max === 0 ? 0 : d / max;

        if(max == min) {
            h = 0; // achromatic
        }
        else {
            switch(max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        return { h: h, s: s, v: v };
    }

    // `hsvToRgb`
    // Converts an HSV color value to RGB.
    // *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
    // *Returns:* { r, g, b } in the set [0, 255]
     function hsvToRgb(h, s, v) {

        h = bound01(h, 360) * 6;
        s = bound01(s, 100);
        v = bound01(v, 100);

        var i = math.floor(h),
            f = h - i,
            p = v * (1 - s),
            q = v * (1 - f * s),
            t = v * (1 - (1 - f) * s),
            mod = i % 6,
            r = [v, q, p, p, t, v][mod],
            g = [t, v, v, q, p, p][mod],
            b = [p, p, t, v, v, q][mod];

        return { r: r * 255, g: g * 255, b: b * 255 };
    }

    // `rgbToHex`
    // Converts an RGB color to hex
    // Assumes r, g, and b are contained in the set [0, 255]
    // Returns a 3 or 6 character hex
    function rgbToHex(r, g, b, allow3Char) {

        var hex = [
            pad2(mathRound(r).toString(16)),
            pad2(mathRound(g).toString(16)),
            pad2(mathRound(b).toString(16))
        ];

        // Return a 3 character hex if possible
        if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
            return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
        }

        return hex.join("");
    }
        // `rgbaToHex`
        // Converts an RGBA color plus alpha transparency to hex
        // Assumes r, g, b and a are contained in the set [0, 255]
        // Returns an 8 character hex
        function rgbaToHex(r, g, b, a) {

            var hex = [
                pad2(convertDecimalToHex(a)),
                pad2(mathRound(r).toString(16)),
                pad2(mathRound(g).toString(16)),
                pad2(mathRound(b).toString(16))
            ];

            return hex.join("");
        }

    // `equals`
    // Can be called with any tinycolor input
    tinycolor.equals = function (color1, color2) {
        if (!color1 || !color2) { return false; }
        return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
    };
    tinycolor.random = function() {
        return tinycolor.fromRatio({
            r: mathRandom(),
            g: mathRandom(),
            b: mathRandom()
        });
    };


    // Modification Functions
    // ----------------------
    // Thanks to less.js for some of the basics here
    // <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

    function desaturate(color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var hsl = tinycolor(color).toHsl();
        hsl.s -= amount / 100;
        hsl.s = clamp01(hsl.s);
        return tinycolor(hsl);
    }

    function saturate(color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var hsl = tinycolor(color).toHsl();
        hsl.s += amount / 100;
        hsl.s = clamp01(hsl.s);
        return tinycolor(hsl);
    }

    function greyscale(color) {
        return tinycolor(color).desaturate(100);
    }

    function lighten (color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var hsl = tinycolor(color).toHsl();
        hsl.l += amount / 100;
        hsl.l = clamp01(hsl.l);
        return tinycolor(hsl);
    }

    function brighten(color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var rgb = tinycolor(color).toRgb();
        rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
        rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
        rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
        return tinycolor(rgb);
    }

    function darken (color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var hsl = tinycolor(color).toHsl();
        hsl.l -= amount / 100;
        hsl.l = clamp01(hsl.l);
        return tinycolor(hsl);
    }

    // Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
    // Values outside of this range will be wrapped into this range.
    function spin(color, amount) {
        var hsl = tinycolor(color).toHsl();
        var hue = (mathRound(hsl.h) + amount) % 360;
        hsl.h = hue < 0 ? 360 + hue : hue;
        return tinycolor(hsl);
    }

    // Combination Functions
    // ---------------------
    // Thanks to jQuery xColor for some of the ideas behind these
    // <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

    function complement(color) {
        var hsl = tinycolor(color).toHsl();
        hsl.h = (hsl.h + 180) % 360;
        return tinycolor(hsl);
    }

    function triad(color) {
        var hsl = tinycolor(color).toHsl();
        var h = hsl.h;
        return [
            tinycolor(color),
            tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
        ];
    }

    function tetrad(color) {
        var hsl = tinycolor(color).toHsl();
        var h = hsl.h;
        return [
            tinycolor(color),
            tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
        ];
    }

    function splitcomplement(color) {
        var hsl = tinycolor(color).toHsl();
        var h = hsl.h;
        return [
            tinycolor(color),
            tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
            tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
        ];
    }

    function analogous(color, results, slices) {
        results = results || 6;
        slices = slices || 30;

        var hsl = tinycolor(color).toHsl();
        var part = 360 / slices;
        var ret = [tinycolor(color)];

        for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
            hsl.h = (hsl.h + part) % 360;
            ret.push(tinycolor(hsl));
        }
        return ret;
    }

    function monochromatic(color, results) {
        results = results || 6;
        var hsv = tinycolor(color).toHsv();
        var h = hsv.h, s = hsv.s, v = hsv.v;
        var ret = [];
        var modification = 1 / results;

        while (results--) {
            ret.push(tinycolor({ h: h, s: s, v: v}));
            v = (v + modification) % 1;
        }

        return ret;
    }

    // Utility Functions
    // ---------------------

    tinycolor.mix = function(color1, color2, amount) {
        amount = (amount === 0) ? 0 : (amount || 50);

        var rgb1 = tinycolor(color1).toRgb();
        var rgb2 = tinycolor(color2).toRgb();

        var p = amount / 100;
        var w = p * 2 - 1;
        var a = rgb2.a - rgb1.a;

        var w1;

        if (w * a == -1) {
            w1 = w;
        } else {
            w1 = (w + a) / (1 + w * a);
        }

        w1 = (w1 + 1) / 2;

        var w2 = 1 - w1;

        var rgba = {
            r: rgb2.r * w1 + rgb1.r * w2,
            g: rgb2.g * w1 + rgb1.g * w2,
            b: rgb2.b * w1 + rgb1.b * w2,
            a: rgb2.a * p  + rgb1.a * (1 - p)
        };

        return tinycolor(rgba);
    };


    // Readability Functions
    // ---------------------
    // <http://www.w3.org/TR/AERT#color-contrast>

    // `readability`
    // Analyze the 2 colors and returns an object with the following properties:
    //    `brightness`: difference in brightness between the two colors
    //    `color`: difference in color/hue between the two colors
    tinycolor.readability = function(color1, color2) {
        var c1 = tinycolor(color1);
        var c2 = tinycolor(color2);
        var rgb1 = c1.toRgb();
        var rgb2 = c2.toRgb();
        var brightnessA = c1.getBrightness();
        var brightnessB = c2.getBrightness();
        var colorDiff = (
            Math.max(rgb1.r, rgb2.r) - Math.min(rgb1.r, rgb2.r) +
            Math.max(rgb1.g, rgb2.g) - Math.min(rgb1.g, rgb2.g) +
            Math.max(rgb1.b, rgb2.b) - Math.min(rgb1.b, rgb2.b)
        );

        return {
            brightness: Math.abs(brightnessA - brightnessB),
            color: colorDiff
        };
    };

    // `readable`
    // http://www.w3.org/TR/AERT#color-contrast
    // Ensure that foreground and background color combinations provide sufficient contrast.
    // *Example*
    //    tinycolor.isReadable("#000", "#111") => false
    tinycolor.isReadable = function(color1, color2) {
        var readability = tinycolor.readability(color1, color2);
        return readability.brightness > 125 && readability.color > 500;
    };

    // `mostReadable`
    // Given a base color and a list of possible foreground or background
    // colors for that base, returns the most readable color.
    // *Example*
    //    tinycolor.mostReadable("#123", ["#fff", "#000"]) => "#000"
    tinycolor.mostReadable = function(baseColor, colorList) {
        var bestColor = null;
        var bestScore = 0;
        var bestIsReadable = false;
        for (var i=0; i < colorList.length; i++) {

            // We normalize both around the "acceptable" breaking point,
            // but rank brightness constrast higher than hue.

            var readability = tinycolor.readability(baseColor, colorList[i]);
            var readable = readability.brightness > 125 && readability.color > 500;
            var score = 3 * (readability.brightness / 125) + (readability.color / 500);

            if ((readable && ! bestIsReadable) ||
                (readable && bestIsReadable && score > bestScore) ||
                ((! readable) && (! bestIsReadable) && score > bestScore)) {
                bestIsReadable = readable;
                bestScore = score;
                bestColor = tinycolor(colorList[i]);
            }
        }
        return bestColor;
    };


    // Big List of Colors
    // ------------------
    // <http://www.w3.org/TR/css3-color/#svg-color>
    var names = tinycolor.names = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "0ff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000",
        blanchedalmond: "ffebcd",
        blue: "00f",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        burntsienna: "ea7e5d",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "0ff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkgrey: "a9a9a9",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkslategrey: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dimgrey: "696969",
        dodgerblue: "1e90ff",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "f0f",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        grey: "808080",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgray: "d3d3d3",
        lightgreen: "90ee90",
        lightgrey: "d3d3d3",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslategray: "789",
        lightslategrey: "789",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "0f0",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "f0f",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370db",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "db7093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        rebeccapurple: "663399",
        red: "f00",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        slategrey: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        wheat: "f5deb3",
        white: "fff",
        whitesmoke: "f5f5f5",
        yellow: "ff0",
        yellowgreen: "9acd32"
    };

    // Make it easy to access colors via `hexNames[hex]`
    var hexNames = tinycolor.hexNames = flip(names);


    // Utilities
    // ---------

    // `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
    function flip(o) {
        var flipped = { };
        for (var i in o) {
            if (o.hasOwnProperty(i)) {
                flipped[o[i]] = i;
            }
        }
        return flipped;
    }

    // Return a valid alpha value [0,1] with all invalid values being set to 1
    function boundAlpha(a) {
        a = parseFloat(a);

        if (isNaN(a) || a < 0 || a > 1) {
            a = 1;
        }

        return a;
    }

    // Take input from [0, n] and return it as [0, 1]
    function bound01(n, max) {
        if (isOnePointZero(n)) { n = "100%"; }

        var processPercent = isPercentage(n);
        n = mathMin(max, mathMax(0, parseFloat(n)));

        // Automatically convert percentage into number
        if (processPercent) {
            n = parseInt(n * max, 10) / 100;
        }

        // Handle floating point rounding errors
        if ((math.abs(n - max) < 0.000001)) {
            return 1;
        }

        // Convert into [0, 1] range if it isn't already
        return (n % max) / parseFloat(max);
    }

    // Force a number between 0 and 1
    function clamp01(val) {
        return mathMin(1, mathMax(0, val));
    }

    // Parse a base-16 hex value into a base-10 integer
    function parseIntFromHex(val) {
        return parseInt(val, 16);
    }

    // Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
    // <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
    function isOnePointZero(n) {
        return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
    }

    // Check to see if string passed in is a percentage
    function isPercentage(n) {
        return typeof n === "string" && n.indexOf('%') != -1;
    }

    // Force a hex value to have 2 characters
    function pad2(c) {
        return c.length == 1 ? '0' + c : '' + c;
    }

    // Replace a decimal with it's percentage value
    function convertToPercentage(n) {
        if (n <= 1) {
            n = (n * 100) + "%";
        }

        return n;
    }

    // Converts a decimal to a hex value
    function convertDecimalToHex(d) {
        return Math.round(parseFloat(d) * 255).toString(16);
    }
    // Converts a hex value to a decimal
    function convertHexToDecimal(h) {
        return (parseIntFromHex(h) / 255);
    }

    var matchers = (function() {

        // <http://www.w3.org/TR/css3-values/#integers>
        var CSS_INTEGER = "[-\\+]?\\d+%?";

        // <http://www.w3.org/TR/css3-values/#number-value>
        var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

        // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
        var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

        // Actual matching.
        // Parentheses and commas are optional, but not required.
        // Whitespace can take the place of commas or opening paren
        var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
        var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

        return {
            rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
            rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
            hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
            hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
            hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
            hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
            hex3: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex6: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
            hex8: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
        };
    })();

    // `stringInputToObject`
    // Permissive string parsing.  Take in a number of formats, and output an object
    // based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
    function stringInputToObject(color) {

        color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
        var named = false;
        if (names[color]) {
            color = names[color];
            named = true;
        }
        else if (color == 'transparent') {
            return { r: 0, g: 0, b: 0, a: 0, format: "name" };
        }

        // Try to match string input using regular expressions.
        // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
        // Just return an object and let the conversion functions handle that.
        // This way the result will be the same whether the tinycolor is initialized with string or object.
        var match;
        if ((match = matchers.rgb.exec(color))) {
            return { r: match[1], g: match[2], b: match[3] };
        }
        if ((match = matchers.rgba.exec(color))) {
            return { r: match[1], g: match[2], b: match[3], a: match[4] };
        }
        if ((match = matchers.hsl.exec(color))) {
            return { h: match[1], s: match[2], l: match[3] };
        }
        if ((match = matchers.hsla.exec(color))) {
            return { h: match[1], s: match[2], l: match[3], a: match[4] };
        }
        if ((match = matchers.hsv.exec(color))) {
            return { h: match[1], s: match[2], v: match[3] };
        }
        if ((match = matchers.hsva.exec(color))) {
            return { h: match[1], s: match[2], v: match[3], a: match[4] };
        }
        if ((match = matchers.hex8.exec(color))) {
            return {
                a: convertHexToDecimal(match[1]),
                r: parseIntFromHex(match[2]),
                g: parseIntFromHex(match[3]),
                b: parseIntFromHex(match[4]),
                format: named ? "name" : "hex8"
            };
        }
        if ((match = matchers.hex6.exec(color))) {
            return {
                r: parseIntFromHex(match[1]),
                g: parseIntFromHex(match[2]),
                b: parseIntFromHex(match[3]),
                format: named ? "name" : "hex"
            };
        }
        if ((match = matchers.hex3.exec(color))) {
            return {
                r: parseIntFromHex(match[1] + '' + match[1]),
                g: parseIntFromHex(match[2] + '' + match[2]),
                b: parseIntFromHex(match[3] + '' + match[3]),
                format: named ? "name" : "hex"
            };
        }

        return false;
    }

    window.tinycolor = tinycolor;
    })();

    $(function () {
        if ($.fn.spectrum.load) {
            $.fn.spectrum.processNativeColorInputs();
        }
    });

});

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */
var saveAs=saveAs||function(e){"use strict";if(typeof e==="undefined"||typeof navigator!=="undefined"&&/MSIE [1-9]\./.test(navigator.userAgent)){return}var t=e.document,n=function(){return e.URL||e.webkitURL||e},r=t.createElementNS("http://www.w3.org/1999/xhtml","a"),o="download"in r,a=function(e){var t=new MouseEvent("click");e.dispatchEvent(t)},i=/constructor/i.test(e.HTMLElement)||e.safari,f=/CriOS\/[\d]+/.test(navigator.userAgent),u=function(t){(e.setImmediate||e.setTimeout)(function(){throw t},0)},s="application/octet-stream",d=1e3*40,c=function(e){var t=function(){if(typeof e==="string"){n().revokeObjectURL(e)}else{e.remove()}};setTimeout(t,d)},l=function(e,t,n){t=[].concat(t);var r=t.length;while(r--){var o=e["on"+t[r]];if(typeof o==="function"){try{o.call(e,n||e)}catch(a){u(a)}}}},p=function(e){if(/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type)){return new Blob([String.fromCharCode(65279),e],{type:e.type})}return e},v=function(t,u,d){if(!d){t=p(t)}var v=this,w=t.type,m=w===s,y,h=function(){l(v,"writestart progress write writeend".split(" "))},S=function(){if((f||m&&i)&&e.FileReader){var r=new FileReader;r.onloadend=function(){var t=f?r.result:r.result.replace(/^data:[^;]*;/,"data:attachment/file;");var n=e.open(t,"_blank");if(!n)e.location.href=t;t=undefined;v.readyState=v.DONE;h()};r.readAsDataURL(t);v.readyState=v.INIT;return}if(!y){y=n().createObjectURL(t)}if(m){e.location.href=y}else{var o=e.open(y,"_blank");if(!o){e.location.href=y}}v.readyState=v.DONE;h();c(y)};v.readyState=v.INIT;if(o){y=n().createObjectURL(t);setTimeout(function(){r.href=y;r.download=u;a(r);h();c(y);v.readyState=v.DONE});return}S()},w=v.prototype,m=function(e,t,n){return new v(e,t||e.name||"download",n)};if(typeof navigator!=="undefined"&&navigator.msSaveOrOpenBlob){return function(e,t,n){t=t||e.name||"download";if(!n){e=p(e)}return navigator.msSaveOrOpenBlob(e,t)}}w.abort=function(){};w.readyState=w.INIT=0;w.WRITING=1;w.DONE=2;w.error=w.onwritestart=w.onprogress=w.onwrite=w.onabort=w.onerror=w.onwriteend=null;return m}(typeof self!=="undefined"&&self||typeof window!=="undefined"&&window||this.content);if(typeof module!=="undefined"&&module.exports){module.exports.saveAs=saveAs}else if(typeof define!=="undefined"&&define!==null&&define.amd!==null){define("FileSaver.js",function(){return saveAs})}

/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.3.2
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

!function(t,a){if("object"==typeof exports&&"object"==typeof module)module.exports=a();else if("function"==typeof define&&define.amd)define([],a);else{var n=a();for(var r in n)("object"==typeof exports?exports:t)[r]=n[r]}}(this,function(){return function(t){function a(r){if(n[r])return n[r].exports;var o=n[r]={exports:{},id:r,loaded:!1};return t[r].call(o.exports,o,o.exports,a),o.loaded=!0,o.exports}var n={};return a.m=t,a.c=n,a.p="",a(0)}([function(t,a,n){a.glMatrix=n(1),a.mat2=n(2),a.mat2d=n(3),a.mat3=n(4),a.mat4=n(5),a.quat=n(6),a.vec2=n(9),a.vec3=n(7),a.vec4=n(8)},function(t,a){var n={};n.EPSILON=1e-6,n.ARRAY_TYPE="undefined"!=typeof Float32Array?Float32Array:Array,n.RANDOM=Math.random,n.ENABLE_SIMD=!1,n.SIMD_AVAILABLE=n.ARRAY_TYPE===Float32Array&&"SIMD"in this,n.USE_SIMD=n.ENABLE_SIMD&&n.SIMD_AVAILABLE,n.setMatrixArrayType=function(t){n.ARRAY_TYPE=t};var r=Math.PI/180;n.toRadian=function(t){return t*r},n.equals=function(t,a){return Math.abs(t-a)<=n.EPSILON*Math.max(1,Math.abs(t),Math.abs(a))},t.exports=n},function(t,a,n){var r=n(1),o={};o.create=function(){var t=new r.ARRAY_TYPE(4);return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t},o.clone=function(t){var a=new r.ARRAY_TYPE(4);return a[0]=t[0],a[1]=t[1],a[2]=t[2],a[3]=t[3],a},o.copy=function(t,a){return t[0]=a[0],t[1]=a[1],t[2]=a[2],t[3]=a[3],t},o.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t},o.fromValues=function(t,a,n,o){var u=new r.ARRAY_TYPE(4);return u[0]=t,u[1]=a,u[2]=n,u[3]=o,u},o.set=function(t,a,n,r,o){return t[0]=a,t[1]=n,t[2]=r,t[3]=o,t},o.transpose=function(t,a){if(t===a){var n=a[1];t[1]=a[2],t[2]=n}else t[0]=a[0],t[1]=a[2],t[2]=a[1],t[3]=a[3];return t},o.invert=function(t,a){var n=a[0],r=a[1],o=a[2],u=a[3],l=n*u-o*r;return l?(l=1/l,t[0]=u*l,t[1]=-r*l,t[2]=-o*l,t[3]=n*l,t):null},o.adjoint=function(t,a){var n=a[0];return t[0]=a[3],t[1]=-a[1],t[2]=-a[2],t[3]=n,t},o.determinant=function(t){return t[0]*t[3]-t[2]*t[1]},o.multiply=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=a[3],e=n[0],M=n[1],s=n[2],i=n[3];return t[0]=r*e+u*M,t[1]=o*e+l*M,t[2]=r*s+u*i,t[3]=o*s+l*i,t},o.mul=o.multiply,o.rotate=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=a[3],e=Math.sin(n),M=Math.cos(n);return t[0]=r*M+u*e,t[1]=o*M+l*e,t[2]=r*-e+u*M,t[3]=o*-e+l*M,t},o.scale=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=a[3],e=n[0],M=n[1];return t[0]=r*e,t[1]=o*e,t[2]=u*M,t[3]=l*M,t},o.fromRotation=function(t,a){var n=Math.sin(a),r=Math.cos(a);return t[0]=r,t[1]=n,t[2]=-n,t[3]=r,t},o.fromScaling=function(t,a){return t[0]=a[0],t[1]=0,t[2]=0,t[3]=a[1],t},o.str=function(t){return"mat2("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"},o.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2))},o.LDU=function(t,a,n,r){return t[2]=r[2]/r[0],n[0]=r[0],n[1]=r[1],n[3]=r[3]-t[2]*n[1],[t,a,n]},o.add=function(t,a,n){return t[0]=a[0]+n[0],t[1]=a[1]+n[1],t[2]=a[2]+n[2],t[3]=a[3]+n[3],t},o.subtract=function(t,a,n){return t[0]=a[0]-n[0],t[1]=a[1]-n[1],t[2]=a[2]-n[2],t[3]=a[3]-n[3],t},o.sub=o.subtract,o.exactEquals=function(t,a){return t[0]===a[0]&&t[1]===a[1]&&t[2]===a[2]&&t[3]===a[3]},o.equals=function(t,a){var n=t[0],o=t[1],u=t[2],l=t[3],e=a[0],M=a[1],s=a[2],i=a[3];return Math.abs(n-e)<=r.EPSILON*Math.max(1,Math.abs(n),Math.abs(e))&&Math.abs(o-M)<=r.EPSILON*Math.max(1,Math.abs(o),Math.abs(M))&&Math.abs(u-s)<=r.EPSILON*Math.max(1,Math.abs(u),Math.abs(s))&&Math.abs(l-i)<=r.EPSILON*Math.max(1,Math.abs(l),Math.abs(i))},o.multiplyScalar=function(t,a,n){return t[0]=a[0]*n,t[1]=a[1]*n,t[2]=a[2]*n,t[3]=a[3]*n,t},o.multiplyScalarAndAdd=function(t,a,n,r){return t[0]=a[0]+n[0]*r,t[1]=a[1]+n[1]*r,t[2]=a[2]+n[2]*r,t[3]=a[3]+n[3]*r,t},t.exports=o},function(t,a,n){var r=n(1),o={};o.create=function(){var t=new r.ARRAY_TYPE(6);return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t},o.clone=function(t){var a=new r.ARRAY_TYPE(6);return a[0]=t[0],a[1]=t[1],a[2]=t[2],a[3]=t[3],a[4]=t[4],a[5]=t[5],a},o.copy=function(t,a){return t[0]=a[0],t[1]=a[1],t[2]=a[2],t[3]=a[3],t[4]=a[4],t[5]=a[5],t},o.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t},o.fromValues=function(t,a,n,o,u,l){var e=new r.ARRAY_TYPE(6);return e[0]=t,e[1]=a,e[2]=n,e[3]=o,e[4]=u,e[5]=l,e},o.set=function(t,a,n,r,o,u,l){return t[0]=a,t[1]=n,t[2]=r,t[3]=o,t[4]=u,t[5]=l,t},o.invert=function(t,a){var n=a[0],r=a[1],o=a[2],u=a[3],l=a[4],e=a[5],M=n*u-r*o;return M?(M=1/M,t[0]=u*M,t[1]=-r*M,t[2]=-o*M,t[3]=n*M,t[4]=(o*e-u*l)*M,t[5]=(r*l-n*e)*M,t):null},o.determinant=function(t){return t[0]*t[3]-t[1]*t[2]},o.multiply=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=a[3],e=a[4],M=a[5],s=n[0],i=n[1],c=n[2],h=n[3],S=n[4],I=n[5];return t[0]=r*s+u*i,t[1]=o*s+l*i,t[2]=r*c+u*h,t[3]=o*c+l*h,t[4]=r*S+u*I+e,t[5]=o*S+l*I+M,t},o.mul=o.multiply,o.rotate=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=a[3],e=a[4],M=a[5],s=Math.sin(n),i=Math.cos(n);return t[0]=r*i+u*s,t[1]=o*i+l*s,t[2]=r*-s+u*i,t[3]=o*-s+l*i,t[4]=e,t[5]=M,t},o.scale=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=a[3],e=a[4],M=a[5],s=n[0],i=n[1];return t[0]=r*s,t[1]=o*s,t[2]=u*i,t[3]=l*i,t[4]=e,t[5]=M,t},o.translate=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=a[3],e=a[4],M=a[5],s=n[0],i=n[1];return t[0]=r,t[1]=o,t[2]=u,t[3]=l,t[4]=r*s+u*i+e,t[5]=o*s+l*i+M,t},o.fromRotation=function(t,a){var n=Math.sin(a),r=Math.cos(a);return t[0]=r,t[1]=n,t[2]=-n,t[3]=r,t[4]=0,t[5]=0,t},o.fromScaling=function(t,a){return t[0]=a[0],t[1]=0,t[2]=0,t[3]=a[1],t[4]=0,t[5]=0,t},o.fromTranslation=function(t,a){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=a[0],t[5]=a[1],t},o.str=function(t){return"mat2d("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+")"},o.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+1)},o.add=function(t,a,n){return t[0]=a[0]+n[0],t[1]=a[1]+n[1],t[2]=a[2]+n[2],t[3]=a[3]+n[3],t[4]=a[4]+n[4],t[5]=a[5]+n[5],t},o.subtract=function(t,a,n){return t[0]=a[0]-n[0],t[1]=a[1]-n[1],t[2]=a[2]-n[2],t[3]=a[3]-n[3],t[4]=a[4]-n[4],t[5]=a[5]-n[5],t},o.sub=o.subtract,o.multiplyScalar=function(t,a,n){return t[0]=a[0]*n,t[1]=a[1]*n,t[2]=a[2]*n,t[3]=a[3]*n,t[4]=a[4]*n,t[5]=a[5]*n,t},o.multiplyScalarAndAdd=function(t,a,n,r){return t[0]=a[0]+n[0]*r,t[1]=a[1]+n[1]*r,t[2]=a[2]+n[2]*r,t[3]=a[3]+n[3]*r,t[4]=a[4]+n[4]*r,t[5]=a[5]+n[5]*r,t},o.exactEquals=function(t,a){return t[0]===a[0]&&t[1]===a[1]&&t[2]===a[2]&&t[3]===a[3]&&t[4]===a[4]&&t[5]===a[5]},o.equals=function(t,a){var n=t[0],o=t[1],u=t[2],l=t[3],e=t[4],M=t[5],s=a[0],i=a[1],c=a[2],h=a[3],S=a[4],I=a[5];return Math.abs(n-s)<=r.EPSILON*Math.max(1,Math.abs(n),Math.abs(s))&&Math.abs(o-i)<=r.EPSILON*Math.max(1,Math.abs(o),Math.abs(i))&&Math.abs(u-c)<=r.EPSILON*Math.max(1,Math.abs(u),Math.abs(c))&&Math.abs(l-h)<=r.EPSILON*Math.max(1,Math.abs(l),Math.abs(h))&&Math.abs(e-S)<=r.EPSILON*Math.max(1,Math.abs(e),Math.abs(S))&&Math.abs(M-I)<=r.EPSILON*Math.max(1,Math.abs(M),Math.abs(I))},t.exports=o},function(t,a,n){var r=n(1),o={};o.create=function(){var t=new r.ARRAY_TYPE(9);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},o.fromMat4=function(t,a){return t[0]=a[0],t[1]=a[1],t[2]=a[2],t[3]=a[4],t[4]=a[5],t[5]=a[6],t[6]=a[8],t[7]=a[9],t[8]=a[10],t},o.clone=function(t){var a=new r.ARRAY_TYPE(9);return a[0]=t[0],a[1]=t[1],a[2]=t[2],a[3]=t[3],a[4]=t[4],a[5]=t[5],a[6]=t[6],a[7]=t[7],a[8]=t[8],a},o.copy=function(t,a){return t[0]=a[0],t[1]=a[1],t[2]=a[2],t[3]=a[3],t[4]=a[4],t[5]=a[5],t[6]=a[6],t[7]=a[7],t[8]=a[8],t},o.fromValues=function(t,a,n,o,u,l,e,M,s){var i=new r.ARRAY_TYPE(9);return i[0]=t,i[1]=a,i[2]=n,i[3]=o,i[4]=u,i[5]=l,i[6]=e,i[7]=M,i[8]=s,i},o.set=function(t,a,n,r,o,u,l,e,M,s){return t[0]=a,t[1]=n,t[2]=r,t[3]=o,t[4]=u,t[5]=l,t[6]=e,t[7]=M,t[8]=s,t},o.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},o.transpose=function(t,a){if(t===a){var n=a[1],r=a[2],o=a[5];t[1]=a[3],t[2]=a[6],t[3]=n,t[5]=a[7],t[6]=r,t[7]=o}else t[0]=a[0],t[1]=a[3],t[2]=a[6],t[3]=a[1],t[4]=a[4],t[5]=a[7],t[6]=a[2],t[7]=a[5],t[8]=a[8];return t},o.invert=function(t,a){var n=a[0],r=a[1],o=a[2],u=a[3],l=a[4],e=a[5],M=a[6],s=a[7],i=a[8],c=i*l-e*s,h=-i*u+e*M,S=s*u-l*M,I=n*c+r*h+o*S;return I?(I=1/I,t[0]=c*I,t[1]=(-i*r+o*s)*I,t[2]=(e*r-o*l)*I,t[3]=h*I,t[4]=(i*n-o*M)*I,t[5]=(-e*n+o*u)*I,t[6]=S*I,t[7]=(-s*n+r*M)*I,t[8]=(l*n-r*u)*I,t):null},o.adjoint=function(t,a){var n=a[0],r=a[1],o=a[2],u=a[3],l=a[4],e=a[5],M=a[6],s=a[7],i=a[8];return t[0]=l*i-e*s,t[1]=o*s-r*i,t[2]=r*e-o*l,t[3]=e*M-u*i,t[4]=n*i-o*M,t[5]=o*u-n*e,t[6]=u*s-l*M,t[7]=r*M-n*s,t[8]=n*l-r*u,t},o.determinant=function(t){var a=t[0],n=t[1],r=t[2],o=t[3],u=t[4],l=t[5],e=t[6],M=t[7],s=t[8];return a*(s*u-l*M)+n*(-s*o+l*e)+r*(M*o-u*e)},o.multiply=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=a[3],e=a[4],M=a[5],s=a[6],i=a[7],c=a[8],h=n[0],S=n[1],I=n[2],f=n[3],x=n[4],D=n[5],F=n[6],m=n[7],d=n[8];return t[0]=h*r+S*l+I*s,t[1]=h*o+S*e+I*i,t[2]=h*u+S*M+I*c,t[3]=f*r+x*l+D*s,t[4]=f*o+x*e+D*i,t[5]=f*u+x*M+D*c,t[6]=F*r+m*l+d*s,t[7]=F*o+m*e+d*i,t[8]=F*u+m*M+d*c,t},o.mul=o.multiply,o.translate=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=a[3],e=a[4],M=a[5],s=a[6],i=a[7],c=a[8],h=n[0],S=n[1];return t[0]=r,t[1]=o,t[2]=u,t[3]=l,t[4]=e,t[5]=M,t[6]=h*r+S*l+s,t[7]=h*o+S*e+i,t[8]=h*u+S*M+c,t},o.rotate=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=a[3],e=a[4],M=a[5],s=a[6],i=a[7],c=a[8],h=Math.sin(n),S=Math.cos(n);return t[0]=S*r+h*l,t[1]=S*o+h*e,t[2]=S*u+h*M,t[3]=S*l-h*r,t[4]=S*e-h*o,t[5]=S*M-h*u,t[6]=s,t[7]=i,t[8]=c,t},o.scale=function(t,a,n){var r=n[0],o=n[1];return t[0]=r*a[0],t[1]=r*a[1],t[2]=r*a[2],t[3]=o*a[3],t[4]=o*a[4],t[5]=o*a[5],t[6]=a[6],t[7]=a[7],t[8]=a[8],t},o.fromTranslation=function(t,a){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=a[0],t[7]=a[1],t[8]=1,t},o.fromRotation=function(t,a){var n=Math.sin(a),r=Math.cos(a);return t[0]=r,t[1]=n,t[2]=0,t[3]=-n,t[4]=r,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},o.fromScaling=function(t,a){return t[0]=a[0],t[1]=0,t[2]=0,t[3]=0,t[4]=a[1],t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},o.fromMat2d=function(t,a){return t[0]=a[0],t[1]=a[1],t[2]=0,t[3]=a[2],t[4]=a[3],t[5]=0,t[6]=a[4],t[7]=a[5],t[8]=1,t},o.fromQuat=function(t,a){var n=a[0],r=a[1],o=a[2],u=a[3],l=n+n,e=r+r,M=o+o,s=n*l,i=r*l,c=r*e,h=o*l,S=o*e,I=o*M,f=u*l,x=u*e,D=u*M;return t[0]=1-c-I,t[3]=i-D,t[6]=h+x,t[1]=i+D,t[4]=1-s-I,t[7]=S-f,t[2]=h-x,t[5]=S+f,t[8]=1-s-c,t},o.normalFromMat4=function(t,a){var n=a[0],r=a[1],o=a[2],u=a[3],l=a[4],e=a[5],M=a[6],s=a[7],i=a[8],c=a[9],h=a[10],S=a[11],I=a[12],f=a[13],x=a[14],D=a[15],F=n*e-r*l,m=n*M-o*l,d=n*s-u*l,b=r*M-o*e,v=r*s-u*e,z=o*s-u*M,p=i*f-c*I,w=i*x-h*I,E=i*D-S*I,A=c*x-h*f,P=c*D-S*f,L=h*D-S*x,q=F*L-m*P+d*A+b*E-v*w+z*p;return q?(q=1/q,t[0]=(e*L-M*P+s*A)*q,t[1]=(M*E-l*L-s*w)*q,t[2]=(l*P-e*E+s*p)*q,t[3]=(o*P-r*L-u*A)*q,t[4]=(n*L-o*E+u*w)*q,t[5]=(r*E-n*P-u*p)*q,t[6]=(f*z-x*v+D*b)*q,t[7]=(x*d-I*z-D*m)*q,t[8]=(I*v-f*d+D*F)*q,t):null},o.str=function(t){return"mat3("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+", "+t[8]+")"},o.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+Math.pow(t[6],2)+Math.pow(t[7],2)+Math.pow(t[8],2))},o.add=function(t,a,n){return t[0]=a[0]+n[0],t[1]=a[1]+n[1],t[2]=a[2]+n[2],t[3]=a[3]+n[3],t[4]=a[4]+n[4],t[5]=a[5]+n[5],t[6]=a[6]+n[6],t[7]=a[7]+n[7],t[8]=a[8]+n[8],t},o.subtract=function(t,a,n){return t[0]=a[0]-n[0],t[1]=a[1]-n[1],t[2]=a[2]-n[2],t[3]=a[3]-n[3],t[4]=a[4]-n[4],t[5]=a[5]-n[5],t[6]=a[6]-n[6],t[7]=a[7]-n[7],t[8]=a[8]-n[8],t},o.sub=o.subtract,o.multiplyScalar=function(t,a,n){return t[0]=a[0]*n,t[1]=a[1]*n,t[2]=a[2]*n,t[3]=a[3]*n,t[4]=a[4]*n,t[5]=a[5]*n,t[6]=a[6]*n,t[7]=a[7]*n,t[8]=a[8]*n,t},o.multiplyScalarAndAdd=function(t,a,n,r){return t[0]=a[0]+n[0]*r,t[1]=a[1]+n[1]*r,t[2]=a[2]+n[2]*r,t[3]=a[3]+n[3]*r,t[4]=a[4]+n[4]*r,t[5]=a[5]+n[5]*r,t[6]=a[6]+n[6]*r,t[7]=a[7]+n[7]*r,t[8]=a[8]+n[8]*r,t},o.exactEquals=function(t,a){return t[0]===a[0]&&t[1]===a[1]&&t[2]===a[2]&&t[3]===a[3]&&t[4]===a[4]&&t[5]===a[5]&&t[6]===a[6]&&t[7]===a[7]&&t[8]===a[8]},o.equals=function(t,a){var n=t[0],o=t[1],u=t[2],l=t[3],e=t[4],M=t[5],s=t[6],i=t[7],c=t[8],h=a[0],S=a[1],I=a[2],f=a[3],x=a[4],D=a[5],F=t[6],m=a[7],d=a[8];return Math.abs(n-h)<=r.EPSILON*Math.max(1,Math.abs(n),Math.abs(h))&&Math.abs(o-S)<=r.EPSILON*Math.max(1,Math.abs(o),Math.abs(S))&&Math.abs(u-I)<=r.EPSILON*Math.max(1,Math.abs(u),Math.abs(I))&&Math.abs(l-f)<=r.EPSILON*Math.max(1,Math.abs(l),Math.abs(f))&&Math.abs(e-x)<=r.EPSILON*Math.max(1,Math.abs(e),Math.abs(x))&&Math.abs(M-D)<=r.EPSILON*Math.max(1,Math.abs(M),Math.abs(D))&&Math.abs(s-F)<=r.EPSILON*Math.max(1,Math.abs(s),Math.abs(F))&&Math.abs(i-m)<=r.EPSILON*Math.max(1,Math.abs(i),Math.abs(m))&&Math.abs(c-d)<=r.EPSILON*Math.max(1,Math.abs(c),Math.abs(d))},t.exports=o},function(t,a,n){var r=n(1),o={scalar:{},SIMD:{}};o.create=function(){var t=new r.ARRAY_TYPE(16);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},o.clone=function(t){var a=new r.ARRAY_TYPE(16);return a[0]=t[0],a[1]=t[1],a[2]=t[2],a[3]=t[3],a[4]=t[4],a[5]=t[5],a[6]=t[6],a[7]=t[7],a[8]=t[8],a[9]=t[9],a[10]=t[10],a[11]=t[11],a[12]=t[12],a[13]=t[13],a[14]=t[14],a[15]=t[15],a},o.copy=function(t,a){return t[0]=a[0],t[1]=a[1],t[2]=a[2],t[3]=a[3],t[4]=a[4],t[5]=a[5],t[6]=a[6],t[7]=a[7],t[8]=a[8],t[9]=a[9],t[10]=a[10],t[11]=a[11],t[12]=a[12],t[13]=a[13],t[14]=a[14],t[15]=a[15],t},o.fromValues=function(t,a,n,o,u,l,e,M,s,i,c,h,S,I,f,x){var D=new r.ARRAY_TYPE(16);return D[0]=t,D[1]=a,D[2]=n,D[3]=o,D[4]=u,D[5]=l,D[6]=e,D[7]=M,D[8]=s,D[9]=i,D[10]=c,D[11]=h,D[12]=S,D[13]=I,D[14]=f,D[15]=x,D},o.set=function(t,a,n,r,o,u,l,e,M,s,i,c,h,S,I,f,x){return t[0]=a,t[1]=n,t[2]=r,t[3]=o,t[4]=u,t[5]=l,t[6]=e,t[7]=M,t[8]=s,t[9]=i,t[10]=c,t[11]=h,t[12]=S,t[13]=I,t[14]=f,t[15]=x,t},o.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},o.scalar.transpose=function(t,a){if(t===a){var n=a[1],r=a[2],o=a[3],u=a[6],l=a[7],e=a[11];t[1]=a[4],t[2]=a[8],t[3]=a[12],t[4]=n,t[6]=a[9],t[7]=a[13],t[8]=r,t[9]=u,t[11]=a[14],t[12]=o,t[13]=l,t[14]=e}else t[0]=a[0],t[1]=a[4],t[2]=a[8],t[3]=a[12],t[4]=a[1],t[5]=a[5],t[6]=a[9],t[7]=a[13],t[8]=a[2],t[9]=a[6],t[10]=a[10],t[11]=a[14],t[12]=a[3],t[13]=a[7],t[14]=a[11],t[15]=a[15];return t},o.SIMD.transpose=function(t,a){var n,r,o,u,l,e,M,s,i,c;return n=SIMD.Float32x4.load(a,0),r=SIMD.Float32x4.load(a,4),o=SIMD.Float32x4.load(a,8),u=SIMD.Float32x4.load(a,12),l=SIMD.Float32x4.shuffle(n,r,0,1,4,5),e=SIMD.Float32x4.shuffle(o,u,0,1,4,5),M=SIMD.Float32x4.shuffle(l,e,0,2,4,6),s=SIMD.Float32x4.shuffle(l,e,1,3,5,7),SIMD.Float32x4.store(t,0,M),SIMD.Float32x4.store(t,4,s),l=SIMD.Float32x4.shuffle(n,r,2,3,6,7),e=SIMD.Float32x4.shuffle(o,u,2,3,6,7),i=SIMD.Float32x4.shuffle(l,e,0,2,4,6),c=SIMD.Float32x4.shuffle(l,e,1,3,5,7),SIMD.Float32x4.store(t,8,i),SIMD.Float32x4.store(t,12,c),t},o.transpose=r.USE_SIMD?o.SIMD.transpose:o.scalar.transpose,o.scalar.invert=function(t,a){var n=a[0],r=a[1],o=a[2],u=a[3],l=a[4],e=a[5],M=a[6],s=a[7],i=a[8],c=a[9],h=a[10],S=a[11],I=a[12],f=a[13],x=a[14],D=a[15],F=n*e-r*l,m=n*M-o*l,d=n*s-u*l,b=r*M-o*e,v=r*s-u*e,z=o*s-u*M,p=i*f-c*I,w=i*x-h*I,E=i*D-S*I,A=c*x-h*f,P=c*D-S*f,L=h*D-S*x,q=F*L-m*P+d*A+b*E-v*w+z*p;return q?(q=1/q,t[0]=(e*L-M*P+s*A)*q,t[1]=(o*P-r*L-u*A)*q,t[2]=(f*z-x*v+D*b)*q,t[3]=(h*v-c*z-S*b)*q,t[4]=(M*E-l*L-s*w)*q,t[5]=(n*L-o*E+u*w)*q,t[6]=(x*d-I*z-D*m)*q,t[7]=(i*z-h*d+S*m)*q,t[8]=(l*P-e*E+s*p)*q,t[9]=(r*E-n*P-u*p)*q,t[10]=(I*v-f*d+D*F)*q,t[11]=(c*d-i*v-S*F)*q,t[12]=(e*w-l*A-M*p)*q,t[13]=(n*A-r*w+o*p)*q,t[14]=(f*m-I*b-x*F)*q,t[15]=(i*b-c*m+h*F)*q,t):null},o.SIMD.invert=function(t,a){var n,r,o,u,l,e,M,s,i,c,h=SIMD.Float32x4.load(a,0),S=SIMD.Float32x4.load(a,4),I=SIMD.Float32x4.load(a,8),f=SIMD.Float32x4.load(a,12);return l=SIMD.Float32x4.shuffle(h,S,0,1,4,5),r=SIMD.Float32x4.shuffle(I,f,0,1,4,5),n=SIMD.Float32x4.shuffle(l,r,0,2,4,6),r=SIMD.Float32x4.shuffle(r,l,1,3,5,7),l=SIMD.Float32x4.shuffle(h,S,2,3,6,7),u=SIMD.Float32x4.shuffle(I,f,2,3,6,7),o=SIMD.Float32x4.shuffle(l,u,0,2,4,6),u=SIMD.Float32x4.shuffle(u,l,1,3,5,7),l=SIMD.Float32x4.mul(o,u),l=SIMD.Float32x4.swizzle(l,1,0,3,2),e=SIMD.Float32x4.mul(r,l),M=SIMD.Float32x4.mul(n,l),l=SIMD.Float32x4.swizzle(l,2,3,0,1),e=SIMD.Float32x4.sub(SIMD.Float32x4.mul(r,l),e),M=SIMD.Float32x4.sub(SIMD.Float32x4.mul(n,l),M),M=SIMD.Float32x4.swizzle(M,2,3,0,1),l=SIMD.Float32x4.mul(r,o),l=SIMD.Float32x4.swizzle(l,1,0,3,2),e=SIMD.Float32x4.add(SIMD.Float32x4.mul(u,l),e),i=SIMD.Float32x4.mul(n,l),l=SIMD.Float32x4.swizzle(l,2,3,0,1),e=SIMD.Float32x4.sub(e,SIMD.Float32x4.mul(u,l)),i=SIMD.Float32x4.sub(SIMD.Float32x4.mul(n,l),i),i=SIMD.Float32x4.swizzle(i,2,3,0,1),l=SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(r,2,3,0,1),u),l=SIMD.Float32x4.swizzle(l,1,0,3,2),o=SIMD.Float32x4.swizzle(o,2,3,0,1),e=SIMD.Float32x4.add(SIMD.Float32x4.mul(o,l),e),s=SIMD.Float32x4.mul(n,l),l=SIMD.Float32x4.swizzle(l,2,3,0,1),e=SIMD.Float32x4.sub(e,SIMD.Float32x4.mul(o,l)),s=SIMD.Float32x4.sub(SIMD.Float32x4.mul(n,l),s),s=SIMD.Float32x4.swizzle(s,2,3,0,1),l=SIMD.Float32x4.mul(n,r),l=SIMD.Float32x4.swizzle(l,1,0,3,2),s=SIMD.Float32x4.add(SIMD.Float32x4.mul(u,l),s),i=SIMD.Float32x4.sub(SIMD.Float32x4.mul(o,l),i),l=SIMD.Float32x4.swizzle(l,2,3,0,1),s=SIMD.Float32x4.sub(SIMD.Float32x4.mul(u,l),s),i=SIMD.Float32x4.sub(i,SIMD.Float32x4.mul(o,l)),l=SIMD.Float32x4.mul(n,u),l=SIMD.Float32x4.swizzle(l,1,0,3,2),M=SIMD.Float32x4.sub(M,SIMD.Float32x4.mul(o,l)),s=SIMD.Float32x4.add(SIMD.Float32x4.mul(r,l),s),l=SIMD.Float32x4.swizzle(l,2,3,0,1),M=SIMD.Float32x4.add(SIMD.Float32x4.mul(o,l),M),s=SIMD.Float32x4.sub(s,SIMD.Float32x4.mul(r,l)),l=SIMD.Float32x4.mul(n,o),l=SIMD.Float32x4.swizzle(l,1,0,3,2),M=SIMD.Float32x4.add(SIMD.Float32x4.mul(u,l),M),i=SIMD.Float32x4.sub(i,SIMD.Float32x4.mul(r,l)),l=SIMD.Float32x4.swizzle(l,2,3,0,1),M=SIMD.Float32x4.sub(M,SIMD.Float32x4.mul(u,l)),i=SIMD.Float32x4.add(SIMD.Float32x4.mul(r,l),i),c=SIMD.Float32x4.mul(n,e),c=SIMD.Float32x4.add(SIMD.Float32x4.swizzle(c,2,3,0,1),c),c=SIMD.Float32x4.add(SIMD.Float32x4.swizzle(c,1,0,3,2),c),l=SIMD.Float32x4.reciprocalApproximation(c),c=SIMD.Float32x4.sub(SIMD.Float32x4.add(l,l),SIMD.Float32x4.mul(c,SIMD.Float32x4.mul(l,l))),(c=SIMD.Float32x4.swizzle(c,0,0,0,0))?(SIMD.Float32x4.store(t,0,SIMD.Float32x4.mul(c,e)),SIMD.Float32x4.store(t,4,SIMD.Float32x4.mul(c,M)),SIMD.Float32x4.store(t,8,SIMD.Float32x4.mul(c,s)),SIMD.Float32x4.store(t,12,SIMD.Float32x4.mul(c,i)),t):null},o.invert=r.USE_SIMD?o.SIMD.invert:o.scalar.invert,o.scalar.adjoint=function(t,a){var n=a[0],r=a[1],o=a[2],u=a[3],l=a[4],e=a[5],M=a[6],s=a[7],i=a[8],c=a[9],h=a[10],S=a[11],I=a[12],f=a[13],x=a[14],D=a[15];return t[0]=e*(h*D-S*x)-c*(M*D-s*x)+f*(M*S-s*h),t[1]=-(r*(h*D-S*x)-c*(o*D-u*x)+f*(o*S-u*h)),t[2]=r*(M*D-s*x)-e*(o*D-u*x)+f*(o*s-u*M),t[3]=-(r*(M*S-s*h)-e*(o*S-u*h)+c*(o*s-u*M)),t[4]=-(l*(h*D-S*x)-i*(M*D-s*x)+I*(M*S-s*h)),t[5]=n*(h*D-S*x)-i*(o*D-u*x)+I*(o*S-u*h),t[6]=-(n*(M*D-s*x)-l*(o*D-u*x)+I*(o*s-u*M)),t[7]=n*(M*S-s*h)-l*(o*S-u*h)+i*(o*s-u*M),t[8]=l*(c*D-S*f)-i*(e*D-s*f)+I*(e*S-s*c),t[9]=-(n*(c*D-S*f)-i*(r*D-u*f)+I*(r*S-u*c)),t[10]=n*(e*D-s*f)-l*(r*D-u*f)+I*(r*s-u*e),t[11]=-(n*(e*S-s*c)-l*(r*S-u*c)+i*(r*s-u*e)),t[12]=-(l*(c*x-h*f)-i*(e*x-M*f)+I*(e*h-M*c)),t[13]=n*(c*x-h*f)-i*(r*x-o*f)+I*(r*h-o*c),t[14]=-(n*(e*x-M*f)-l*(r*x-o*f)+I*(r*M-o*e)),t[15]=n*(e*h-M*c)-l*(r*h-o*c)+i*(r*M-o*e),t},o.SIMD.adjoint=function(t,a){var n,r,o,u,l,e,M,s,i,c,h,S,I,n=SIMD.Float32x4.load(a,0),r=SIMD.Float32x4.load(a,4),o=SIMD.Float32x4.load(a,8),u=SIMD.Float32x4.load(a,12);return i=SIMD.Float32x4.shuffle(n,r,0,1,4,5),e=SIMD.Float32x4.shuffle(o,u,0,1,4,5),l=SIMD.Float32x4.shuffle(i,e,0,2,4,6),e=SIMD.Float32x4.shuffle(e,i,1,3,5,7),i=SIMD.Float32x4.shuffle(n,r,2,3,6,7),s=SIMD.Float32x4.shuffle(o,u,2,3,6,7),M=SIMD.Float32x4.shuffle(i,s,0,2,4,6),s=SIMD.Float32x4.shuffle(s,i,1,3,5,7),i=SIMD.Float32x4.mul(M,s),i=SIMD.Float32x4.swizzle(i,1,0,3,2),c=SIMD.Float32x4.mul(e,i),h=SIMD.Float32x4.mul(l,i),i=SIMD.Float32x4.swizzle(i,2,3,0,1),c=SIMD.Float32x4.sub(SIMD.Float32x4.mul(e,i),c),h=SIMD.Float32x4.sub(SIMD.Float32x4.mul(l,i),h),h=SIMD.Float32x4.swizzle(h,2,3,0,1),i=SIMD.Float32x4.mul(e,M),i=SIMD.Float32x4.swizzle(i,1,0,3,2),c=SIMD.Float32x4.add(SIMD.Float32x4.mul(s,i),c),I=SIMD.Float32x4.mul(l,i),i=SIMD.Float32x4.swizzle(i,2,3,0,1),c=SIMD.Float32x4.sub(c,SIMD.Float32x4.mul(s,i)),I=SIMD.Float32x4.sub(SIMD.Float32x4.mul(l,i),I),I=SIMD.Float32x4.swizzle(I,2,3,0,1),i=SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(e,2,3,0,1),s),i=SIMD.Float32x4.swizzle(i,1,0,3,2),M=SIMD.Float32x4.swizzle(M,2,3,0,1),c=SIMD.Float32x4.add(SIMD.Float32x4.mul(M,i),c),S=SIMD.Float32x4.mul(l,i),i=SIMD.Float32x4.swizzle(i,2,3,0,1),c=SIMD.Float32x4.sub(c,SIMD.Float32x4.mul(M,i)),S=SIMD.Float32x4.sub(SIMD.Float32x4.mul(l,i),S),S=SIMD.Float32x4.swizzle(S,2,3,0,1),i=SIMD.Float32x4.mul(l,e),i=SIMD.Float32x4.swizzle(i,1,0,3,2),S=SIMD.Float32x4.add(SIMD.Float32x4.mul(s,i),S),I=SIMD.Float32x4.sub(SIMD.Float32x4.mul(M,i),I),i=SIMD.Float32x4.swizzle(i,2,3,0,1),S=SIMD.Float32x4.sub(SIMD.Float32x4.mul(s,i),S),I=SIMD.Float32x4.sub(I,SIMD.Float32x4.mul(M,i)),i=SIMD.Float32x4.mul(l,s),i=SIMD.Float32x4.swizzle(i,1,0,3,2),h=SIMD.Float32x4.sub(h,SIMD.Float32x4.mul(M,i)),S=SIMD.Float32x4.add(SIMD.Float32x4.mul(e,i),S),i=SIMD.Float32x4.swizzle(i,2,3,0,1),h=SIMD.Float32x4.add(SIMD.Float32x4.mul(M,i),h),S=SIMD.Float32x4.sub(S,SIMD.Float32x4.mul(e,i)),i=SIMD.Float32x4.mul(l,M),i=SIMD.Float32x4.swizzle(i,1,0,3,2),h=SIMD.Float32x4.add(SIMD.Float32x4.mul(s,i),h),I=SIMD.Float32x4.sub(I,SIMD.Float32x4.mul(e,i)),i=SIMD.Float32x4.swizzle(i,2,3,0,1),h=SIMD.Float32x4.sub(h,SIMD.Float32x4.mul(s,i)),I=SIMD.Float32x4.add(SIMD.Float32x4.mul(e,i),I),SIMD.Float32x4.store(t,0,c),SIMD.Float32x4.store(t,4,h),SIMD.Float32x4.store(t,8,S),SIMD.Float32x4.store(t,12,I),t},o.adjoint=r.USE_SIMD?o.SIMD.adjoint:o.scalar.adjoint,o.determinant=function(t){var a=t[0],n=t[1],r=t[2],o=t[3],u=t[4],l=t[5],e=t[6],M=t[7],s=t[8],i=t[9],c=t[10],h=t[11],S=t[12],I=t[13],f=t[14],x=t[15],D=a*l-n*u,F=a*e-r*u,m=a*M-o*u,d=n*e-r*l,b=n*M-o*l,v=r*M-o*e,z=s*I-i*S,p=s*f-c*S,w=s*x-h*S,E=i*f-c*I,A=i*x-h*I,P=c*x-h*f;return D*P-F*A+m*E+d*w-b*p+v*z},o.SIMD.multiply=function(t,a,n){var r=SIMD.Float32x4.load(a,0),o=SIMD.Float32x4.load(a,4),u=SIMD.Float32x4.load(a,8),l=SIMD.Float32x4.load(a,12),e=SIMD.Float32x4.load(n,0),M=SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(e,0,0,0,0),r),SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(e,1,1,1,1),o),SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(e,2,2,2,2),u),SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(e,3,3,3,3),l))));SIMD.Float32x4.store(t,0,M);var s=SIMD.Float32x4.load(n,4),i=SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(s,0,0,0,0),r),SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(s,1,1,1,1),o),SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(s,2,2,2,2),u),SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(s,3,3,3,3),l))));SIMD.Float32x4.store(t,4,i);var c=SIMD.Float32x4.load(n,8),h=SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(c,0,0,0,0),r),SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(c,1,1,1,1),o),SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(c,2,2,2,2),u),SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(c,3,3,3,3),l))));SIMD.Float32x4.store(t,8,h);var S=SIMD.Float32x4.load(n,12),I=SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(S,0,0,0,0),r),SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(S,1,1,1,1),o),SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(S,2,2,2,2),u),SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(S,3,3,3,3),l))));return SIMD.Float32x4.store(t,12,I),t},o.scalar.multiply=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=a[3],e=a[4],M=a[5],s=a[6],i=a[7],c=a[8],h=a[9],S=a[10],I=a[11],f=a[12],x=a[13],D=a[14],F=a[15],m=n[0],d=n[1],b=n[2],v=n[3];return t[0]=m*r+d*e+b*c+v*f,t[1]=m*o+d*M+b*h+v*x,t[2]=m*u+d*s+b*S+v*D,t[3]=m*l+d*i+b*I+v*F,m=n[4],d=n[5],b=n[6],v=n[7],t[4]=m*r+d*e+b*c+v*f,t[5]=m*o+d*M+b*h+v*x,t[6]=m*u+d*s+b*S+v*D,t[7]=m*l+d*i+b*I+v*F,m=n[8],d=n[9],b=n[10],v=n[11],t[8]=m*r+d*e+b*c+v*f,t[9]=m*o+d*M+b*h+v*x,t[10]=m*u+d*s+b*S+v*D,t[11]=m*l+d*i+b*I+v*F,m=n[12],d=n[13],b=n[14],v=n[15],t[12]=m*r+d*e+b*c+v*f,t[13]=m*o+d*M+b*h+v*x,t[14]=m*u+d*s+b*S+v*D,t[15]=m*l+d*i+b*I+v*F,t},o.multiply=r.USE_SIMD?o.SIMD.multiply:o.scalar.multiply,o.mul=o.multiply,o.scalar.translate=function(t,a,n){var r,o,u,l,e,M,s,i,c,h,S,I,f=n[0],x=n[1],D=n[2];return a===t?(t[12]=a[0]*f+a[4]*x+a[8]*D+a[12],t[13]=a[1]*f+a[5]*x+a[9]*D+a[13],t[14]=a[2]*f+a[6]*x+a[10]*D+a[14],t[15]=a[3]*f+a[7]*x+a[11]*D+a[15]):(r=a[0],o=a[1],u=a[2],l=a[3],e=a[4],M=a[5],s=a[6],i=a[7],c=a[8],h=a[9],S=a[10],I=a[11],t[0]=r,t[1]=o,t[2]=u,t[3]=l,t[4]=e,t[5]=M,t[6]=s,t[7]=i,t[8]=c,t[9]=h,t[10]=S,t[11]=I,t[12]=r*f+e*x+c*D+a[12],t[13]=o*f+M*x+h*D+a[13],t[14]=u*f+s*x+S*D+a[14],t[15]=l*f+i*x+I*D+a[15]),t},o.SIMD.translate=function(t,a,n){var r=SIMD.Float32x4.load(a,0),o=SIMD.Float32x4.load(a,4),u=SIMD.Float32x4.load(a,8),l=SIMD.Float32x4.load(a,12),e=SIMD.Float32x4(n[0],n[1],n[2],0);a!==t&&(t[0]=a[0],t[1]=a[1],t[2]=a[2],t[3]=a[3],t[4]=a[4],t[5]=a[5],t[6]=a[6],t[7]=a[7],t[8]=a[8],t[9]=a[9],t[10]=a[10],t[11]=a[11]),r=SIMD.Float32x4.mul(r,SIMD.Float32x4.swizzle(e,0,0,0,0)),o=SIMD.Float32x4.mul(o,SIMD.Float32x4.swizzle(e,1,1,1,1)),u=SIMD.Float32x4.mul(u,SIMD.Float32x4.swizzle(e,2,2,2,2));var M=SIMD.Float32x4.add(r,SIMD.Float32x4.add(o,SIMD.Float32x4.add(u,l)));return SIMD.Float32x4.store(t,12,M),t},o.translate=r.USE_SIMD?o.SIMD.translate:o.scalar.translate,o.scalar.scale=function(t,a,n){var r=n[0],o=n[1],u=n[2];return t[0]=a[0]*r,t[1]=a[1]*r,t[2]=a[2]*r,t[3]=a[3]*r,t[4]=a[4]*o,t[5]=a[5]*o,t[6]=a[6]*o,t[7]=a[7]*o,t[8]=a[8]*u,t[9]=a[9]*u,t[10]=a[10]*u,t[11]=a[11]*u,t[12]=a[12],t[13]=a[13],t[14]=a[14],t[15]=a[15],t},o.SIMD.scale=function(t,a,n){var r,o,u,l=SIMD.Float32x4(n[0],n[1],n[2],0);return r=SIMD.Float32x4.load(a,0),SIMD.Float32x4.store(t,0,SIMD.Float32x4.mul(r,SIMD.Float32x4.swizzle(l,0,0,0,0))),o=SIMD.Float32x4.load(a,4),SIMD.Float32x4.store(t,4,SIMD.Float32x4.mul(o,SIMD.Float32x4.swizzle(l,1,1,1,1))),u=SIMD.Float32x4.load(a,8),SIMD.Float32x4.store(t,8,SIMD.Float32x4.mul(u,SIMD.Float32x4.swizzle(l,2,2,2,2))),t[12]=a[12],t[13]=a[13],t[14]=a[14],t[15]=a[15],t},o.scale=r.USE_SIMD?o.SIMD.scale:o.scalar.scale,o.rotate=function(t,a,n,o){var u,l,e,M,s,i,c,h,S,I,f,x,D,F,m,d,b,v,z,p,w,E,A,P,L=o[0],q=o[1],R=o[2],N=Math.sqrt(L*L+q*q+R*R);return Math.abs(N)<r.EPSILON?null:(N=1/N,L*=N,q*=N,R*=N,u=Math.sin(n),l=Math.cos(n),e=1-l,M=a[0],s=a[1],i=a[2],c=a[3],h=a[4],S=a[5],I=a[6],f=a[7],x=a[8],D=a[9],F=a[10],m=a[11],d=L*L*e+l,b=q*L*e+R*u,v=R*L*e-q*u,z=L*q*e-R*u,p=q*q*e+l,w=R*q*e+L*u,E=L*R*e+q*u,A=q*R*e-L*u,P=R*R*e+l,t[0]=M*d+h*b+x*v,t[1]=s*d+S*b+D*v,t[2]=i*d+I*b+F*v,t[3]=c*d+f*b+m*v,t[4]=M*z+h*p+x*w,t[5]=s*z+S*p+D*w,t[6]=i*z+I*p+F*w,t[7]=c*z+f*p+m*w,t[8]=M*E+h*A+x*P,t[9]=s*E+S*A+D*P,t[10]=i*E+I*A+F*P,t[11]=c*E+f*A+m*P,a!==t&&(t[12]=a[12],t[13]=a[13],t[14]=a[14],t[15]=a[15]),t)},o.scalar.rotateX=function(t,a,n){var r=Math.sin(n),o=Math.cos(n),u=a[4],l=a[5],e=a[6],M=a[7],s=a[8],i=a[9],c=a[10],h=a[11];return a!==t&&(t[0]=a[0],t[1]=a[1],t[2]=a[2],t[3]=a[3],t[12]=a[12],t[13]=a[13],t[14]=a[14],t[15]=a[15]),t[4]=u*o+s*r,t[5]=l*o+i*r,t[6]=e*o+c*r,t[7]=M*o+h*r,t[8]=s*o-u*r,t[9]=i*o-l*r,t[10]=c*o-e*r,t[11]=h*o-M*r,t},o.SIMD.rotateX=function(t,a,n){var r=SIMD.Float32x4.splat(Math.sin(n)),o=SIMD.Float32x4.splat(Math.cos(n));a!==t&&(t[0]=a[0],t[1]=a[1],t[2]=a[2],t[3]=a[3],t[12]=a[12],t[13]=a[13],t[14]=a[14],t[15]=a[15]);var u=SIMD.Float32x4.load(a,4),l=SIMD.Float32x4.load(a,8);return SIMD.Float32x4.store(t,4,SIMD.Float32x4.add(SIMD.Float32x4.mul(u,o),SIMD.Float32x4.mul(l,r))),SIMD.Float32x4.store(t,8,SIMD.Float32x4.sub(SIMD.Float32x4.mul(l,o),SIMD.Float32x4.mul(u,r))),t},o.rotateX=r.USE_SIMD?o.SIMD.rotateX:o.scalar.rotateX,o.scalar.rotateY=function(t,a,n){var r=Math.sin(n),o=Math.cos(n),u=a[0],l=a[1],e=a[2],M=a[3],s=a[8],i=a[9],c=a[10],h=a[11];return a!==t&&(t[4]=a[4],t[5]=a[5],t[6]=a[6],t[7]=a[7],t[12]=a[12],t[13]=a[13],t[14]=a[14],t[15]=a[15]),t[0]=u*o-s*r,t[1]=l*o-i*r,t[2]=e*o-c*r,t[3]=M*o-h*r,t[8]=u*r+s*o,t[9]=l*r+i*o,t[10]=e*r+c*o,t[11]=M*r+h*o,t},o.SIMD.rotateY=function(t,a,n){var r=SIMD.Float32x4.splat(Math.sin(n)),o=SIMD.Float32x4.splat(Math.cos(n));a!==t&&(t[4]=a[4],t[5]=a[5],t[6]=a[6],t[7]=a[7],t[12]=a[12],t[13]=a[13],t[14]=a[14],t[15]=a[15]);var u=SIMD.Float32x4.load(a,0),l=SIMD.Float32x4.load(a,8);return SIMD.Float32x4.store(t,0,SIMD.Float32x4.sub(SIMD.Float32x4.mul(u,o),SIMD.Float32x4.mul(l,r))),SIMD.Float32x4.store(t,8,SIMD.Float32x4.add(SIMD.Float32x4.mul(u,r),SIMD.Float32x4.mul(l,o))),t},o.rotateY=r.USE_SIMD?o.SIMD.rotateY:o.scalar.rotateY,o.scalar.rotateZ=function(t,a,n){var r=Math.sin(n),o=Math.cos(n),u=a[0],l=a[1],e=a[2],M=a[3],s=a[4],i=a[5],c=a[6],h=a[7];return a!==t&&(t[8]=a[8],t[9]=a[9],t[10]=a[10],t[11]=a[11],t[12]=a[12],t[13]=a[13],t[14]=a[14],t[15]=a[15]),t[0]=u*o+s*r,t[1]=l*o+i*r,t[2]=e*o+c*r,t[3]=M*o+h*r,t[4]=s*o-u*r,t[5]=i*o-l*r,t[6]=c*o-e*r,t[7]=h*o-M*r,t},o.SIMD.rotateZ=function(t,a,n){var r=SIMD.Float32x4.splat(Math.sin(n)),o=SIMD.Float32x4.splat(Math.cos(n));a!==t&&(t[8]=a[8],t[9]=a[9],t[10]=a[10],t[11]=a[11],t[12]=a[12],t[13]=a[13],t[14]=a[14],t[15]=a[15]);var u=SIMD.Float32x4.load(a,0),l=SIMD.Float32x4.load(a,4);return SIMD.Float32x4.store(t,0,SIMD.Float32x4.add(SIMD.Float32x4.mul(u,o),SIMD.Float32x4.mul(l,r))),SIMD.Float32x4.store(t,4,SIMD.Float32x4.sub(SIMD.Float32x4.mul(l,o),SIMD.Float32x4.mul(u,r))),t},o.rotateZ=r.USE_SIMD?o.SIMD.rotateZ:o.scalar.rotateZ,o.fromTranslation=function(t,a){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=a[0],t[13]=a[1],t[14]=a[2],t[15]=1,t},o.fromScaling=function(t,a){return t[0]=a[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=a[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=a[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},o.fromRotation=function(t,a,n){var o,u,l,e=n[0],M=n[1],s=n[2],i=Math.sqrt(e*e+M*M+s*s);return Math.abs(i)<r.EPSILON?null:(i=1/i,e*=i,M*=i,s*=i,o=Math.sin(a),u=Math.cos(a),l=1-u,t[0]=e*e*l+u,t[1]=M*e*l+s*o,t[2]=s*e*l-M*o,t[3]=0,t[4]=e*M*l-s*o,t[5]=M*M*l+u,t[6]=s*M*l+e*o,t[7]=0,t[8]=e*s*l+M*o,t[9]=M*s*l-e*o,t[10]=s*s*l+u,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t)},o.fromXRotation=function(t,a){var n=Math.sin(a),r=Math.cos(a);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=r,t[6]=n,t[7]=0,t[8]=0,t[9]=-n,t[10]=r,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},o.fromYRotation=function(t,a){var n=Math.sin(a),r=Math.cos(a);return t[0]=r,t[1]=0,t[2]=-n,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=n,t[9]=0,t[10]=r,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},o.fromZRotation=function(t,a){var n=Math.sin(a),r=Math.cos(a);return t[0]=r,t[1]=n,t[2]=0,t[3]=0,t[4]=-n,t[5]=r,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},o.fromRotationTranslation=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=a[3],e=r+r,M=o+o,s=u+u,i=r*e,c=r*M,h=r*s,S=o*M,I=o*s,f=u*s,x=l*e,D=l*M,F=l*s;return t[0]=1-(S+f),t[1]=c+F,t[2]=h-D,t[3]=0,t[4]=c-F,t[5]=1-(i+f),t[6]=I+x,t[7]=0,t[8]=h+D,t[9]=I-x,t[10]=1-(i+S),t[11]=0,t[12]=n[0],t[13]=n[1],t[14]=n[2],t[15]=1,t},o.getTranslation=function(t,a){return t[0]=a[12],t[1]=a[13],t[2]=a[14],t},o.getRotation=function(t,a){var n=a[0]+a[5]+a[10],r=0;return n>0?(r=2*Math.sqrt(n+1),t[3]=.25*r,t[0]=(a[6]-a[9])/r,t[1]=(a[8]-a[2])/r,t[2]=(a[1]-a[4])/r):a[0]>a[5]&a[0]>a[10]?(r=2*Math.sqrt(1+a[0]-a[5]-a[10]),t[3]=(a[6]-a[9])/r,t[0]=.25*r,t[1]=(a[1]+a[4])/r,t[2]=(a[8]+a[2])/r):a[5]>a[10]?(r=2*Math.sqrt(1+a[5]-a[0]-a[10]),t[3]=(a[8]-a[2])/r,t[0]=(a[1]+a[4])/r,t[1]=.25*r,t[2]=(a[6]+a[9])/r):(r=2*Math.sqrt(1+a[10]-a[0]-a[5]),t[3]=(a[1]-a[4])/r,t[0]=(a[8]+a[2])/r,t[1]=(a[6]+a[9])/r,t[2]=.25*r),t},o.fromRotationTranslationScale=function(t,a,n,r){var o=a[0],u=a[1],l=a[2],e=a[3],M=o+o,s=u+u,i=l+l,c=o*M,h=o*s,S=o*i,I=u*s,f=u*i,x=l*i,D=e*M,F=e*s,m=e*i,d=r[0],b=r[1],v=r[2];return t[0]=(1-(I+x))*d,t[1]=(h+m)*d,t[2]=(S-F)*d,t[3]=0,t[4]=(h-m)*b,t[5]=(1-(c+x))*b,t[6]=(f+D)*b,t[7]=0,t[8]=(S+F)*v,t[9]=(f-D)*v,t[10]=(1-(c+I))*v,t[11]=0,t[12]=n[0],t[13]=n[1],t[14]=n[2],t[15]=1,t},o.fromRotationTranslationScaleOrigin=function(t,a,n,r,o){
var u=a[0],l=a[1],e=a[2],M=a[3],s=u+u,i=l+l,c=e+e,h=u*s,S=u*i,I=u*c,f=l*i,x=l*c,D=e*c,F=M*s,m=M*i,d=M*c,b=r[0],v=r[1],z=r[2],p=o[0],w=o[1],E=o[2];return t[0]=(1-(f+D))*b,t[1]=(S+d)*b,t[2]=(I-m)*b,t[3]=0,t[4]=(S-d)*v,t[5]=(1-(h+D))*v,t[6]=(x+F)*v,t[7]=0,t[8]=(I+m)*z,t[9]=(x-F)*z,t[10]=(1-(h+f))*z,t[11]=0,t[12]=n[0]+p-(t[0]*p+t[4]*w+t[8]*E),t[13]=n[1]+w-(t[1]*p+t[5]*w+t[9]*E),t[14]=n[2]+E-(t[2]*p+t[6]*w+t[10]*E),t[15]=1,t},o.fromQuat=function(t,a){var n=a[0],r=a[1],o=a[2],u=a[3],l=n+n,e=r+r,M=o+o,s=n*l,i=r*l,c=r*e,h=o*l,S=o*e,I=o*M,f=u*l,x=u*e,D=u*M;return t[0]=1-c-I,t[1]=i+D,t[2]=h-x,t[3]=0,t[4]=i-D,t[5]=1-s-I,t[6]=S+f,t[7]=0,t[8]=h+x,t[9]=S-f,t[10]=1-s-c,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},o.frustum=function(t,a,n,r,o,u,l){var e=1/(n-a),M=1/(o-r),s=1/(u-l);return t[0]=2*u*e,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=2*u*M,t[6]=0,t[7]=0,t[8]=(n+a)*e,t[9]=(o+r)*M,t[10]=(l+u)*s,t[11]=-1,t[12]=0,t[13]=0,t[14]=l*u*2*s,t[15]=0,t},o.perspective=function(t,a,n,r,o){var u=1/Math.tan(a/2),l=1/(r-o);return t[0]=u/n,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=u,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=(o+r)*l,t[11]=-1,t[12]=0,t[13]=0,t[14]=2*o*r*l,t[15]=0,t},o.perspectiveFromFieldOfView=function(t,a,n,r){var o=Math.tan(a.upDegrees*Math.PI/180),u=Math.tan(a.downDegrees*Math.PI/180),l=Math.tan(a.leftDegrees*Math.PI/180),e=Math.tan(a.rightDegrees*Math.PI/180),M=2/(l+e),s=2/(o+u);return t[0]=M,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=s,t[6]=0,t[7]=0,t[8]=-((l-e)*M*.5),t[9]=(o-u)*s*.5,t[10]=r/(n-r),t[11]=-1,t[12]=0,t[13]=0,t[14]=r*n/(n-r),t[15]=0,t},o.ortho=function(t,a,n,r,o,u,l){var e=1/(a-n),M=1/(r-o),s=1/(u-l);return t[0]=-2*e,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*M,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*s,t[11]=0,t[12]=(a+n)*e,t[13]=(o+r)*M,t[14]=(l+u)*s,t[15]=1,t},o.lookAt=function(t,a,n,u){var l,e,M,s,i,c,h,S,I,f,x=a[0],D=a[1],F=a[2],m=u[0],d=u[1],b=u[2],v=n[0],z=n[1],p=n[2];return Math.abs(x-v)<r.EPSILON&&Math.abs(D-z)<r.EPSILON&&Math.abs(F-p)<r.EPSILON?o.identity(t):(h=x-v,S=D-z,I=F-p,f=1/Math.sqrt(h*h+S*S+I*I),h*=f,S*=f,I*=f,l=d*I-b*S,e=b*h-m*I,M=m*S-d*h,f=Math.sqrt(l*l+e*e+M*M),f?(f=1/f,l*=f,e*=f,M*=f):(l=0,e=0,M=0),s=S*M-I*e,i=I*l-h*M,c=h*e-S*l,f=Math.sqrt(s*s+i*i+c*c),f?(f=1/f,s*=f,i*=f,c*=f):(s=0,i=0,c=0),t[0]=l,t[1]=s,t[2]=h,t[3]=0,t[4]=e,t[5]=i,t[6]=S,t[7]=0,t[8]=M,t[9]=c,t[10]=I,t[11]=0,t[12]=-(l*x+e*D+M*F),t[13]=-(s*x+i*D+c*F),t[14]=-(h*x+S*D+I*F),t[15]=1,t)},o.str=function(t){return"mat4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+", "+t[8]+", "+t[9]+", "+t[10]+", "+t[11]+", "+t[12]+", "+t[13]+", "+t[14]+", "+t[15]+")"},o.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+Math.pow(t[6],2)+Math.pow(t[7],2)+Math.pow(t[8],2)+Math.pow(t[9],2)+Math.pow(t[10],2)+Math.pow(t[11],2)+Math.pow(t[12],2)+Math.pow(t[13],2)+Math.pow(t[14],2)+Math.pow(t[15],2))},o.add=function(t,a,n){return t[0]=a[0]+n[0],t[1]=a[1]+n[1],t[2]=a[2]+n[2],t[3]=a[3]+n[3],t[4]=a[4]+n[4],t[5]=a[5]+n[5],t[6]=a[6]+n[6],t[7]=a[7]+n[7],t[8]=a[8]+n[8],t[9]=a[9]+n[9],t[10]=a[10]+n[10],t[11]=a[11]+n[11],t[12]=a[12]+n[12],t[13]=a[13]+n[13],t[14]=a[14]+n[14],t[15]=a[15]+n[15],t},o.subtract=function(t,a,n){return t[0]=a[0]-n[0],t[1]=a[1]-n[1],t[2]=a[2]-n[2],t[3]=a[3]-n[3],t[4]=a[4]-n[4],t[5]=a[5]-n[5],t[6]=a[6]-n[6],t[7]=a[7]-n[7],t[8]=a[8]-n[8],t[9]=a[9]-n[9],t[10]=a[10]-n[10],t[11]=a[11]-n[11],t[12]=a[12]-n[12],t[13]=a[13]-n[13],t[14]=a[14]-n[14],t[15]=a[15]-n[15],t},o.sub=o.subtract,o.multiplyScalar=function(t,a,n){return t[0]=a[0]*n,t[1]=a[1]*n,t[2]=a[2]*n,t[3]=a[3]*n,t[4]=a[4]*n,t[5]=a[5]*n,t[6]=a[6]*n,t[7]=a[7]*n,t[8]=a[8]*n,t[9]=a[9]*n,t[10]=a[10]*n,t[11]=a[11]*n,t[12]=a[12]*n,t[13]=a[13]*n,t[14]=a[14]*n,t[15]=a[15]*n,t},o.multiplyScalarAndAdd=function(t,a,n,r){return t[0]=a[0]+n[0]*r,t[1]=a[1]+n[1]*r,t[2]=a[2]+n[2]*r,t[3]=a[3]+n[3]*r,t[4]=a[4]+n[4]*r,t[5]=a[5]+n[5]*r,t[6]=a[6]+n[6]*r,t[7]=a[7]+n[7]*r,t[8]=a[8]+n[8]*r,t[9]=a[9]+n[9]*r,t[10]=a[10]+n[10]*r,t[11]=a[11]+n[11]*r,t[12]=a[12]+n[12]*r,t[13]=a[13]+n[13]*r,t[14]=a[14]+n[14]*r,t[15]=a[15]+n[15]*r,t},o.exactEquals=function(t,a){return t[0]===a[0]&&t[1]===a[1]&&t[2]===a[2]&&t[3]===a[3]&&t[4]===a[4]&&t[5]===a[5]&&t[6]===a[6]&&t[7]===a[7]&&t[8]===a[8]&&t[9]===a[9]&&t[10]===a[10]&&t[11]===a[11]&&t[12]===a[12]&&t[13]===a[13]&&t[14]===a[14]&&t[15]===a[15]},o.equals=function(t,a){var n=t[0],o=t[1],u=t[2],l=t[3],e=t[4],M=t[5],s=t[6],i=t[7],c=t[8],h=t[9],S=t[10],I=t[11],f=t[12],x=t[13],D=t[14],F=t[15],m=a[0],d=a[1],b=a[2],v=a[3],z=a[4],p=a[5],w=a[6],E=a[7],A=a[8],P=a[9],L=a[10],q=a[11],R=a[12],N=a[13],O=a[14],Y=a[15];return Math.abs(n-m)<=r.EPSILON*Math.max(1,Math.abs(n),Math.abs(m))&&Math.abs(o-d)<=r.EPSILON*Math.max(1,Math.abs(o),Math.abs(d))&&Math.abs(u-b)<=r.EPSILON*Math.max(1,Math.abs(u),Math.abs(b))&&Math.abs(l-v)<=r.EPSILON*Math.max(1,Math.abs(l),Math.abs(v))&&Math.abs(e-z)<=r.EPSILON*Math.max(1,Math.abs(e),Math.abs(z))&&Math.abs(M-p)<=r.EPSILON*Math.max(1,Math.abs(M),Math.abs(p))&&Math.abs(s-w)<=r.EPSILON*Math.max(1,Math.abs(s),Math.abs(w))&&Math.abs(i-E)<=r.EPSILON*Math.max(1,Math.abs(i),Math.abs(E))&&Math.abs(c-A)<=r.EPSILON*Math.max(1,Math.abs(c),Math.abs(A))&&Math.abs(h-P)<=r.EPSILON*Math.max(1,Math.abs(h),Math.abs(P))&&Math.abs(S-L)<=r.EPSILON*Math.max(1,Math.abs(S),Math.abs(L))&&Math.abs(I-q)<=r.EPSILON*Math.max(1,Math.abs(I),Math.abs(q))&&Math.abs(f-R)<=r.EPSILON*Math.max(1,Math.abs(f),Math.abs(R))&&Math.abs(x-N)<=r.EPSILON*Math.max(1,Math.abs(x),Math.abs(N))&&Math.abs(D-O)<=r.EPSILON*Math.max(1,Math.abs(D),Math.abs(O))&&Math.abs(F-Y)<=r.EPSILON*Math.max(1,Math.abs(F),Math.abs(Y))},t.exports=o},function(t,a,n){var r=n(1),o=n(4),u=n(7),l=n(8),e={};e.create=function(){var t=new r.ARRAY_TYPE(4);return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t},e.rotationTo=function(){var t=u.create(),a=u.fromValues(1,0,0),n=u.fromValues(0,1,0);return function(r,o,l){var M=u.dot(o,l);return-.999999>M?(u.cross(t,a,o),u.length(t)<1e-6&&u.cross(t,n,o),u.normalize(t,t),e.setAxisAngle(r,t,Math.PI),r):M>.999999?(r[0]=0,r[1]=0,r[2]=0,r[3]=1,r):(u.cross(t,o,l),r[0]=t[0],r[1]=t[1],r[2]=t[2],r[3]=1+M,e.normalize(r,r))}}(),e.setAxes=function(){var t=o.create();return function(a,n,r,o){return t[0]=r[0],t[3]=r[1],t[6]=r[2],t[1]=o[0],t[4]=o[1],t[7]=o[2],t[2]=-n[0],t[5]=-n[1],t[8]=-n[2],e.normalize(a,e.fromMat3(a,t))}}(),e.clone=l.clone,e.fromValues=l.fromValues,e.copy=l.copy,e.set=l.set,e.identity=function(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t},e.setAxisAngle=function(t,a,n){n=.5*n;var r=Math.sin(n);return t[0]=r*a[0],t[1]=r*a[1],t[2]=r*a[2],t[3]=Math.cos(n),t},e.getAxisAngle=function(t,a){var n=2*Math.acos(a[3]),r=Math.sin(n/2);return 0!=r?(t[0]=a[0]/r,t[1]=a[1]/r,t[2]=a[2]/r):(t[0]=1,t[1]=0,t[2]=0),n},e.add=l.add,e.multiply=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=a[3],e=n[0],M=n[1],s=n[2],i=n[3];return t[0]=r*i+l*e+o*s-u*M,t[1]=o*i+l*M+u*e-r*s,t[2]=u*i+l*s+r*M-o*e,t[3]=l*i-r*e-o*M-u*s,t},e.mul=e.multiply,e.scale=l.scale,e.rotateX=function(t,a,n){n*=.5;var r=a[0],o=a[1],u=a[2],l=a[3],e=Math.sin(n),M=Math.cos(n);return t[0]=r*M+l*e,t[1]=o*M+u*e,t[2]=u*M-o*e,t[3]=l*M-r*e,t},e.rotateY=function(t,a,n){n*=.5;var r=a[0],o=a[1],u=a[2],l=a[3],e=Math.sin(n),M=Math.cos(n);return t[0]=r*M-u*e,t[1]=o*M+l*e,t[2]=u*M+r*e,t[3]=l*M-o*e,t},e.rotateZ=function(t,a,n){n*=.5;var r=a[0],o=a[1],u=a[2],l=a[3],e=Math.sin(n),M=Math.cos(n);return t[0]=r*M+o*e,t[1]=o*M-r*e,t[2]=u*M+l*e,t[3]=l*M-u*e,t},e.calculateW=function(t,a){var n=a[0],r=a[1],o=a[2];return t[0]=n,t[1]=r,t[2]=o,t[3]=Math.sqrt(Math.abs(1-n*n-r*r-o*o)),t},e.dot=l.dot,e.lerp=l.lerp,e.slerp=function(t,a,n,r){var o,u,l,e,M,s=a[0],i=a[1],c=a[2],h=a[3],S=n[0],I=n[1],f=n[2],x=n[3];return u=s*S+i*I+c*f+h*x,0>u&&(u=-u,S=-S,I=-I,f=-f,x=-x),1-u>1e-6?(o=Math.acos(u),l=Math.sin(o),e=Math.sin((1-r)*o)/l,M=Math.sin(r*o)/l):(e=1-r,M=r),t[0]=e*s+M*S,t[1]=e*i+M*I,t[2]=e*c+M*f,t[3]=e*h+M*x,t},e.sqlerp=function(){var t=e.create(),a=e.create();return function(n,r,o,u,l,M){return e.slerp(t,r,l,M),e.slerp(a,o,u,M),e.slerp(n,t,a,2*M*(1-M)),n}}(),e.invert=function(t,a){var n=a[0],r=a[1],o=a[2],u=a[3],l=n*n+r*r+o*o+u*u,e=l?1/l:0;return t[0]=-n*e,t[1]=-r*e,t[2]=-o*e,t[3]=u*e,t},e.conjugate=function(t,a){return t[0]=-a[0],t[1]=-a[1],t[2]=-a[2],t[3]=a[3],t},e.length=l.length,e.len=e.length,e.squaredLength=l.squaredLength,e.sqrLen=e.squaredLength,e.normalize=l.normalize,e.fromMat3=function(t,a){var n,r=a[0]+a[4]+a[8];if(r>0)n=Math.sqrt(r+1),t[3]=.5*n,n=.5/n,t[0]=(a[5]-a[7])*n,t[1]=(a[6]-a[2])*n,t[2]=(a[1]-a[3])*n;else{var o=0;a[4]>a[0]&&(o=1),a[8]>a[3*o+o]&&(o=2);var u=(o+1)%3,l=(o+2)%3;n=Math.sqrt(a[3*o+o]-a[3*u+u]-a[3*l+l]+1),t[o]=.5*n,n=.5/n,t[3]=(a[3*u+l]-a[3*l+u])*n,t[u]=(a[3*u+o]+a[3*o+u])*n,t[l]=(a[3*l+o]+a[3*o+l])*n}return t},e.str=function(t){return"quat("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"},e.exactEquals=l.exactEquals,e.equals=l.equals,t.exports=e},function(t,a,n){var r=n(1),o={};o.create=function(){var t=new r.ARRAY_TYPE(3);return t[0]=0,t[1]=0,t[2]=0,t},o.clone=function(t){var a=new r.ARRAY_TYPE(3);return a[0]=t[0],a[1]=t[1],a[2]=t[2],a},o.fromValues=function(t,a,n){var o=new r.ARRAY_TYPE(3);return o[0]=t,o[1]=a,o[2]=n,o},o.copy=function(t,a){return t[0]=a[0],t[1]=a[1],t[2]=a[2],t},o.set=function(t,a,n,r){return t[0]=a,t[1]=n,t[2]=r,t},o.add=function(t,a,n){return t[0]=a[0]+n[0],t[1]=a[1]+n[1],t[2]=a[2]+n[2],t},o.subtract=function(t,a,n){return t[0]=a[0]-n[0],t[1]=a[1]-n[1],t[2]=a[2]-n[2],t},o.sub=o.subtract,o.multiply=function(t,a,n){return t[0]=a[0]*n[0],t[1]=a[1]*n[1],t[2]=a[2]*n[2],t},o.mul=o.multiply,o.divide=function(t,a,n){return t[0]=a[0]/n[0],t[1]=a[1]/n[1],t[2]=a[2]/n[2],t},o.div=o.divide,o.ceil=function(t,a){return t[0]=Math.ceil(a[0]),t[1]=Math.ceil(a[1]),t[2]=Math.ceil(a[2]),t},o.floor=function(t,a){return t[0]=Math.floor(a[0]),t[1]=Math.floor(a[1]),t[2]=Math.floor(a[2]),t},o.min=function(t,a,n){return t[0]=Math.min(a[0],n[0]),t[1]=Math.min(a[1],n[1]),t[2]=Math.min(a[2],n[2]),t},o.max=function(t,a,n){return t[0]=Math.max(a[0],n[0]),t[1]=Math.max(a[1],n[1]),t[2]=Math.max(a[2],n[2]),t},o.round=function(t,a){return t[0]=Math.round(a[0]),t[1]=Math.round(a[1]),t[2]=Math.round(a[2]),t},o.scale=function(t,a,n){return t[0]=a[0]*n,t[1]=a[1]*n,t[2]=a[2]*n,t},o.scaleAndAdd=function(t,a,n,r){return t[0]=a[0]+n[0]*r,t[1]=a[1]+n[1]*r,t[2]=a[2]+n[2]*r,t},o.distance=function(t,a){var n=a[0]-t[0],r=a[1]-t[1],o=a[2]-t[2];return Math.sqrt(n*n+r*r+o*o)},o.dist=o.distance,o.squaredDistance=function(t,a){var n=a[0]-t[0],r=a[1]-t[1],o=a[2]-t[2];return n*n+r*r+o*o},o.sqrDist=o.squaredDistance,o.length=function(t){var a=t[0],n=t[1],r=t[2];return Math.sqrt(a*a+n*n+r*r)},o.len=o.length,o.squaredLength=function(t){var a=t[0],n=t[1],r=t[2];return a*a+n*n+r*r},o.sqrLen=o.squaredLength,o.negate=function(t,a){return t[0]=-a[0],t[1]=-a[1],t[2]=-a[2],t},o.inverse=function(t,a){return t[0]=1/a[0],t[1]=1/a[1],t[2]=1/a[2],t},o.normalize=function(t,a){var n=a[0],r=a[1],o=a[2],u=n*n+r*r+o*o;return u>0&&(u=1/Math.sqrt(u),t[0]=a[0]*u,t[1]=a[1]*u,t[2]=a[2]*u),t},o.dot=function(t,a){return t[0]*a[0]+t[1]*a[1]+t[2]*a[2]},o.cross=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=n[0],e=n[1],M=n[2];return t[0]=o*M-u*e,t[1]=u*l-r*M,t[2]=r*e-o*l,t},o.lerp=function(t,a,n,r){var o=a[0],u=a[1],l=a[2];return t[0]=o+r*(n[0]-o),t[1]=u+r*(n[1]-u),t[2]=l+r*(n[2]-l),t},o.hermite=function(t,a,n,r,o,u){var l=u*u,e=l*(2*u-3)+1,M=l*(u-2)+u,s=l*(u-1),i=l*(3-2*u);return t[0]=a[0]*e+n[0]*M+r[0]*s+o[0]*i,t[1]=a[1]*e+n[1]*M+r[1]*s+o[1]*i,t[2]=a[2]*e+n[2]*M+r[2]*s+o[2]*i,t},o.bezier=function(t,a,n,r,o,u){var l=1-u,e=l*l,M=u*u,s=e*l,i=3*u*e,c=3*M*l,h=M*u;return t[0]=a[0]*s+n[0]*i+r[0]*c+o[0]*h,t[1]=a[1]*s+n[1]*i+r[1]*c+o[1]*h,t[2]=a[2]*s+n[2]*i+r[2]*c+o[2]*h,t},o.random=function(t,a){a=a||1;var n=2*r.RANDOM()*Math.PI,o=2*r.RANDOM()-1,u=Math.sqrt(1-o*o)*a;return t[0]=Math.cos(n)*u,t[1]=Math.sin(n)*u,t[2]=o*a,t},o.transformMat4=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=n[3]*r+n[7]*o+n[11]*u+n[15];return l=l||1,t[0]=(n[0]*r+n[4]*o+n[8]*u+n[12])/l,t[1]=(n[1]*r+n[5]*o+n[9]*u+n[13])/l,t[2]=(n[2]*r+n[6]*o+n[10]*u+n[14])/l,t},o.transformMat3=function(t,a,n){var r=a[0],o=a[1],u=a[2];return t[0]=r*n[0]+o*n[3]+u*n[6],t[1]=r*n[1]+o*n[4]+u*n[7],t[2]=r*n[2]+o*n[5]+u*n[8],t},o.transformQuat=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=n[0],e=n[1],M=n[2],s=n[3],i=s*r+e*u-M*o,c=s*o+M*r-l*u,h=s*u+l*o-e*r,S=-l*r-e*o-M*u;return t[0]=i*s+S*-l+c*-M-h*-e,t[1]=c*s+S*-e+h*-l-i*-M,t[2]=h*s+S*-M+i*-e-c*-l,t},o.rotateX=function(t,a,n,r){var o=[],u=[];return o[0]=a[0]-n[0],o[1]=a[1]-n[1],o[2]=a[2]-n[2],u[0]=o[0],u[1]=o[1]*Math.cos(r)-o[2]*Math.sin(r),u[2]=o[1]*Math.sin(r)+o[2]*Math.cos(r),t[0]=u[0]+n[0],t[1]=u[1]+n[1],t[2]=u[2]+n[2],t},o.rotateY=function(t,a,n,r){var o=[],u=[];return o[0]=a[0]-n[0],o[1]=a[1]-n[1],o[2]=a[2]-n[2],u[0]=o[2]*Math.sin(r)+o[0]*Math.cos(r),u[1]=o[1],u[2]=o[2]*Math.cos(r)-o[0]*Math.sin(r),t[0]=u[0]+n[0],t[1]=u[1]+n[1],t[2]=u[2]+n[2],t},o.rotateZ=function(t,a,n,r){var o=[],u=[];return o[0]=a[0]-n[0],o[1]=a[1]-n[1],o[2]=a[2]-n[2],u[0]=o[0]*Math.cos(r)-o[1]*Math.sin(r),u[1]=o[0]*Math.sin(r)+o[1]*Math.cos(r),u[2]=o[2],t[0]=u[0]+n[0],t[1]=u[1]+n[1],t[2]=u[2]+n[2],t},o.forEach=function(){var t=o.create();return function(a,n,r,o,u,l){var e,M;for(n||(n=3),r||(r=0),M=o?Math.min(o*n+r,a.length):a.length,e=r;M>e;e+=n)t[0]=a[e],t[1]=a[e+1],t[2]=a[e+2],u(t,t,l),a[e]=t[0],a[e+1]=t[1],a[e+2]=t[2];return a}}(),o.angle=function(t,a){var n=o.fromValues(t[0],t[1],t[2]),r=o.fromValues(a[0],a[1],a[2]);o.normalize(n,n),o.normalize(r,r);var u=o.dot(n,r);return u>1?0:Math.acos(u)},o.str=function(t){return"vec3("+t[0]+", "+t[1]+", "+t[2]+")"},o.exactEquals=function(t,a){return t[0]===a[0]&&t[1]===a[1]&&t[2]===a[2]},o.equals=function(t,a){var n=t[0],o=t[1],u=t[2],l=a[0],e=a[1],M=a[2];return Math.abs(n-l)<=r.EPSILON*Math.max(1,Math.abs(n),Math.abs(l))&&Math.abs(o-e)<=r.EPSILON*Math.max(1,Math.abs(o),Math.abs(e))&&Math.abs(u-M)<=r.EPSILON*Math.max(1,Math.abs(u),Math.abs(M))},t.exports=o},function(t,a,n){var r=n(1),o={};o.create=function(){var t=new r.ARRAY_TYPE(4);return t[0]=0,t[1]=0,t[2]=0,t[3]=0,t},o.clone=function(t){var a=new r.ARRAY_TYPE(4);return a[0]=t[0],a[1]=t[1],a[2]=t[2],a[3]=t[3],a},o.fromValues=function(t,a,n,o){var u=new r.ARRAY_TYPE(4);return u[0]=t,u[1]=a,u[2]=n,u[3]=o,u},o.copy=function(t,a){return t[0]=a[0],t[1]=a[1],t[2]=a[2],t[3]=a[3],t},o.set=function(t,a,n,r,o){return t[0]=a,t[1]=n,t[2]=r,t[3]=o,t},o.add=function(t,a,n){return t[0]=a[0]+n[0],t[1]=a[1]+n[1],t[2]=a[2]+n[2],t[3]=a[3]+n[3],t},o.subtract=function(t,a,n){return t[0]=a[0]-n[0],t[1]=a[1]-n[1],t[2]=a[2]-n[2],t[3]=a[3]-n[3],t},o.sub=o.subtract,o.multiply=function(t,a,n){return t[0]=a[0]*n[0],t[1]=a[1]*n[1],t[2]=a[2]*n[2],t[3]=a[3]*n[3],t},o.mul=o.multiply,o.divide=function(t,a,n){return t[0]=a[0]/n[0],t[1]=a[1]/n[1],t[2]=a[2]/n[2],t[3]=a[3]/n[3],t},o.div=o.divide,o.ceil=function(t,a){return t[0]=Math.ceil(a[0]),t[1]=Math.ceil(a[1]),t[2]=Math.ceil(a[2]),t[3]=Math.ceil(a[3]),t},o.floor=function(t,a){return t[0]=Math.floor(a[0]),t[1]=Math.floor(a[1]),t[2]=Math.floor(a[2]),t[3]=Math.floor(a[3]),t},o.min=function(t,a,n){return t[0]=Math.min(a[0],n[0]),t[1]=Math.min(a[1],n[1]),t[2]=Math.min(a[2],n[2]),t[3]=Math.min(a[3],n[3]),t},o.max=function(t,a,n){return t[0]=Math.max(a[0],n[0]),t[1]=Math.max(a[1],n[1]),t[2]=Math.max(a[2],n[2]),t[3]=Math.max(a[3],n[3]),t},o.round=function(t,a){return t[0]=Math.round(a[0]),t[1]=Math.round(a[1]),t[2]=Math.round(a[2]),t[3]=Math.round(a[3]),t},o.scale=function(t,a,n){return t[0]=a[0]*n,t[1]=a[1]*n,t[2]=a[2]*n,t[3]=a[3]*n,t},o.scaleAndAdd=function(t,a,n,r){return t[0]=a[0]+n[0]*r,t[1]=a[1]+n[1]*r,t[2]=a[2]+n[2]*r,t[3]=a[3]+n[3]*r,t},o.distance=function(t,a){var n=a[0]-t[0],r=a[1]-t[1],o=a[2]-t[2],u=a[3]-t[3];return Math.sqrt(n*n+r*r+o*o+u*u)},o.dist=o.distance,o.squaredDistance=function(t,a){var n=a[0]-t[0],r=a[1]-t[1],o=a[2]-t[2],u=a[3]-t[3];return n*n+r*r+o*o+u*u},o.sqrDist=o.squaredDistance,o.length=function(t){var a=t[0],n=t[1],r=t[2],o=t[3];return Math.sqrt(a*a+n*n+r*r+o*o)},o.len=o.length,o.squaredLength=function(t){var a=t[0],n=t[1],r=t[2],o=t[3];return a*a+n*n+r*r+o*o},o.sqrLen=o.squaredLength,o.negate=function(t,a){return t[0]=-a[0],t[1]=-a[1],t[2]=-a[2],t[3]=-a[3],t},o.inverse=function(t,a){return t[0]=1/a[0],t[1]=1/a[1],t[2]=1/a[2],t[3]=1/a[3],t},o.normalize=function(t,a){var n=a[0],r=a[1],o=a[2],u=a[3],l=n*n+r*r+o*o+u*u;return l>0&&(l=1/Math.sqrt(l),t[0]=n*l,t[1]=r*l,t[2]=o*l,t[3]=u*l),t},o.dot=function(t,a){return t[0]*a[0]+t[1]*a[1]+t[2]*a[2]+t[3]*a[3]},o.lerp=function(t,a,n,r){var o=a[0],u=a[1],l=a[2],e=a[3];return t[0]=o+r*(n[0]-o),t[1]=u+r*(n[1]-u),t[2]=l+r*(n[2]-l),t[3]=e+r*(n[3]-e),t},o.random=function(t,a){return a=a||1,t[0]=r.RANDOM(),t[1]=r.RANDOM(),t[2]=r.RANDOM(),t[3]=r.RANDOM(),o.normalize(t,t),o.scale(t,t,a),t},o.transformMat4=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=a[3];return t[0]=n[0]*r+n[4]*o+n[8]*u+n[12]*l,t[1]=n[1]*r+n[5]*o+n[9]*u+n[13]*l,t[2]=n[2]*r+n[6]*o+n[10]*u+n[14]*l,t[3]=n[3]*r+n[7]*o+n[11]*u+n[15]*l,t},o.transformQuat=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=n[0],e=n[1],M=n[2],s=n[3],i=s*r+e*u-M*o,c=s*o+M*r-l*u,h=s*u+l*o-e*r,S=-l*r-e*o-M*u;return t[0]=i*s+S*-l+c*-M-h*-e,t[1]=c*s+S*-e+h*-l-i*-M,t[2]=h*s+S*-M+i*-e-c*-l,t[3]=a[3],t},o.forEach=function(){var t=o.create();return function(a,n,r,o,u,l){var e,M;for(n||(n=4),r||(r=0),M=o?Math.min(o*n+r,a.length):a.length,e=r;M>e;e+=n)t[0]=a[e],t[1]=a[e+1],t[2]=a[e+2],t[3]=a[e+3],u(t,t,l),a[e]=t[0],a[e+1]=t[1],a[e+2]=t[2],a[e+3]=t[3];return a}}(),o.str=function(t){return"vec4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"},o.exactEquals=function(t,a){return t[0]===a[0]&&t[1]===a[1]&&t[2]===a[2]&&t[3]===a[3]},o.equals=function(t,a){var n=t[0],o=t[1],u=t[2],l=t[3],e=a[0],M=a[1],s=a[2],i=a[3];return Math.abs(n-e)<=r.EPSILON*Math.max(1,Math.abs(n),Math.abs(e))&&Math.abs(o-M)<=r.EPSILON*Math.max(1,Math.abs(o),Math.abs(M))&&Math.abs(u-s)<=r.EPSILON*Math.max(1,Math.abs(u),Math.abs(s))&&Math.abs(l-i)<=r.EPSILON*Math.max(1,Math.abs(l),Math.abs(i))},t.exports=o},function(t,a,n){var r=n(1),o={};o.create=function(){var t=new r.ARRAY_TYPE(2);return t[0]=0,t[1]=0,t},o.clone=function(t){var a=new r.ARRAY_TYPE(2);return a[0]=t[0],a[1]=t[1],a},o.fromValues=function(t,a){var n=new r.ARRAY_TYPE(2);return n[0]=t,n[1]=a,n},o.copy=function(t,a){return t[0]=a[0],t[1]=a[1],t},o.set=function(t,a,n){return t[0]=a,t[1]=n,t},o.add=function(t,a,n){return t[0]=a[0]+n[0],t[1]=a[1]+n[1],t},o.subtract=function(t,a,n){return t[0]=a[0]-n[0],t[1]=a[1]-n[1],t},o.sub=o.subtract,o.multiply=function(t,a,n){return t[0]=a[0]*n[0],t[1]=a[1]*n[1],t},o.mul=o.multiply,o.divide=function(t,a,n){return t[0]=a[0]/n[0],t[1]=a[1]/n[1],t},o.div=o.divide,o.ceil=function(t,a){return t[0]=Math.ceil(a[0]),t[1]=Math.ceil(a[1]),t},o.floor=function(t,a){return t[0]=Math.floor(a[0]),t[1]=Math.floor(a[1]),t},o.min=function(t,a,n){return t[0]=Math.min(a[0],n[0]),t[1]=Math.min(a[1],n[1]),t},o.max=function(t,a,n){return t[0]=Math.max(a[0],n[0]),t[1]=Math.max(a[1],n[1]),t},o.round=function(t,a){return t[0]=Math.round(a[0]),t[1]=Math.round(a[1]),t},o.scale=function(t,a,n){return t[0]=a[0]*n,t[1]=a[1]*n,t},o.scaleAndAdd=function(t,a,n,r){return t[0]=a[0]+n[0]*r,t[1]=a[1]+n[1]*r,t},o.distance=function(t,a){var n=a[0]-t[0],r=a[1]-t[1];return Math.sqrt(n*n+r*r)},o.dist=o.distance,o.squaredDistance=function(t,a){var n=a[0]-t[0],r=a[1]-t[1];return n*n+r*r},o.sqrDist=o.squaredDistance,o.length=function(t){var a=t[0],n=t[1];return Math.sqrt(a*a+n*n)},o.len=o.length,o.squaredLength=function(t){var a=t[0],n=t[1];return a*a+n*n},o.sqrLen=o.squaredLength,o.negate=function(t,a){return t[0]=-a[0],t[1]=-a[1],t},o.inverse=function(t,a){return t[0]=1/a[0],t[1]=1/a[1],t},o.normalize=function(t,a){var n=a[0],r=a[1],o=n*n+r*r;return o>0&&(o=1/Math.sqrt(o),t[0]=a[0]*o,t[1]=a[1]*o),t},o.dot=function(t,a){return t[0]*a[0]+t[1]*a[1]},o.cross=function(t,a,n){var r=a[0]*n[1]-a[1]*n[0];return t[0]=t[1]=0,t[2]=r,t},o.lerp=function(t,a,n,r){var o=a[0],u=a[1];return t[0]=o+r*(n[0]-o),t[1]=u+r*(n[1]-u),t},o.random=function(t,a){a=a||1;var n=2*r.RANDOM()*Math.PI;return t[0]=Math.cos(n)*a,t[1]=Math.sin(n)*a,t},o.transformMat2=function(t,a,n){var r=a[0],o=a[1];return t[0]=n[0]*r+n[2]*o,t[1]=n[1]*r+n[3]*o,t},o.transformMat2d=function(t,a,n){var r=a[0],o=a[1];return t[0]=n[0]*r+n[2]*o+n[4],t[1]=n[1]*r+n[3]*o+n[5],t},o.transformMat3=function(t,a,n){var r=a[0],o=a[1];return t[0]=n[0]*r+n[3]*o+n[6],t[1]=n[1]*r+n[4]*o+n[7],t},o.transformMat4=function(t,a,n){var r=a[0],o=a[1];return t[0]=n[0]*r+n[4]*o+n[12],t[1]=n[1]*r+n[5]*o+n[13],t},o.forEach=function(){var t=o.create();return function(a,n,r,o,u,l){var e,M;for(n||(n=2),r||(r=0),M=o?Math.min(o*n+r,a.length):a.length,e=r;M>e;e+=n)t[0]=a[e],t[1]=a[e+1],u(t,t,l),a[e]=t[0],a[e+1]=t[1];return a}}(),o.str=function(t){return"vec2("+t[0]+", "+t[1]+")"},o.exactEquals=function(t,a){return t[0]===a[0]&&t[1]===a[1]},o.equals=function(t,a){var n=t[0],o=t[1],u=a[0],l=a[1];return Math.abs(n-u)<=r.EPSILON*Math.max(1,Math.abs(n),Math.abs(u))&&Math.abs(o-l)<=r.EPSILON*Math.max(1,Math.abs(o),Math.abs(l))},t.exports=o}])});
/*
*
* Copyright (c) 2011-2014- Justin Dearing (zippy1981@gmail.com)
* Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
* and GPL (http://www.opensource.org/licenses/gpl-license.php) version 2 licenses.
* This software is not distributed under version 3 or later of the GPL.
*
* Version 1.0.2
*
*/

if (!document) var document = { cookie: '' }; // fix crashes on node

/**
 * Javascript class that mimics how WCF serializes a object of type MongoDB.Bson.ObjectId
 * and converts between that format and the standard 24 character representation.
*/
var ObjectId = (function () {
    var increment = Math.floor(Math.random() * (16777216));
    var pid = Math.floor(Math.random() * (65536));
    var machine = Math.floor(Math.random() * (16777216));

    var setMachineCookie = function() {
        var cookieList = document.cookie.split('; ');
        for (var i in cookieList) {
            var cookie = cookieList[i].split('=');
            var cookieMachineId = parseInt(cookie[1], 10);
            if (cookie[0] == 'mongoMachineId' && cookieMachineId && cookieMachineId >= 0 && cookieMachineId <= 16777215) {
                machine = cookieMachineId;
                break;
            }
        }
        document.cookie = 'mongoMachineId=' + machine + ';expires=Tue, 19 Jan 2038 05:00:00 GMT;path=/';
    };
    if (typeof (localStorage) != 'undefined') {
        try {
            var mongoMachineId = parseInt(localStorage['mongoMachineId']);
            if (mongoMachineId >= 0 && mongoMachineId <= 16777215) {
                machine = Math.floor(localStorage['mongoMachineId']);
            }
            // Just always stick the value in.
            localStorage['mongoMachineId'] = machine;
        } catch (e) {
            setMachineCookie();
        }
    }
    else {
        setMachineCookie();
    }

    function ObjId() {
        if (!(this instanceof ObjectId)) {
            return new ObjectId(arguments[0], arguments[1], arguments[2], arguments[3]).toString();
        }

        if (typeof (arguments[0]) == 'object') {
            this.timestamp = arguments[0].timestamp;
            this.machine = arguments[0].machine;
            this.pid = arguments[0].pid;
            this.increment = arguments[0].increment;
        }
        else if (typeof (arguments[0]) == 'string' && arguments[0].length == 24) {
            this.timestamp = Number('0x' + arguments[0].substr(0, 8)),
            this.machine = Number('0x' + arguments[0].substr(8, 6)),
            this.pid = Number('0x' + arguments[0].substr(14, 4)),
            this.increment = Number('0x' + arguments[0].substr(18, 6))
        }
        else if (arguments.length == 4 && arguments[0] != null) {
            this.timestamp = arguments[0];
            this.machine = arguments[1];
            this.pid = arguments[2];
            this.increment = arguments[3];
        }
        else {
            this.timestamp = Math.floor(new Date().valueOf() / 1000);
            this.machine = machine;
            this.pid = pid;
            this.increment = increment++;
            if (increment > 0xffffff) {
                increment = 0;
            }
        }
    };
    return ObjId;
})();

ObjectId.prototype.getDate = function () {
    return new Date(this.timestamp * 1000);
};

ObjectId.prototype.toArray = function () {
    var strOid = this.toString();
    var array = [];
    var i;
    for(i = 0; i < 12; i++) {
        array[i] = parseInt(strOid.slice(i*2, i*2+2), 16);
    }
    return array;
};

/**
* Turns a WCF representation of a BSON ObjectId into a 24 character string representation.
*/
ObjectId.prototype.toString = function () {
    if (this.timestamp === undefined
        || this.machine === undefined
        || this.pid === undefined
        || this.increment === undefined) {
        return 'Invalid ObjectId';
    }

    var timestamp = this.timestamp.toString(16);
    var machine = this.machine.toString(16);
    var pid = this.pid.toString(16);
    var increment = this.increment.toString(16);
    return '00000000'.substr(0, 8 - timestamp.length) + timestamp +
           '000000'.substr(0, 6 - machine.length) + machine +
           '0000'.substr(0, 4 - pid.length) + pid +
           '000000'.substr(0, 6 - increment.length) + increment;
};

// Active is used for a single widget when we are drawing or editing.
// Selected can be multiple widgets.

// -Separating annotations from the viewer. They have their own canvas / layer now.
// -This is more like a view than a viewer.
// -Viewer still handles stack correlations crosses.
// -This object does not bind events, but does have handle methods called by
//  the viewer.  We could change this if the annotationsLayer received
//  events before the viewer.
// -Leave the copyright stuff in the viewer too.  It is not rendered in the canvas.
// -AnnotationWidget (the panel for choosing an annotation to add) is
//  separate from this class.
// -I will need to fix saving images from the canvas.  Saving large imag
//  should still work. Use this for everything.
// -This class does not handle annotation visibility (part of annotationWidget).

(function () {
  'use strict';

  window.SAM = window.SAM || {};
  window.SAM.ImagePathUrl = 'not set';
  window.SAM.MOBILE_DEVICE = false;

  // Widget factory.  Return a widget from its serialized metadata.
  SAM.ConstructWidget = function (obj, layer) {
    var widget;
    switch (obj.type) {
      case 'lasso':
        widget = new SAM.LassoWidget(layer);
        break;
      case 'pencil':
        widget = new SAM.PencilWidget(layer);
        break;
      case 'text':
        widget = new SAM.TextWidget(layer);
        break;
      case 'arrow':
        widget = new SAM.ArrowWidget(layer);
        break;
      case 'circle':
        widget = new SAM.CircleWidget(layer);
        break;
      case 'polyline':
        widget = new SAM.PolylineWidget(layer);
        break;
      case 'rectangle':
        widget = new SAM.RectWidget(layer);
        break;
      case 'rect_set':
        widget = new SAM.RectSetWidget(layer);
        break;
      case 'grid':
        widget = new SAM.GridWidget(layer);
        break;
    }
    widget.Load(obj);
    // TODO: Get rid of this hack.
    // This is the messy way of detecting widgets that did not load
    // properly.
    if (widget.Type === 'sections' && widget.IsEmpty()) {
      // delete widget;
      return undefined;
    }
    return widget;
  };

  SAM.detectMobile = function () {
    if (SAM.MOBILE_DEVICE) {
      return SAM.MOBILE_DEVICE;
    }
    SAM.MOBILE_DEVICE = false;
    if (navigator.userAgent.match(/Android/i)) {
      SAM.MOBILE_DEVICE = 'Andriod';
    }
    if (navigator.userAgent.match(/webOS/i)) {
      SAM.MOBILE_DEVICE = 'webOS';
    }
    if (navigator.userAgent.match(/iPhone/i)) {
      SAM.MOBILE_DEVICE = 'iPhone';
    }
    if (navigator.userAgent.match(/iPad/i)) {
      SAM.MOBILE_DEVICE = 'iPad';
    }
    if (navigator.userAgent.match(/iPod/i)) {
      SAM.MOBILE_DEVICE = 'iPod';
    }
    if (navigator.userAgent.match(/BlackBerry/i)) {
      SAM.MOBILE_DEVICE = 'BlackBerry';
    }
    if (navigator.userAgent.match(/Windows Phone/i)) {
      SAM.MOBILE_DEVICE = 'Windows Phone';
    }
    return SAM.MOBILE_DEVICE;
  };

  // Debugging ... not called in normal operation.
  // Report the area for each polyline in the sequence.
  SAM.areaSequence = function (r, g, b) {
    var pl = new SAM.Polyline();
    var vr = SA.RootNote.ViewerRecords;
    var areaSequence = [];
    for (var i = 0; i < vr.length; ++i) {
      var area = 0;
      var as = vr[i].Annotations;
      for (var j = 0; j < as.length; ++j) {
        var an = as[j];
        if (an.type === 'polyline' &&
                    Math.round(an.outlinecolor[0] * 255) === r &&
                    Math.round(an.outlinecolor[1] * 255) === g &&
                    Math.round(an.outlinecolor[2] * 255) === b) {
          if (area !== 0) { console.log('Found more than one in a section'); }
          pl.Points = an.points;
          area += pl.ComputeArea() * 0.25 * 0.25;
          area = Math.round(area * 100) / 100.0;
        }
      }
      areaSequence.push(area);
    }
    // console.log(JSON.stringify(areaSequence));
    return areaSequence;
  };

  // Convert any color to an array [r,g,b] values 0->1
  SAM.ConvertColor = function (color) {
    if (typeof (color) === 'string' && color[0] !== '#') {
      if (color.slice(0, 5) === 'rgba(') {
        color = color.slice(5, -1).split(',');
        color[0] = color[0] / 255;
        color[1] = color[1] / 255;
        color[2] = color[1] / 255;
        return color;
      }

      // Deal with color names.
      var colors = {
        'aliceblue': '#f0f8ff',
        'antiquewhite': '#faebd7',
        'aqua': '#00ffff',
        'aquamarine': '#7fffd4',
        'azure': '#f0ffff',
        'beige': '#f5f5dc',
        'bisque': '#ffe4c4',
        'black': '#000000',
        'blanchedalmond': '#ffebcd',
        'blue': '#0000ff',
        'blueviolet': '#8a2be2',
        'brown': '#a52a2a',
        'burlywood': '#deb887',
        'cadetblue': '#5f9ea0',
        'chartreuse': '#7fff00',
        'chocolate': '#d2691e',
        'coral': '#ff7f50',
        'cornflowerblue': '#6495ed',
        'cornsilk': '#fff8dc',
        'crimson': '#dc143c',
        'cyan': '#00ffff',
        'darkblue': '#00008b',
        'darkcyan': '#008b8b',
        'darkgoldenrod': '#b8860b',
        'darkgray': '#a9a9a9',
        'darkgreen': '#006400',
        'darkkhaki': '#bdb76b',
        'darkmagenta': '#8b008b',
        'darkolivegreen': '#556b2f',
        'darkorange': '#ff8c00',
        'darkorchid': '#9932cc',
        'darkred': '#8b0000',
        'darksalmon': '#e9967a',
        'darkseagreen': '#8fbc8f',
        'darkslateblue': '#483d8b',
        'darkslategray': '#2f4f4f',
        'darkturquoise': '#00ced1',
        'darkviolet': '#9400d3',
        'deeppink': '#ff1493',
        'deepskyblue': '#00bfff',
        'dimgray': '#696969',
        'dodgerblue': '#1e90ff',
        'firebrick': '#b22222',
        'floralwhite': '#fffaf0',
        'forestgreen': '#228b22',
        'fuchsia': '#ff00ff',
        'gainsboro': '#dcdcdc',
        'ghostwhite': '#f8f8ff',
        'gold': '#ffd700',
        'goldenrod': '#daa520',
        'gray': '#808080',
        'green': '#008000',
        'greenyellow': '#adff2f',
        'honeydew': '#f0fff0',
        'hotpink': '#ff69b4',
        'indianred ': '#cd5c5c',
        'indigo ': '#4b0082',
        'ivory': '#fffff0',
        'khaki': '#f0e68c',
        'lavender': '#e6e6fa',
        'lavenderblush': '#fff0f5',
        'lawngreen': '#7cfc00',
        'lemonchiffon': '#fffacd',
        'lightblue': '#add8e6',
        'lightcoral': '#f08080',
        'lightcyan': '#e0ffff',
        'lightgoldenrodyellow': '#fafad2',
        'lightgrey': '#d3d3d3',
        'lightgreen': '#90ee90',
        'lightpink': '#ffb6c1',
        'lightsalmon': '#ffa07a',
        'lightseagreen': '#20b2aa',
        'lightskyblue': '#87cefa',
        'lightslategray': '#778899',
        'lightsteelblue': '#b0c4de',
        'lightyellow': '#ffffe0',
        'lime': '#00ff00',
        'limegreen': '#32cd32',
        'linen': '#faf0e6',
        'magenta': '#ff00ff',
        'maroon': '#800000',
        'mediumaquamarine': '#66cdaa',
        'mediumblue': '#0000cd',
        'mediumorchid': '#ba55d3',
        'mediumpurple': '#9370d8',
        'mediumseagreen': '#3cb371',
        'mediumslateblue': '#7b68ee',
        'mediumspringgreen': '#00fa9a',
        'mediumturquoise': '#48d1cc',
        'mediumvioletred': '#c71585',
        'midnightblue': '#191970',
        'mintcream': '#f5fffa',
        'mistyrose': '#ffe4e1',
        'moccasin': '#ffe4b5',
        'navajowhite': '#ffdead',
        'navy': '#000080',
        'oldlace': '#fdf5e6',
        'olive': '#808000',
        'olivedrab': '#6b8e23',
        'orange': '#ffa500',
        'orangered': '#ff4500',
        'orchid': '#da70d6',
        'palegoldenrod': '#eee8aa',
        'palegreen': '#98fb98',
        'paleturquoise': '#afeeee',
        'palevioletred': '#d87093',
        'papayawhip': '#ffefd5',
        'peachpuff': '#ffdab9',
        'peru': '#cd853f',
        'pink': '#ffc0cb',
        'plum': '#dda0dd',
        'powderblue': '#b0e0e6',
        'purple': '#800080',
        'red': '#ff0000',
        'rosybrown': '#bc8f8f',
        'royalblue': '#4169e1',
        'saddlebrown': '#8b4513',
        'salmon': '#fa8072',
        'sandybrown': '#f4a460',
        'seagreen': '#2e8b57',
        'seashell': '#fff5ee',
        'sienna': '#a0522d',
        'silver': '#c0c0c0',
        'skyblue': '#87ceeb',
        'slateblue': '#6a5acd',
        'slategray': '#708090',
        'snow': '#fffafa',
        'springgreen': '#00ff7f',
        'steelblue': '#4682b4',
        'tan': '#d2b48c',
        'teal': '#008080',
        'thistle': '#d8bfd8',
        'tomato': '#ff6347',
        'turquoise': '#40e0d0',
        'violet': '#ee82ee',
        'wheat': '#f5deb3',
        'white': '#ffffff',
        'whitesmoke': '#f5f5f5',
        'yellow': '#ffff00',
        'yellowgreen': '#9acd32'
      };
      if (typeof colors[color.toLowerCase()] !== 'undefined') {
        color = colors[color.toLowerCase()];
      } else {
        alert('Unknown color ' + color);
      }
    }

    // Deal with color in hex format i.e. #0000ff
    if (typeof (color) === 'string' && color.length === 7 && color[0] === '#') {
      var floatColor = [];
      var idx = 1;
      for (var i = 0; i < 3; ++i) {
        var val = ((16.0 * SAM.HexDigitToInt(color[idx++])) + SAM.HexDigitToInt(color[idx++])) / 255.0;
        floatColor.push(val);
      }
      return floatColor;
    }
    if (typeof (color) === 'string') {
      // No other formats for now.
      console.error('Cannot decode color ' + color);
      var colorArray = new Array(3);
      colorArray.fill(0);
      return colorArray;
    }
    // Fall through arrays.
    return color.slice();
  };

  // RGB [Float, Float, Float] to #RRGGBB string
  SAM.ConvertColorToHex = function (color) {
    if (typeof (color) === 'string') {
      if (color.slice(0, 5) === 'rgba(') {
        return color;
      }
      color = SAM.ConvertColorNameToHex(color);
      if (color.substring(0, 1) === '#') {
        return color;
      } else if (color.substring(0, 3) === 'rgb') {
        var temp = color.substring(4, color.length - 1).split(',');
        color = [parseInt(temp[0]) / 255,
          parseInt(temp[1]) / 255,
          parseInt(temp[2]) / 255];
      }
    }
    var hexDigits = '0123456789abcdef';
    var str = '#';
    for (var i = 0; i < 3; ++i) {
      var tmp = color[i];
      for (var j = 0; j < 2; ++j) {
        tmp *= 16.0;
        var digit = Math.floor(tmp);
        if (digit < 0) { digit = 0; }
        if (digit > 15) { digit = 15; }
        tmp = tmp - digit;
        str += hexDigits.charAt(digit);
      }
    }
    return str;
  };

  // 0-f hex digit to int
  SAM.HexDigitToInt = function (hex) {
    if (hex === '1') {
      return 1.0;
    } else if (hex === '2') {
      return 2.0;
    } else if (hex === '3') {
      return 3.0;
    } else if (hex === '4') {
      return 4.0;
    } else if (hex === '5') {
      return 5.0;
    } else if (hex === '6') {
      return 6.0;
    } else if (hex === '7') {
      return 7.0;
    } else if (hex === '8') {
      return 8.0;
    } else if (hex === '9') {
      return 9.0;
    } else if (hex === 'a' || hex === 'A') {
      return 10.0;
    } else if (hex === 'b' || hex === 'B') {
      return 11.0;
    } else if (hex === 'c' || hex === 'C') {
      return 12.0;
    } else if (hex === 'd' || hex === 'D') {
      return 13.0;
    } else if (hex === 'e' || hex === 'E') {
      return 14.0;
    } else if (hex === 'f' || hex === 'F') {
      return 15.0;
    }
    return 0.0;
  };

  SAM.ConvertColorNameToHex = function (color) {
    // Deal with color names.
    if (typeof (color) === 'string' && color[0] !== '#') {
      var colors = {
        'aliceblue': '#f0f8ff',
        'antiquewhite': '#faebd7',
        'aqua': '#00ffff',
        'aquamarine': '#7fffd4',
        'azure': '#f0ffff',
        'beige': '#f5f5dc',
        'bisque': '#ffe4c4',
        'black': '#000000',
        'blanchedalmond': '#ffebcd',
        'blue': '#0000ff',
        'blueviolet': '#8a2be2',
        'brown': '#a52a2a',
        'burlywood': '#deb887',
        'cadetblue': '#5f9ea0',
        'chartreuse': '#7fff00',
        'chocolate': '#d2691e',
        'coral': '#ff7f50',
        'cornflowerblue': '#6495ed',
        'cornsilk': '#fff8dc',
        'crimson': '#dc143c',
        'cyan': '#00ffff',
        'darkblue': '#00008b',
        'darkcyan': '#008b8b',
        'darkgoldenrod': '#b8860b',
        'darkgray': '#a9a9a9',
        'darkgreen': '#006400',
        'darkkhaki': '#bdb76b',
        'darkmagenta': '#8b008b',
        'darkolivegreen': '#556b2f',
        'darkorange': '#ff8c00',
        'darkorchid': '#9932cc',
        'darkred': '#8b0000',
        'darksalmon': '#e9967a',
        'darkseagreen': '#8fbc8f',
        'darkslateblue': '#483d8b',
        'darkslategray': '#2f4f4f',
        'darkturquoise': '#00ced1',
        'darkviolet': '#9400d3',
        'deeppink': '#ff1493',
        'deepskyblue': '#00bfff',
        'dimgray': '#696969',
        'dodgerblue': '#1e90ff',
        'firebrick': '#b22222',
        'floralwhite': '#fffaf0',
        'forestgreen': '#228b22',
        'fuchsia': '#ff00ff',
        'gainsboro': '#dcdcdc',
        'ghostwhite': '#f8f8ff',
        'gold': '#ffd700',
        'goldenrod': '#daa520',
        'gray': '#808080',
        'green': '#008000',
        'greenyellow': '#adff2f',
        'honeydew': '#f0fff0',
        'hotpink': '#ff69b4',
        'indianred': '#cd5c5c',
        'indigo ': '#4b0082',
        'ivory': '#fffff0',
        'khaki': '#f0e68c',
        'lavender': '#e6e6fa',
        'lavenderblush': '#fff0f5',
        'lawngreen': '#7cfc00',
        'lemonchiffon': '#fffacd',
        'lightblue': '#add8e6',
        'lightcoral': '#f08080',
        'lightcyan': '#e0ffff',
        'lightgoldenrodyellow': '#fafad2',
        'lightgrey': '#d3d3d3',
        'lightgreen': '#90ee90',
        'lightpink': '#ffb6c1',
        'lightsalmon': '#ffa07a',
        'lightseagreen': '#20b2aa',
        'lightskyblue': '#87cefa',
        'lightslategray': '#778899',
        'lightsteelblue': '#b0c4de',
        'lightyellow': '#ffffe0',
        'lime': '#00ff00',
        'limegreen': '#32cd32',
        'linen': '#faf0e6',
        'magenta': '#ff00ff',
        'maroon': '#800000',
        'mediumaquamarine': '#66cdaa',
        'mediumblue': '#0000cd',
        'mediumorchid': '#ba55d3',
        'mediumpurple': '#9370d8',
        'mediumseagreen': '#3cb371',
        'mediumslateblue': '#7b68ee',
        'mediumspringgreen': '#00fa9a',
        'mediumturquoise': '#48d1cc',
        'mediumvioletred': '#c71585',
        'midnightblue': '#191970',
        'mintcream': '#f5fffa',
        'mistyrose': '#ffe4e1',
        'moccasin': '#ffe4b5',
        'navajowhite': '#ffdead',
        'navy': '#000080',
        'oldlace': '#fdf5e6',
        'olive': '#808000',
        'olivedrab': '#6b8e23',
        'orange': '#ffa500',
        'orangered': '#ff4500',
        'orchid': '#da70d6',
        'palegoldenrod': '#eee8aa',
        'palegreen': '#98fb98',
        'paleturquoise': '#afeeee',
        'palevioletred': '#d87093',
        'papayawhip': '#ffefd5',
        'peachpuff': '#ffdab9',
        'peru': '#cd853f',
        'pink': '#ffc0cb',
        'plum': '#dda0dd',
        'powderblue': '#b0e0e6',
        'purple': '#800080',
        'red': '#ff0000',
        'rosybrown': '#bc8f8f',
        'royalblue': '#4169e1',
        'saddlebrown': '#8b4513',
        'salmon': '#fa8072',
        'sandybrown': '#f4a460',
        'seagreen': '#2e8b57',
        'seashell': '#fff5ee',
        'sienna': '#a0522d',
        'silver': '#c0c0c0',
        'skyblue': '#87ceeb',
        'slateblue': '#6a5acd',
        'slategray': '#708090',
        'snow': '#fffafa',
        'springgreen': '#00ff7f',
        'steelblue': '#4682b4',
        'tan': '#d2b48c',
        'teal': '#008080',
        'thistle': '#d8bfd8',
        'tomato': '#ff6347',
        'turquoise': '#40e0d0',
        'violet': '#ee82ee',
        'wheat': '#f5deb3',
        'white': '#ffffff',
        'whitesmoke': '#f5f5f5',
        'yellow': '#ffff00',
        'yellowgreen': '#9acd32'
      };
      color = color.toLowerCase();
      if (typeof colors[color] !== 'undefined') {
        color = colors[color];
      }
    }
    return color;
  };

  // length units = meters
  window.SAM.DistanceToString = function (length) {
    var lengthStr = '';
    if (length < 0.001) {
      // Latin-1 00B5 is micro sign
      lengthStr += (length * 1e6).toFixed(2) + ' \xB5m';
    } else if (length < 0.01) {
      lengthStr += (length * 1e3).toFixed(2) + ' mm';
    } else if (length < 1.0) {
      lengthStr += (length * 1e2).toFixed(2) + ' cm';
    } else if (length < 1000) {
      lengthStr += (length).toFixed(2) + ' m';
    } else {
      lengthStr += (length).toFixed(2) + ' km';
    }
    return lengthStr;
  };

  window.SAM.StringToDistance = function (lengthStr) {
    var length = 0;
    lengthStr = lengthStr.trim(); // remove leading and trailing spaces.
    var len = lengthStr.length;
    // Convert to microns
    if (lengthStr.substring(len - 2, len) === '\xB5m') {
      length = parseFloat(lengthStr.substring(0, len - 2)) / 1e6;
    } else if (lengthStr.substring(len - 2, len) === 'mm') {
      length = parseFloat(lengthStr.substring(0, len - 2)) / 1e3;
    } else if (lengthStr.substring(len - 2, len) === 'cm') {
      length = parseFloat(lengthStr.substring(0, len - 2)) / 1e2;
    } else if (lengthStr.substring(len - 2, len) === ' m') {
      length = parseFloat(lengthStr.substring(0, len - 2));
    } else if (lengthStr.substring(len - 2, len) === 'km') {
      length = parseFloat(lengthStr.substring(0, len - 2)) * 1e3;
    }

    return length;
  };

  // ConvertToMeters.
  window.SAM.ConvertToMeters = function (distObj) {
    if (!distObj.units || distObj.units === 'Units') {
      return distObj.value;
    }

    if (distObj.units.toLowerCase() === 'nm') {
      distObj.units = 'm';
      distObj.value *= 1e-9;
      return distObj.value;
    }
    if (distObj.units.toLowerCase() === '\xB5m') {
      distObj.units = 'm';
      distObj.value *= 1e-6;
      return distObj.value;
    }
    if (distObj.units.toLowerCase() === 'mm') {
      distObj.units = 'm';
      distObj.value *= 1e-3;
      return distObj.value;
    }
    if (distObj.units.toLowerCase() === 'cm') {
      distObj.units = 'm';
      distObj.value *= 1e-2;
      return distObj.value;
    }
    if (distObj.units.toLowerCase() === 'dm') {
      distObj.units = 'm';
      distObj.value *= 1e-1;
      return distObj.value;
    }
    if (distObj.units.toLowerCase() === 'm') {
      distObj.units = 'm';
      return distObj.value;
    }
    if (distObj.units.toLowerCase() === 'km') {
      distObj.units = 'm';
      distObj.value *= 1e3;
      return distObj.value;
    }
    console.log('Unknown units: ' + distObj.units);
    return distObj.value;
  };

  window.SAM.ConvertForGui = function (distObj) {
    if (!distObj.units) {
      distObj.units = 'Units';
      return;
    }
    SAM.ConvertToMeters(distObj);
    if (distObj.value > 1000) {
      distObj.value = distObj.value / 1000;
      distObj.units = 'km';
      return;
    }
    if (distObj.value > 1) {
      distObj.value = distObj.value;
      distObj.units = 'm';
      return;
    }
    if (distObj.value > 0.01) {
      distObj.value = distObj.value * 100;
      distObj.units = 'cm';
      return;
    }
    if (distObj.value > 0.001) {
      distObj.value = distObj.value * 1000;
      distObj.units = 'mm';
      return;
    }
    if (distObj.value > 0.0000001) {
      distObj.value = distObj.value * 1000000;
      distObj.units = '\xB5m';
      return;
    }
    distObj.value = distObj.value * 1000000000;
    distObj.units = 'nm';
  };

  // Pass in the viewer div.
  // TODO: Pass the camera into the draw method.  It is shared here.
  function AnnotationLayer (parent) {
    var self = this;

    // For stack.  Z = 0 is default for single images.
    // Annotations use this to decide whether to draw or not.
    // It is changed when the GirderStackWidget changes frame.
    this.ZTime = 0;

    // This will be called when a widget is selected by the user.
    // So the panel can put the layer into edit mode.
    this.ActivatedCallback = undefined;
    this.SelectionChangeCallback = undefined;
    this.ModifiedCallback = undefined;

    // Equivalent to editing.  Only one should be editing at a time.
    this.Active = false;

    this.Visibility = true;
    // TODO: Get rid of this.  The layer should not enforce
    // a single active widget.
    this.ActiveWidget = null;

    this.Parent = parent;
    this.LoadCallbacks = [];
    this.LayerDiv = $('<div>')
      .appendTo(parent)
      .css({
        'position': 'absolute',
        'left': '0px',
        'top': '0px',
        'border-width': '0px',
        'width': '100%',
        'height': '100%',
        'z-index': '1',
        'box-sizing': 'border-box'
      })
            .addClass('sa-resize');

    // I do not like modifying the parent.
    this.LayerDiv.saOnResize(
            function () {
              self.UpdateSize();
            });

    // Hack for debugging
    SAM.DebugLayer = this;

    // TODO: Abstract the view to a layer somehow.
    this.AnnotationView = new SAM.View(this.LayerDiv);

    this.AnnotationView.Canvas
      .saOnResize(function () { self.UpdateCanvasSize(); });

    this.WidgetList = [];
    // TODO:
    // I want to move away from having each shape have its own interaction (dialog).
    // Instead, I want to keep the shapes, and then have helper objects for interaction.
    // Right now this is used for non interactive annotation.
    // In the future I will add interaction helper object to manipulate shapes..
    // this.ShapeList = []; // Not needed quite yet.

    // Scale widget is unique. Deal with it separately so it is not
    // saved with the notes.
    this.ScaleWidget = new SAM.ScaleWidget(this);
  }

  // Like jquery remove.  Remove elements and events.
  AnnotationLayer.prototype.Remove = function () {
    this.LayerDiv.remove();
    this.Parent = undefined;
  };

  // This gets called when a click causes as single widget in this layer
  // to be selected. The annotation panel, uses it to turn editing on for this layer.
  AnnotationLayer.prototype.SetActivatedCallback = function (callback) {
    this.ActivatedCallback = callback;
  };
  AnnotationLayer.prototype.SetActive = function (flag) {
    if (flag === this.Active) {
      return;
    }
    this.Active = flag;
    if (flag && this.ActivatedCallback) {
      (this.ActivatedCallback)(this);
    }
  };

  // This will be called anytime one of the widgets in this layer gets modified.
  // This layer is apssed as an argument (rethink this.  It is not necessary).
  AnnotationLayer.prototype.SetModifiedCallback = function (callback) {
    this.ModifiedCallback = callback;
  };

  AnnotationLayer.prototype.Modified = function () {
    if (this.ModifiedCallback) {
      (this.ModifiedCallback)(this);
    }
  };

  // TODO: Not really select: Remove this (or change its name)
  // This will be called when a widget is selected by the user.
  // I am not sure about the usefulness of this method.
  AnnotationLayer.prototype.SetSelectionChangeCallback = function (callback) {
    this.SelectionChangeCallback = callback;
  };

  // Applies to all widgets in the layer.
  // Returns true if something changed.
  AnnotationLayer.prototype.SetSelected = function (flag) {
    var changed = false;
    for (var idx = 0; idx < this.WidgetList.length; ++idx) {
      var widget = this.WidgetList[idx];
      if (widget.SetSelected && widget.SetSelected(flag)) {
        changed = true;
      }
    }
    if (changed && this.SelectionChangeCallback) {
      (this.SelectionChangeCallback)(this);
    }
    return changed;
  };

  // Returns true if the annotation layer is completely empty.
  AnnotationLayer.prototype.IsEmpty = function () {
    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (!widget.IsEmpty()) {
        return false;
      }
    }
    return true;
  };

  AnnotationLayer.prototype.InactivateAll = function () {
    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.SetActive(false)) {
        widget.SetActive(false);
      }
    }
    return true;
  };

  AnnotationLayer.prototype.UnselectAll = function () {
    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.SetSelected) {
        widget.SetSelected(false);
      }
    }
  };

  // Returns true if any widget was deleted.
  // This Also prunes empty widgets.
  AnnotationLayer.prototype.DeleteSelected = function () {
    var modified = false;
    var keepers = [];
    // Let every widget delete its selected components.
    for (var idx = 0; idx < this.WidgetList.length; ++idx) {
      var widget = this.WidgetList[idx];
      // Only deletes the selected widgets / shapes.
      if (widget.DeleteSelected()) {
        modified = true;
        if (!widget.IsEmpty()) {
          keepers.push(widget);
        }
      } else {
        keepers.push(widget);
      }
    }
    if (this.WidgetList.length !== keepers.length) {
      this.WidgetList = keepers;
    }

    return modified;
  };

  AnnotationLayer.prototype.GetVisibility = function () {
    return this.Visibility;
  };
  AnnotationLayer.prototype.SetVisibility = function (vis) {
    if (vis === this.Visibility) {
      return;
    }
    this.Visibility = vis;
    // Since KeyDown (V) can change visibility, this resets it.
    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.SetVisibility) {
        widget.SetVisibility(vis);
      }
    }
    this.EventuallyDraw();
  };

  AnnotationLayer.prototype.GetCamera = function () {
    return this.AnnotationView.GetCamera();
  };
  AnnotationLayer.prototype.SetCamera = function (cam) {
    return this.AnnotationView.SetCamera(cam);
  };
  AnnotationLayer.prototype.GetViewport = function () {
    return this.AnnotationView.Viewport;
  };
  AnnotationLayer.prototype.UpdateCanvasSize = function () {
    this.AnnotationView.UpdateCanvasSize();
  };
  AnnotationLayer.prototype.Clear = function () {
    this.AnnotationView.Clear();
  };
  // This is the same as LayerDiv.
  // Get the div of the layer (main div).
  // It is used to append DOM GUI children.
  AnnotationLayer.prototype.GetParent = function () {
    // return this.AnnotationView.Parent;
    return this.Parent;
  };
  // Get the current scale factor between pixels and world units.
  AnnotationLayer.prototype.GetPixelsPerUnit = function () {
    return this.AnnotationView.GetPixelsPerUnit();
  };

  AnnotationLayer.prototype.GetMetersPerUnit = function () {
    return this.AnnotationView.GetMetersPerUnit();
  };

  /*
  AnnotationLayer.prototype.TestDrawingOnImage = function () {
    if (false && !this.TestImageLoading) {
      // Load the test image
      var self = this;
      var test = new Image();
      test.onload = function () {
        self.TestImage = test;
        var width = 1024;
        var height = 512;
        var canvas = $('<canvas>')
          .attr('width', width.toString())
          .attr('height', height.toString())
          .hide();
        var ctx = canvas[0].getContext('2d');
        // ----- Image canvas.
        ctx.drawImage(self.TestImage,0,0);
        // self.TestImage.style.display = 'none';
        // ----- Canvas to data
        var imageData = ctx.getImageData(0, 0, width, height);
        var data = imageData.data;
        for (var y = 0; y < height; y += 1) {
          for (var x = 512; x < width; x += 1) {
            var idx = 4*(x + y * width);
            data[idx]     = 255 - data[idx];     // red
            // data[idx + 1] = 255 - data[idx + 1]; // green
            data[idx + 2] = 255 - data[idx + 2]; // blue
            data[idx + 3] = 255 - data[idx + 3]; // alpha
          }
        }
        // ----- data back to canvas.
        ctx.putImageData(imageData, 0, 0);
        // ----- canvas to image.
        self.TestImage2 = new Image();
        SA.GirderView.uploadImage(canvas[0].toDataURL('image/png'), '5990fc973f24e54cbd1469b9');
        self.TestImage2.src = canvas[0].toDataURL('image/png');

      };
      test.src = SA.ImagePathUrl + 'imageTest.png';
      test.src = 'http://lemon/api/v1/file/5ad3eb243f24e55361fb4fd9/download?contentDisposition=inline';
      this.TestImageLoading = true;
    }

    if (this.TestImage2) {
      var ctx=this.AnnotationView.Context2d;
      ctx.drawImage(this.TestImage2, 10, 10);
    }
  };
  */

  // the view arg is necessary for rendering into a separate canvas for
  // saving large images.
  AnnotationLayer.prototype.Draw = function () {
    this.AnnotationView.Clear();
    // this.TestDrawingOnImage();

    if (!this.Visibility) { return; }

    for (var i = 0; i < this.WidgetList.length; ++i) {
      this.WidgetList[i].Draw(this);
    }
    // if (this.ScaleWidget) {
      // Girder is not setting spacing correct.
      // But we still need the scale widget for the grid widget.
      // this.ScaleWidget.Draw(this.AnnotationView);
    // }
  };

  AnnotationLayer.prototype.GetView = function () {
    return this.AnnotationView;
  };

  // To compress draw events.
  AnnotationLayer.prototype.EventuallyDraw = function () {
    if (!this.RenderPending) {
      this.RenderPending = true;
      var self = this;
      window.requestAnimationFrame(
                function () {
                  self.RenderPending = false;
                  self.Draw();
                });
    }
  };

  // Allow the layer to receive keyboard events.
  // TODO: If we have not bound out own events, forward focus to the viewer.
  AnnotationLayer.prototype.Focus = function () {
    // This looks like an error LayerDiv is a jquery pointer
    // It was probably can = this.AnnotationView.Parent
    // which is the same thing as LayerDiv (unless AnnotationView was created without a parent arg)
    // var can = this.LayerDiv.Parent;
    var can = this.LayerDiv;
    can.focus();
  };

  // Some widgets need access to the viewer.
  AnnotationLayer.prototype.GetViewer = function () {
    return this.Viewer;
  };

  // I hate to do this, but .....
  // The viewer bindings keeps any children divs from editing text.
  // A second Solution is to make the text dialog a sibling of the viewer.
  // Then full screen would have to be on their parent.
  // TODO: Get rid of this reference.
  AnnotationLayer.prototype.SetViewer = function (viewer) {
    this.Viewer = viewer;
  };

  // Load an array of anntoations into this layer.
  // It does not clear previous annotations. Call reset to do that.
  // Called by Viewer.SetViewerRecord()
  // This is neede to give a callback to an app that needs to update the
  // visibility of annotations based on a threshold.
  AnnotationLayer.prototype.LoadAnnotations = function (annotations) {
    // TODO: Fix this.  Keep actual widgets in the records / notes.
    // For now lets just do the easy thing and recreate all the
    // annotations.
    for (var i = 0; i < annotations.length; ++i) {
      var widget = this.LoadWidget(annotations[i]);
      // This a bad hack. Modifying that array passed in.
      // It is not really needed.  It was a fix for a schema mistake.
      if (!widget) {
        // Get rid of corrupt widgets that do not load properly
        annotations.splice(i, 1);
        --i;
      }
    }

    // This is used by the vigilant plugnin to update which annotations
    // are visible based on a confidence threshold.
    if (this.LoadCallback) {
      (this.LoadCallback)();
    }
    if (this.LoadCallbacks) {
      for (i = 0; i < this.LoadCallbacks.length; ++i) {
        (this.LoadCallbacks[i])();
      }
    }
  };

  // Load a widget from a json object (origin MongoDB).
  // Returns the widget if there was not an error.
  AnnotationLayer.prototype.LoadWidget = function (obj) {
    var widget = SAM.ConstructWidget(obj, this);
    if (widget) {
      this.AddWidget(widget);
    }
    return widget;
  };

  // Return to initial state.
  AnnotationLayer.prototype.Reset = function () {
    this.Clear();
    this.WidgetList = [];
  };

  AnnotationLayer.prototype.GetMouseWorld = function () {
    return this.MouseWorld;
  };

  AnnotationLayer.prototype.ComputeMouseWorld = function (event) {
    this.MouseWorld = this.GetCamera().ConvertPointViewerToWorld(event.offsetX, event.offsetY);
    // Put this extra ivar in the even object.
    event.worldX = this.MouseWorld[0];
    event.worldY = this.MouseWorld[1];
    return this.MouseWorld;
  };

  // TODO: share this code with viewer.
  // I think MouseX,Y and, offestX,Y are both
  // Save the previous touches and record the new
  // touch locations in viewport coordinates.
  AnnotationLayer.prototype.InitializeTouch = function (event, startFlag) {
    this.OriginalEvent = event;
    var date = new Date();
    var t = date.getTime();
    // I have had trouble on the iPad with 0 delta times.
    // Lets see how it behaves with fewer events.
    // It was a bug in iPad4 Javascript.
    // This throttle is not necessary.
    if (t - this.Time < 20 && !startFlag) { return false; }

    this.LastTime = this.Time;
    this.Time = t;

    // Still used on mobile devices?
    this.LastTouches = this.Touches;
    this.Touches = [];
    for (var i = 0; i < event.targetTouches.length; ++i) {
      var offset = this.AnnotationView.Canvas.offset();
      var x = event.targetTouches[i].pageX - offset.left;
      var y = event.targetTouches[i].pageY - offset.top;
      this.Touches.push([x, y]);
    }

    this.LastMouseX = this.MouseX;
    this.LastMouseY = this.MouseY;

    // Compute the touch average.
    var numTouches = this.Touches.length;
    this.MouseX = this.MouseY = 0.0;
    for (i = 0; i < numTouches; ++i) {
      this.MouseX += this.Touches[i][0];
      this.MouseY += this.Touches[i][1];
    }
    this.MouseX = this.MouseX / numTouches;
    this.MouseY = this.MouseY / numTouches;

    // Hack because we are moving away from using the event manager
    // Mouse interaction are already independant...
    this.offsetX = this.MouseX;
    this.offsetY = this.MouseY;

    return true;
  };

  // TODO: Try to get rid of the viewer argument.
  AnnotationLayer.prototype.HandleTouchStart = function (event) {
    if (!this.GetVisibility()) {
      return true;
    }

    this.Event = event;
    this.InitializeTouch(event, true);

    if (event.pencil) {
      console.log('ipad pencil start');
      var pencil = this.GetIPadPencilWidget();
      pencil.SetStateToDrawing();
      pencil.HandleTouchStart(this);
      return false;
    }

    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.HandleTouchStart && !widget.HandleTouchStart(this)) {
        return false;
      }
    }
  };

  AnnotationLayer.prototype.HandleTouchMove = function (e) {
    if (!this.GetVisibility()) {
      return true;
    }
    // Put a throttle on events
    if (!this.InitializeTouch(e, false)) { return; }

    if (event.pencil) {
      console.log('ipad pencil move');
      var pencil = this.GetIPadPencilWidget();
      pencil.HandleTouchMove(this);
      return false;
    }

    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.HandleTouchMove && !widget.HandleTouchMove(this)) {
        return false;
      }
    }

    // More complex touch interactions.
    if (this.Touches.length === 1) {
      return this.HandleTouchPan(this);
    }
    if (this.Touches.length === 2) {
      return this.HandleTouchPinch(this);
    }
  };

  AnnotationLayer.prototype.HandleTouchPan = function (event) {
    if (!this.GetVisibility()) {
      return true;
    }
    if (this.ActiveWidget && this.ActiveWidget.HandleTouchPan) {
      this.Event = event;
      return this.ActiveWidget.HandleTouchPan(this);
    }
    return true;
  };

  AnnotationLayer.prototype.HandleTouchPinch = function (event) {
    if (!this.GetVisibility()) {
      return true;
    }
    this.Event = event;
    if (this.ActiveWidget && this.ActiveWidget.HandleTouchPinch) {
      return this.ActiveWidget.HandleTouchPinch(this);
    }
    return true;
  };

  AnnotationLayer.prototype.HandleTouchEnd = function (event) {
    if (!this.GetVisibility()) {
      return true;
    }
    this.Event = event;

    // It seems that end events do not have a force (to indicate iPad pencil).
    if (this.Pencil && this.Pencil.IsStateDrawingDown()) {
      event.pencil = true;
    }

    if (event.pencil) {
      var pencil = this.GetIPadPencilWidget();
      pencil.HandleTouchEnd(this);
      pencil.SetActive(false);
      this.Modified();
      // Tell the panel that this layer selection has changed.
      if (this.SelectionChangedCallback) {
        (this.SelectionChangedCallback)(this);
      }
      return false;
    }

    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.HandleTouchEnd && !widget.HandleTouchEnd(this)) {
        return false;
      }
    }
    return true;
  };

  AnnotationLayer.prototype.SetMousePositionFromEvent = function (event) {
    if (event.MouseX && event.MouseY) {
      this.MouseX = event.MouseX;
      this.MouseY = event.MouseY;
    } else if (event.offsetX && event.offsetY) {
      this.MouseX = event.offsetX;
      this.MouseY = event.offsetY;
    } else if (event.layerX && event.layerY) {
      this.MouseX = event.layerX;
      this.MouseY = event.layerY;
      event.offsetX = event.layerX;
      event.offsetY = event.layerY;
    }
    this.MouseTime = new Date().getTime();
  };

  // Is any part of the layer selected.
  AnnotationLayer.prototype.IsSelected = function () {
    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.IsSelected()) {
        return true;
      }
    }
  };

  // Click will only select one widget.
  // returns the widget selected or undefined.
  AnnotationLayer.prototype.HandleSelect = function (event) {
    if (!this.GetVisibility()) {
      return;
    }
    this.Event = event;
    this.SetMousePositionFromEvent(event);

    // Not the same as modified.
    var modified = false;
    // This is to limit selection to a single widget, unless shift is held.
    var selectedWidgets = [];

    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      var selectedOld = widget.IsSelected();
      // Skip calling select if widget is already selected and we allow multiple selections.
      if (!(event.shiftKey && selectedOld)) {
        if (widget.HandleSelect && widget.HandleSelect(this)) {
          selectedWidgets.push(widget);
        }
      }

      if (selectedOld !== widget.IsSelected()) {
        modified = true;
      }
      // widget "handleSelect should do this.
      // pencil can have multiple shapes.  I do not wnat them all selected.
      // widget.SetSelected(pick);
    }

    if (selectedWidgets.length > 0 && !this.Active) {
      // Active means editing, since a selected widget will respond to events
      // and change, the layer has to be active.
      this.SetActive(true);
    }

    // This does not work when previously selected
    if (modified) {
      if (this.SelectionChangeCallback) {
        (this.SelectionChangeCallback)(this);
      }
      this.EventuallyDraw();
    }
    return selectedWidgets;
  };

  AnnotationLayer.prototype.HasSelections = function () {
    if (this.GetASelectedWidget()) {
      return true;
    }
    return false;
  };

  // Widget type is the objects type string instance variable.
  // If undefined, it will match any type.
  AnnotationLayer.prototype.GetASelectedWidget = function (widgetType) {
    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.IsSelected && widget.IsSelected()) {
        if (widgetType === undefined || widgetType === widget.Type) {
          return this.WidgetList[i];
        }
      }
    }
    return undefined;
  };

  AnnotationLayer.prototype.HandleMouseDown = function (event) {
    if (!this.GetVisibility()) {
      return true;
    }
    this.Event = event;
    this.LastMouseDownTime = this.MouseDownTime || 1;
    this.SetMousePositionFromEvent(event);
    this.ComputeMouseWorld(event);

    // Trying to detect click
    // TODO: How to skip clicks when doubleclick occur.
    // this.MouseClick = true;
    this.MouseDownX = this.MouseX;
    this.MouseDownY = this.MouseY;
    this.MouseDownTime = this.MouseTime;

    if (this.LastMouseDownTime) {
      if (this.MouseDownTime - this.LastMouseDownTime < 200) {
        delete this.LastMouseDownTime;
        return this.HandleDoubleClick(this);
      }
    }

    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.HandleMouseDown && !widget.HandleMouseDown(this)) {
        return false;
      }
    }
    return true;
  };

  AnnotationLayer.prototype.HandleDoubleClick = function (event) {
    if (!this.GetVisibility()) {
      return true;
    }
    if (this.ActiveWidget && this.ActiveWidget.HandleDoubleClick) {
      this.Event = event;
      return this.ActiveWidget.HandleDoubleClick(this);
    }
    return true;
  };

  AnnotationLayer.prototype.HandleMouseClick = function (event) {
    if (!this.GetVisibility()) {
      return true;
    }
    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.HandleMouseClick && !widget.HandleMouseClick(this)) {
        return false;
      }
    }

    return true;
  };

  AnnotationLayer.prototype.HandleMouseUp = function (event) {
    if (!this.GetVisibility()) {
      return true;
    }

    // if (this.MouseClick) {
    //  this.MouseClick = false;
    //  return this.HandleClick(event);
    // }

    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.HandleMouseUp && !widget.HandleMouseUp(this)) {
        return false;
      }
    }

    return true;
  };

  AnnotationLayer.prototype.HandleMouseMove = function (event) {
    if (!this.GetVisibility()) {
      return true;
    }

    this.Event = event;
    this.SetMousePositionFromEvent(event);

    // The event position is relative to the target which can be a tab on
    // top of the canvas.  Just skip these events.
    // if ($(event.target).width() !== $(event.currentTarget).width()) {
      // console.log('child event ' + event.MouseY);
    // }

    this.ComputeMouseWorld(event);

    // Firefox does not set "which" for move events.
    event.which = event.buttons;
    if (event.which === 2) {
      event.which = 3;
    } else if (event.which === 3) {
      event.which = 2;
    }

    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.HandleMouseMove && !widget.HandleMouseMove(this)) {
        return false;
      }
    }

    // An active widget should stop propagation even if it does not
    // respond to the event.
    return true;
  };

  AnnotationLayer.prototype.HandleMouseWheel = function (event) {
    if (!this.GetVisibility()) {
      return true;
    }
    if (this.ActiveWidget && this.ActiveWidget.HandleMouseWheel) {
      this.Event = event;
      return this.ActiveWidget.HandleMouseWheel(this);
    }
    return true;
  };

  AnnotationLayer.prototype.HandleKeyDown = function (event) {
    if (!this.GetVisibility()) {
      return true;
    }

    if (event.keyCode === 77) {
      // Hack to merge tracks for timelapse
      var strokes = [];
      for (var i = 0; i < this.WidgetList.length; ++i) {
        var w = this.WidgetList[i];
        if (w.IsSelected()) {
          strokes.push(w);
        }
      }
      if (strokes.length > 1) {
        var s0 = strokes[0].Shapes.Shapes[0];
        var s1 = strokes[1].Shapes.Shapes[0];
        // This only works for single strokes.
        // TODO: Get rid of "Shapes".  The correct way to do this is to
        // Just keep polylines (not widgets).
        // A widget drawing can still keep its list of polylines, but the layer
        // does not (has only polylines).  This is a significant change, but not huge.
        // Connect the closest ends.
        var pt0 = s0.Points[s0.Points.length - 1];
        var pt1 = s1.Points[0];
        var dx = pt1[0] - pt0[0];
        var dy = pt1[1] - pt0[1];
        var dist01 = Math.sqrt(dx * dx + dy * dy);
        pt0 = s0.Points[0];
        pt1 = s1.Points[s1.Points.length - 1];
        dx = pt1[0] - pt0[0];
        dy = pt1[1] - pt0[1];
        var dist10 = Math.sqrt(dx * dx + dy * dy);
        if (dist01 < dist10) {
          s0.Points = s0.Points.concat(s1.Points);
        } else {
          s0.Points = s1.Points.concat(s0.Points);
        }
        s0.UpdateBuffers(this.AnnotationView);
        this.RemoveWidget(strokes[1]);
        this.EventuallyDraw();
        return false;
      }
    }

    this.Event = event;

    for (i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.HandleKeyDown && !widget.HandleKeyDown(this)) {
        return false;
      }
    }

    return true;
  };

  AnnotationLayer.prototype.HandleKeyUp = function (event) {
    if (!this.GetVisibility()) {
      return true;
    }

    if (event.keyCode === 46) { // delete key
      // Some browser (safari?) was navigating when the delete key was pressed.
      // (Even though we returned false here. Maybe it was triggered on the keyup.
      event.preventDefault();
      return false;
    }

    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.HandleKeyDown && !widget.HandleKeyDown(this)) {
        return false;
      }
    }
    return true;
  };

  AnnotationLayer.prototype.GetNumberOfWidgets = function () {
    return this.WidgetList.length;
  };

  AnnotationLayer.prototype.GetWidget = function (i) {
    return this.WidgetList[i];
  };

  // Legacy
  AnnotationLayer.prototype.GetWidgets = function () {
    return this.WidgetList;
  };

  AnnotationLayer.prototype.AddWidget = function (widget) {
    var self = this;
    this.WidgetList.push(widget);
    if (widget.SetModifiedCallback) {
      widget.SetModifiedCallback(
        function (w) { self.WidgetModifiedCallback(w); });
    }

    if (widget.UpdateBuffers) { widget.UpdateBuffers(this); }
  };

  // Callback being used for to generally.
  AnnotationLayer.prototype.WidgetModifiedCallback = function (widget) {
    // Just forward the message on.
    this.Modified();
  };

  // Hmmmm.  Try to remove this.  It would be nice not to keep a pointer to an active widget.
  AnnotationLayer.prototype.ActivateWidget = function (widget) {
    if (widget !== this.ActiveWidget) {
      this.LayerDiv.focus();
      this.ActiveWidget = widget;
      // Tell the panel that this layer selection has changed.
      if (this.SelectionChangedCallback) {
        (this.SelectionChangedCallback)(this);
      }
    }
  };

  // TODO: Get rid of this depreciated methods.
  // A widget cannot call this if another widget is active.
  // The widget deals with its own activation and deactivation.
  AnnotationLayer.prototype.DeactivateWidget = function (widget) {
    if (this.ActiveWidget !== widget || widget === null) {
      // Do nothing if the widget is not active.
      return;
    }
    // Incase the widget changed the cursor.  Change it back.
    this.LayerDiv.css({'cursor': ''});
    // The cursor does not change immediatly.  Try to flush.
    this.EventuallyDraw();
    this.ActiveWidget = null;
    widget.SetActive(false);
  };
  // Deactivate all widgets (should the layer have an active state?)
  AnnotationLayer.prototype.Deactivate = function () {
    for (var idx = 0; idx < this.WidgetList.length; ++idx) {
      this.WidgetList[idx].SetActive(false);
    }
  };

  AnnotationLayer.prototype.GetActiveWidget = function () {
    return this.ActiveWidget;
  };

  AnnotationLayer.prototype.RemoveWidget = function (widget) {
    if (widget.Layer === null) {
      return;
    }
    if (this.ActiveWidget === widget) {
      this.ActiveWidget = undefined;
    }
    widget.Layer = null;
    var idx = this.WidgetList.indexOf(widget);
    if (idx !== -1) {
      this.WidgetList.splice(idx, 1);
      this.Modified();
    }
  };

  AnnotationLayer.prototype.LoadGirderItem = function (id) {
    var itemId = '564e42fe3f24e538e9a20eb9';
    var data = {'itemId': itemId,
      'limit': 50,
      'offset': 0,
      'sort': 'lowerName',
      'sortdir': 1};

    // This gives an array of {_id:"....",annotation:{name:"...."},itemId:"...."}
    girder.rest.restRequest({
      type: 'get',
      url: 'annotation',
      data: JSON.stringify(data),
      success: function (data, status) {
        console.log('success');
      },
      error: function () {
        alert('AJAX - error() : annotation get');
      }
    });

    var annotationId = '572be29d3f24e53573aa8e91';
    girder.rest.restRequest({
      url: 'annotation/' + annotationId,    // note that you don't need
      // api/v1
      method: 'GET',                          // data will be put in the
      // body of a POST
      contentType: 'application/json'        // this tells jQuery that we
      // are passing JSON in the body
    }).done(function (data) {
      console.log('done');
    });
  };

  AnnotationLayer.prototype.SaveGirderItem = function (id) {
    // Create a new annotation.
    var annotId = '572be29d3f24e53573aa8e91';
    var data = {'name': 'Test3',
      'elements': [{'type': 'circle',
        'lineColor': '#FFFF00',
        'lineWidth': 20,
        'center': [5000, 5000, 0],
        'radius': 2000}]
    };
    girder.rest.restRequest({
      type: 'post',
      url: 'annotation',
      data: JSON.stringify(data),
      success: function (data, status) {
        console.log('success');
      },
      error: function () {
        alert('AJAX - error() : annotation get');
      }
    });

    // Change an existing annotation
    data = {'name': 'Test',
      'elements': [{'type': 'polyline',
        'points': [[6500, 6600, 0], [3300, 5600, 0], [10600, 500, 6]],
        'closed': true,
        'fillColor': 'rgba(0, 255, 0, 1)'} ]
    };
    girder.rest.restRequest({
      type: 'put',
      url: 'annotation/' + annotId,
      data: JSON.stringify(data),
      success: function (data, status) {
        console.log('success2');
      },
      error: function () {
        alert('AJAX - error() : annotation get');
      }
    });
  };

  AnnotationLayer.prototype.UpdateSize = function () {
    if (!this.AnnotationView) {
      return false;
    }
    if (this.AnnotationView.UpdateCanvasSize()) {
      this.EventuallyDraw();
      return true;
    }
    return false;
  };

  AnnotationLayer.prototype.Test = function () {
    for (var i = 0; i < this.WidgetList.length; ++i) {
      var w = this.WidgetList[i];
      if (w.Type === 'polyline') {
        w.ColorByHandedness();
      }
      this.EventuallyDraw();
    }
  };

  // Order of preference: 1: a selected widget, 2: IVar "Pencil", 3: Stylus only.
  // 4: a new constructed pencil  Widget.
  AnnotationLayer.prototype.GetIPadPencilWidget = function () {
    // For efficiency.
    if (this.Pencil && this.Pencil.IsSelected()) {
      return this.Pencil;
    }

    // Look for a selected.
    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.StylusOnly) {
        this.Pencil = widget;
      }
      if (widget.Type === 'pencil' && widget.IsSelected()) {
        this.Pencil = widget;
        return widget;
      }
    }

    if (this.Pencil) {
      return this.Pencil;
    }

    // Code to make a new pencil
    // Make a new widget (and make it active).
    this.Pencil = new SAM.PencilWidget(this, false);
    // I want this widget to only respond to pencil/stylus events
    this.Pencil.StylusOnly = true;
    this.WidgetList.push(this.Pencil);
    return this.Pencil;
  };

  SAM.AnnotationLayer = AnnotationLayer;
})();

// here temporarily
// transformation that user camera models
(function () {
  'use strict';

  // ==============================================================================
  // A correlation is just a pair of matching points from two sections.
  // Abstract the correlation so we have an api for getting points.
  // Currently, stack has direct access to correlation ivars / points.
  // The api will make forward and back transformations use the same code.

  // Pass in world to image transformation (3x3) for each image.
  function MatrixTransformation () {
    this.WorldToImage1 = mat3.create();
    this.Image1ToWorld = mat3.create();
    this.WorldToImage2 = mat3.create();
    this.Image2ToWorld = mat3.create();
  }

  MatrixTransformation.prototype.M2Invert = function (m1) {
    var d = m1[0] * m1[3] - m1[1] * m1[2];
    return [ m1[3] / d, -m1[1] / d,
      -m1[2] / d, m1[0] / d];
  };
  MatrixTransformation.prototype.M2Multiply = function (m1, m2) {
    return [m1[0] * m2[0] + m1[1] * m2[2], m1[0] * m2[1] + m1[1] * m2[3],
      m1[2] * m2[0] + m1[3] * m2[2], m1[2] * m2[1] + m1[3] * m2[3]];
  };

  // Initialize with 3 corresponding points.
  MatrixTransformation.prototype.InitializeWithPoints = function (p1a, p2a, p1b, p2b, p1c, p2c) {
    var m1 = mat3.create();
    var m2 = mat3.create();
    mat3.identity(m1);
    mat3.identity(m2);
    // Take the first point as the origin.
    m1[2] = p1a[0]; m1[5] = p1a[1];
    m2[2] = p2a[0]; m2[5] = p2a[1];
    // Assume that the image1 coordinates (minus origin) are world.
    // Matrix to transform i,j to new basis b,c
    var A1 = [p1b[0] - p1a[0], p1c[0] - p1a[0],
      p1b[1] - p1a[1], p1c[1] - p1a[1]];
    var A2 = [p2b[0] - p2a[0], p2c[0] - p2a[0],
      p2b[1] - p2a[1], p2c[1] - p2a[1]];
    var M = this.M2Multiply(A2, this.M2Invert(A1));
    // Use the 2x2 in the 3x3
    m2[0] = M[0]; m2[1] = M[1];
    m2[3] = M[2]; m2[4] = M[3];

    this.Initialize(m1, m2);
  };

  // Pass in two matrixes (World to image)
  MatrixTransformation.prototype.Initialize = function (m1, m2) {
    // Now invert these matrixes.
    mat3.set(m1, this.WorldToImage1);
    mat3.set(m2, this.WorldToImage2);

    // A lot of hastle to get the inverse for a 3x3.
    // It is not that hard to compute.
    var m4a = mat4.create();
    var m4b = mat4.create();
    mat3.toMat4(this.WorldToImage1, m4a);
    mat4.inverse(m4a, m4b);
    mat4.toMat3(m4b, this.Image1ToWorld);

    mat3.toMat4(this.WorldToImage2, m4a);
    mat4.inverse(m4a, m4b);
    mat4.toMat3(m4b, this.Image2ToWorld);
  };

  // 1->2
  // This is confusing because for slides I consider image as world.
  // World here is geo location.
  MatrixTransformation.prototype.ForwardTransformPoint = function (ptIn) {
    var m = this.Image1ToWorld;
    var x = ptIn[0] * m[0] + ptIn[1] * m[1] + m[2];
    var y = ptIn[0] * m[3] + ptIn[1] * m[4] + m[5];
    var h = ptIn[0] * m[6] + ptIn[1] * m[7] + m[8];
    m = this.WorldToImage2;
    var x2 = x * m[0] + y * m[1] + h * m[2];
    var y2 = x * m[3] + y * m[4] + h * m[5];
    var h2 = x * m[6] + y * m[7] + h * m[8];
    return [x2 / h2, y2 / h2];
  };
  // 2->1
  MatrixTransformation.prototype.ReverseTransformPoint = function (ptIn) {
    var m = this.Image2ToWorld;
    var x = ptIn[0] * m[0] + ptIn[1] * m[1] + m[2];
    var y = ptIn[0] * m[3] + ptIn[1] * m[4] + m[5];
    var h = ptIn[0] * m[6] + ptIn[1] * m[7] + m[8];
    m = this.WorldToImage1;
    var x2 = x * m[0] + y * m[1] + h * m[2];
    var y2 = x * m[3] + y * m[4] + h * m[5];
    var h2 = x * m[6] + y * m[7] + h * m[8];
    return [x2 / h2, y2 / h2];
  };

  // 1->2
  MatrixTransformation.prototype.ForwardTransformCamera = function (camIn, camOut) {
    var fpIn = camIn.GetWorldFocalPoint();
    var fpOut = camOut.GetWorldFocalPoint();
    var upIn = [fpIn[0] + 1, fpIn[1]];

    var pt = this.ForwardTransformPoint(fpIn);
    fpOut[0] = pt[0]; fpOut[1] = pt[1];
    var upOut = this.ForwardTransformPoint(upIn);
    upOut[0] -= fpOut[0];
    upOut[1] -= fpOut[1];
    var scale = Math.sqrt(upOut[0] * upOut[0] + upOut[1] * upOut[1]);
    // compute the height.
    camOut.SetHeight(camIn.GetHeight() * scale);
    camOut.SetWorldRoll(camIn.GetWorldRoll());
    camOut.ComputeMatrix();
  };

  // 2->1
  MatrixTransformation.prototype.ReverseTransformCamera = function (camIn, camOut) {
    var fpIn = camIn.GetWorldFocalPoint();
    var fpOut = camOut.GetWorldFocalPoint();
    var upIn = [fpIn[0] + 1, fpIn[1]];

    var pt = this.ReverseTransformPoint(fpIn);
    fpOut[0] = pt[0]; fpOut[1] = pt[1];
    var upOut = this.ReverseTransformPoint(upIn);
    upOut[0] -= fpOut[0];
    upOut[1] -= fpOut[1];
    var scale = Math.sqrt(upOut[0] * upOut[0] + upOut[1] * upOut[1]);
    // compute the height.
    camOut.SetHeight(camIn.GetHeight() * scale);
    camOut.SetWorldRoll(camIn.GetWorldRoll());
    camOut.ComputeMatrix();
  };

  SAM.MatrixTransformation = MatrixTransformation;
})();

// TODO:
// Cleanup API for choosing coordinate systems.
// Position (currently Origin) is in slide.
//   I want to extend this to Viewer.
//   Relative to corners or center and
//   possibly relative to left, right of shape ... like css
// Currently we use FixedSize to choose width and height units.

// For the sort term I need an option to have position relative to upper
// left of the viewer.

(function () {
  'use strict';

  function Shape () {
    this.Orientation = 0.0; // in degrees, counter clockwise, 0 is left
    this.PositionCoordinateSystem = Shape.SLIDE;
    // This is the position of the shape origin in the containing
    // coordinate system. Probably better called position.
    this.Origin = new Array(2);
    this.Origin.fill(10000); // Anchor in world coordinates.
    // FixedSize => PointBuffer units in viewer pixels.
    // otherwise
    this.FixedSize = false;
    this.FixedOrientation = false;
    this.LineWidth = 0; // Line width has to be in same coordinates as points.
    this.Visibility = true; // An easy way to turn off a shape (with removing it from the shapeList).
    this.Selected = false;
    this.SelectedColor = [1.0, 1.0, 0.0];
    // Playing around with layering.  The anchor is being obscured by the text.
    this.ZOffset = 0.1;

    // Grouping shapes.
    // TODO: Change widgets to interactors (that can deal with multiple shapes).
    this.Children = {};
  }

  Shape.prototype.GetLineWidth = function () {
    return this.LineWidth;
  };

  Shape.prototype.GetOrigin = function () {
    return this.Origin;
  };

  // in degrees
  Shape.prototype.GetOrientation = function () {
    return this.Orientation;
  };

  // in radians
  Shape.prototype.GetRotation = function () {
    return this.Orientation * Math.PI / 180.0;
  };

  Shape.prototype.Modified = function () {
    this.Matrix = undefined;
  };

  Shape.prototype.DeleteSelected = function () {
    for (var name in this.Children) {
      if (this.Children[name].DeleteSelected()) {
        delete this.Children[name];
      }
    }
    if (this.IsSelected()) {
      this.PointBuffer = undefined;
      return true;
    }
    return false;
  };

  Shape.prototype.IsEmpty = function () {
    return this.PointBuffer === undefined;
  };

  // Coordinate Systems
  Shape.SLIDE = 0; // Pixel of highest resolution level.
  Shape.VIEWER = 1; // Pixel of viewer canvas.

  Shape.prototype.destructor = function () {
    // Get rid of the buffers?
  };

  // Returns true if the selected state changed.
  Shape.prototype.SetSelected = function (f) {
    if (f === this.Selected) { return false; }
    this.Selected = f;
    // When a parent is selected, the children are highligted too.
    for (var childKey in this.Children) {
      var child = this.Children[childKey];
      child.SetSelected(f);
    }

    return true;
  };

  Shape.prototype.IsSelected = function () {
    return this.Selected;
  };

  Shape.prototype.Draw = function (view) {
    if (!this.Visibility) {
      return;
    }
    if (this.Matrix === undefined) {
      this.UpdateBuffers(view);
    }

    if (this.IsEmpty()) {
      return;
    }

    var theta;
    var m;
    var x;
    var y;
    if (view.gl) {
      // Lets use the camera to change coordinate system to pixels.
      // TODO: Put this camera in the view or viewer to avoid creating one each render.
      var camMatrix = mat4.create();
      mat4.identity(camMatrix);
      if (this.FixedSize) {
        var viewFrontZ = view.Camera.ZRange[0] + 0.01;
        // This camera matrix changes pixel/ screen coordinate system to
        // view [-1,1],[-1,1],z
        camMatrix[0] = 2.0 / view.Viewport[2];
        camMatrix[12] = -1.0;
        camMatrix[5] = -2.0 / view.Viewport[3];
        camMatrix[13] = 1.0;
        camMatrix[14] = viewFrontZ; // In front of tiles in this view
      }

      // The actor matrix that rotates to orientation and shift (0,0) to origin.
      // Rotate based on ivar orientation.
      theta = this.Orientation * 3.1415926536 / 180.0;
      this.Matrix[0] = Math.cos(theta);
      this.Matrix[1] = -Math.sin(theta);
      this.Matrix[4] = Math.sin(theta);
      this.Matrix[5] = Math.cos(theta);
      // Place the origin of the shape.
      x = this.Origin[0];
      y = this.Origin[1];
      if (this.FixedSize) {
        // For fixed size, translation must be in view/pixel coordinates.
        // First transform the world to view.
        m = view.Camera.Matrix;
        x = (this.Origin[0] * m[0] + this.Origin[1] * m[4] + m[12]) / m[15];
        y = (this.Origin[0] * m[1] + this.Origin[1] * m[5] + m[13]) / m[15];
        // convert view to pixels (view coordinate system).
        x = view.Viewport[2] * (0.5 * (1.0 + x));
        y = view.Viewport[3] * (0.5 * (1.0 - y));
      }
      // Translate to place the origin.
      this.Matrix[12] = x;
      this.Matrix[13] = y;
      this.Matrix[14] = this.ZOffset;

      var program = SA.polyProgram;

      view.gl.useProgram(program);
      view.gl.disable(view.gl.BLEND);
      view.gl.enable(view.gl.DEPTH_TEST);

      // This does not work.
      // I will need to make thick lines with polygons.
      // view.gl.lineWidth(5);

      // These are the same for every tile.
      // Vertex points (shifted by tiles matrix)
      view.gl.bindBuffer(view.gl.ARRAY_BUFFER, this.VertexPositionBuffer);
      // Needed for outline ??? For some reason, DrawOutline did not work
      // without this call first.
      view.gl.vertexAttribPointer(program.vertexPositionAttribute,
                                   this.VertexPositionBuffer.itemSize,
                                   view.gl.FLOAT, false, 0, 0);     // Texture coordinates
      // Local view.
      view.gl.viewport(view.Viewport[0], view.Viewport[1],
                        view.Viewport[2], view.Viewport[3]);

      view.gl.uniformMatrix4fv(program.mvMatrixUniform, false, this.Matrix);
      if (this.FixedSize) {
        view.gl.uniformMatrix4fv(program.pMatrixUniform, false, camMatrix);
      } else {
        // Use main views camera to convert world to view.
        view.gl.uniformMatrix4fv(program.pMatrixUniform, false, view.Camera.GetImageMatrix());
      }

      // Fill color
      if (this.FillColor !== undefined) {
        if (this.Selected) {
          view.gl.uniform3f(program.colorUniform, this.SelectedColor[0],
                                 this.SelectedColor[1], this.SelectedColor[2]);
        } else {
          view.gl.uniform3f(program.colorUniform, this.FillColor[0],
                                 this.FillColor[1], this.FillColor[2]);
        }
        // Cell Connectivity
        view.gl.bindBuffer(view.gl.ELEMENT_ARRAY_BUFFER, this.CellBuffer);

        view.gl.drawElements(view.gl.TRIANGLES, this.CellBuffer.numItems,
                                view.gl.UNSIGNED_SHORT, 0);
      }

      if (this.OutlineColor !== undefined) {
        if (this.Selected) {
          view.gl.uniform3f(program.colorUniform, this.SelectedColor[0],
                                 this.SelectedColor[1], this.SelectedColor[2]);
        } else {
          view.gl.uniform3f(program.colorUniform, this.OutlineColor[0],
                                 this.OutlineColor[1], this.OutlineColor[2]);
        }

        if (this.LineWidth === 0) {
          if (this.WireFrame) {
            view.gl.bindBuffer(view.gl.ELEMENT_ARRAY_BUFFER, this.CellBuffer);
            view.gl.drawElements(view.gl.LINE_LOOP, this.CellBuffer.numItems,
                                        view.gl.UNSIGNED_SHORT, 0);
          } else {
            // Outline. This only works for polylines
            view.gl.drawArrays(view.gl.LINE_STRIP, 0, this.VertexPositionBuffer.numItems);
          }
        } else {
          // Cell Connectivity
          view.gl.bindBuffer(view.gl.ELEMENT_ARRAY_BUFFER, this.LineCellBuffer);
          view.gl.drawElements(view.gl.TRIANGLES, this.LineCellBuffer.numItems,
                                    view.gl.UNSIGNED_SHORT, 0);
        }
      }
    } else { // 2d Canvas -----------------------------------------------
      view.Context2d.save();
      // Identity.
      view.Context2d.setTransform(1, 0, 0, 1, 0, 0);

      var scale;
      if (this.PositionCoordinateSystem === Shape.SLIDE) {
        theta = (this.Orientation * 3.1415926536 / 180.0);
        if (!this.FixedSize) {
          theta -= view.Camera.GetImageRoll();
        }
        this.Matrix[0] = Math.cos(theta);
        this.Matrix[1] = -Math.sin(theta);
        this.Matrix[4] = Math.sin(theta);
        this.Matrix[5] = Math.cos(theta);
        // Place the origin of the shape.
        x = this.Origin[0];
        y = this.Origin[1];
        scale = 1.0;
        if (!this.FixedSize) {
          // World need to be drawn in view coordinate system so the
          scale = view.Viewport[3] / view.Camera.GetHeight();
        }
        // First transform the origin-world to view.
        m = view.Camera.GetImageMatrix();
        x = (this.Origin[0] * m[0] + this.Origin[1] * m[4] + m[12]) / m[15];
        y = (this.Origin[0] * m[1] + this.Origin[1] * m[5] + m[13]) / m[15];

        // convert origin-view to pixels (view coordinate system).
        x = view.Viewport[2] * (0.5 * (1.0 + x));
        y = view.Viewport[3] * (0.5 * (1.0 - y));
        view.Context2d.transform(this.Matrix[0], this.Matrix[1], this.Matrix[4], this.Matrix[5], x, y);
      } else if (this.PositionCoordinateSystem === Shape.VIEWER) {
        theta = (this.Orientation * 3.1415926536 / 180.0);
        this.Matrix[0] = Math.cos(theta);
        this.Matrix[1] = -Math.sin(theta);
        this.Matrix[4] = Math.sin(theta);
        this.Matrix[5] = Math.cos(theta);
        // Place the origin of the shape.
        x = this.Origin[0];
        y = this.Origin[1];
        scale = 1.0;

        view.Context2d.transform(this.Matrix[0], this.Matrix[1], this.Matrix[4], this.Matrix[5], x, y);
      }

      // Right now this is specific to a rectangle.
      // It is here because I need the transformation.  It could be generalized...
      if (this.Image && this.Image.complete && this.Width && this.Height) {
        view.Context2d.save();
        // Scale the image to match the rectangle
        var a = this.Width * scale / this.Image.width;
        var d = this.Height * scale / this.Image.height;
        // move the origin to the corner of the image.
        var e = -this.Width * scale / 2.0;
        var f = -this.Height * scale / 2.0;
        // a c e
        // b d f
        view.Context2d.transform(a, 0, 0, d, e, f);
        view.Context2d.drawImage(this.Image, 0, 0);
        view.Context2d.restore();
      }

      // for debugging section alignment.
      var x0 = this.PointBuffer[0];
      var y0 = this.PointBuffer[1];
      // For debugging gradient decent aligning contours.
      // This could be put into the canvas transform, but it is only for debugging.
      // if (this.Trans) {
      //      var vx = x0-this.Trans.cx;
      //      var vy = y0-this.Trans.cy;
      //      var rx =  this.Trans.c*vx + this.Trans.s*vy;
      //      var ry = -this.Trans.s*vx + this.Trans.c*vy;
      //      x0 = x0 + (rx-vx) + this.Trans.sx;
      //      y0 = y0 + (ry-vy) + this.Trans.sy;
      // }

      // This gets remove when the debug code is uncommented.
      view.Context2d.beginPath();
      view.Context2d.moveTo(x0 * scale, y0 * scale);

      var i = 3;
      while (i < this.PointBuffer.length) {
        var x1 = this.PointBuffer[i];
        var y1 = this.PointBuffer[i + 1];
        // For debugging.  Apply a transformation and color by scalars.
        // if (this.Trans) {
        //    var vx = x1-this.Trans.cx;
        //    var vy = y1-this.Trans.cy;
        //    var rx =  this.Trans.c*vx + this.Trans.s*vy;
        //    var ry = -this.Trans.s*vx + this.Trans.c*vy;
        //    x1 = x1 + (rx-vx) + this.Trans.sx;
        //    y1 = y1 + (ry-vy) + this.Trans.sy;
        // }
        // view.Context2d.beginPath();
        // view.Context2d.moveTo(x0*scale,y0*scale);
        // Also for debugging
        // if (this.DebugScalars) {
        //    view.Context2d.strokeStyle=SAM.ConvertColorToHex([1,this.DebugScalars[i/3], 0]);
        // } else {
        //    view.Context2d.strokeStyle=SAM.ConvertColorToHex(this.OutlineColor);
        // }
        // view.Context2d.stroke();
        // x0 = x1;
        // y0 = y1;

        // This gets remove when the debug code is uncommented.
        view.Context2d.lineTo(x1 * scale, y1 * scale);

        i += 3;
      }

      if (this.OutlineColor !== undefined) {
        var width = this.LineWidth * scale;
        if (width === 0) {
          width = 1;
        }
        view.Context2d.lineWidth = width;
        if (this.Selected) {
          view.Context2d.strokeStyle = SAM.ConvertColorToHex(this.SelectedColor);
        } else {
          view.Context2d.strokeStyle = SAM.ConvertColorToHex(this.OutlineColor);
        }
        // This gets remove when the debug code is uncommented.
        view.Context2d.stroke();
      }

      if (this.FillColor !== undefined) {
        if (this.Selected) {
          view.Context2d.fillStyle = SAM.ConvertColorToHex(this.SelectedColor);
        } else {
          view.Context2d.fillStyle = SAM.ConvertColorToHex(this.FillColor);
        }
        view.Context2d.fill();
      }

      view.Context2d.restore();
    }
    for (var name in this.Children) {
      if (this.Children[name] && this.Children[name].Draw) {
        this.Children[name].Draw(view);
      }
    }
  };

  // Invert the fill color.
  Shape.prototype.ChooseOutlineColor = function () {
    if (this.FillColor) {
      this.OutlineColor = [1.0 - this.FillColor[0],
        1.0 - this.FillColor[1],
        1.0 - this.FillColor[2]];
    }
  };

  Shape.prototype.SetOrigin = function (o) {
    this.Origin = o.slice();
  };

  Shape.prototype.SetOutlineColor = function (c) {
    this.OutlineColor = SAM.ConvertColor(c);
  };

  Shape.prototype.GetOutlineColor = function (c) {
    return this.OutlineColor;
  };

  Shape.prototype.SetFillColor = function (c) {
    this.FillColor = SAM.ConvertColor(c);
  };

  Shape.prototype.HandleMouseMove = function (event, dx, dy) {
    // superclass does nothing
    return false;
  };

  // Shape.prototype.UpdateBuffers = function(view) {
  //    // The superclass does not implement this method.
  // }

  // Returns undefined if the point is not on the segment.
  // Returns the interpolation index if it is touching the edge.
  // NOTE: Confusion between undefined and 0. I could return -1 ...???...
  // However -1 could mean extrapolation ....
  Shape.prototype.IntersectPointLine = function (pt, end0, end1, dist) {
    // make end0 the origin.
    var x = pt[0] - end0[0];
    var y = pt[1] - end0[1];
    var vx = end1[0] - end0[0];
    var vy = end1[1] - end0[1];

    // Rotate so the edge lies on the x axis.
    var length = Math.sqrt(vx * vx + vy * vy); // Avoid atan2 ... by rotating with complex numbers
    if (length === 0) {
      return undefined;
    }

    // Get the edge normal direction.
    vx = vx / length;
    vy = -vy / length;
    // Rotate the coordinate system to put the edge on the x axis.
    var newX = (x * vx - y * vy);
    var newY = (x * vy + y * vx);

    if (Math.abs(newY) > dist ||
            newX < 0 || newX > length) {
      return undefined;
    }
    return newX / length;
  };

  SAM.Shape = Shape;
})();

// Originally to hold a set of polylines for the pencil widget.

(function () {
  // Depends on the CIRCLE widget
  'use strict';

  function ShapeGroup () {
    this.Shapes = [];
    this.Bounds = [0, -1, 0, -1];
  }

  ShapeGroup.prototype.UpdateBuffers = function (view) {
    for (var i = 1; i < this.Shapes.length; ++i) {
      var shape = this.Shapes[i];
      if (shape.UpdateBuffers) {
        shape.UpdateBuffers(view);
      }
    }
  };

  ShapeGroup.prototype.GetBounds = function () {
    return this.Bounds;
  };

  // Returns 0 if is does not overlap at all.
  // Returns 1 if part of the section is in the bounds.
  // Returns 2 if all of the section is in the bounds.
  ShapeGroup.prototype.ContainedInBounds = function (bds) {
    if (this.Shapes.length === 0) { return 0; }
    var retVal = this.Shapes[0].ContainedInBounds(bds);
    for (var i = 1; i < this.Shapes.length; ++i) {
      if (retVal === 1) {
                // Both inside and outside. Nothing more to check.
        return retVal;
      }
      var shapeVal = this.Shapes[i].ContainedInBounds(bds);
      if (retVal === 0 && shapeVal !== 0) {
        retVal = 1;
      }
      if (retVal === 2 && shapeVal !== 2) {
        retVal = 1;
      }
    }
    return retVal;
  };

  // Returns the selecteded shape (or undefined).
  ShapeGroup.prototype.HandleSelect = function (pt, dist) {
    var found;
    for (var idx = 0; idx < this.Shapes.length; ++idx) {
      var shape = this.Shapes[idx];
      if (found || !shape.PointOnShape(pt, dist)) {
        // A shape was already selected. Just unselect the rest.
        if (!SAM.ShiftKey) {
          shape.SetSelected(false);
        }
      } else {
        shape.SetSelected(true);
        found = shape;
      }
    }
    return found;
  };

  // Legacy?
  // Returns the index of the shape selected,  -1 if None.
  ShapeGroup.prototype.PointOnShape = function (pt, dist) {
    for (var i = 0; i < this.Shapes.length; ++i) {
      if (this.Shapes[i].PointOnShape(pt, dist)) {
        return i;
      }
    }
    return -1;
  };

  ShapeGroup.prototype.Modified = function () {
    for (var i = 0; i < this.Shapes.length; ++i) {
      this.Shapes.Modified();
    }
  };

  // Return true if any shape was deleted.
  ShapeGroup.prototype.DeleteSelected = function () {
    var modified = false;
    var keepers = [];
    for (var idx = 0; idx < this.Shapes.length; ++idx) {
      var shape = this.Shapes[idx];
      if (this.Shapes[idx].DeleteSelected()) {
        // Something was deleted.
        modified = true;
      }
      if (!shape.IsEmpty()) {
        keepers.push(this.Shapes[idx]);
      }
    }
    if (keepers.length < this.Shapes.length) {
      this.Shapes = keepers;
    }
    return modified;
  };

  ShapeGroup.prototype.IsEmpty = function () {
    for (var idx = 0; idx < this.Shapes.length; ++idx) {
      if (!this.Shapes[idx].IsEmpty()) {
        return false;
      }
    }
    return true;
  };

  // Depreciates: TODO:  Remove this method.
  // I decided I hate popups.  They are visual noise and
  // when there are many annotations, you cannot get the one you want.
  // They always got orphaned for some reason.  Not worth fixing.
  // Find a world location of a popup point given a camera.
  ShapeGroup.prototype.FindPopupPoint = function (cam) {
    if (this.Shapes.length === 0) { return; }
    var roll = cam.GetWorldRoll();
    var s = Math.sin(roll + (Math.PI * 0.25));
    var c = Math.cos(roll + (Math.PI * 0.25));
    var bestPt = this.Shapes[0].FindPopupPoint(cam);
    var bestProjection = (c * bestPt[0]) - (s * bestPt[1]);
    for (var i = 1; i < this.Shapes.length; ++i) {
      var pt = this.Shapes[i].FindPopupPoint(cam);
      var projection = (c * pt[0]) - (s * pt[1]);
      if (projection > bestProjection) {
        bestProjection = projection;
        bestPt = pt;
      }
    }
    return bestPt;
  };

  ShapeGroup.prototype.Draw = function (view) {
    for (var i = 0; i < this.Shapes.length; ++i) {
      this.Shapes[i].Draw(view);
    }
  };

  ShapeGroup.prototype.AddShape = function (shape) {
    this.Shapes.push(shape);
  };

  ShapeGroup.prototype.GetNumberOfShapes = function () {
    return this.Shapes.length;
  };

  ShapeGroup.prototype.GetShape = function (index) {
    return this.Shapes[index];
  };

  ShapeGroup.prototype.PopShape = function () {
    return this.Shapes.pop();
  };

  // Should be called remove child
  ShapeGroup.prototype.DeleteChild = function (idx) {
    return this.Shapes.splice(idx, 1);
  };

  // Set the all to the same selected state.
  // Returns true if any selection changed.
  ShapeGroup.prototype.SetSelected = function (flag) {
    var changed = false;
    for (var i = 0; i < this.Shapes.length; ++i) {
      if (this.Shapes[i].SetSelected(flag)) {
        changed = true;
      }
    }
    return changed;
  };

  // Set only one child selected state
  ShapeGroup.prototype.SetSelectedChild = function (idx, flag) {
    this.Shapes[idx].SetSelected(flag);
  };

  // Returns true if any shapes are selected.
  ShapeGroup.prototype.IsSelected = function () {
    for (var i = 0; i < this.Shapes.length; ++i) {
      if (this.Shapes[i].IsSelected()) {
        return true;
      }
    }
    return false;
  };

  ShapeGroup.prototype.SetLineWidth = function (lineWidth) {
    for (var i = 0; i < this.Shapes.length; ++i) {
      this.Shapes[i].LineWidth = lineWidth;
    }
  };

  // Just returns the first.
  ShapeGroup.prototype.GetLineWidth = function () {
    if (this.Shapes.length !== 0) {
      return this.Shapes[0].GetLineWidth();
    }
    return 0;
  };

  ShapeGroup.prototype.SetOutlineColor = function (color) {
    for (var i = 0; i < this.Shapes.length; ++i) {
      this.Shapes[i].OutlineColor = color;
    }
  };

  // Just returns the first.
  ShapeGroup.prototype.GetOutlineColor = function () {
    if (this.Shapes.length !== 0) {
      return this.Shapes[0].OutlineColor;
    }
    return [0, 0, 0];
  };

  ShapeGroup.prototype.SetOrigin = function (origin) {
    for (var i = 0; i < this.Shapes.length; ++i) {
      // Makes a copy of the array.
      this.Shapes[i].SetOrigin(origin);
    }
  };

  // Adds origin to points and sets origin to 0.
  ShapeGroup.prototype.ResetOrigin = function () {
    for (var i = 0; i < this.Shapes.length; ++i) {
      this.Shapes[i].ResetOrigin();
    }
  };

  // Just returns the first.
  ShapeGroup.prototype.GetOrigin = function () {
    if (this.Shapes.length !== 0) {
      return this.Shapes[0].Origin;
    }
    return [0, 0, 0];
  };

  SAM.ShapeGroup = ShapeGroup;
})();

// ==============================================================================
// Feedback for the image that will be downloaded with the cutout service.
// Todo:
// - Key events and tooltips for buttons.
//   This is difficult because the widget would have to be active all the time.
//   Hold off on this.

(function () {
  'use strict';

  function CutoutWidget (parent, viewer) {
    this.Viewer = viewer;
    // this.Layer = viewer.GetAnnotationLayer();
    var cam = this.Layer.GetCamera();
    var fp = cam.GetWorldFocalPoint();

    var rad = cam.Height / 4;
    this.Bounds = [fp[0] - rad, fp[0] + rad, fp[1] - rad, fp[1] + rad];
    this.DragBounds = [fp[0] - rad, fp[0] + rad, fp[1] - rad, fp[1] + rad];

    this.Layer.AddWidget(this);
    this.Viewer.EventuallyRender();

        // Bits that indicate which edges are active.
    this.Active = 0;

    var self = this;
    this.Div = $('<div>')
            .appendTo(parent)
            .addClass('sa-view-cutout-div');
    $('<button>')
            .appendTo(this.Div)
            .text('Cancel')
            .addClass('sa-view-cutout-button')
            .click(function () { self.Cancel(); });
    $('<button>')
            .appendTo(this.Div)
            .text('Download')
            .addClass('sa-view-cutout-button')
            .click(function () { self.Accept(); });

    this.Select = $('<select>')
            .appendTo(this.Div);
    $('<option>').appendTo(this.Select)
            .attr('value', 0)
            .text('tif');
    $('<option>').appendTo(this.Select)
            .attr('value', 1)
            .text('jpeg');
    $('<option>').appendTo(this.Select)
            .attr('value', 2)
            .text('png');
    $('<option>').appendTo(this.Select)
            .attr('value', 3)
            .text('svs');

    this.Label = $('<div>')
            .addClass('sa-view-cutout-label')
            .appendTo(this.Div);
    this.UpdateBounds();
    this.HandleMouseUp();
  }

  CutoutWidget.prototype.Accept = function () {
    this.Deactivate();
    var types = ['tif', 'jpeg', 'png', 'svs'];
    var imageSource = this.Viewer.GetCache().Image;
        // var bounds = [];
        // for (var i=0; i <this.Bounds.length; i++) {
        //  bounds[i] = this.Bounds[i] -1;
        // }

    window.location = '/cutout/' + imageSource.database + '/' +
            imageSource._id + '/image.' + types[this.Select.val()] + '?bounds=' + JSON.stringify(this.Bounds);
  };

  CutoutWidget.prototype.Cancel = function () {
    this.Deactivate();
  };

  CutoutWidget.prototype.Serialize = function () {
    return false;
  };

  CutoutWidget.prototype.Draw = function (view) {
    var center = [(this.DragBounds[0] + this.DragBounds[1]) * 0.5,
      (this.DragBounds[2] + this.DragBounds[3]) * 0.5];
    var cam = view.Camera;

    if (view.gl) {
      alert('webGL cutout not supported');
    } else {
      // The 2d canvas was left in world coordinates.
      var ctx = view.Context2d;
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      this.DrawRectangle(ctx, this.Bounds, cam, '#00A', 1, 0);
      this.DrawRectangle(ctx, this.DragBounds, cam, '#000', 2, this.Active);
      this.DrawCenter(ctx, center, cam, '#000');
      ctx.restore();
    }
  };

  CutoutWidget.prototype.DrawRectangle = function (ctx, bds, cam, color,
                                                    lineWidth, active) {
        // Convert the for corners to view.
    var pt0 = cam.ConvertPointWorldToViewer(bds[0], bds[2]);
    var pt1 = cam.ConvertPointWorldToViewer(bds[1], bds[2]);
    var pt2 = cam.ConvertPointWorldToViewer(bds[1], bds[3]);
    var pt3 = cam.ConvertPointWorldToViewer(bds[0], bds[3]);

    ctx.lineWidth = lineWidth;

    ctx.beginPath();
    ctx.strokeStyle = (active & 4) ? '#FF0' : color;
    ctx.moveTo(pt0[0], pt0[1]);
    ctx.lineTo(pt1[0], pt1[1]);
    ctx.stroke();

    ctx.beginPath();
    ctx.strokeStyle = (active & 2) ? '#FF0' : color;
    ctx.moveTo(pt1[0], pt1[1]);
    ctx.lineTo(pt2[0], pt2[1]);
    ctx.stroke();

    ctx.beginPath();
    ctx.strokeStyle = (active & 8) ? '#FF0' : color;
    ctx.moveTo(pt2[0], pt2[1]);
    ctx.lineTo(pt3[0], pt3[1]);
    ctx.stroke();

    ctx.beginPath();
    ctx.strokeStyle = (active & 1) ? '#FF0' : color;
    ctx.moveTo(pt3[0], pt3[1]);
    ctx.lineTo(pt0[0], pt0[1]);
    ctx.stroke();
  };

  CutoutWidget.prototype.DrawCenter = function (ctx, pt, cam, color) {
        // Convert the for corners to view.
    var pt0 = cam.ConvertPointWorldToViewer(pt[0], pt[1]);

    ctx.strokeStyle = (this.Active & 16) ? '#FF0' : color;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(pt0[0] - 5, pt0[1]);
    ctx.lineTo(pt0[0] + 5, pt0[1]);
    ctx.moveTo(pt0[0], pt0[1] - 5);
    ctx.lineTo(pt0[0], pt0[1] + 5);
    ctx.stroke();
  };

  CutoutWidget.prototype.HandleKeyPress = function (keyCode, shift) {
        // Return is the same as except.
    if (event.keyCode === 67) {
      alert('Accept');
    }
        // esc or delete: cancel
    if (event.keyCode === 67) {
      alert('Cancel');
    }

    return true;
  };

  CutoutWidget.prototype.HandleDoubleClick = function (event) {
    return true;
  };

  CutoutWidget.prototype.HandleMouseDown = function (event) {
    if (event.which !== 1) {
      return false;
    }
    return true;
  };

    // returns false when it is finished doing its work.
  CutoutWidget.prototype.HandleMouseUp = function () {
    var tmp;
    if (this.Bounds[0] > this.Bounds[1]) {
      tmp = this.Bounds[0];
      this.Bounds[0] = this.Bounds[1];
      this.Bounds[1] = tmp;
    }
    if (this.Bounds[2] > this.Bounds[3]) {
      tmp = this.Bounds[2];
      this.Bounds[2] = this.Bounds[3];
      this.Bounds[3] = tmp;
    }

    this.DragBounds = this.Bounds.slice(0);
    this.Viewer.EventuallyRender();
  };

  CutoutWidget.prototype.HandleMouseMove = function (event) {
    if (event.which === 0) {
      this.CheckActive(event);
      return;
    }

    if (this.Active) {
      var cam = this.Layer.GetCamera();
      var pt = cam.ConvertPointViewerToWorld(event.offsetX, event.offsetY);
      if (this.Active & 1) {
        this.DragBounds[0] = pt[0];
      }
      if (this.Active & 2) {
        this.DragBounds[1] = pt[0];
      }
      if (this.Active & 4) {
        this.DragBounds[2] = pt[1];
      }
      if (this.Active & 8) {
        this.DragBounds[3] = pt[1];
      }
      if (this.Active & 16) {
        var dx = pt[0] - 0.5 * (this.DragBounds[0] + this.DragBounds[1]);
        var dy = pt[1] - 0.5 * (this.DragBounds[2] + this.DragBounds[3]);
        this.DragBounds[0] += dx;
        this.DragBounds[1] += dx;
        this.DragBounds[2] += dy;
        this.DragBounds[3] += dy;
      }
      this.UpdateBounds();
      this.Viewer.EventuallyRender();
      return true;
    }
    return false;
  };

    // Bounds follow drag bounds, but snap to the tile grid.
    // Maybe we should not force Bounds to contain DragBounds.
    // Bounds Grow when dragging the center. Maybe
    // round rather the use floor and ceil.
  CutoutWidget.prototype.UpdateBounds = function (event) {
    var cache = this.Viewer.GetCache();
    var tileWidth = cache.Image.TileWidth;
    var tileHeight = cache.Image.TileHeight;

    var bds = [0, 0, 0, 0];
    bds[0] = Math.round(this.DragBounds[0] / tileWidth) * tileWidth;
    bds[1] = Math.round(this.DragBounds[1] / tileWidth) * tileWidth;
    bds[2] = Math.round(this.DragBounds[2] / tileHeight) * tileHeight;
    bds[3] = Math.round(this.DragBounds[3] / tileHeight) * tileHeight;

    // Keep the bounds in the image.
    // min and max could be inverted.
    // I am not sure the image bounds have to be on the tile boundaries.
    var imgBds = cache.Image.bounds;
    if (bds[0] < imgBds[0]) {
      bds[0] = imgBds[0];
    }
    if (bds[1] < imgBds[0]) {
      bds[1] = imgBds[0];
    }
    if (bds[2] < imgBds[2]) {
      bds[2] = imgBds[2];
    }
    if (bds[3] < imgBds[2]) {
      bds[3] = imgBds[2];
    }

    if (bds[0] > imgBds[1]) {
      bds[0] = imgBds[1];
    }
    if (bds[1] > imgBds[1]) {
      bds[1] = imgBds[1];
    }
    if (bds[2] > imgBds[3]) {
      bds[2] = imgBds[3];
    }
    if (bds[3] > imgBds[3]) {
      bds[3] = imgBds[3];
    }

    // Do not the bounds go to zero area.
    if (bds[0] !== bds[1]) {
      this.Bounds[0] = bds[0];
      this.Bounds[1] = bds[1];
    }
    if (bds[2] !== bds[3]) {
      this.Bounds[2] = bds[2];
      this.Bounds[3] = bds[3];
    }

        // Update the label.
    var dim = [this.Bounds[1] - this.Bounds[0], this.Bounds[3] - this.Bounds[2]];
    this.Label.text(dim[0] + ' x ' + dim[1] +
                        ' = ' + this.FormatPixels(dim[0] * dim[1]) + 'pixels');
  };

  CutoutWidget.prototype.FormatPixels = function (num) {
    if (num > 1000000000) {
      return Math.round(num / 1000000000) + 'G';
    }
    if (num > 1000000) {
      return Math.round(num / 1000000) + 'M';
    }
    if (num > 1000) {
      return Math.round(num / 1000) + 'k';
    }
    return num;
  };

  CutoutWidget.prototype.HandleTouchPan = function (event) {
  };

  CutoutWidget.prototype.HandleTouchPinch = function (event) {
  };

  CutoutWidget.prototype.HandleTouchEnd = function (event) {
  };

  CutoutWidget.prototype.CheckActive = function (event) {
    var cam = this.Layer.GetCamera();
        // it is easier to make the comparison in slide coordinates,
        // but we need a tolerance in pixels.
    var tolerance = cam.Height / 200;
    var pt = cam.ConvertPointViewerToWorld(event.offsetX, event.offsetY);
    var active = 0;

    var inX = (this.DragBounds[0] - tolerance < pt[0] && pt[0] < this.DragBounds[1] + tolerance);
    var inY = (this.DragBounds[2] - tolerance < pt[1] && pt[1] < this.DragBounds[3] + tolerance);
    if (inY && Math.abs(pt[0] - this.DragBounds[0]) < tolerance) {
      active = active | 1;
    }
    if (inY && Math.abs(pt[0] - this.DragBounds[1]) < tolerance) {
      active = active | 2;
    }
    if (inX && Math.abs(pt[1] - this.DragBounds[2]) < tolerance) {
      active = active | 4;
    }
    if (inX && Math.abs(pt[1] - this.DragBounds[3]) < tolerance) {
      active = active | 8;
    }

    var center = [(this.DragBounds[0] + this.DragBounds[1]) * 0.5,
      (this.DragBounds[2] + this.DragBounds[3]) * 0.5];
    tolerance *= 2;
    if (Math.abs(pt[0] - center[0]) < tolerance &&
            Math.abs(pt[1] - center[1]) < tolerance) {
      active = active | 16;
    }

    if (active !== this.Active) {
      this.SetActive(active);
      this.Viewewr.EventuallyRender();
    }

    return false;
  };

    // Multiple active states. Active state is a bit confusing.
  CutoutWidget.prototype.GetActive = function () {
    return this.Active;
  };

  CutoutWidget.prototype.Deactivate = function () {
    this.Div.remove();
    if (this.Layer === null) {
      return;
    }
    this.Layer.DeactivateWidget(this);
    this.Layer.RemoveWidget(this);

    this.Viewer.EventuallyRender();
  };

    // Setting to active always puts state into "active".
    // It can move to other states and stay active.
  CutoutWidget.prototype.SetActive = function (active) {
    if (this.Active === active) {
      return;
    }
    this.Active = active;

    if (active !== 0) {
      this.Layer.ActivateWidget(this);
    } else {
      this.Layer.DeactivateWidget(this);
    }
    this.Viewer.EventuallyRender();
  };

  SAM.CutoutWidget = CutoutWidget;
})();

// TODO:
// Fix the webGL attributes not initialized properly warning.
// Multiple text object should share the same texture.
// Add symbols -=+[]{},.<>'";: .....

(function () {
  'use strict';

  var LINE_SPACING = 1.3;

    // I need an array to map ascii to my letter index.
    // a = 97
  var ASCII_LOOKUP =
    [[0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 0
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 5
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 10
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 15
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 20
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 25
         [0, 413, 50, 98], [0, 413, 50, 98], [900, 17, 30, 98], [791, 119, 28, 95], [0, 413, 50, 98], // 30 32 = ' ' 33="!"
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 35
         [260, 18, 32, 97], [292, 18, 32, 97], [0, 413, 50, 98], [0, 413, 50, 98], [635, 120, 25, 36], // 40 40="(" 41=")" 44=','
         [783, 17, 37, 57], [662, 121, 25, 34], [687, 121, 46, 96], [822, 214, 58, 98], [881, 214, 50, 98], // 45 45="-" 46="." 47="/" 48 = 01
         [932, 214, 56, 98], [0, 114, 53, 98], [54, 114, 54, 98], [109, 114, 54, 98], [164, 114, 57, 98], // 50 = 23456
         [222, 114, 49, 98], [272, 114, 57, 98], [330, 114, 56, 98], [554, 18, 25, 76], [579, 121, 28, 73], // 55 = 789 (387 ') 58=":" 59=";"
         [0, 413, 50, 98], [412, 120, 62, 69], [0, 413, 50, 98], [733, 10, 53, 106], [0, 413, 50, 98], // 60 61 = "=" 63="?"
         [263, 314, 67, 98], [331, 314, 55, 98], [387, 314, 59, 98], [447, 314, 66, 98], [514, 314, 52, 98], // 65 = ABCDE
         [566, 314, 49, 98], [616, 314, 67, 98], [684, 314, 67, 98], [752, 314, 24, 98], [777, 314, 36, 98], // 70 = FGHIJ
         [814, 314, 58, 98], [873, 314, 45, 98], [919, 314, 88, 98], [0, 214, 66, 98], [69, 214, 72, 98], // 75 = KLMNO
         [142, 214, 54, 98], [197, 214, 76, 98], [274, 214, 53, 98], [328, 214, 49, 98], [378, 214, 55, 98], // 80 = PQRST
         [434, 214, 66, 98], [501, 214, 63, 98], [565, 214, 96, 98], [662, 214, 55, 98], [718, 214, 53, 98], // 85 = UVWXY
         [772, 214, 49, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 90 = Z
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [51, 413, 56, 98], [108, 413, 50, 98], // 95 97 = abc
         [154, 413, 50, 98], [210, 413, 50, 98], [263, 413, 39, 98], [301, 413, 50, 98], [350, 413, 54, 98], // 100 = defgh
         [406, 413, 22, 98], [427, 413, 34, 98], [458, 413, 50, 98], [508, 413, 24, 98], [532, 413, 88, 98], // 105 = ijklm
         [619, 413, 57, 98], [675, 413, 60, 98], [734, 413, 57, 98], [790, 413, 57, 98], [847, 413, 40, 98], // 110 = nopqr
         [886, 413, 42, 98], [925, 413, 41, 98], [966, 413, 56, 98], [0, 314, 49, 98], [50, 314, 77, 98], // 115 = stuvw
         [127, 314, 48, 98], [173, 314, 52, 98], [224, 314, 42, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 120 = xyz
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 125
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 130
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 135
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 140
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 145
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 150
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 155
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 160
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 165
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 170
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 175
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 180
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 185
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 198
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 195
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 200
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 205
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 210
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 215
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 220
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 225
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 230
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 235
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 240
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 245
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 250
         [0, 413, 50, 98]];

  // All text object use the same texture map.

  function Text () {
    this.Color = [0.0, 0.1, 0.5];
    this.FontSize = 12; // Height in pixels

    // Position of the anchor in the world coordinate system.
    this.Position = [100, 100];
    this.Orientation = 0.0; // in degrees, counter clockwise, 0 is left

    // The anchor point and position are the same point.
    // Position is in world coordinates.
    // Offset is in pixel coordinates of text (buffers).
    // In pixel(text) coordinate system
    // It is the position of the upper left corner relative to the postion / anchor.
    this.Offset = [0, 0];
    this.Selected = false;

    // this.String = "Hello World";
    // this.String = "0123456789";
    this.String = '';

    // Pixel bounds are in text box coordiante system.
    this.PixelBounds = [0, 0, 0, 0];

    this.BackgroundFlag = false;
  }

  Text.prototype.DeleteSelected = function () {
    if (this.IsSelected()) {
      this.SetString('');
      return true;
    }
  };

  Text.prototype.IsEmpty = function () {
    return this.String === undefined || this.String === '';
  };

  Text.prototype.SetString = function (str) {
    this.String = str;
  };

  Text.prototype.GetString = function () {
    return this.String;
  };

  Text.prototype.Draw = function (view) {
    // Place the anchor of the text.
    // First transform the world anchor to view.
    var x = this.Position[0];
    var y = this.Position[1];
    if (this.PositionCoordinateSystem !== SAM.Shape.VIEWER) {
      var m = view.Camera.GetImageMatrix();
      x = (this.Position[0] * m[0] + this.Position[1] * m[4] + m[12]) / m[15];
      y = (this.Position[0] * m[1] + this.Position[1] * m[5] + m[13]) / m[15];
      // convert view to pixels (view coordinate system).
      x = view.Viewport[2] * (0.5 * (1.0 + x));
      y = view.Viewport[3] * (0.5 * (1.0 - y));
    }

    // Hacky attempt to mitigate the bug that randomly sends the Offset values into the tens of thousands.
    if (Math.abs(this.Offset[0]) > 1000 || Math.abs(this.Offset[1]) > 1000) {
      this.Offset = [-50, 0];
    }

    // (x,y) is the screen position of the text.
    // Canvas text location is lower left of first letter.
    var strArray = this.String.split('\n');
    // Move (x,y) from tip of the arrow to the upper left of the text box.
    var ctx = view.Context2d;
    ctx.save();
    var radians = this.Orientation * Math.PI / 180;
    var s = Math.sin(radians);
    var c = Math.cos(radians);
    ctx.setTransform(c, -s, s, c, x, y);
    x = -this.Offset[0];
    y = -this.Offset[1];

    ctx.font = this.FontSize + 'pt Calibri';
    var width = this.PixelBounds[1];
    var height = this.PixelBounds[3];
    // Draw the background text box.
    if (this.BackgroundFlag) {
      // ctx.fillStyle = '#fff';
      // ctx.strokeStyle = '#000';
      // ctx.fillRect(x - 2, y - 2, this.PixelBounds[1] + 4, (this.PixelBounds[3] + this.FontSize/3)*1.4);
      var radius = this.FontSize / 4;
      roundRect(ctx, x - radius, y - radius,
                width + 2 * radius, height + 2 * radius,
                radius, true, false);
    }

    // Choose the color for the text.
    if (this.Selected) {
      ctx.fillStyle = '#FF0';
    } else {
      ctx.fillStyle = SAM.ConvertColorToHex(this.Color);
    }

    // Convert (x,y) from upper left of textbox to lower left of first character.
    y = y + this.FontSize;
    // Draw the lines of the text.
    for (var i = 0; i < strArray.length; ++i) {
      ctx.fillText(strArray[i], x, y);
      // Move to the lower left of the next line.
      y = y + this.FontSize * LINE_SPACING;
    }

    // ctx.stroke();
    ctx.restore();
  };

  function roundRect (ctx, x, y, width, height, radius) {
    if (typeof radius === 'undefined') {
      radius = 2;
    }
    ctx.fillStyle = '#fff';
    // ctx.strokeStyle = '#666';
    ctx.fillRect(x, y, width, height);

    /*
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
    */
    // ctx.stroke();
    // ctx.fill();
  }

  Text.prototype.UpdateBuffers = function (view) {
    var i;
    if (!view.gl) {
      // Canvas.  Compute pixel bounds.
      var strArray = this.String.split('\n');
      var height = this.FontSize * LINE_SPACING * strArray.length;
      var width = 0;
      // Hack: use a global viewer because I do not have the viewer.
      // Maybe it should be passed in as an argument, or store the context
      // as an instance variable.
      var ctx = view.Context2d;
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.font = this.FontSize + 'pt Calibri';
      // Compute the width of the text box.
      for (i = 0; i < strArray.length; ++i) {
        var lineWidth = ctx.measureText(strArray[i]).width;
        if (lineWidth > width) { width = lineWidth; }
      }
      this.PixelBounds = [0, width, 0, height];
      ctx.restore();
      return;
    }
    // Create a textured quad for each letter.
    var vertexPositionData = [];
    var textureCoordData = [];
    var cellData = [];
        // 128 for power of 2, but 98 to top of characters.
    var charLeft = 0;
    var charTop = 0;
    var ptId = 0;
    this.PixelBounds = [0, 0, 0, this.FontSize];

    for (i = 0; i < this.String.length; ++i) {
      var idx = this.String.charCodeAt(i);
      if (idx === 10 || idx === 13) { // newline
        charLeft = 0;
        charTop += this.FontSize;
      } else {
        var port = ASCII_LOOKUP[idx];
        // Convert to texture coordinate values.
        var tLeft = port[0] / 1024.0;
        var tRight = (port[0] + port[2]) / 1024.0;
        var tBottom = port[1] / 512.0;
        var tTop = (port[1] + port[3]) / 512.0;
        // To place vertices
        var charRight = charLeft + port[2] * this.FontSize / 98.0;
        var charBottom = charTop + port[3] * this.FontSize / 98.0;

        // Accumulate bounds;
        if (this.PixelBounds[0] > charLeft) { this.PixelBounds[0] = charLeft; }
        if (this.PixelBounds[1] < charRight) { this.PixelBounds[1] = charRight; }
        if (this.PixelBounds[2] > charTop) { this.PixelBounds[2] = charTop; }
        if (this.PixelBounds[3] < charBottom) { this.PixelBounds[3] = charBottom; }

        // Make 4 points, We could share points.
        textureCoordData.push(tLeft);
        textureCoordData.push(tBottom);
        vertexPositionData.push(charLeft);
        vertexPositionData.push(charBottom);
        vertexPositionData.push(0.0);

        textureCoordData.push(tRight);
        textureCoordData.push(tBottom);
        vertexPositionData.push(charRight);
        vertexPositionData.push(charBottom);
        vertexPositionData.push(0.0);

        textureCoordData.push(tLeft);
        textureCoordData.push(tTop);
        vertexPositionData.push(charLeft);
        vertexPositionData.push(charTop);
        vertexPositionData.push(0.0);

        textureCoordData.push(tRight);
        textureCoordData.push(tTop);
        vertexPositionData.push(charRight);
        vertexPositionData.push(charTop);
        vertexPositionData.push(0.0);

        charLeft = charRight;

        // Now create the cell.
        cellData.push(0 + ptId);
        cellData.push(1 + ptId);
        cellData.push(2 + ptId);

        cellData.push(2 + ptId);
        cellData.push(1 + ptId);
        cellData.push(3 + ptId);
        ptId += 4;
      }
    }

    this.VertexTextureCoordBuffer = view.gl.createBuffer();
    view.gl.bindBuffer(view.gl.ARRAY_BUFFER, this.VertexTextureCoordBuffer);
    view.gl.bufferData(view.gl.ARRAY_BUFFER, new Float32Array(textureCoordData), view.gl.STATIC_DRAW);
    this.VertexTextureCoordBuffer.itemSize = 2;
    this.VertexTextureCoordBuffer.numItems = textureCoordData.length / 2;

    this.VertexPositionBuffer = view.gl.createBuffer();
    view.gl.bindBuffer(view.gl.ARRAY_BUFFER, this.VertexPositionBuffer);
    view.gl.bufferData(view.gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), view.gl.STATIC_DRAW);
    this.VertexPositionBuffer.itemSize = 3;
    this.VertexPositionBuffer.numItems = vertexPositionData.length / 3;

    this.CellBuffer = view.gl.createBuffer();
    view.gl.bindBuffer(view.gl.ELEMENT_ARRAY_BUFFER, this.CellBuffer);
    view.gl.bufferData(view.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cellData), view.gl.STATIC_DRAW);
    this.CellBuffer.itemSize = 1;
    this.CellBuffer.numItems = cellData.length;
  };

  // Point in text coordinates is over the text.
  Text.prototype.PointInText = function (xMouse, yMouse) {
    if (!this.Visibility) { return false; }

    var bds = this.PixelBounds.slice(0);
    if (this.BackgroundFlag) {
      var radius = this.FontSize / 4;
      bds[0] -= radius;
      bds[1] += radius;
      bds[2] -= radius;
      bds[3] += radius;
    }
    if (xMouse > bds[0] && xMouse < bds[1] &&
        yMouse > bds[2] && yMouse < bds[3]) {
      return true;
    }
    return false;
  };

  Text.prototype.SetColor = function (c) {
    this.Color = SAM.ConvertColor(c);
  };
  Text.prototype.GetColor = function () {
    return this.Color;
  };

  Text.prototype.SetFontSize = function (s) {
    this.FontSize = s;
  };
  Text.prototype.GetFontSize = function () {
    return this.FontSize;
  };

  Text.prototype.SetBackgroundFlag = function (f) {
    this.BackgroundFlag = f;
  };
  Text.prototype.GetBackgroundFlag = function () {
    return this.BackgroundFlag;
  };

  Text.prototype.IsSelected = function () {
    return this.Selected;
  };

  // Returns true if the selected state changed.
  Text.prototype.SetSelected = function (f) {
    if (f === this.Selected) { return false; }
    this.Selected = f;
    return true;
  };

  SAM.Text = Text;
})();

// ==============================================================================

(function () {
    // Depends on the CIRCLE widget
  'use strict';

  // Not receiving events
  var INACTIVE = 0;
  // Receiving events but not clickable
  var ACTIVE = 1;
  // Mouse over widget and clickable
  var HOVER = 2;
  // Dialog window is up.
  var DIALOG = 3;
  // Dragging the text but not the arrow point
  var DRAG_TEXT = 4;
  // Draggind the text and arrow.
  var DRAG = 5;

  var TEXT_ONLY = 0;
  var ARROW_HOVER = 1;
  var TEXT_ARROW = 2;

  // TODO: Get rid of this layer in the constructor.
  function TextWidget (layer) {
    this.Layer = layer;

    this.Type = 'text';

    this.Text = new SAM.Text();
    this.Text.BackgroundFlag = true;
    this.Arrow = new SAM.Arrow();
    this.ArrowModified = true;
    this.State = INACTIVE;

    this.VisibilityMode = TEXT_ONLY;

    // This method gets called if anything is added, deleted or moved.
    this.ModifiedCallback = undefined;
    // This method gets called if the active state of this widget turns on or off.
    // This is used to turn off the pencil button in the Panel.
    this.StateChangeCallback = undefined;
    // This is used by the annotationPanel to transfer draing mode to a new selected widget.
    this.SelectedCallback = undefined;

    // Hack because I do not have the layer here.  Net toset the initial position.
    this.Uninitialized = true;
  }

  TextWidget.prototype.SetModifiedCallback = function (callback) {
    this.ModifiedCallback = callback;
  };

  TextWidget.prototype.SetSelectedCallback = function (callback) {
    this.SelectedCallback = callback;
  };

  // Selects the widget if the text is fuly contained in the selection rectangle.
  TextWidget.prototype.ApplySelect = function (selection) {
    var bds = this.Text.PixelBounds;
    var cam = this.Layer.GetCamera();
    var p = cam.ConvertPointWorldToViewer(this.Text.Position[0], this.Text.Position[1]);

    if (selection.ViewerPointInSelection(p[0] + bds[0], p[1] + bds[2]) &&
        selection.ViewerPointInSelection(p[0] + bds[0], p[1] + bds[3]) &&
        selection.ViewerPointInSelection(p[0] + bds[1], p[1] + bds[2]) &&
        selection.ViewerPointInSelection(p[0] + bds[1], p[1] + bds[3])) {
      this.Text.SetSelected(true);
      this.Arrow.SetSelected(true);
      return true;
    }
    this.Text.SetSelected(false);
    this.Arrow.SetSelected(false);
    return false;
  };

  TextWidget.prototype.SetCreationCamera = function (cam) {
    // Lets save the zoom level (sort of).
    // Load will overwrite this for existing annotations.
    // This will allow us to expand annotations into notes.
    this.CreationCamera = cam.Serialize();
  };

  // This callback gets called when ever the active state changes,
  // even if caused by an external call. This widget is passed as a argument.
  // This is used to turn off the pencil button in the Panel.
  TextWidget.prototype.SetStateChangeCallback = function (callback) {
    this.StateChangeCallback = callback;
  };

  // Called when the state changes.
  TextWidget.prototype.StateChanged = function () {
    if (this.StateChangeCallback) {
      this.StateChangeCallback(this);
    }
  };

  // Called when widget is modified.
  TextWidget.prototype.Modified = function () {
    if (this.ModifiedCallback) {
      this.ModifiedCallback(this);
    }
  };

  TextWidget.prototype.SetActive = function (flag) {
    if (flag && this.State !== ACTIVE) {
      this.State = HOVER;
      this.StateChanged();
    }
    if (!flag && this.State !== INACTIVE) {
      this.State = INACTIVE;
      this.StateChanged();
      // I should just let te caller do this.
      this.Text.SetSelected(false);
      this.Arrow.SetSelected(false);
    }
    // And this.
    this.Layer.EventuallyDraw();
  };

  // I am not sure if this is used.  We have multiple selected states.
  // Default to the whole widget selected.
  TextWidget.prototype.SetSelected = function (flag) {
    this.Text.SetSelected(flag);
    this.Arrow.SetSelected(flag);

    if (flag && this.SelectedCallback) {
      (this.SelectedCallback)(this);
    }
    if (!flag) {
      // We can be selected without being active, but we cannot be
      // active without being selected.
      this.SetActive(false);
    }
  };

  TextWidget.prototype.SetStateToDialog = function () {
    if (this.State === DIALOG) {
      return;
    }
    if (!this.Dialog) {
      this.InitializeDialog();
    }
    this.State = DIALOG;
    this.WidgetPropertiesToDialog();
    this.StateChanged();
    this.ShowPropertiesDialog();
  };

  // Can we delete this?
  TextWidget.prototype.IsEmpty = function () {
    return this.Text.IsEmpty();
  };

  TextWidget.prototype.IsSelected = function () {
    return this.Text.IsSelected() || this.Arrow.IsSelected();
  };

  TextWidget.prototype.SetPositionToDefault = function () {
    var view = this.Layer.GetView();
    this.Text.UpdateBuffers(view); // Needed to get the bounds.
    // middle top(above)
    var offset = [
      (this.Text.PixelBounds[0] + this.Text.PixelBounds[1]) * 0.5,
      -this.Text.PixelBounds[3]];
    var middle = [
      0.5 * (this.Text.PixelBounds[0] + this.Text.PixelBounds[1]),
      0.5 * (this.Text.PixelBounds[2] + this.Text.PixelBounds[3])];
    if (this.VisibilityMode === TEXT_ONLY) {
      this.Text.Offset = middle;
      this.SavedTextOffset = offset;
    } else {
      this.Text.Offset = offset;
      this.SavedTextOffset = offset;
    }

    // I would like to setup the anchor in the middle of the screen,
    // And have the Anchor in the middle of the text.
    var cam = this.Layer.GetCamera();
    var fp = cam.GetWorldFocalPoint();
    this.Text.Position = [fp[0], fp[1], 0];
    this.ArrowModified = true;
    this.Uninitialized = false;
  };

  // Three state visibility so text can be hidden during calss questions.
  // The combined visibilities is confusing.
  // Global text visibility is passed in as argument.
  // Local visiblity mode is the hover state of this text. (0 text only, 1: hover, 2: both on).
  TextWidget.prototype.Draw = function () {
    if (this.State === DIALOG) {
      // So it does not draw until after the initial dialog is gone.
      return;
    }
    // Get the text bounds and initialize the postion anchor and offset.
    if (this.Uninitialized) {
      this.SetPositionToDefault();
    }
    var view = this.Layer.GetView();
    // TODO:  FIx this . it is hacky.
    // I think bounds are not computable until after the first render or something.
    if (this.Text.PixelBounds[1] === 0) {
      this.Text.UpdateBuffers(view);
      this.ArrowModified = true;
    }
    if (this.ArrowModified) {
      this.UpdateArrow();
    }

    if (this.VisibilityMode !== 0) {
      this.Arrow.Draw(view);
    }
    // if (this.VisibilityMode !== ARROW_HOVER || this.Arrow.IsSelected()) {
    this.Text.Draw(view);
    this.Text.Visibility = true;
    // } else {
    //  this.Text.Visibility = false;
    // }
  };

  TextWidget.prototype.PasteCallback = function (data, mouseWorldPt) {
    this.Load(data);
    // Place the tip of the arrow at the mose location.
    this.Text.Position[0] = mouseWorldPt[0];
    this.Text.Position[1] = mouseWorldPt[1];
    this.ArrowModified = true;
    this.Layer.EventuallyDraw();
    this.Modified();
  };

  TextWidget.prototype.Serialize = function () {
    if (this.Text === undefined) { return null; }
    var obj = {};
    obj.type = 'text';
    obj.user_note_flag = this.UserNoteFlag;
    obj.color = this.Text.Color;
    obj.size = this.Text.FontSize;
    obj.offset = [-this.Text.Offset[0], -this.Text.Offset[1]];
    obj.position = this.Text.Position;
    obj.string = this.Text.String;
    obj.visibility = this.VisibilityMode;
    obj.backgroundFlag = this.Text.BackgroundFlag;
    obj.creation_camera = this.CreationCamera;

    return obj;
  };

  // Load a widget from a json object (origin MongoDB).
  TextWidget.prototype.Load = function (obj) {
    this.UserNoteFlag = obj.user_note_flag;

    this.Text.String = obj.string;
    var rgb = [parseFloat(obj.color[0]),
      parseFloat(obj.color[1]),
      parseFloat(obj.color[2])];
    this.Text.SetColor(rgb);
    this.Text.SetFontSize(parseFloat(obj.size));
    if (obj.backgroundFlag !== undefined) {
      this.Text.BackgroundFlag = obj.backgroundFlag;
    }
    this.Text.Position = [parseFloat(obj.position[0]),
      parseFloat(obj.position[1]),
      parseFloat(obj.position[2])];

    // I added offest and I have to deal with entries that do not have it.
    if (obj.offset) { // how to try / catch in javascript?
      this.SetTextOffset(parseFloat(obj.offset[0]),
                         parseFloat(obj.offset[1]));
    }

    // How zoomed in was the view when the annotation was created.
    if (obj.creation_camera !== undefined) {
      this.CreationCamera = obj.creation_camera;
    }

    if (obj.visibility !== undefined) {
      this.VisibilityMode = obj.visibility;
    }

    this.Arrow.SetFillColor(rgb);
    this.Arrow.ChooseOutlineColor();
    this.ArrowModified = true;
    this.Uninitialized = false;
  };

  // When the arrow is visible, the text is offset from the position (tip of arrow).
  TextWidget.prototype.SetTextOffset = function (x, y) {
    this.SavedTextOffset = [-x, -y];
    this.Text.Offset = this.SavedTextOffset.slice(0);
    this.ArrowModified = true;
  };

  // When the arrow is visible, the text is offset from the position (tip of arrow).
  TextWidget.prototype.SetPosition = function (x, y) {
    this.Text.Position = [x, y, 0];
    this.ArrowModified = true;
  };

  // Offset is in the middle of the bounds when the shape is not visible.
  TextWidget.prototype.SetVisibilityMode = function (mode) {
    if (mode === this.VisibilityMode) {
      return;
    }
    // var modified = true;
    this.ArrowModified = true;
    if (mode === TEXT_ONLY) {
      this.SavedTextOffset = this.Text.Offset.slice(0);
      // Adjust the offset so the anchor is in the center of the text.
      this.Text.Offset = [
        (this.Text.PixelBounds[0] + this.Text.PixelBounds[1]) * 0.5,
        (this.Text.PixelBounds[2] + this.Text.PixelBounds[3]) * 0.5];
    }
    if (this.VisibilityMode === TEXT_ONLY) {
      if (this.SavedTextOffset) {
        this.Text.Offset = this.SavedTextOffset.slice(0);
      } else {
        // SHort arrow pointing to the left.
        this.Text.Offset = [
          (this.Text.PixelBounds[0] + this.Text.PixelBounds[1]) * 0.5,
          -this.Text.PixelBounds[3]];
      }
    }
    this.VisibilityMode = mode;
  };

  // Change orientation and length of arrow based on the anchor location.
  TextWidget.prototype.UpdateArrow = function () {
    if (this.Text.PixelBounds[3] === 0) {
      return;
    }
    this.Arrow.Origin = this.Text.Position;

    // Compute the middle of the text bounds.
    var xMid = 0.5 * (this.Text.PixelBounds[0] + this.Text.PixelBounds[1]);
    var yMid = 0.5 * (this.Text.PixelBounds[2] + this.Text.PixelBounds[3]);
    var xRad = 0.5 * (this.Text.PixelBounds[1] - this.Text.PixelBounds[0]);
    var yRad = 0.5 * (this.Text.PixelBounds[3] - this.Text.PixelBounds[2]);

    // Compute the angle of the arrow.
    var dx = this.Text.Offset[0] - xMid;
    var dy = this.Text.Offset[1] - yMid;
    this.Arrow.Orientation = -(180.0 + Math.atan2(dy, dx) * 180.0 / Math.PI);
    // Compute the length of the arrow.
    var length = Math.sqrt(dx * dx + dy * dy);
    // Find the intersection of the vector and the bounding box.
    var min = length;
    var d;
    if (dy !== 0) {
      d = Math.abs(length * yRad / dy);
      if (min > d) { min = d; }
    }
    if (dx !== 0) {
      d = Math.abs(length * xRad / dx);
      if (min > d) { min = d; }
    }
    length = length - min - 5;
    if (length < 5) { length = 5; }
    this.Arrow.Length = length;
    this.Arrow.UpdateBuffers(this.Layer.GetView());
    this.ArrowModified = false;
  };

  // Returns this widget if it is selected, undefined otherwise.
  TextWidget.prototype.HandleSelect = function () {
    if (this.State === DIALOG) {
      return;
    }
    var event = this.Layer.Event;
    var tMouse = this.ScreenPixelToTextPixelPoint(event.offsetX, event.offsetY);

    if (this.Text.PointInText(tMouse[0], tMouse[1])) {
      this.Text.SetSelected(true);
      this.Arrow.SetSelected(false);
      this.Layer.GetParent().css({'cursor': 'move'});
      this.State = HOVER;
      return this;
    }
    var anchor = this.Text.Offset;
    if (this.Arrow.PointInShape(tMouse[0] - anchor[0], tMouse[1] - anchor[1])) {
      this.Text.SetSelected(true);
      this.Arrow.SetSelected(true);
      this.Layer.GetParent().css({'cursor': 'move'});
      this.State = DRAG;
      return this;
    }
    // Not really necesary, but it cannot hurt.
    this.SetActive(false);
  };

  // Returns true if modified.
  TextWidget.prototype.DeleteSelected = function () {
    return this.Text.DeleteSelected();
  };

  TextWidget.prototype.HandleKeyDown = function () {
    // The dialog consumes all key events.
    if (this.State === DIALOG) {
      return false;
    }

    // Copy
    var event = this.Layer.Event;
    if (event.keyCode === 67 && event.ctrlKey) {
      // control-c for copy
      // The extra identifier is not needed for widgets, but will be
      // needed if we have some other object on the clipboard.
      var clip = {Type: 'TextWidget', Data: this.Serialize()};
      localStorage.ClipBoard = JSON.stringify(clip);
      return false;
    }

    return true;
  };

  TextWidget.prototype.HandleMouseDown = function () {
    if (this.State === INACTIVE) {
      return true;
    }

    var event = this.Layer.Event;
    if (event.which === 1) {
      var x = event.offsetX;
      var y = event.offsetY;
      this.LastMouse = [x, y];
      // var tMouse = this.ScreenPixelToTextPixelPoint(x, y);
      if (this.State === HOVER) {
        if (this.Arrow.IsSelected()) {
          this.State = DRAG;
        } else if (this.Text.IsSelected()) {
          if (this.VisibilityMode === TEXT_ONLY) {
            this.State = DRAG;
          } else {
            this.State = DRAG_TEXT;
          }
        }
      }
    }

    return this.State === ACTIVE;
  };

  // returns false when it is finished doing its work.
  TextWidget.prototype.HandleMouseUp = function () {
    if (this.State === INACTIVE) {
      return true;
    }
    if (this.State === DRAG_TEXT || this.State === DRAG) {
      this.SetActive(true);
      this.Modified();
    }
    return false;
  };

  // I need to convert mouse screen point to coordinates of text buffer
  // to see if the mouse position is in the bounds of the text.
  // Screen y vector point down (up is negative).
  // Text coordinate system will match canvas text: origin upper left, Y point down.
  TextWidget.prototype.ScreenPixelToTextPixelPoint = function (x, y) {
    // convert the world arrow tip to screen.
    var cam = this.Layer.GetCamera();
    var textOriginScreenPixelPosition =
            cam.ConvertPointWorldToViewer(this.Text.Position[0], this.Text.Position[1]);
    // Offset to the text)
    x = (x - textOriginScreenPixelPosition[0]) + this.Text.Offset[0];
    y = (y - textOriginScreenPixelPosition[1]) + this.Text.Offset[1];

    return [x, y];
  };

  TextWidget.prototype.HandleMouseMove = function () {
    if (this.State === INACTIVE) {
      return true;
    }

    // Handle the hovering feature.
    // Indicates that clicking will drag by changing the cursor.
    var event = this.Layer.Event;
    var x = event.offsetX;
    var y = event.offsetY;
    if (this.State === ACTIVE || this.State === HOVER) {
      var cursor = '';
      var tMouse = this.ScreenPixelToTextPixelPoint(x, y);
      var anchor = this.Text.Offset;
      if (this.Text.IsSelected() && this.Text.PointInText(tMouse[0], tMouse[1])) {
        cursor = 'move';
        this.State = HOVER;
      } else if (this.Arrow.IsSelected() && this.Arrow.PointInShape(tMouse[0] - anchor[0], tMouse[1] - anchor[1])) {
        cursor = 'move';
        this.State = HOVER;
      } else {
        this.State = ACTIVE;
      }
      this.Layer.GetParent().css({'cursor': cursor});
    }

    if ((this.VisibilityMode === 0 && this.State === DRAG_TEXT) ||
        this.State === DRAG) {
      var cam = this.Layer.GetCamera();
      var w0 = cam.ConvertPointViewerToWorld(this.LastMouse[0], this.LastMouse[1]);
      var w1 = cam.ConvertPointViewerToWorld(x, y);
      var wdx = w1[0] - w0[0];
      var wdy = w1[1] - w0[1];
      this.Text.Position[0] += wdx;
      this.Text.Position[1] += wdy;
      this.ArrowModified = true;
      this.Layer.EventuallyDraw();
      this.LastMouse = [x, y];
      return false;
    } else if (this.State === DRAG_TEXT) { // Just the text not the anchor glyph
      var dx = event.offsetX - this.LastMouse[0];
      var dy = event.offsetY - this.LastMouse[1];
      this.LastMouse = [event.offsetX, event.offsetY];
      // TODO: Get the Mouse Deltas out of the layer.
      this.Text.Offset[0] -= dx;
      this.Text.Offset[1] -= dy;
      this.ArrowModified = true;
      this.Layer.EventuallyDraw();
      return false;
    }
    return true;
  };

  TextWidget.prototype.HandleTouchPan = function () {
    // We should probably have a handle touch start too.
    if (this.State === INACTIVE) {
      return true;
    }

    this.Layer.MouseDeltaX = this.Layer.MouseX - this.Layer.LastMouseX;
    this.Layer.MouseDeltaY = this.Layer.MouseY - this.Layer.LastMouseY;
    this.HandleMouseMove();
    return false;
  };

  TextWidget.prototype.HandleTouchEnd = function () {
    if (this.State === INACTIVE) {
      return true;
    }
    this.Modified();
    return false;
  };

  TextWidget.prototype.GetActive = function () {
    if (this.State !== INACTIVE) {
      return true;
    }
    return false;
  };

  // This creates the dialog and sets all values to defaults (from local storage).
  TextWidget.prototype.InitializeDialog = function () {
    this.Dialog = new SAM.Dialog(this.Layer.GetParent().parent());
    this.Dialog.Title.text('Text Annotation Editor');
    this.Dialog.Body.css({'margin': '1em 2em'});

    this.Dialog.TextInput =
      $('<textarea>')
      .appendTo(this.Dialog.Body)
      .css({
        'width': '87%',
        'height': '8em'});

    this.Dialog.FontDiv = $('<div>')
      .appendTo(this.Dialog.Body)
      .css({'display': 'table-row'});
    this.Dialog.FontLabel = $('<div>')
      .appendTo(this.Dialog.FontDiv)
      .text('Font (px):')
      .css({
        'display': 'table-cell',
        'text-align': 'left'});
    this.Dialog.FontInput = $('<input type="number">')
      .appendTo(this.Dialog.FontDiv)
      .val('12')
      .css({'display': 'table-cell'});

    this.Dialog.ColorDiv = $('<div>')
      .appendTo(this.Dialog.Body)
      .css({'display': 'table-row'});
    this.Dialog.ColorLabel = $('<div>')
      .appendTo(this.Dialog.ColorDiv)
      .text('Color:')
      .css({
        'display': 'table-cell',
        'text-align': 'left'});
    this.Dialog.ColorInput = $('<input type="color">')
      .appendTo(this.Dialog.ColorDiv)
      .val('#30ff00')
            .css({'display': 'table-cell'});

    this.Dialog.VisibilityModeDiv = $('<div>')
      .appendTo(this.Dialog.Body)
      .css({'display': 'table-row'});
    this.Dialog.VisibilityModeLabel = $('<div>')
      .appendTo(this.Dialog.VisibilityModeDiv)
      .text('Visibility:')
      .css({
        'display': 'table-cell',
        'text-align': 'left'});
    this.Dialog.VisibilityModeInputButtons = $('<div>')
      .appendTo(this.Dialog.VisibilityModeDiv)
      .css({'display': 'table-cell'});
    this.Dialog.VisibilityModeInputs = [];
    this.Dialog.VisibilityModeInputs[TEXT_ONLY] =
      $('<input type="radio" name="visibilityoptions" value="0">Text only</input>')
      .appendTo(this.Dialog.VisibilityModeInputButtons);

    $('<br>').appendTo(this.Dialog.VisibilityModeInputButtons);

    this.Dialog.VisibilityModeInputs[ARROW_HOVER] =
      $('<input type="radio" name="visibilityoptions" value="1">Arrow only, text on hover</input>')
      .appendTo(this.Dialog.VisibilityModeInputButtons);

    $('<br>').appendTo(this.Dialog.VisibilityModeInputButtons);

    this.Dialog.VisibilityModeInputs[TEXT_ARROW] =
      $('<input type="radio" name="visibilityoptions" value="2">Arrow and text visible</input>')
      .appendTo(this.Dialog.VisibilityModeInputButtons);

    this.Dialog.VisibilityModeInputs[TEXT_ONLY].attr('checked', 'true');

    this.Dialog.BackgroundDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.BackgroundLabel =
            $('<div>')
            .appendTo(this.Dialog.BackgroundDiv)
            .text('Background:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.BackgroundInput =
            $('<input type="checkbox">')
            .appendTo(this.Dialog.BackgroundDiv)
            .css({'display': 'table-cell'});

    // Get default properties.
    this.VisibilityMode = TEXT_ONLY;
    this.Dialog.BackgroundInput.prop('checked', true);
    var hexcolor = SAM.ConvertColorToHex(this.Dialog.ColorInput.val());
    if (localStorage.TextWidgetDefaults) {
      var defaults = JSON.parse(localStorage.TextWidgetDefaults);
      if (defaults.Color) {
        hexcolor = SAM.ConvertColorToHex(defaults.Color);
        this.Text.SetColor(hexcolor);
        this.Arrow.SetFillColor(hexcolor);
      } else {
        this.Arrow.SetFillColor(this.Text.Color);
      }
      if (defaults.FontSize) {
        // font size was wrongly saved as a string.
        this.Text.SetFontSize(parseFloat(defaults.FontSize));
      }
      if (defaults.BackgroundFlag !== undefined) {
        this.Text.BackgroundFlag = defaults.BackgroundFlag;
      }
      if (defaults.VisibilityMode !== undefined) {
        this.VisibilityMode = defaults.VisibilityMode;
        this.Dialog.VisibilityModeInputs[this.VisibilityMode].attr('checked', 'true');
      }
    }
  };

  // Can we bind the dialog apply callback to an objects method?
  TextWidget.prototype.ShowPropertiesDialog = function () {
    var self = this;
    this.Dialog.SetApplyCallback(function () { self.DialogApplyCallback(); });
    this.Dialog.SetCloseCallback(function () { self.DialogCloseCallback(); });
    this.Dialog.Show(true);
    this.Dialog.TextInput.focus();
  };

  TextWidget.prototype.DialogApplyCallback = function () {
    // Transfer properties fromt he dialog GUI to the widget.
    this.DialogPropertiesToWidget();
    // View bindings kept the dialog text input from working.
    if (!this.Layer) {
      return;
    }
    this.SetActive(false);
    this.Layer.EventuallyDraw();
  };

  TextWidget.prototype.DialogCloseCallback = function () {
    // View bindings keep dialog text input from working.
    if (this.Uninitialized) {
      // This will triger the layer to get rid of the text widget.
      this.Text.SetString('');
    }
    // Why doen't the layer do this?
    if (this.IsEmpty()) {
      this.Layer.EventuallyDraw();
      this.Layer.RemoveWidget(this);
      // Trigger the changed callback  (should we have a delete callback?)
      this.StateChanged();
      return;
    }

    this.SetActive(false);
    this.Layer.EventuallyDraw();
  };

  // Fill the dialog values from the widget values.
  TextWidget.prototype.WidgetPropertiesToDialog = function () {
    this.Dialog.ColorInput.val(SAM.ConvertColorToHex(this.Text.Color));
    this.Dialog.FontInput.val(this.Text.GetFontSize().toFixed(0));
    this.Dialog.BackgroundInput.prop('checked', this.Text.BackgroundFlag);
    this.Dialog.TextInput.val(this.Text.String);
    // this.Dialog.VisibilityModeInputs[this.VisibilityMode].attr('checked', true);
  };

  // Copy the properties of the dialog into the widget
  TextWidget.prototype.DialogPropertiesToWidget = function () {
    var modified = false;

    // Get the string
    this.ApplyLineBreaks();
    var string = this.Dialog.TextInput.val();
    // remove any trailing white space.
    string = string.trim();
    if (string === '') {
      this.Layer.EventuallyDraw();
      this.Layer.RemoveWidget(this);
      // Trigger the changed callback  (should we have a delete callback?)
      this.StateChanged();
      return;
    }
    if (string !== this.Text.GetString()) { modified = true; }
    this.Text.SetString(string);

    // Get the color
    var hexcolor = SAM.ConvertColorToHex(this.Dialog.ColorInput.val());
    if (hexcolor !== this.Text.GetColor()) {
      modified = true;
      this.Text.SetColor(hexcolor);
      this.Arrow.SetFillColor(hexcolor);
      this.Arrow.ChooseOutlineColor();
      this.ArrowModified = true;
    }

    // Get the font size
    var fontSize = parseFloat(this.Dialog.FontInput.val());
    if (fontSize !== this.Text.GetFontSize()) { modified = true; }
    this.Text.SetFontSize(fontSize);

    // Get the visibility mode
    var mode = TEXT_ONLY;
    if (this.Dialog.VisibilityModeInputs[TEXT_ONLY].prop('checked')) {
      if (this.VisibilityMode !== TEXT_ONLY) { modified = true; }
      mode = TEXT_ONLY;
    } else if (this.Dialog.VisibilityModeInputs[ARROW_HOVER].prop('checked')) {
      if (this.VisibilityMode !== ARROW_HOVER) { modified = true; }
      mode = ARROW_HOVER;
    } else {
      if (this.VisibilityMode !== TEXT_ARROW) { modified = true; }
      mode = TEXT_ARROW;
    }
    if (this.VisibilityMode !== mode) {
      // This also changes the anchor if necessary.
      this.SetVisibilityMode(mode);
      modified = true;
    }

    // Background flag is not working for some reasop.
    var backgroundFlag = this.Dialog.BackgroundInput.prop('checked');
    if (backgroundFlag !== this.Text.GetBackgroundFlag()) {
      modified = true;
      this.Text.SetBackgroundFlag(backgroundFlag);
    }

    // Save values in local storage as defaults for next time.
    localStorage.TextWidgetDefaults = JSON.stringify({
      Color: hexcolor,
      FontSize: this.Text.GetFontSize(),
      VisibilityMode: this.VisibilityMode,
      BackgroundFlag: backgroundFlag});

    if (modified) {
      this.Modified();
    }
  };

  // Function to apply line breaks to textarea text.
  TextWidget.prototype.ApplyLineBreaks = function () {
    var oTextarea = this.Dialog.TextInput[0];

    oTextarea.setAttribute('wrap', 'off');
    var strRawValue = oTextarea.value;
    oTextarea.value = '';
    var nEmptyWidth = oTextarea.scrollWidth;
    var nLastWrappingIndex = -1;
    for (var i = 0; i < strRawValue.length; i++) {
      var curChar = strRawValue.charAt(i);
      if (curChar === ' ' || curChar === '-' || curChar === '+') {
        nLastWrappingIndex = i;
      }
      oTextarea.value += curChar;
      if (oTextarea.scrollWidth > nEmptyWidth) {
        var buffer = '';
        if (nLastWrappingIndex >= 0) {
          for (var j = nLastWrappingIndex + 1; j < i; j++) {
            buffer += strRawValue.charAt(j);
          }
          nLastWrappingIndex = -1;
        }
        buffer += curChar;
        oTextarea.value = oTextarea.value.substr(0, oTextarea.value.length - buffer.length);
        oTextarea.value += '\n' + buffer;
      }
    }
    oTextarea.setAttribute('wrap', '');
  };

  SAM.TextWidget = TextWidget;
})();

// Polyline. one line witn multiple segments.

(function () {
  'use strict';

  function Polyline () {
    SAM.Shape.call(this);
    this.Origin = [0.0, 0.0]; // Center in world coordinates.
    this.Points = [];
    this.Closed = false;
    this.Bounds = [0, -1, 0, -1];
  }
  Polyline.prototype = new SAM.Shape();

  // Polyline.prototype.destructor=function() {
  // Get rid of the buffers?
  // }

  // A single point is considered empty.
  Polyline.prototype.IsEmpty = function () {
    if (this.Points.length < 2) {
      return true;
    }
    return false;
  };

  Polyline.prototype.DeleteSelected = function () {
    if (this.IsSelected()) {
      this.Points = [];
      return true;
    }
    return false;
  };

  Polyline.prototype.SetLineWidth = function (lineWidth) {
    this.LineWidth = lineWidth;
  };

  Polyline.prototype.GetLineWidth = function () {
    return this.LineWidth;
  };

  Polyline.prototype.GetEdgeLength = function (edgeIdx) {
    if (edgeIdx < 0 || edgeIdx > this.Points.length - 2) {
      return 0;
    }
    var dx = this.Points[edgeIdx + 1][0] - this.Points[edgeIdx][0];
    var dy = this.Points[edgeIdx + 1][1] - this.Points[edgeIdx][1];

    return Math.sqrt(dx * dx + dy * dy);
  };

  Polyline.prototype.GetNumberOfPoints = function () {
    return this.Points.length;
  };

  // Internal bounds will ignore origin and orientation.
  Polyline.prototype.GetBounds = function () {
    var bounds = this.Bounds.slice(0);
    bounds[0] += this.Origin[0];
    bounds[1] += this.Origin[0];
    bounds[2] += this.Origin[1];
    bounds[3] += this.Origin[1];
    return bounds;
  };

  // Returns 0 if is does not overlap at all.
  // Returns 1 if part of the section is in the bounds.
  // Returns 2 if all of the section is in the bounds.
  Polyline.prototype.ContainedInBounds = function (bds) {
    // Need to get world bounds.
    var myBds = this.GetBounds();

    // Polyline does not cache bounds, so just look to the points.
    if (bds[1] < myBds[0] || bds[0] > myBds[1] ||
            bds[3] < myBds[2] || bds[2] > myBds[3]) {
      return 0;
    }
    if (bds[1] >= myBds[0] && bds[0] <= myBds[1] &&
            bds[3] >= myBds[2] && bds[2] <= myBds[3]) {
      return 2;
    }
    return 1;
  };

  Polyline.prototype.SetOrigin = function (origin) {
    this.Origin = origin.slice(0);
  };

  // Adds origin to points and sets origin to 0.
  Polyline.prototype.ResetOrigin = function (view) {
    for (var i = 0; i < this.Points.length; ++i) {
      var pt = this.Points[i];
      pt[0] += this.Origin[0];
      pt[1] += this.Origin[1];
    }
    this.Origin[0] = 0;
    this.Origin[1] = 0;
    this.UpdateBuffers(view);
  };

  // Returns -1 if the point is not on a vertex.
  // Returns the index of the vertex is the point is within dist of a the
  // vertex.
  Polyline.prototype.PointOnVertex = function (pt, dist) {
    dist = dist * dist;
    for (var i = 0; i < this.Points.length; ++i) {
      var dx = this.Points[i][0] - pt[0];
      var dy = this.Points[i][1] - pt[1];
      if (dx * dx + dy * dy < dist) {
        return i;
      }
    }
    return -1;
  };

  // Returns undefined if the point is not on the shape.
  // Otherwise returns the indexes of the segment touched [i0, i1, k].
  Polyline.prototype.PointOnShape = function (pt, dist) {
    // Make a copy of the point (array).
    pt = pt.slice(0);
    pt[0] -= this.Origin[0];
    pt[1] -= this.Origin[1];
    // NOTE: bounds already includes lineWidth
    if (pt[0] + dist < this.Bounds[0] || pt[0] - dist > this.Bounds[1] ||
            pt[1] + dist < this.Bounds[2] || pt[1] - dist > this.Bounds[3]) {
      return undefined;
    }
    // Check for mouse touching an edge.
    var k;
    for (var i = 1; i < this.Points.length; ++i) {
      k = this.IntersectPointLine(pt, this.Points[i - 1],
                                  this.Points[i], dist);
      if (k !== undefined) {
        return [i - 1, i, k];
      }
    }
    if (this.Closed) {
      k = this.IntersectPointLine(pt, this.Points[this.Points.length - 1],
                                  this.Points[0], dist);
      if (k !== undefined) {
        return [this.Points.length - 1, 0, k];
      }
    }
    return undefined;
  };

  // Find a world location of a popup point given a camera.
  Polyline.prototype.FindPopupPoint = function (cam) {
    if (this.Points.length === 0) { return; }
    var roll = cam.GetWorldRoll();
    var s = Math.sin(roll + (Math.PI * 0.25));
    var c = Math.cos(roll + (Math.PI * 0.25));
    var bestPt = this.Points[0];
    var bestProjection = (c * bestPt[0]) - (s * bestPt[1]);
    for (var i = 1; i < this.Points.length; ++i) {
      var pt = this.Points[i];
      var projection = (c * pt[0]) - (s * pt[1]);
      if (projection > bestProjection) {
        bestProjection = projection;
        bestPt = pt;
      }
    }
    bestPt[0] += this.Origin[0];
    bestPt[1] += this.Origin[1];
    return bestPt;
  };

  // Note, self intersection can cause unexpected areas.
  // i.e looping around a point twice ...
  Polyline.prototype.ComputeArea = function () {
    if (this.Points.length < 3) {
      return 0.0;
    }

    // Compute the center. It should be more numerically stable.
    // I could just choose the first point as the origin.
    var cx = 0;
    var cy = 0;
    for (var j = 0; j < this.Points.length; ++j) {
      cx += this.Points[j][0];
      cy += this.Points[j][1];
    }
    cx = cx / this.Points.length;
    cy = cy / this.Points.length;

    var area = 0.0;
    // Iterate over triangles adding the area of each
    var last = this.Points.length - 1;
    var vx1 = this.Points[last][0] - cx;
    var vy1 = this.Points[last][1] - cy;
    // First and last point form another triangle (they are not the same).
    for (j = 0; j < this.Points.length; ++j) {
      // Area of triangle is 1/2 magnitude of cross product.
      var vx2 = vx1;
      var vy2 = vy1;
      vx1 = this.Points[j][0] - cx;
      vy1 = this.Points[j][1] - cy;
      area += (vx1 * vy2) - (vx2 * vy1);
    }

    return area;
  };

  Polyline.prototype.MergePoints = function (thresh, view) {
    thresh = thresh * thresh;
    var modified = false;
    for (var i = 1; i < this.Points.length; ++i) {
      var dx = this.Points[i][0] - this.Points[i - 1][0];
      var dy = this.Points[i][1] - this.Points[i - 1][1];
      if (dx * dx + dy * dy < thresh) {
                // The two points are close. Remove the point.
        this.Points.splice(i, 1);
                // Removing elements from the array we are iterating over.
        --i;
        modified = true;
      }
    }
    if (modified) {
      this.UpdateBuffers(view);
    }
  };

  // The real problem is aliasing.  Line is jagged with high frequency sampling artifacts.
  // Pass in the spacing as a hint to get rid of aliasing.
  Polyline.prototype.Decimate = function (spacing, view) {
    // Keep looping over the line removing points until the line does not change.
    var modified = true;
    while (modified) {
      modified = false;
      var newPoints = [];
      newPoints.push(this.Points[0]);
      // Window of four points.
      var i = 3;
      while (i < this.Points.length) {
        var p0 = this.Points[i];
        var p1 = this.Points[i - 1];
        var p2 = this.Points[i - 2];
        var p3 = this.Points[i - 3];
        // Compute the average of the center two.
        var cx = (p1[0] + p2[0]) * 0.5;
        var cy = (p1[1] + p2[1]) * 0.5;
        // Find the perendicular normal.
        var nx = (p0[1] - p3[1]);
        var ny = -(p0[0] - p3[0]);
        var mag = Math.sqrt(nx * nx + ny * ny);
        nx = nx / mag;
        ny = ny / mag;
        mag = Math.abs(nx * (cx - this.Points[i - 3][0]) + ny * (cy - this.Points[i - 3][1]));
        // Mag metric does not distinguish between line and a stroke that double backs on itself.
        // Make sure the two point being merged are between the outer points 0 and 3.
        var dir1 = (p0[0] - p1[0]) * (p3[0] - p1[0]) + (p0[1] - p1[1]) * (p3[1] - p1[1]);
        var dir2 = (p0[0] - p2[0]) * (p3[0] - p2[0]) + (p0[1] - p2[1]) * (p3[1] - p2[1]);
        if (mag < spacing && dir1 < 0.0 && dir2 < 0.0) {
          // Replace the two points with their average.
          newPoints.push([cx, cy, 0]);
          modified = true;
          // Skip the next point the window will have one old merged point,
          // but that is ok because it is just used as reference and not altered.
          i += 2;
        } else {
          //  No modification.  Just move the window one.
          newPoints.push(this.Points[i - 2]);
          ++i;
        }
      }
      // Copy the remaing point / 2 points
      i = i - 2;
      while (i < this.Points.length) {
        newPoints.push(this.Points[i]);
        ++i;
      }
      this.Points = newPoints;
    }
    this.UpdateBuffers(view);
  };

  Polyline.prototype.AddPointToBounds = function (pt, radius) {
    if (pt[0] - radius < this.Bounds[0]) {
      this.Bounds[0] = pt[0] - radius;
    }
    if (pt[0] + radius > this.Bounds[1]) {
      this.Bounds[1] = pt[0] + radius;
    }

    if (pt[1] - radius < this.Bounds[2]) {
      this.Bounds[2] = pt[1] - radius;
    }
    if (pt[1] + radius > this.Bounds[3]) {
      this.Bounds[3] = pt[1] + radius;
    }
  };

  // NOTE: Line thickness is handled by style in canvas.
  // I think the GL version that uses triangles is broken.
  Polyline.prototype.UpdateBuffers = function (view) {
    // Hack: Annotations really do not need to worry about webgl
    // anymore. And the view is only used to get the webgl context.
    view = view || {};

    var points = this.Points.slice(0);
    if (this.Closed && points.length > 2) {
      points.push(points[0]);
    }
    this.PointBuffer = [];
    var cellData = [];
    var lineCellData = [];
    this.Matrix = mat4.create();
    mat4.identity(this.Matrix);

    if (this.Points.length === 0) { return; }
    // xMin,xMax, yMin,yMax
    this.Bounds = [points[0][0], points[0][0], points[0][1], points[0][1]];

    var i;
    if (this.LineWidth === 0 || !view.gl) {
      for (i = 0; i < points.length; ++i) {
        this.PointBuffer.push(points[i][0]);
        this.PointBuffer.push(points[i][1]);
        this.PointBuffer.push(0.0);
        this.AddPointToBounds(points[i], 0);
      }
      // Not used for line width === 0.
      for (i = 2; i < points.length; ++i) {
        cellData.push(0);
        cellData.push(i - 1);
        cellData.push(i);
      }
    } else {
      // Compute a list normals for middle points.
      var edgeNormals = [];
      var mag;
      var x;
      var y;
      var end = points.length - 1;
      // Compute the edge normals.
      for (i = 0; i < end; ++i) {
        x = points[i + 1][0] - points[i][0];
        y = points[i + 1][1] - points[i][1];
        mag = Math.sqrt(x * x + y * y);
        edgeNormals.push([-y / mag, x / mag]);
      }

      if (end > 0) {
        var half = this.LineWidth / 2.0;
        // 4 corners per point
        var dx = edgeNormals[0][0] * half;
        var dy = edgeNormals[0][1] * half;
        this.PointBuffer.push(points[0][0] - dx);
        this.PointBuffer.push(points[0][1] - dy);
        this.PointBuffer.push(0.0);
        this.PointBuffer.push(points[0][0] + dx);
        this.PointBuffer.push(points[0][1] + dy);
        this.PointBuffer.push(0.0);
        this.AddPointToBounds(points[i], half);
        for (i = 1; i < end; ++i) {
          this.PointBuffer.push(points[i][0] - dx);
          this.PointBuffer.push(points[i][1] - dy);
          this.PointBuffer.push(0.0);
          this.PointBuffer.push(points[i][0] + dx);
          this.PointBuffer.push(points[i][1] + dy);
          this.PointBuffer.push(0.0);
          dx = edgeNormals[i][0] * half;
          dy = edgeNormals[i][1] * half;
          this.PointBuffer.push(points[i][0] - dx);
          this.PointBuffer.push(points[i][1] - dy);
          this.PointBuffer.push(0.0);
          this.PointBuffer.push(points[i][0] + dx);
          this.PointBuffer.push(points[i][1] + dy);
          this.PointBuffer.push(0.0);
        }
        this.PointBuffer.push(points[end][0] - dx);
        this.PointBuffer.push(points[end][1] - dy);
        this.PointBuffer.push(0.0);
        this.PointBuffer.push(points[end][0] + dx);
        this.PointBuffer.push(points[end][1] + dy);
        this.PointBuffer.push(0.0);
      }
      // Generate the triangles for a thick line
      for (i = 0; i < end; ++i) {
        lineCellData.push(0 + 4 * i);
        lineCellData.push(1 + 4 * i);
        lineCellData.push(3 + 4 * i);
        lineCellData.push(0 + 4 * i);
        lineCellData.push(3 + 4 * i);
        lineCellData.push(2 + 4 * i);
      }

      // Not used.
      for (i = 2; i < points.length; ++i) {
        cellData.push(0);
        cellData.push((2 * i) - 1);
        cellData.push(2 * i);
      }
    }

    if (view.gl) {
      this.VertexPositionBuffer = view.gl.createBuffer();
      view.gl.bindBuffer(view.gl.ARRAY_BUFFER, this.VertexPositionBuffer);
      view.gl.bufferData(view.gl.ARRAY_BUFFER, new Float32Array(this.PointBuffer), view.gl.STATIC_DRAW);
      this.VertexPositionBuffer.itemSize = 3;
      this.VertexPositionBuffer.numItems = this.PointBuffer.length / 3;

      this.CellBuffer = view.gl.createBuffer();
      view.gl.bindBuffer(view.gl.ELEMENT_ARRAY_BUFFER, this.CellBuffer);
      view.gl.bufferData(view.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cellData), view.gl.STATIC_DRAW);
      this.CellBuffer.itemSize = 1;
      this.CellBuffer.numItems = cellData.length;

      if (this.LineWidth !== 0) {
        this.LineCellBuffer = view.gl.createBuffer();
        view.gl.bindBuffer(view.gl.ELEMENT_ARRAY_BUFFER, this.LineCellBuffer);
        view.gl.bufferData(view.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(lineCellData), view.gl.STATIC_DRAW);
        this.LineCellBuffer.itemSize = 1;
        this.LineCellBuffer.numItems = lineCellData.length;
      }
    }
  };

  // GLOBAL To Position the orientation of the edge.
  var EDGE_ANGLE = (2 * Math.PI) * 0 / 24;
  var EDGE_OFFSET = 0; // In screen pixels.
  var EDGE_ROOT = 'edge';
  var EDGE_DELAY = 200;
  // Saves images centered at spots on the edge.
  // Roll is set to put the edge horizontal.
  // Step is in screen pixel units
  // Count is the starting index for file name generation.
  Polyline.prototype.SampleEdge = function (viewer, dim, step, count, callback) {
    var cam = viewer.GetCamera();
    var scale = cam.GetHeight() / cam.ViewportHeight;
    // Convert the step from screen pixels to world.
    step *= scale;
    var cache = viewer.GetCache();
    var dimensions = [dim, dim];
    // Distance between edge p0 to next sample point.
    var remaining = step / 2;
    // Recursive to serialize asynchronous cutouts.
    this.RecursiveSampleEdge(this.Points.length - 1, 0, remaining, step, count,
                             cache, dimensions, scale, callback);
  };
  Polyline.prototype.RecursiveSampleEdge = function (i0, i1, remaining, step, count,
                                                      cache, dimensions, scale, callback) {
    var pt0 = this.Points[i0];
    var pt1 = this.Points[i1];
    // Compute the length of the edge.
    var dx = pt1[0] - pt0[0];
    var dy = pt1[1] - pt0[1];
    var length = Math.sqrt(dx * dx + dy * dy);
    // Take steps along the edge (size 'step')
    if (remaining > length) {
      // We passed over this edge. Move to the next edge.
      remaining = remaining - length;
      i0 = i1;
      i1 += 1;
      // Test for terminating condition.
      if (i1 < this.Points.length) {
        this.RecursiveSampleEdge(i0, i1, remaining, step, count,
                                         cache, dimensions, scale, callback);
      } else {
        (callback)();
      }
    } else {
      var self = this;
      // Compute the sample point and tangent on this edge.
      var edgeAngle = -Math.atan2(dy, dx) + EDGE_ANGLE;
      var k = remaining / length;
      var x = pt0[0] + k * (pt1[0] - pt0[0]);
      var y = pt0[1] + k * (pt1[1] - pt0[1]);
      // Normal (should be out if loop is clockwise).
      var nx = -dy;
      var ny = dx;
      var mag = Math.sqrt(nx * nx + ny * ny);
      nx = (nx / mag) * EDGE_OFFSET * scale;
      ny = (ny / mag) * EDGE_OFFSET * scale;

      // Save an image at this sample point.
      SA.GetCutoutImage(
        cache, dimensions, [x + nx, y + ny], scale,
        edgeAngle, EDGE_ROOT + count + '.png',
        function () {
          setTimeout(
            function () {
              ++count;
              remaining += step;
              self.RecursiveSampleEdge(
                i0, i1, remaining, step, count,
                cache, dimensions, scale, callback);
            },
            EDGE_DELAY);
        }
      );
    }
  };

  // Returns true if the selection changed.
  Polyline.prototype.SetSelected = function (flag) {
    if (this.Selected === flag) {
      return false;
    }
    this.Selected = flag;
    return true;
  };

  Polyline.prototype.IsSelected = function () {
    return this.Selected;
  };

  // Polyline.prototype.Draw = function (view) {
  //  SAM.Shape.prototype.Draw.call(this, view);
  // };

  SAM.Polyline = Polyline;
})();

// Two behaviors:
// 1: Single click and drag causes a vertex to follow the
// mouse. A new vertex is inserted if the click was on an edge.  If a
// vertex is dropped on top of its neighbor, the are merged.
// 2: WHen the widget is first created or double cliccked, it goes into
// drawing mode.  A vertex follows the cursor with no buttons pressed.
// A single click causes another vertex to be added.  Double click ends the
// draing state.

(function () {
  // Depends on the CIRCLE widget
  'use strict';

  var VERTEX_RADIUS = 8;
  var EDGE_RADIUS = 4;

  // These need to be cleaned up.
  // Drawing started with 0 points or drawing restarted.
  var DRAWING = 0;
  // Drawing mode: Mouse is up and the new point is following the mouse.
  var DRAWING_EDGE = 1;
  // Not active.
  var WAITING = 2;
  // Waiting but receiving events.  The circle handle is active.
  var ACTIVE = 5;
  // Dialog is active.
  var PROPERTIES_DIALOG = 6;

  function PolylineWidget (layer, newFlag) {
    if (layer === undefined) {
      return;
    }

    // Keep track of annotation created by students without edit
    // permission.
    this.UserNoteFlag = !SA.Edit;
    this.Type = 'polyline';

    // Circle is to show an active vertex.
    this.Circle = new SAM.Circle();
    this.Polyline = new SAM.Polyline();

    this.InitializeDialog(layer);

    // Get default properties.
    this.LineWidth = 10.0;
    this.Polyline.Closed = false;
    if (localStorage.PolylineWidgetDefaults) {
      var defaults = JSON.parse(localStorage.PolylineWidgetDefaults);
      if (defaults.Color) {
        this.Dialog.ColorInput.val(SAM.ConvertColorToHex(defaults.Color));
      }
      // Remebering closed flag seems arbitrary.  User can complete
      // the loop if they want it closed. Leaving it open allow
      // restart too.
      // if (defaults.ClosedLoop !== undefined) {
      //    this.Polyline.Closed = defaults.ClosedLoop;
      // }
      if (defaults.LineWidth) {
        this.LineWidth = defaults.LineWidth;
        this.Dialog.LineWidthInput.val(this.LineWidth);
      }
    }

    this.Circle.FillColor = [1.0, 1.0, 0.2];
    this.Circle.OutlineColor = [0.0, 0.0, 0.0];
    this.Circle.FixedSize = false;
    this.Circle.ZOffset = -0.05;

    this.Polyline.OutlineColor = [0.0, 0.0, 0.0];
    this.Polyline.SetOutlineColor(this.Dialog.ColorInput.val());
    this.Polyline.FixedSize = false;

    layer.AddWidget(this);

    // Set line thickness using layer. (5 pixels).
    // The Line width of the shape switches to 0 (single line)
    // when the actual line with is too thin.
    this.Polyline.LineWidth = this.LineWidth;
    this.Circle.Radius = this.LineWidth;
    this.Circle.UpdateBuffers(layer.AnnotationView);

    // ActiveVertex and Edge are for placing the circle handle.
    this.ActiveVertex = -1;
    this.ActiveEdge = undefined;
    // Which vertec is being dragged.
    this.DrawingVertex = -1;

    if (newFlag) {
      this.State = DRAWING;
      this.SetCursorToDrawing(layer);
      // this.Polyline.Active = true;
      layer.ActivateWidget(this);
    } else {
      this.State = WAITING;
      this.Circle.Visibility = false;
    }

    // Lets save the zoom level (sort of).
    // Load will overwrite this for existing annotations.
    // This will allow us to expand annotations into notes.
    this.CreationCamera = layer.GetCamera().Serialize();

    // Set to be the width of a pixel.
    this.MinLine = 1.0;

    layer.EventuallyDraw(false);
  }

  PolylineWidget.prototype.InitializeDialog = function (layer) {
    var self = this;
    this.Dialog = new SAM.Dialog(function () { self.DialogApplyCallback(layer); });
    // Customize dialog for a lasso.
    this.Dialog.Title.text('Lasso Annotation Editor');
    this.Dialog.Body.css({'margin': '1em 2em'});
    // Color
    this.Dialog.ColorDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.ColorLabel =
            $('<div>')
            .appendTo(this.Dialog.ColorDiv)
            .text('Color:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.ColorInput =
            $('<input type="color">')
            .appendTo(this.Dialog.ColorDiv)
            .val('#30ff00')
            .css({'display': 'table-cell'});

    // closed check
    this.Dialog.ClosedDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.ClosedLabel =
            $('<div>')
            .appendTo(this.Dialog.ClosedDiv)
            .text('Closed:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.ClosedInput =
            $('<input type="checkbox">')
            .appendTo(this.Dialog.ClosedDiv)
            .attr('checked', 'false')
            .css({'display': 'table-cell'});
    /*
      this.Dialog.ReverseButton =
            $('<button>')
            .appendTo(this.Dialog.ClosedDiv)
            .text('Reverse')
            .css({'display': 'table-cell'})
            .on('click touchstart',
                function () {
                  self.Polyline.Points.reverse();
                });
    */

    // Line Width
    this.Dialog.LineWidthDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.LineWidthLabel =
            $('<div>')
            .appendTo(this.Dialog.LineWidthDiv)
            .text('Line Width:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.LineWidthInput =
            $('<input type="number">')
            .appendTo(this.Dialog.LineWidthDiv)
            .css({'display': 'table-cell'})
            .keypress(function (event) { return event.keyCode !== 13; });

    // Length
    this.Dialog.LengthDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.LengthLabel =
            $('<div>')
            .appendTo(this.Dialog.LengthDiv)
            .text('Length:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.Length =
            $('<div>')
            .appendTo(this.Dialog.LengthDiv)
            .css({'display': 'table-cell'});

    // Area
    this.Dialog.AreaDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.AreaLabel =
            $('<div>')
            .appendTo(this.Dialog.AreaDiv)
            .text('Area:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.Area =
            $('<div>')
            .appendTo(this.Dialog.AreaDiv)
            .css({'display': 'table-cell'});
  };

  PolylineWidget.prototype.Draw = function (view) {
    // When the line is too thin, we can see nothing.
    // Change it to line drawing.
    var cam = view.GetCamera();
    this.MinLine = cam.GetSpacing();
    if (this.LineWidth < this.MinLine) {
      // Too thin. Use a single line.
      this.Polyline.LineWidth = 0;
    } else {
      this.Polyline.LineWidth = this.LineWidth;
    }

    this.Polyline.Draw(view);
    this.Circle.Draw(view);
    if (this.Text) {
      this.PositionText();
      this.Text.Draw(view);
    }
  };

  PolylineWidget.prototype.PasteCallback = function (data, layer, mouseWorldPt) {
    this.Load(data);
    // Place the widget over the mouse.
    // This is more difficult than the circle.  Compute the shift.
    var bounds = this.Polyline.GetBounds();
    if (!bounds) {
      console.log('Warining: Pasting empty polyline');
      return;
    }
    var xOffset = mouseWorldPt[0] - (bounds[0] + bounds[1]) / 2;
    var yOffset = mouseWorldPt[1] - (bounds[2] + bounds[3]) / 2;
    for (var i = 0; i < this.Polyline.GetNumberOfPoints(); ++i) {
      this.Polyline.Points[i][0] += xOffset;
      this.Polyline.Points[i][1] += yOffset;
    }
    this.Polyline.UpdateBuffers(layer.AnnotationView);
    if (SAM.NotesWidget && !this.UserNoteFlag) { SAM.NotesWidget.MarkAsModified(); } // Hack
    if (this.UserNoteFlag && SA.notesWidget) { SA.notesWidget.EventuallySaveUserNote(); }
    layer.EventuallyDraw(true);
  };

  PolylineWidget.prototype.Serialize = function () {
    if (this.Polyline === undefined) { return null; }
    var obj = {};
    obj.type = 'polyline';
    obj.user_note_flag = this.UserNoteFlag;
    obj.lineColor = SAM.ConvertColorToHex(this.Polyline.OutlineColor);
    obj.lineWidth = this.LineWidth;
    // Copy the points to avoid array reference bug.
    obj.points = [];
    for (var i = 0; i < this.Polyline.GetNumberOfPoints(); ++i) {
      obj.points.push([this.Polyline.Points[i][0], this.Polyline.Points[i][1]]);
    }

    obj.creation_camera = this.CreationCamera;
    obj.closedloop = this.Polyline.Closed;

    if (this.Text) {
      obj.text = this.Text.String;
    }

    return obj;
  };

  PolylineWidget.prototype.InitializeText = function (layer) {
    if (this.Text) { return; }
    this.Text = new SAM.Text();
    this.Text.String = 'Hello';
    this.Text.UpdateBuffers(layer.AnnotationView); // Needed to get the bounds.
    this.Text.Color = [0.0, 0.0, 1.0];
    // position the middle of the text string
    this.Text.Anchor = [0.5 * (this.Text.PixelBounds[0] + this.Text.PixelBounds[1]),
      0.5 * (this.Text.PixelBounds[2] + this.Text.PixelBounds[3])];
    this.Text.Position = [100, 100, 0];
    // no sign background
    this.Text.BackgroundFlag = false;
  };

  PolylineWidget.prototype.PositionText = function () {
    var bounds = this.Polyline.GetBounds();
    var x = (bounds[0] + bounds[1]) / 2;
    var y = bounds[2];
    this.Text.Position = [x, y - 40, 0];
  };

  // Load a widget from a json object (origin MongoDB).
  // Object already json decoded.
  PolylineWidget.prototype.Load = function (obj, layer) {
    if (obj.lineColor) {
      this.Polyline.OutlineColor = SAM.ConvertColor(obj.lineColor);
    }
    if (obj.lineWidth !== undefined) {
      this.LineWidth = parseFloat(obj.lineWidth);
      this.Polyline.LineWidth = this.LineWidth;
    }
    this.Polyline.Points = [];
    for (var n = 0; n < obj.points.length; n++) {
      this.Polyline.Points[n] = [parseFloat(obj.points[n][0]),
        parseFloat(obj.points[n][1])];
    }
    if (obj.closedloop !== undefined) {
      this.Polyline.Closed = obj.closedloop;
    }
    this.Polyline.UpdateBuffers(layer.AnnotationView);

    if (obj.text) {
      if (!this.Text) {
        this.InitializeText(layer);
      }
      this.Text.String = obj.text;
    }

    // How zoomed in was the view when the annotation was created.
    if (obj.view_height !== undefined) {
      this.CreationCamera = obj.creation_camera;
    }
  };

  PolylineWidget.prototype.CityBlockDistance = function (p0, p1) {
    return Math.abs(p1[0] - p0[0]) + Math.abs(p1[1] - p0[1]);
  };

  PolylineWidget.prototype.HandleKeyDown = function (layer) {
    // 'r' reverses loop (and colors: Blue clockwise, Red counter clockwise)
    var event = layer.Event;
    if (event.keyCode === 82) {
      this.Polyline.Points.reverse();
      this.ColorByHandedness(layer);
      layer.EventuallyDraw(true);
    }

    // Copy
    if (event.keyCode === 67 && event.ctrlKey) {
      // control-c for copy
      // The extra identifier is not needed for widgets, but will be
      // needed if we have some other object on the clipboard.
      var clip = {Type: 'PolylineWidget', Data: this.Serialize()};
      localStorage.ClipBoard = JSON.stringify(clip);
      return false;
    }

    // escape key (or space or enter) to turn off drawing
    if (event.keyCode === 27 || event.keyCode === 32 || event.keyCode === 13) {
      // Last resort.  ESC key always deactivates the widget.
      // Deactivate.
      layer.DeactivateWidget(this);
      if (SAM.NotesWidget && !this.UserNoteFlag) { SAM.NotesWidget.MarkAsModified(); } // Hack
      if (this.UserNoteFlag && SA.notesWidget) { SA.notesWidget.EventuallySaveUserNote(); }
      if (window.SA) { SA.RecordState(); }
      return false;
    }

    return true;
  };

  PolylineWidget.prototype.HandleDoubleClick = function (layer) {
    if (this.State === DRAWING || this.State === DRAWING_EDGE) {
      this.Polyline.MergePoints(this.Circle.Radius);
      layer.DeactivateWidget(this);
      return false;
    }
    // Handle: Restart drawing mode. Any point on the line can be used.
    var event = layer.Event;
    if (this.State === ACTIVE) {
      var x = event.offsetX;
      var y = event.offsetY;
      var pt = layer.GetCamera().ConvertPointViewerToWorld(x, y);
      // Active => Double click starts drawing again.
      if (this.ActiveVertex !== -1) {
        this.Polyline.Points[this.ActiveVertex] = pt;
        this.DrawingVertex = this.ActiveVertex;
        this.ActiveVertex = -1;
      } else if (this.ActiveEdge) {
        // Insert a new point in the edge.
        // mouse down gets called before this and does this.
        // TODO: Fix it so mouse down/up do not get called on
        // double click.
        this.Polyline.Points.splice(this.ActiveEdge[1], 0, pt);
        this.DrawingVertex = this.ActiveEdge[1];
        this.ActiveEdge = undefined;
      } else {
        // Sanity check:
        console.log('No vertex or edge is active.');
        return false;
      }
      this.Polyline.UpdateBuffers(layer.AnnotationView);
      this.SetCursorToDrawing(layer);
      // Transition to drawing edge when we know which way the user
      // is dragging.
      this.State = DRAWING;
      layer.EventuallyDraw(false);
      return false;
    }
  };

  // Because of double click:
  // Mouse should do nothing. Mouse move and mouse up should cause all
  // the changes.
  PolylineWidget.prototype.HandleMouseDown = function (layer) {
    var event = layer.Event;
    // Only chnage handle properties.  Nothing permanent changes with mousedown.
    if (event.which === 1 && this.State === ACTIVE) {
      // User has started dragging a point with the mouse down.
      // Change the circle color to the line color when dragging.
      this.Circle.FillColor = this.Polyline.OutlineColor;
      this.Circle.Active = false;
    }

    return false;
  };

  // Returns false when it is finished doing its work.
  PolylineWidget.prototype.HandleClick = function (layer) {
    var event = layer.Event;
    this.HandleMouseUp(event);
  };

  // Returns false when it is finished doing its work.
  PolylineWidget.prototype.HandleMouseUp = function (layer) {
    var event = layer.Event;
    // Shop dialog with right click.  I could have a menu appear.
    if (event.which === 3) {
      // Right mouse was pressed.
      // Pop up the properties dialog.
      this.State = PROPERTIES_DIALOG;
      this.ShowPropertiesDialog();
      return false;
    }

    if (event.which !== 1) {
      return false;
    }

    if (this.State === ACTIVE) {
      // Dragging a vertex just ended.
      // Handle merging points when user drags a vertex onto another.
      this.Polyline.MergePoints(this.Circle.Radius);
      // TODO: Manage modidfied more consistently.
      if (SAM.NotesWidget && !this.UserNoteFlag) { SAM.NotesWidget.MarkAsModified(); } // Hack
      if (window.SA) { SA.RecordState(); }
      if (this.UserNoteFlag && SA.notesWidget) { SA.notesWidget.EventuallySaveUserNote(); }
      return false;
    }

    var x = event.offsetX;
    var y = event.offsetY;
    var pt = layer.GetCamera().ConvertPointViewerToWorld(x, y);

    if (this.State === DRAWING) {
      // handle the case where we restarted drawing and clicked again
      // before moving the mouse. (triple click).  Do nothing.
      if (this.Polyline.GetNumberOfPoints() > 0) {
        return false;
      }
      // First point after creation. We delayed adding the first
      // point so add it now.
      this.Polyline.Points.push(pt);
      // Not really necessary because DRAWING_EDGE case resets it.
      this.DrawingVertex = this.Polyline.GetNumberOfPoints() - 1;
      this.State = DRAWING_EDGE;
    }
    if (this.State === DRAWING_EDGE) {
      // Check to see if the loop was closed.
      if (this.Polyline.GetNumberOfPoints() > 2 && this.ActiveVertex === 0) {
        // The user clicked on the first vertex. End the line.
        // Remove the temporary point at end used for drawing.
        this.Polyline.Points.pop();
        this.Polyline.Closed = true;
        layer.DeactivateWidget(this);
        if (window.SA) { SA.RecordState(); }
        return false;
      }
      // Insert another point to drag around.
      this.DrawingVertex += 1;
      this.Polyline.Points.splice(this.DrawingVertex, 0, pt);
      this.Polyline.UpdateBuffers(layer.AnnotationView);
      layer.EventuallyDraw(true);
      return false;
    }
    if (this.UserNoteFlag && SA.notesWidget) { SA.notesWidget.EventuallySaveUserNote(); }
    return false;
  };

  //  Preconditions: State === ACTIVE, Mouse 1 is down.
  // ActiveVertex !== 1 or ActiveEdge === [p0,p1,k]
  PolylineWidget.prototype.HandleDrag = function (pt, layer) {
    if (this.ActiveEdge) {
      // User is dragging an edge point that has not been
      // created yet.
      var pt0 = this.Polyline.Points[this.ActiveEdge[0]];
      var pt1 = this.Polyline.Points[this.ActiveEdge[1]];
      var x = pt0[0] + this.ActiveEdge[2] * (pt1[0] - pt0[0]);
      var y = pt0[1] + this.ActiveEdge[2] * (pt1[1] - pt0[1]);
      this.Polyline.Points.splice(this.ActiveEdge[1], 0, [x, y]);
      this.ActiveVertex = this.ActiveEdge[1];
      this.ActiveEdge = undefined;
      this.HighlightVertex(this.ActiveVertex, layer);
      // When dragging, circle is the same color as the line.
      this.Circle.Active = false;
    }
    if (this.ActiveVertex === -1) {
      // Sanity check.
      return false;
    }
    // If a vertex is dragged onto its neighbor, indicate that
    // the vertexes will be merged. Change the color of the
    // circle to active as an indicator.
    this.Circle.Active = false;
    this.Polyline.Points[this.ActiveVertex] = pt;
    if (this.ActiveVertex > 0 &&
            this.Polyline.GetEdgeLength(this.ActiveVertex - 1) < this.Circle.Radius) {
      this.Circle.Active = true;
      // Snap to the neighbor. Deep copy the point
      pt = this.Polyline.Points[this.ActiveVertex - 1].slice(0);
    }
    if (this.ActiveVertex < this.Polyline.GetNumberOfPoints() - 1 &&
            this.Polyline.GetEdgeLength(this.ActiveVertex) < this.Circle.Radius) {
      this.Circle.Active = true;
      // Snap to the neighbor. Deep copy the point
      pt = this.Polyline.Points[this.ActiveVertex + 1].slice(0);
    }
    // Move the vertex with the mouse.
    this.Polyline.Points[this.ActiveVertex] = pt;
    // Move the hightlight circle with the vertex.
    this.Circle.Origin = pt;
    this.Polyline.UpdateBuffers(layer.AnnotationView);

    // TODO: Fix this hack.
    if (SAM.NotesWidget && !this.UserNoteFlag) { SAM.NotesWidget.MarkAsModified(); } // Hack
    if (this.UserNoteFlag && SA.notesWidget) { SA.notesWidget.EventuallySaveUserNote(); }
    layer.EventuallyDraw(true);
  };

  // precondition : State === DRAWING
  // postcondition: State === DRAWING_EDGE
  // Handle a bunch of cases.  First created, restart at ends or middle.
  PolylineWidget.prototype.StartDrawing = function (pt) {
    // If the widget was just created do nothing.
    if (this.Polyline.GetNumberOfPoints() === 0) {
      return;
    }
    // If we are the begining, Reverse the points.
    if (this.DrawingVertex === 0) {
      this.Polyline.Points.reverse();
      this.DrawingVertex = this.Polyline.GetNumberOfPoints() - 1;
    }
    // If we are at the end.  Add a point.
    if (this.DrawingVertex === this.Polyline.GetNumberOfPoints() - 1) {
      this.Polyline.Points.push(pt);
      this.DrawingVertex += 1;
      this.State = DRAWING_EDGE;
      return;
    }
    // If we are in the middle. Choose between the two edges.
    var pt0 = this.Polyline.Points[this.DrawingVertex - 1];
    var pt1 = this.Polyline.Points[this.DrawingVertex];
    var pt2 = this.Polyline.Points[this.DrawingVertex + 1];
    // Movement vector
    var dx = pt[0] - pt1[0];
    var dy = pt[1] - pt1[1];
    // This is sort of a pain. Normalize the edges.
    var e0 = [pt0[0] - pt1[0], pt0[1] - pt1[1]];
    var dist0 = Math.sqrt(e0[0] * e0[0] + e0[1] * e0[1]);
    dist0 = (dx * e0[0] + dy * e0[1]) / dist0;
    var e1 = [pt2[0] - pt1[0], pt2[1] - pt1[1]];
    var dist1 = Math.sqrt(e1[0] * e1[0] + e1[1] * e1[1]);
    dist1 = (dx * e1[0] + dy * e1[1]) / dist0;
    // if the user is draggin backward, reverse the points.
    if (dist0 > dist1) {
      this.Polyline.Points.reverse();
      this.DrawingVertex = this.Polyline.GetNumberOfPoints() - this.DrawingVertex - 1;
    }
    // Insert a point to continue drawing.
    this.DrawingVertex += 1;
    this.Polyline.Points.splice(this.DrawingVertex, 0, pt);
    this.State = DRAWING_EDGE;
    return false;
  };

  PolylineWidget.prototype.HandleMouseMove = function (layer) {
    var event = layer.Event;
    var x = event.offsetX;
    var y = event.offsetY;
    var pt = layer.GetCamera().ConvertPointViewerToWorld(x, y);

    if (this.State === DRAWING) {
      this.StartDrawing(pt);
      return false;
    }
    if (this.State === DRAWING_EDGE) {
      // Move the active point to follor the cursor.
      this.Polyline.Points[this.DrawingVertex] = pt;
      this.Polyline.UpdateBuffers(layer.AnnotationView);

      // This higlights the first vertex when a loop is possible.
      var idx = this.Polyline.PointOnVertex(pt, this.Circle.Radius);
      if (this.DrawingVertex === this.Polyline.GetNumberOfPoints() - 1 && idx === 0) {
        // Highlight first vertex to indicate potential loop closure.
        this.HighlightVertex(0, layer);
      } else {
        this.HighlightVertex(-1, layer);
      }
      return false;
    }

    if (this.State === ACTIVE) {
      if (event.which === 0) {
        // Turn off the active vertex if the mouse moves away.
        // if (!this.CheckActive(layer)) {
        //  layer.DeactivateWidget(this);
        // } else {
        //  this.UpdateActiveCircle(layer);
        // }
        return false;
      }
      if (this.State === ACTIVE && event.which === 1) {
        // We are in the middle of dragging a vertex (not in
        // drawing mode). Leave the circle highlighted.
        // Use ActiveVertex instead of DrawingVertex which is used
        // for drawing mode.
        this.HandleDrag(pt, layer);
      }
    }
  };

  // Just returns true and false.  It saves either ActiveVertex or
  // ActiveEdge if true. Otherwise, it has no side effects.
  PolylineWidget.prototype.CheckActive = function (layer) {
    return false;
    /*
    var event = layer.Event;
    var x = event.offsetX;
    var y = event.offsetY;
    var pt = layer.GetCamera().ConvertPointViewerToWorld(x, y);
    var dist;

    this.ActiveEdge = undefined;

    // Check for mouse touching a vertex circle.
    dist = VERTEX_RADIUS / layer.GetPixelsPerUnit();
    dist = Math.max(dist, this.Polyline.GetLineWidth());
    this.ActiveVertex = this.Polyline.PointOnVertex(pt, dist);

    if (this.State === DRAWING_EDGE) {
      // TODO:  The same logic is in mouse move.  Decide which to remove.
      // Only allow the first vertex to be active (closing the loop).
      if (this.Polyline.GetNumberOfPoints() < 2 ||
          this.ActiveVertex !== 0) {
        this.ActiveVertex = -1;
        return false;
      }
      return true;
    }

    if (this.ActiveVertex === -1) {
      // Tolerance: 5 screen pixels.
      dist = EDGE_RADIUS / layer.GetPixelsPerUnit();
      dist = Math.max(dist, this.Polyline.GetLineWidth() / 2);
      this.ActiveEdge = this.Polyline.PointOnShape(pt, dist);
      if (!this.ActiveEdge) {
        return false;
      }
    }
    return true;
    */
  };

  // This does not handle the case where we want to highlight an edge
  // point that has not been created yet.
  PolylineWidget.prototype.HighlightVertex = function (vertexIdx, layer) {
    if (vertexIdx < 0 || vertexIdx >= this.Polyline.GetNumberOfPoints()) {
      this.Circle.Visibility = false;
    } else {
      this.Circle.Visibility = true;
      this.Circle.Active = true;
      this.Circle.Radius = VERTEX_RADIUS / layer.GetPixelsPerUnit();
      this.CircleRadius = Math.max(this.CircleRadius,
                                         this.Polyline.GetLineWidth() * 1.5);
      this.Circle.UpdateBuffers(layer.AnnotationView);
      this.Circle.Origin = this.Polyline.Points[vertexIdx];
    }
    this.ActiveVertex = vertexIdx;
    layer.EventuallyDraw(true);
  };

  // Use ActiveVertex and ActiveEdge iVars to place and size circle.
  PolylineWidget.prototype.UpdateActiveCircle = function (layer) {
    if (this.ActiveVertex !== -1) {
      this.HighlightVertex(this.ActiveVertex, layer);
      return;
    } else if (this.ActiveEdge) {
      this.Circle.Visibility = true;
      this.Circle.Active = true;
      this.Circle.Radius = EDGE_RADIUS / layer.GetPixelsPerUnit();
      this.CircleRadius = Math.max(this.CircleRadius,
                                         this.Polyline.GetLineWidth());
      // Find the exact point on the edge (projection of
      // cursor on the edge).
      var pt0 = this.Polyline.Points[this.ActiveEdge[0]];
      var pt1 = this.Polyline.Points[this.ActiveEdge[1]];
      var x = pt0[0] + this.ActiveEdge[2] * (pt1[0] - pt0[0]);
      var y = pt0[1] + this.ActiveEdge[2] * (pt1[1] - pt0[1]);
      this.Circle.Origin = [x, y, 0];
      this.Circle.UpdateBuffers(layer.AnnotationView);
    } else {
      // Not active.
      this.Circle.Visibility = false;
      // We never hightlight the whold polyline now.
      // this.Polyline.Active = false;
    }
    layer.EventuallyDraw(false);
  };

  // Multiple active states. Active state is a bit confusing.
  // Only one state (WAITING) does not receive events from the layer.
  PolylineWidget.prototype.GetActive = function () {
    if (this.State === WAITING) {
      return false;
    }
    return true;
  };

  // Active means that the widget is receiving events.  It is
  // "hot" and waiting to do something.
  // However, it is not active when in drawing mode.
  // This draws a circle at the active spot.
  // Vertexes are active for click and drag or double click into drawing
  // mode. Edges are active to insert a new vertex and drag or double
  // click to insert a new vertex and go into drawing mode.
  PolylineWidget.prototype.SetActive = function (flag, layer) {
    if (flag === this.GetActive()) {
      // Nothing has changed.  Do nothing.
      return;
    }

    if (flag) {
      this.State = ACTIVE;
      this.UpdateActiveCircle(layer);
    } else {
      this.State = WAITING;
      this.DrawingVertex = -1;
      this.ActiveVertex = -1;
      this.ActiveEdge = undefined;
      this.Circle.Visibility = false;
      if (this.DeactivateCallback) {
        this.DeactivateCallback();
      }
      // Remove invisible lines (with 0 or 1 points).
      if (this.Polyline.GetNumberOfPoints() < 2) {
        if (layer) {
          layer.RemoveWidget(this);
        }
      }
    }

    layer.EventuallyDraw(false);
  };

  PolylineWidget.prototype.SetCursorToDrawing = function (layer) {
    layer.GetParent().css(
            {'cursor': 'url(' + SAM.ImagePathUrl + 'dotCursor8.png) 4 4,crosshair'});
    layer.EventuallyDraw();
  };

  PolylineWidget.prototype.ShowPropertiesDialog = function () {
    this.Dialog.ColorInput.val(SAM.ConvertColorToHex(this.Polyline.OutlineColor));
    this.Dialog.ClosedInput.prop('checked', this.Polyline.Closed);
    this.Dialog.LineWidthInput.val((this.Polyline.LineWidth).toFixed(2));

    var length = this.ComputeLength() * 0.25; // microns per pixel.
    var lengthString = '';
    if (this.Polyline.FixedSize) {
      lengthString += length.toFixed(2);
      lengthString += ' px';
    } else {
      if (length > 1000) {
        lengthString += (length / 1000).toFixed(2) + ' mm';
      } else {
        // Latin-1 00B5 is micro sign
        lengthString += length.toFixed(2) + ' \xB5m';
      }
    }
    this.Dialog.Length.text(lengthString);

    if (this.Polyline.Closed) {
      this.Dialog.AreaDiv.show();
      var area = Math.abs(this.ComputeArea() * 0.25 * 0.25);
      var areaString = '';
      if (this.Polyline.FixedSize) {
        areaString += area.toFixed(2);
        areaString += ' pixels^2';
      } else {
        if (area > 1000000) {
          areaString += (area / 1000000).toFixed(2) + ' mm^2';
        } else {
          // Latin-1 00B5 is micro sign
          areaString += area.toFixed(2) + ' \xB5m^2';
        }
      }
      this.Dialog.Area.text(areaString);
    } else {
      this.Dialog.AreaDiv.hide();
    }
    this.Dialog.Show(true);
  };

  PolylineWidget.prototype.DialogApplyCallback = function (layer) {
    var hexcolor = this.Dialog.ColorInput.val();
    this.Polyline.SetOutlineColor(hexcolor);
    this.Polyline.Closed = this.Dialog.ClosedInput.prop('checked');

    // Cannot use the shap line width because it is set to zero (single pixel)
    // it the dialog value is too thin.
    this.LineWidth = parseFloat(this.Dialog.LineWidthInput.val());
    this.Polyline.UpdateBuffers(layer.AnnotationView);
    this.SetActive(false, layer);
    if (window.SA) { SA.RecordState(); }
    layer.EventuallyDraw(false);

    localStorage.PolylineWidgetDefaults = JSON.stringify(
      {Color: hexcolor,
        ClosedLoop: this.Polyline.Closed,
        LineWidth: this.LineWidth});
    if (SAM.NotesWidget && !this.UserNoteFlag) { SAM.NotesWidget.MarkAsModified(); } // Hack
    if (this.UserNoteFlag && SA.notesWidget) { SA.notesWidget.EventuallySaveUserNote(); }
  };

  // Note, self intersection can cause unexpected areas.
  // i.e looping around a point twice ...
  PolylineWidget.prototype.ComputeLength = function () {
    if (this.Polyline.GetNumberOfPoints() < 2) {
      return 0.0;
    }

    var length = 0;
    var x0 = this.Polyline.Points[0][0];
    var y0 = this.Polyline.Points[0][1];
    for (var j = 1; j < this.Polyline.GetNumberOfPoints(); ++j) {
      var x1 = this.Polyline.Points[j][0];
      var y1 = this.Polyline.Points[j][1];
      var dx = x1 - x0;
      var dy = y1 - y0;
      x0 = x1;
      y0 = y1;
      length += Math.sqrt(dx * dx + dy * dy);
    }

    return length;
  };

  // This differentiates the inside of the polygion from the outside.
  // It is used to sample points in a segmented region.
  // Not actively used (more for experimentation for now).
  PolylineWidget.prototype.PointInside = function (ox, oy) {
    if (this.Polyline.Closed === false) {
      return false;
    }
    var x;
    var max = this.Polyline.GetNumberOfPoints() - 1;
    var xPos = 0;
    var xNeg = 0;
    // var yCount = 0;
    var pt0 = this.Polyline.Points[max];
    pt0 = [pt0[0] - ox, pt0[1] - oy];
    for (var idx = 0; idx <= max; ++idx) {
      var pt1 = this.Polyline.Points[idx];
      pt1 = [pt1[0] - ox, pt1[1] - oy];
      var k;
      k = (pt1[1] - pt0[1]);
      if (k !== 0) {
        k = -pt0[1] / k;
        if (k > 0 && k <= 1) {
          // Edge crosses the axis.  Find the intersection.
          x = pt0[0] + k * (pt1[0] - pt0[0]);
          if (x > 0) { xPos += 1; }
          if (x < 0) { xNeg += 1; }
        }
      }
      pt0 = pt1;
    }

    if ((xPos % 2) && (xNeg % 2)) {
      return true;
    }
    return false;
  };

  // TODO: This will not work with Layer.  Move this to the viewer or a
  // helper object.
  // Save images with centers inside the polyline.
  PolylineWidget.prototype.Sample = function (dim, spacing, skip, root, count, layer) {
    var bds = this.Polyline.GetBounds();
    var ctx = layer.Context2d;
    for (var y = bds[2]; y < bds[3]; y += skip) {
      for (var x = bds[0]; x < bds[1]; x += skip) {
        if (this.PointInside(x, y)) {
          var ip = layer.GetCamera().ConvertPointWorldToViewer(x, y);
          ip[0] = Math.round(ip[0] - dim / 2);
          ip[1] = Math.round(ip[1] - dim / 2);
          var data = ctx.getImageData(ip[0], ip[1], dim, dim);
          SA.DownloadImageData(data, root + '_' + count + '.png');
          ++count;
        }
      }
    }
  };

  // Convert to right handed loop
  PolylineWidget.prototype.ColorByHandedness = function (layer) {
    var area = this.Polyline.ComputeArea();
    if (area > 0) {
      // right handed
      this.Polyline.OutlineColor = [1.0, 0.0, 0.0];
    } else {
      // left handed
      this.Polyline.OutlineColor = [0.0, 0.0, 1.0];
    }

    layer.EventuallyDraw(true);
  };

  /*
    // Saves images centered at spots on the edge.
    // Roll is set to put the edge horizontal.
    // Step is in screen pixel units
    PolylineWidget.prototype.SampleEdge = function(dim, step, count, callback, layer) {
    this.Polyline.SampleEdge(layer,dim,step,count,callback);
    }

    function DownloadTheano(widgetIdx, angleIdx) {
    EDGE_ANGLE = 2*Math.PI * angleIdx / 24;
    LAYERS[0].WidgetList[widgetIdx].SampleEdge(
    64,4,EDGE_COUNT,
    function () {
    setTimeout(function(){ DownloadTheano2(widgetIdx, angleIdx); }, 1000);
    },     layer
    );
    }

    function DownloadTheano2(widgetIdx, angleIdx) {
    ++angleIdx;
    if (angleIdx >= 24) {
    angleIdx = 0;
    ++widgetIdx;
    }
    if (widgetIdx < LAYERS[0].WidgetList.length) {
    DownloadTheano(widgetIdx, angleIdx);
    }
    }
    */

  SAM.PolylineWidget = PolylineWidget;
})();

// ==============================================================================
// Temporary drawing with a pencil.  It goes away as soon as the camera changes.
// pencil icon (image as html) follows the cursor.
// Middle mouse button (or properties menu item) drops pencil.
// maybe option in properties menu to save the drawing permanently.

// Merging lasso interactor style is with pencil.
// Differences. The previous stroke does not deselect when a new stroke is started/
// When a stroke ends,  A method is called to see if it can be merged with the selected stroke.

(function () {
  // Depends on the CIRCLE widget
  'use strict';

  // Not receiving events. Nothing selected. Just drawing.
  var INACTIVE = 0;

  // Various states for drawing.
  // Pencil up and pencil down.
  var DRAWING_UP = 2;
  var DRAWING_DOWN = 3;

  var OPEN = 0;
  var CLOSED = 1;

  function PencilWidget (layer) {
    this.Layer = layer;
    this.State = INACTIVE;

    // This method gets called if anything is added, deleted or moved.
    this.ModifiedCallback = undefined;
    // This method gets called if the active state of this widget turns on or off.
    // This is used to turn off the pencil button in the Panel.
    this.StateChangeCallback = undefined;
    // This is used by the annotationPanel to transfer draing mode to a new selected widget.
    this.SelectedCallback = undefined;

    this.Type = 'pencil';
    // True when this widget is dedicated to the apple pencil.
    this.StylusOnly = false;

    this.LineWidth = 0;
    this.Mode = OPEN;
    this.Color = '#00c';
    this.LoadDefaults();

    this.Shapes = new SAM.ShapeGroup();

    // Temporary way of showing time
    this.Circle = new SAM.Circle();
    this.Circle.Radius = 5;
    this.Circle.FixedSize = true;
    this.Circle.UpdateBuffers(layer.AnnotationView);
  }

  PencilWidget.prototype.LoadDefaults = function () {
    if (localStorage.PencilWidgetDefaults) {
      var defaults = JSON.parse(localStorage.PencilWidgetDefaults);
      if (defaults.Color) {
        this.Color = defaults.Color;
      }
      if (defaults.LineWidth !== undefined) {
        this.LineWidth = defaults.LineWidth;
      }
      if (defaults.Mode !== undefined) {
        if (defaults.Mode === 'open') {
          this.Mode = OPEN;
        } else {
          this.Mode = CLOSED;
        }
      }
    }
  };

  PencilWidget.prototype.InitializeDialog = function () {
    this.Dialog = new SAM.Dialog(this.Layer.GetParent().parent());
    var self = this;
    this.Dialog.SetApplyCallback(function () { self.DialogApplyCallback(); });
    // Customize dialog for a pencil.
    this.Dialog.Title.text('Pencil Annotation Editor');
    this.Dialog.Body.css({'margin': '1em 2em'});
    // Color
    this.Dialog.ColorDiv =
      $('<div>')
      .appendTo(this.Dialog.Body)
      .css({'display': 'table-row'});
    this.Dialog.ColorLabel =
      $('<div>')
      .appendTo(this.Dialog.ColorDiv)
      .text('Color:')
      .css({
        'display': 'table-cell',
        'text-align': 'left'});
    this.Dialog.ColorInput =
      $('<input type="color">')
      .appendTo(this.Dialog.ColorDiv)
      .val(this.Color)
      .css({'display': 'table-cell'});

    // Line Width
    this.Dialog.LineWidthDiv =
      $('<div>')
      .appendTo(this.Dialog.Body)
      .css({'display': 'table-row'});
    this.Dialog.LineWidthLabel =
      $('<div>')
      .appendTo(this.Dialog.LineWidthDiv)
      .text('Line Width:')
      .css({
        'display': 'table-cell',
        'text-align': 'left'});
    this.Dialog.LineWidthInput =
      $('<input type="number">')
      .appendTo(this.Dialog.LineWidthDiv)
      .val(this.LineWidth)
      .css({'display': 'table-cell'})
      .keypress(function (event) { return event.keyCode !== 13; });

    // closed check
    this.Dialog.ClosedDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.ClosedLabel =
            $('<div>')
            .appendTo(this.Dialog.ClosedDiv)
            .text('Closed:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.ClosedInput =
            $('<input type="checkbox">')
            .appendTo(this.Dialog.ClosedDiv)
            .attr('checked', 'false')
            .css({'display': 'table-cell'});
  };

  // This callback gets called when ever the active state changes,
  // even if caused by an external call. This widget is passed as a argument.
  // This is used to turn off the pencil button in the Panel.
  PencilWidget.prototype.SetStateChangeCallback = function (callback) {
    this.StateChangeCallback = callback;
  };

  PencilWidget.prototype.SetModifiedCallback = function (callback) {
    this.ModifiedCallback = callback;
  };

  PencilWidget.prototype.SetSelectedCallback = function (callback) {
    this.SelectedCallback = callback;
  };

  // Called when the state changes.
  PencilWidget.prototype.StateChanged = function () {
    if (this.StateChangeCallback) {
      this.StateChangeCallback(this);
    }
  };

  // Called when the state changes.
  PencilWidget.prototype.Modified = function () {
    if (this.ModifiedCallback) {
      (this.ModifiedCallback)(this);
    }
  };
  // PencilWidget.prototype.Modified = function () {
  //  this.Shapes.Modified();
  // };

  // Called when the state changes.
  PencilWidget.prototype.SelectionChanged = function () {
    if (this.SelectedCallback) {
      (this.SelectedCallback)(this);
    }
  };

  // Can we delete this?
  PencilWidget.prototype.IsEmpty = function () {
    return this.Shapes.IsEmpty();
  };

  // TODO: CLean this up.
  PencilWidget.prototype.SetModeToOpen = function () {
    // For new strokes
    this.Mode = OPEN;
    // For old selected strokes.
    for (var i = 0; i < this.Shapes.GetNumberOfShapes(); ++i) {
      var stroke = this.Shapes.GetShape(i);
      if (stroke.IsSelected()) {
        if (stroke.Closed === true) {
          this.Modified();
        }
        stroke.Closed = false;
        stroke.UpdateBuffers(this.Layer.AnnotationView);
        stroke.Modified();
      }
    }
    this.SaveDefaults();
  };
  PencilWidget.prototype.SetModeToClosed = function () {
    // Used for future strokes.
    this.Mode = CLOSED;
    // For old selected strokes.
    for (var i = 0; i < this.Shapes.GetNumberOfShapes(); ++i) {
      var stroke = this.Shapes.GetShape(i);
      if (stroke.IsSelected()) {
        if (stroke.Closed === false) {
          this.Modified();
        }
        stroke.Closed = true;
        stroke.UpdateBuffers(this.Layer.AnnotationView);
        stroke.Modified();
      }
    }
    this.SaveDefaults();
  };
  PencilWidget.prototype.IsModeClosed = function () {
    return this.Mode === CLOSED;
  };

  // Not used yet, but might be useful.
  PencilWidget.prototype.SetCreationCamera = function (cam) {
    // Lets save the zoom level (sort of).
    // Load will overwrite this for existing annotations.
    // This will allow us to expand annotations into notes.
    this.CreationCamera = cam.Serialize();
  };

  PencilWidget.prototype.GetActive = function () {
    return this.State !== INACTIVE;
  };

  PencilWidget.prototype.SetActive = function (flag) {
    if (flag && this.State === INACTIVE) {
      this.State = DRAWING_UP;
      this.StateChanged();
    }
    if (!flag && this.State !== INACTIVE) {
      this.State = INACTIVE;
      this.StateChanged();
    }
    // TODO: Fix: Single select must be setting the state to inactive without calling this method.
    // Cursor was not changing back.
    if (!flag) {
      this.Layer.GetParent().css({'cursor': ''});
    }
  };

  PencilWidget.prototype.IsStateDrawingDown = function () {
    return this.State === DRAWING_DOWN;
  };

  PencilWidget.prototype.SetStateToDrawing = function () {
    if (this.State === DRAWING_UP || this.State === DRAWING_DOWN) {
      return;
    }

    this.State = DRAWING_UP;
    this.StateChanged();

    if (!this.StylusOnly) {
      // Do not use the icon for the apple pencil
      this.Layer.GetParent().css(
        {'cursor': 'url(' + SAM.ImagePathUrl + 'Pencil-icon.png) 0 24,crosshair'});
    }
    this.Layer.EventuallyDraw();
  };

  PencilWidget.prototype.Draw = function () {
    var view = this.Layer.GetView();
    this.Shapes.Draw(view);
    this.Circle.FillColor = this.Color;
    if (this.Layer.ZTime !== undefined && this.Shapes.Shapes.length > 0) {
      // Find the time in the list of points
      var pts = this.Shapes.Shapes[0].Points;
      for (var i = 0; i < pts.length; ++i) {
        var pt = pts[i];
        if (pt.length === 3 && pt[2] === this.Layer.ZTime) {
          this.Circle.Origin = pt;
          // this.Circle.Draw(view);
          break;
        }
      }
    }
  };

  PencilWidget.prototype.Serialize = function () {
    var obj = {};
    obj.type = 'pencil';
    obj.shapes = [];
    // Hacky way to include closed flags.
    obj.closedFlags = [];
    for (var i = 0; i < this.Shapes.GetNumberOfShapes(); ++i) {
      // NOTE: Assumes shape is a Polyline.
      var shape = this.Shapes.GetShape(i);
      var points = shape.Points.slice(0);
      obj.shapes.push(points);
      obj.closedFlags.push(shape.Closed);
      obj.lineColor = SAM.ConvertColorToHex(shape.OutlineColor);
      obj.lineWidth = shape.LineWidth;
    }
    obj.creation_camera = this.CreationCamera;

    return obj;
  };

  // Load a widget from a json object (origin MongoDB).
  PencilWidget.prototype.Load = function (obj) {
    this.LineWidth = 0;
    if (obj.lineWidth !== undefined) {
      this.LineWidth = parseFloat(obj.lineWidth);
    }

    // Shapes use [1,1,1] instead of hex color. Really!!!

    var outlineColor = this.Color;
    if (obj.lineColor) {
      this.Color = obj.lineColor;
    }
    for (var n = 0; n < obj.shapes.length; n++) {
      var points = obj.shapes[n];
      var shape = new SAM.Polyline();
      if (obj.closedFlags) {
        shape.Closed = obj.closedFlags[n];
        if (shape.Closed) {
          this.Mode = CLOSED;
        } else {
          this.Mode = OPEN;
        }
      }
      shape.SetOutlineColor(outlineColor);
      shape.FixedSize = false;
      shape.LineWidth = this.LineWidth;
      if (this.Mode === CLOSED) {
        shape.Closed = true;
      }
      this.Shapes.AddShape(shape);
      // A copy of the points array is probably not necesary.
      shape.Points = points.slice(0);
      // Make sure they all have 3 coordinates
      for (var i = 0; i < shape.Points.length; ++i) {
        var pt = shape.Points[i];
        if (pt.length === 2) {
          shape.Points[i] = [pt[0], pt[1], 0.0];
        }
      }
    }

    // How zoomed in was the view when the annotation was created.
    if (obj.view_height !== undefined) {
      this.CreationCamera = obj.creation_camera;
    }
  };

  // Returns true if something was deleted.
  PencilWidget.prototype.DeleteSelected = function () {
    // Delete is handled by the caller.
    return this.Shapes.DeleteSelected();
  };

  PencilWidget.prototype.HandleKeyDown = function () {
    if (this.State === INACTIVE) {
      return true;
    }
    if (this.StylusOnly) {
      // I am not sure why the apple pencil needs this.
      return true;
    }
    if (this.State === DRAWING_UP || this.State === DRAWING_DOWN) {
      // escape key (or space or enter) to turn off drawing
      if (event.keyCode === 27 || event.keyCode === 32 || event.keyCode === 13) {
        this.SetActive(false);
        return false;
      }
    }
    return true;
  };

  /*
  PencilWidget.prototype.HandleDoubleClick = function () {
    if (this.State === DRAWING_UP || this.State === DRAWING_DOWN) {
      this.SetActive(false);
      return false;
    }
    if (this.State === SELECTED) {
      this.SetStateToDrawing();
      return false;
    }
    return true;
  };
  */

  PencilWidget.prototype.SetStateToDrawingDown = function (x, y) {
    if (this.State === DRAWING_DOWN) {
      return;
    }

    if (this.State !== DRAWING_UP) {
      // Consider DRAWIN_UP and DRAWING_DOWN as a single state.
      this.StateChanged();
    }

    this.State = DRAWING_DOWN;
    // Open: Unselect the last stroke.
    // Closed:  Keep the last selected because the two might be merged.
    if (this.Mode === OPEN) {
      var numStrokes = this.Shapes.GetNumberOfShapes();
      if (numStrokes > 0) {
        // Trying out cut feature
        // this.Shapes.SetSelectedChild(numStrokes - 1, false);
      }
    }
    // Start a new stroke
    var shape = new SAM.Polyline();
    // Select the current stroke.
    shape.SetSelected(true);
    // Leave the new stroke open unti we stop.
    if (!this.Dialog) {
      this.InitializeDialog();
    }
    shape.SetOutlineColor(this.Color);
    shape.FixedSize = false;
    shape.LineWidth = this.LineWidth;
    // Leave stroke open until it is finished.
    shape.Closed = false;
    this.Shapes.AddShape(shape);

    var pt = this.Layer.GetCamera().ConvertPointViewerToWorld(x, y);
    shape.Points.push([pt[0], pt[1], 0.0]); // avoid same reference.
  };

  // Returns the selected stroke or undefined.
  PencilWidget.prototype.HandleSelect = function () {
    // Check to see if a stroke was clicked.
    var x = this.Layer.MouseX;
    var y = this.Layer.MouseY;
    var pt = this.Layer.GetCamera().ConvertPointViewerToWorld(x, y);

    // Hack in click to add a point to the line.
    if (SAM.ControlKey) {
      if (this.IsSelected()) {
        var stroke = this.Shapes.Shapes[0];
        var p0 = stroke.Points[0];
        var p1 = stroke.Points[stroke.Points.length - 1];
        var dx = pt[0] - p0[0];
        var dy = pt[1] - p0[1];
        var dist0 = (dx * dx) + (dy * dy);
        dx = pt[0] - p1[0];
        dy = pt[1] - p1[1];
        var dist1 = (dx * dx) + (dy * dy);
        pt = [pt[0], pt[1], this.Layer.ZTime];
        console.log(pt.toString());
        if (dist1 < dist0) {
          // add point to the end.
          stroke.Points.push(pt);
        } else {
          // Add point to the beginning.
          stroke.Points = [pt].concat(stroke.Points);
        }
        this.Modified();
        stroke.UpdateBuffers(this.Layer.AnnotationView);
        this.Layer.EventuallyDraw();
        return this;
      } else {
        return false;
      }
    }

    var width = this.Shapes.GetLineWidth();
    // Tolerance: 5 screen pixels.
    var minWidth = 20.0 / this.Layer.GetPixelsPerUnit();
    if (width < minWidth) { width = minWidth; }

    var selectedShape = this.Shapes.HandleSelect(pt, width);
    if (selectedShape) {
      // Change the widget mode to match the selected stroke.
      if (selectedShape.Closed) {
        this.Mode = CLOSED;
      } else {
        this.Mode = OPEN;
      }
      // I do not this this is used anymore.
      this.SelectionChanged();
      return selectedShape;
    } else {
      this.SetActive(false);
      this.SelectionChanged();
    }
  };

  PencilWidget.prototype.HandleMouseDown = function () {
    if (this.State === INACTIVE) {
      return true;
    }
    if (this.StylusOnly) {
      // IPads do not have mice, so this is probably unecessary.
      return true;
    }

    var x = this.Layer.MouseX;
    var y = this.Layer.MouseY;

    // Anticipate dragging (might instead be a click or double click)
    var cam = this.Layer.GetCamera();
    this.LastMouse = cam.ConvertPointViewerToWorld(x, y);

    // if (event.which === 3) {
    //  // Right mouse was pressed.
    //  // Pop up the properties dialog.
    //  if (this.State === ACTIVE) {
    //    this.ShowPropertiesDialog();
    //  } else if (this.State === DRAWING_DOWN || this.State === DRAWING_UP) {
    //    // Undo a stroke
    //    if (this.Shapes.GetNumberOfShapes() > 1) {
    //      this.Shapes.PopShape();
    //      this.Layer.EventuallyDraw();
    //   }
    //  }
    //  return false;
    // }

    return false;
  };

  PencilWidget.prototype.HandleTouchStart = function () {
    if (this.State === INACTIVE) {
      return true;
    }
    if (this.StylusOnly && !this.Layer.Event.pencil) {
      // This allows viewer interaction with touches on the ipad pro..
      return true;
    }

    if (this.Layer.Touches.length !== 1) {
      // We pass one multiple touches
      return true;
    }

    if (this.State === DRAWING_UP) {
      var x = this.Layer.Touches[0][0];
      var y = this.Layer.Touches[0][1];
      this.SetStateToDrawingDown(x, y);
    }
    return false;
  };

  PencilWidget.prototype.HandleStop = function () {
    // A stroke has just been finished.
    var last = this.Shapes.GetNumberOfShapes() - 1;

    if (this.State === DRAWING_DOWN && last >= 0) {
      var spacing = this.Layer.GetCamera().GetSpacing();
      // NOTE: This assume that the shapes are polylines.
      var stroke = this.Shapes.GetShape(last);
      stroke.Decimate(spacing * 0.5);
      stroke.Closed = this.Mode === CLOSED;
      if (stroke.length <= 1) {
        stroke.Points.pop();
        return false;
      }
      this.Modified();
      // Do not trigger a state change event on drawing up/down transistions.
      this.State = DRAWING_UP;

      // When closed,  the interation is like a lasso.  The last
      // Can be merged with the selected stroke (if they overlap).
      if (this.Mode === CLOSED) {
        this.HandleLassoMerge();
      } else {
        // use intersecting stroke to cut a line.
        this.HandleOpenCut();
      }
    }
    return false;
  };

  PencilWidget.prototype.HandleMouseUp = function () {
    if (this.State === INACTIVE) {
      return true;
    }
    if (this.StylusOnly) {
      // IPads do not have mice, so this is probably unecessary.
      return true;
    }
    // Middle mouse deactivates the widget.
    var event = this.Layer.Event;
    if (event.which === 2) {
      // Middle mouse was pressed.
      this.SetActive(false);
      return false;
    }

    return this.HandleStop();
  };

  PencilWidget.prototype.HandleTouchEnd = function () {
    if (this.StylusOnly && !this.Layer.Event.pencil) {
      // The apple pencil needs to ignore viewer touch events.
      return true;
    }
    if (this.State !== DRAWING_DOWN) {
      return true;
    }
    return this.HandleStop();
  };

  PencilWidget.prototype.HandleMove = function (x, y) {
    if (this.State === DRAWING_UP) {
      this.SetStateToDrawingDown(x, y);
    }

    if (this.State === DRAWING_DOWN) {
      var last = this.Shapes.GetNumberOfShapes() - 1;
      var shape = this.Shapes.GetShape(last);
      var pt = this.Layer.GetCamera().ConvertPointViewerToWorld(x, y);
      shape.Points.push([pt[0], pt[1], 0.0]); // avoid same reference.
      shape.Modified();
      this.Layer.EventuallyDraw();
      return false;
    }

    return true;
  };

  PencilWidget.prototype.HandleMouseMove = function () {
    if (this.State === INACTIVE) {
      return true;
    }
    if (this.StylusOnly) {
      // IPads do not have mice, so this is probably unecessary.
      return true;
    }
    var event = this.Layer.Event;
    var x = this.Layer.MouseX;
    var y = this.Layer.MouseY;

    if (event.which === 1) {
      if (this.HandleMove(x, y) === false) {
        return false;
      }
    }

    return false;
  };

  PencilWidget.prototype.HandleTouchMove = function () {
    if (this.State === INACTIVE) {
      return true;
    }
    if (this.StylusOnly && !this.Layer.Event.pencil) {
      // The apple pencil needs to ignore viewer touch events.
      return true;
    }
    if (this.Layer.Touches.length !== 1) {
      return true;
    }

    var x = this.Layer.Touches[0][0];
    var y = this.Layer.Touches[0][1];

    this.HandleMove(x, y);
    return false;
  };

  // Selects or unselects all strokes.
  // Returns true if any selection changed.
  PencilWidget.prototype.SetSelected = function (flag) {
    var ret = this.Shapes.SetSelected(flag);

    if (flag) {
      this.SelectionChanged();
    }
    if (!flag) {
      // We can be selected without being active, but we cannot be
      // active without being selected.
      this.SetActive(false);
    }

    return ret;
  };

  // Returns true if any strokes are selected.
  PencilWidget.prototype.IsSelected = function () {
    return this.Shapes.IsSelected();
  };

  // Selects all strokes that match the selection
  // TODO: Check all the points in the stroke after the rough bounds check.
  PencilWidget.prototype.ApplySelect = function (selection) {
    var selected = false;
    for (var idx = 0; idx < this.Shapes.GetNumberOfShapes(); ++idx) {
      var shape = this.Shapes.GetShape(idx);
      // first check the bounds (xmin,xmax,ymin,ymax].
      var bds = shape.GetBounds();
      if (selection.WorldPointInSelection(bds[0], bds[2]) &&
          selection.WorldPointInSelection(bds[0], bds[3]) &&
          selection.WorldPointInSelection(bds[1], bds[2]) &&
          selection.WorldPointInSelection(bds[1], bds[3])) {
        // Good enough for now
        shape.SetSelected(true);
        selected = true;
      } else {
        shape.SetSelected(false);
      }
    }
    return selected;
  };

  // Can we bind the dialog apply callback to an objects method?
  PencilWidget.prototype.ShowPropertiesDialog = function () {
    if (!this.Dialog) {
      this.InitializeDialog();
    }
    this.Dialog.ColorInput.val(this.Color);
    this.Dialog.LineWidthInput.val(this.LineWidth.toFixed(2));
    this.Dialog.ClosedInput.prop('checked', this.Mode === CLOSED);

    this.Dialog.Show(true);
  };

  PencilWidget.prototype.DialogApplyCallback = function () {
    this.Color = this.Dialog.ColorInput.val();
    this.LineWidth = parseFloat(this.Dialog.LineWidthInput.val());
    if (this.Dialog.ClosedInput.prop('checked')) {
      this.SetModeToClosed();
    } else {
      this.SetModeToOpen();
    }

    this.Shapes.SetOutlineColor(this.Color);
    this.Shapes.SetLineWidth(parseFloat(this.Dialog.LineWidthInput.val()));
    this.Shapes.UpdateBuffers(this.Layer.AnnotationView);
    this.SetSelected(false);
    if (window.SA) { SA.RecordState(); }
    this.Layer.EventuallyDraw();
    this.Modified();
    this.SaveDefaults();
  };

  PencilWidget.prototype.SaveDefaults = function () {
    var hexcolor = this.Color;
    var mode = 'open';
    if (this.Mode === CLOSED) {
      mode = 'closed';
    }
    localStorage.PencilWidgetDefaults = JSON.stringify({
      Color: hexcolor,
      LineWidth: this.LineWidth,
      Mode: mode
    });
  };

  // ====================================================================
  // Lasso merge logic.

  // See if we can merge the last stroke with the selected stroke.
  PencilWidget.prototype.HandleLassoMerge = function () {
    var lastIdx = this.Shapes.GetNumberOfShapes() - 1;
    // This is the one just drawn.
    var stroke2 = this.Shapes.GetShape(lastIdx);
    // Find the selected stroke.
    var found = false;
    for (var stroke1Idx = 0; stroke1Idx < lastIdx; ++stroke1Idx) {
      var stroke1 = this.Shapes.GetShape(stroke1Idx);
      if (stroke1.IsSelected()) {
        found = true;
        break;
      }
    }
    if (!found) {
      // We could not find a second stroke.
      // Just close the last stroke and return.
      stroke2.Closed = true;
      stroke2.UpdateBuffers(this.Layer.AnnotationView);
      this.Layer.EventuallyDraw();
      console.log('first stroke not found');
      return;
    }

    // Now see if they overlap.
    if (this.CombineStrokes(stroke1, stroke2)) {
      console.log('stroke merged');
      // The last stroke has been merged.  Remove it.
      this.Shapes.DeleteChild(lastIdx);
      // Leave the other stroke selected.
      stroke1.UpdateBuffers(this.Layer.AnnotationView);
    } else {
      console.log('no intersection');
      // no intersection.  Keep them both, but leave the new one selected.
      stroke1.SetSelected(false);
      if (this.Mode === CLOSED) {
        stroke2.Closed = true;
      }
      stroke2.UpdateBuffers(this.Layer.AnnotationView);
    }
    this.Layer.EventuallyDraw();
  };

  // Loop is the old, stroke is the new.
  // returns true if merged, false if not.;
  PencilWidget.prototype.CombineStrokes = function (polyLineLoop, polyLineStroke) {
    var loop = polyLineLoop.Points;
    var stroke = polyLineStroke.Points;

    // This algorithm was desinged to have the first point be the same as the last point.
    // To generalize polylineWidgets and lassoWidgets, I changed this and put a closed
    // flag (which implicitely draws the last segment) in polyline.
    // It is easier to temporarily add the extra point and them remove it, than change the algorithm.
    loop.push(loop[0]);

    // Find the first and last intersection points between stroke and loop.
    var intersection0;
    var intersection1;
    for (var i = 1; i < stroke.length; ++i) {
      var pt0 = stroke[i - 1];
      var pt1 = stroke[i];
      var intersections = this.FindSegmentLoopIntersections(pt0, pt1, loop);
      // We are looking for the first and last interestions: so sort.
      intersections.sort(function (a, b) { return a.k - b.k; });
      for (var j = 0; j < intersections.length; ++j) {
        var intersection = intersections[j];
        if (intersections.length > 0) {
          if (intersection0 === undefined) {
            intersection0 = intersection;
            intersection0.StrokeIdx0 = i - 1;
            intersection0.StrokeIdx1 = i;
          } else {
            intersection1 = intersection;
            intersection1.StrokeIdx0 = i - 1;
            intersection1.StrokeIdx1 = i;
          }
        }
      }
    }

    // If we have two intersections, clip the loop with the stroke.
    if (intersection1 === undefined) {
      // Get rid of that extra duplicated point we added.
      loop.pop();
      return false;
    }

    // Crop the stroke and add the two new intersection points to the front and end.
    var croppedStroke = [intersection0.Point];
    croppedStroke = croppedStroke.concat(stroke.slice(intersection0.StrokeIdx1,
                                                      intersection1.StrokeIdx1));
    croppedStroke.push(intersection1.Point);

    // Do we need to reverse the cropped stroke?
    var reverseCroppedStroke = true;

    // Crop the loop into two parts.
    // Build both loops keeing track of their lengths.
    // Keep the longer part.
    var tmp;
    if (intersection1.LoopIdx1 < intersection0.LoopIdx1) {
      tmp = intersection0;
      intersection0 = intersection1;
      intersection1 = tmp;
      reverseCroppedStroke = !reverseCroppedStroke;
    }
    // The middle part.
    var croppedLoop = loop.slice(intersection0.LoopIdx1, intersection1.LoopIdx1);
    // The second part is the combination of the end and start pieces.
    tmp = loop.slice(intersection1.LoopIdx1);
    // Get rid of that extra duplicated point we added.
    tmp.pop();
    // Now add the start piece to the end piece. (it is a loop).
    tmp = tmp.concat(loop.slice(0, intersection0.LoopIdx1));
    if (this.ComputeStrokeLength(tmp) > this.ComputeStrokeLength(croppedLoop)) {
      // If we keep the second part because it is longer, we have to reverse the stroke.
      croppedLoop = tmp;
      reverseCroppedStroke = !reverseCroppedStroke;
    }
    if (reverseCroppedStroke) {
      croppedStroke.reverse();
    }
    polyLineLoop.Points = croppedLoop.concat(croppedStroke);

    return true;
  };

  PencilWidget.prototype.ComputeStrokeLength = function (stroke) {
    if (stroke.length === 0) {
      return 0;
    }
    var pt0 = stroke[0];
    var pt1, x, y;
    var length = 0;
    for (var i = 1; i < stroke.length; ++i) {
      pt1 = stroke[i];
      x = pt1[0] - pt0[0];
      y = pt1[1] - pt0[1];
      length += Math.sqrt(x * x + y * y);
    }
    return length;
  };

  // Returns all te points that a loop intersects with a single stroke segment.
  // transform all points so p0 is origin and p1 maps to (1,0)
  // Returns an empty array if no intersection,
  // It returns an array of intersections [{Point: newPt, LoopIndex: i}, ...] .
  // (sorted starting with the ones closest to p0).
  // It does not change the loop.
  PencilWidget.prototype.FindSegmentLoopIntersections = function (p0, p1, loop) {
    var intersections = [];
    var p = [(p1[0] - p0[0]), (p1[1] - p0[1])];
    var mag = Math.sqrt(p[0] * p[0] + p[1] * p[1]);
    if (mag <= 0.0) {
      return [];
    }
    p[0] = p[0] / mag;
    p[1] = p[1] / mag;

    var m0 = loop[0];
    var n0 = [(m0[0] - p0[0]) / mag, (m0[1] - p0[1]) / mag];
    var k0 = [(n0[0] * p[0] + n0[1] * p[1]), (n0[1] * p[0] - n0[0] * p[1])];

    for (var i = 1; i < loop.length; ++i) {
      var m1 = loop[i];
      // Avoid an infinite loop inserting points.
      if (p0 === m0 || p0 === m1) {
        continue;
      }
      var n1 = [(m1[0] - p0[0]) / mag, (m1[1] - p0[1]) / mag];
      var k1 = [(n1[0] * p[0] + n1[1] * p[1]), (n1[1] * p[0] - n1[0] * p[1])];
      if ((k1[1] >= 0.0 && k0[1] <= 0.0) || (k1[1] <= 0.0 && k0[1] >= 0.0)) {
        var k = k0[1] / (k0[1] - k1[1]);
        var x = k0[0] + k * (k1[0] - k0[0]);
        if (x > 0 && x <= 1) {
          var newPt = [(m0[0] + k * (m1[0] - m0[0])), (m0[1] + k * (m1[1] - m0[1])), 0.0];
          intersections.push({Point: newPt, LoopIdx0: i - 1, LoopIdx1: i, k: x});
        }
      }
      m0 = m1;
      n0 = n1;
      k0 = k1;
    }

    return intersections;
  };

  // This is not actually needed!  So it is not used.
  PencilWidget.prototype.IsPointInsideLoop = function (x, y, loop) {
    // Sum up angles.  Inside poitns will sum to 2pi, outside will sum to 0.
    var angle = 0.0;
    var pt0 = loop[loop.length - 1];
    for (var i = 0; i < loop.length; ++i) {
      var pt1 = loop[i];
      var v0 = [pt0[0] - x, pt0[1] - y];
      var v1 = [pt1[0] - x, pt1[1] - y];
      var mag0 = Math.sqrt(v0[0] * v0[0] + v0[1] * v0[1]);
      var mag1 = Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1]);
      angle += Math.arcsin((v0[0] * v1[1] - v0[1] * v1[0]) / (mag0 * mag1));
    }
    return (angle > 3.14 || angle < -3.14);
  };

  // --------------------------------------------------------------------------------
  // Stuff for eraser. Never finihsed.

  // Left turn.
  // Returns 'undefined' if zero length segment.
  PencilWidget.prototype.ComputeSegmentNormal = function (pt0, pt1) {
    var dx = pt1[0] - pt0[0];
    var dy = pt1[1] - pt0[1];
    var mag = Math.sqrt(dx * dx + dy * dy);
    if (mag === 0) {
      return;
    }
    return [-dy / mag, dx / mag];
  };

  // We need a fat line. Handle one segment at a time.
  // Output is an loop (array of points) around a thick line with rounded ends.
  // The first and last points are the same.
  PencilWidget.prototype.SegmentToLoop = function (pt1, pt2, radius) {
    var divisions = 8;
    var loop = [];
    // Compute a normal to the line segment.
    var n = this.ComputeSegmentNormal(pt1, pt2);
    if (!n) {
      n = [0, 1];
      loop.concat(this.EndCap(pt1, n, radius, divisions));
      // Do not duplicate the point in the middle of the circle.
      loop.pop();
      loop.concat(this.EndCap(pt1, n, -radius, divisions));
      return loop;
    }
    loop.concat(this.EndCap(pt1, n, radius, divisions));
    loop.concat(this.EndCap(pt2, n, -radius, divisions));
    return loop;
  };

  // I did not finish this method.
  /*
  // We need a fat line.
  // Output is an loop (array of points) around a thick line with rounded ends.
  // The first and last points of the output are the same.
  PencilWidget.prototype.StrokeToLoop = function (polyLineStroke, radius) {
    var stroke = polyLineStroke.Points;
    if (stroke.length === 0) {
      return;
    }

    // Compute normals for every segment in the loop.
    // (and get rid of 0 length segments).
    var normals = []; // One fewer normals than points.
    var pt0 = stroke[0];
    var points = [pt0]; // Only keep the non zero length segments.
    for (var i = 1; i < stroke.length; ++i) {
      var pt1 = points[i];
      n = this.ComputeSegmentNormal(pt0, pt1);
      if (n) {
        points.push(pt1);
        normals.push(n);
        pt0 = pt1;
      }
    }

    pt0 = points[0];
    // First the endcap.
    var loop = this.EndCap(points[0], nommals[0], radius, divisions);
    // Grow both ends of the loop as we add segments?  Maybe

    //  .... Just compute all points niavely and then check inside/ outside of circle box set.
    //  .... Will have to compute partial segments.
    pt1 = points[1];

    var divisions = 8;
    var dTheata = Math.PI / divisions;

    // Compute a normal to the line segment.
    var n = [pt2[0] - pt1[0], pt2[1] - pt1[1]];
    var mag = Math.sqrt(n[0] * n[0] + n[1] * n[1]);
    if (mag === 0.0) {
      n = [0,1];
      loop.concat(this.EndCap(pt1, n, radius, divisions));
      // Do not duplicate the point in the middle of the circle.
      loop.pop();
      loop.concat(this.EndCap(pt1, n, -radius, divisions));
      return loop;
    }
    loop.concat(this.EndCap(pt1, n, radius, divisions));
    loop.concat(this.EndCap(pt2, n, -radius, divisions));
    return loop;
  };
  */

  // Return half a circle.
  PencilWidget.prototype.EndCap = function (center, n, radius, divisions) {
    var points = [];
    for (var i = 0; i <= divisions; ++i) {
      var theta = Math.PI * i / divisions;
      var c = Math.cos(theta);
      var s = Math.sin(theta);
      // Rotate
      var x = center[0] + radius * (c * n[0] - s * n[1]);
      var y = center[1] + radius * (c * n[1] + s * n[0]);
      points.push([x, y]);
    }
    return points;
  };

  // Loop is the old, stroke is the new eraser stroke.
  // returns true if merged, false if not.;
  PencilWidget.prototype.CombineEraserStroke = function (polyLineLoop, polyLineStroke) {
    var loop = polyLineLoop.Points;
    var stroke = polyLineStroke.Points;

    // This algorithm was desinged to have the first point be the same as the last point.
    // To generalize polylineWidgets and lassoWidgets, I changed this and put a closed
    // flag (which implicitely draws the last segment) in polyline.
    // It is easier to temporarily add the extra point and them remove it, than change the algorithm.
    loop.push(loop[0]);

    // TODO: Fix this.  I got in an infinite loop.
    // Inserting points it the array we are iterating over.
    // Find the first and last intersection points between stroke and loop.
    var intersection0;
    var intersection1;
    for (var i = 1; i < stroke.length; ++i) {
      var pt0 = stroke[i - 1];
      var pt1 = stroke[i];
      var intersections = this.FindSegmentLoopIntersections(pt0, pt1, loop);
      // We are looking for the first and last interestions: so sort.
      intersections.sort(function (a, b) { return a.k - b.k; });
      if (intersections.length > 0) {
        if (intersection0 === undefined) {
          intersection0 = intersections[0];
          intersection0.StrokeIdx0 = i - 1;
          intersection0.StrokeIdx1 = i;
        } else {
          var last = intersections.length - 1;
          intersection1 = intersections[last];
          intersection1.StrokeIdx0 = i - 1;
          intersection1.StrokeIdx1 = i;
        }
      }
    }

    // If we have two intersections, clip the loop with the stroke.
    if (intersection1 === undefined) {
      // Get rid of that extra duplicated point we added.
      loop.pop();
      return false;
    }

    // Crop the stroke and add the two new intersection points to the front and end.
    var croppedStroke = [intersection0.Point];
    croppedStroke = croppedStroke.concat(stroke.slice(intersection0.StrokeIdx1,
                                                      intersection1.StrokeIdx1));
    croppedStroke.push(intersection1.Point);

    // Do we need to reverse the cropped stroke?
    var reverseCroppedStroke = true;

    // Crop the loop into two parts.
    // Build both loops keeing track of their lengths.
    // Keep the longer part.
    var tmp;
    if (intersection1.LoopIdx1 < intersection0.LoopIdx1) {
      tmp = intersection0;
      intersection0 = intersection1;
      intersection1 = tmp;
      reverseCroppedStroke = !reverseCroppedStroke;
    }
    // The middle part.
    var croppedLoop = loop.slice(intersection0.LoopIdx1, intersection1.LoopIdx1);
    // The second part is the combination of the end and start pieces.
    tmp = loop.slice(intersection1.LoopIdx1);
    // Get rid of that extra duplicated point we added.
    tmp.pop();
    // Now add the start piece to the end piece. (it is a loop).
    tmp = tmp.concat(loop.slice(0, intersection0.LoopIdx1));
    if (this.ComputeStrokeLength(tmp) > this.ComputeStrokeLength(croppedLoop)) {
      // If we keep the second part because it is longer, we have to reverse the stroke.
      croppedLoop = tmp;
      reverseCroppedStroke = !reverseCroppedStroke;
    }
    if (reverseCroppedStroke) {
      croppedStroke.reverse();
    }
    polyLineLoop.Points = croppedLoop.concat(croppedStroke);

    return true;
  };

  // ====================================================================
  // open cut logic

  //  If stroke crosses selected line, cut it.
  PencilWidget.prototype.HandleOpenCut = function () {
    var lastIdx = this.Shapes.GetNumberOfShapes() - 1;
    // This is the one just drawn.
    var stroke2 = this.Shapes.GetShape(lastIdx);
    // Find the selected stroke.
    var found = false;
    for (var stroke1Idx = 0; stroke1Idx < lastIdx; ++stroke1Idx) {
      var stroke1 = this.Shapes.GetShape(stroke1Idx);
      if (stroke1.IsSelected()) {
        found = true;
        break;
      }
    }
    if (!found) {
      // We could not find a second stroke.
      return;
    }

    // Now see if they overlap.
    for (var i = 1; i < stroke1.Points.length; ++i) {
      var pt0 = stroke1.Points[i - 1];
      var pt1 = stroke1.Points[i];
      var intersections = this.FindSegmentLoopIntersections(pt0, pt1, stroke2.Points);
      if (intersections.length > 0) {
        // Cut the line here.
        var part1 = stroke1.Points.slice(i);
        var part2 = stroke1.Points.slice(0, i);
        if (part1.length < 2) {
          part1 = part2;
          part2 = undefined;
        }
        stroke1.Points = part1;
        stroke1.UpdateBuffers(this.Layer.AnnotationView);
        // The last stroke either gets moved to a new widget or deleted.
        this.Shapes.DeleteChild(lastIdx);

        if (part2) {
          stroke2.Points = part2;
          stroke2.UpdateBuffers(this.Layer.AnnotationView);
          // Problems with multiple strokes in one widget.  Make a new widget.
          var widget2 = new PencilWidget(this.Layer);
          widget2.Shapes.AddShape(stroke2);
          widget2.Color = this.Color;
          this.Layer.AddWidget(widget2);
        }
        this.Layer.EventuallyDraw();
        this.SelectionChanged();
        return;
      }
    }
    stroke1.SetSelected(false);
    this.Layer.EventuallyDraw();
    this.SelectionChanged();
  };

  SAM.PencilWidget = PencilWidget;
})();

// ==============================================================================
// Segmentation / fill.  But should I change it into a contour at the end?

(function () {
  'use strict';

  var FILL_WIDGET_DRAWING = 0;
  var FILL_WIDGET_ACTIVE = 1;
  var FILL_WIDGET_WAITING = 2;

  function FillWidget (viewer, newFlag) {
    if (viewer === null) {
      return;
    }

        // I am not sure what to do for the fill because
        // I plan to change it to a contour.

    this.Dialog = new SAM.Dialog(this);
        // Customize dialog for a lasso.
    this.Dialog.Title.text('Fill Annotation Editor');
    this.Dialog.Body.css({'margin': '1em 2em'});
        // Color
    this.Dialog.ColorDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .addClass('sa-view-fill-div');
    this.Dialog.ColorLabel =
            $('<div>')
            .appendTo(this.Dialog.ColorDiv)
            .text('Color:')
            .addClass('sa-view-fill-label');
    this.Dialog.ColorInput =
            $('<input type="color">')
            .appendTo(this.Dialog.ColorDiv)
            .val('#30ff00')
            .addClass('sa-view-fill-input');

        // Line Width
    this.Dialog.LineWidthDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .addClass('sa-view-fill-div');
    this.Dialog.LineWidthLabel =
            $('<div>')
            .appendTo(this.Dialog.LineWidthDiv)
            .text('Line Width:')
            .addClass('sa-view-fill-label');
    this.Dialog.LineWidthInput =
            $('<input type="number">')
            .appendTo(this.Dialog.LineWidthDiv)
            .addClass('sa-view-fill-input')
            .keypress(function (event) { return event.keyCode !== 13; });

    this.Popup = new SAM.WidgetPopup(this);
    this.Viewer = viewer;
    this.Viewer.AddWidget(this);

    this.Cursor = $('<img>').appendTo('body')
            .addClass('sa-view-fill-cursor')
            .attr('type', 'image')
            .attr('src', SAM.ImagePathUrl + 'brush1.jpg');

    // I am trying to stop images from getting move events and displaying a circle/slash.
    // This did not work.  preventDefault did not either.
    // this.Cursor.mousedown(function (event) {self.HandleMouseDown(event);})
    // this.Cursor.mousemove(function (event) {self.HandleMouseMove(event);})
    // this.Cursor.mouseup(function (event) {self.HandleMouseUp(event);})
    // .preventDefault();

    this.ActiveCenter = [0, 0];

    this.State = FILL_WIDGET_DRAWING;
    if (!newFlag) {
      this.State = FILL_WIDGET_WAITING;
    }

    // Lets save the zoom level (sort of).
    // Load will overwrite this for existing annotations.
    // This will allow us to expand annotations into notes.
    this.CreationCamera = viewer.GetCamera().Serialize;
  }

  // This is expensive, so initialize explicitely outside the constructor.
  FillWidget.prototype.Initialize = function (view) {
    // Now for the segmentation initialization.
    this.Segmentation = new SA.Segmentation(this.Viewer);
  };

  FillWidget.prototype.Draw = function (view) {
    this.Segmentation.ImageAnnotation.Draw(view);
  };

  // I do not know what we are saving yet.
  FillWidget.prototype.Serialize = function () {
        /*
          var obj = new Object();
          obj.type = "pencil";
          obj.shapes = [];
          for (var i = 0; i < this.Shapes.length; ++i) {
          var shape = this.Shapes[i];
          var points = [];
          for (var j = 0; j < shape.Points.length; ++j) {
          points.push([shape.Points[j][0], shape.Points[j][1]]);
          }
          obj.shapes.push(points);
          }
          obj.creation_camera = this.CreationCamera;

          return obj;
        */
  };

    // Load a widget from a json object (origin MongoDB).
  FillWidget.prototype.Load = function (obj) {
        /*
          for(var n=0; n < obj.shapes.length; n++){
          var points = obj.shapes[n];
          var shape = new SAM.Polyline();
          shape.OutlineColor = [0.9, 1.0, 0.0];
          shape.FixedSize = false;
          shape.LineWidth = 0;
          this.Shapes.push(shape);
          for (var m = 0; m < points.length; ++m) {
          shape.Points[m] = [points[m][0], points[m][1]];
          }
          shape.UpdateBuffers(this.Viewer.AnnotationView);
          }

          // How zoomed in was the view when the annotation was created.
          if (obj.view_height !== undefined) {
          this.CreationCamera = obj.creation_camera;
          }
        */
  };

  FillWidget.prototype.HandleKeyPress = function (keyCode, shift) {
    return false;
  };

  FillWidget.prototype.Deactivate = function () {
    this.Popup.StartHideTimer();
    this.Viewer.DeactivateWidget(this);
    this.State = FILL_WIDGET_WAITING;
    if (this.DeactivateCallback) {
      this.DeactivateCallback();
    }
    this.Viewer.EventuallyRender();
  };

  FillWidget.prototype.HandleMouseDown = function (event) {
    var x = this.Viewer.MouseX;
    var y = this.Viewer.MouseY;

    var ptWorld;
    if (event.which === 1) {
      ptWorld = this.Viewer.ConvertPointViewerToWorld(x, y);
      this.Cursor.attr('src', SAM.ImagePathUrl + 'brush1.jpg');
      this.Cursor.show();
      this.Segmentation.AddPositive(ptWorld);
    }
    if (event.which === 3) {
      ptWorld = this.Viewer.ConvertPointViewerToWorld(x, y);
      this.Cursor.attr('src', SAM.ImagePathUrl + 'eraser1.jpg');
      this.Cursor.show();
      this.Segmentation.AddNegative(ptWorld);
    }
  };

  FillWidget.prototype.HandleMouseUp = function (event) {
    // Middle mouse deactivates the widget.
    if (event.which === 2) {
      // Middle mouse was pressed.
      this.Deactivate();
    }

    // A stroke has just been finished.
    if (event.which === 1 || event.which === 3) {
      this.Cursor.hide();
      this.Segmentation.Update();
      this.Segmentation.Draw();
      this.Viewer.EventuallyRender();
    }
  };

  FillWidget.prototype.HandleDoubleClick = function (event) {
  };

  FillWidget.prototype.HandleMouseMove = function (event) {
    var x = this.Viewer.MouseX;
    var y = this.Viewer.MouseY;

    // Move the paint bucket icon to follow the mouse.
    this.Cursor.css({'left': (x + 4), 'top': (y - 32)});

    if (this.Viewer.MouseDown === true && this.State === FILL_WIDGET_DRAWING) {
      var ptWorld;
      if (event.which === 1) {
        ptWorld = this.Viewer.ConvertPointViewerToWorld(x, y);
        this.Segmentation.AddPositive(ptWorld);
      }
      if (event.which === 3) {
        ptWorld = this.Viewer.ConvertPointViewerToWorld(x, y);
        this.Segmentation.AddNegative(ptWorld);
      }
    }
  };

  FillWidget.prototype.ComputeActiveCenter = function () {
        /*
          var count = 0;
          var sx = 0.0;
          var sy = 0.0;
          for (var i = 0; i < this.Shapes.length; ++i) {
          var shape = this.Shapes[i];
          var points = [];
          for (var j = 0; j < shape.Points.length; ++j) {
          sx += shape.Points[j][0];
          sy += shape.Points[j][1];
          }
          count += shape.Points.length;
          }

          this.ActiveCenter[0] = sx / count;
          this.ActiveCenter[1] = sy / count;
        */
  };

    // This also shows the popup if it is not visible already.
  FillWidget.prototype.PlacePopup = function () {
        /*
          var pt = this.Viewer.ConvertPointWorldToViewer(this.ActiveCenter[0],
          this.ActiveCenter[1]);
          pt[0] += 40;
          pt[1] -= 40;
          this.Popup.Show(pt[0],pt[1]);
        */
  };

  FillWidget.prototype.CheckActive = function (event) {
        /*
          if (this.State === FILL_WIDGET_DRAWING) { return; }

          var pt = this.Viewer.ConvertPointWorldToViewer(this.ActiveCenter[0],
          this.ActiveCenter[1]);

          var dx = this.Viewer.MouseX - pt[0];
          var dy = this.Viewer.MouseY - pt[1];
          var active = false;

          if (dx*dx + dy*dy < 1600) {
          active = true;
          }
          this.SetActive(active);
          return active;
        */
  };

  FillWidget.prototype.GetActive = function () {
    return false;
  };

    // Setting to active always puts state into "active".
    // It can move to other states and stay active.
  FillWidget.prototype.SetActive = function (flag) {
    if (flag) {
      this.Viewer.ActivateWidget(this);
      this.State = FILL_WIDGET_ACTIVE;
      for (var i = 0; i < this.Shapes.length; ++i) {
        this.Shapes[i].Active = true;
      }
      this.PlacePopup();
      this.Viewer.EventuallyRender();
    } else {
      this.Deactivate();
      this.Viewer.DeactivateWidget(this);
    }
  };

  FillWidget.prototype.RemoveFromViewer = function () {
    if (this.Viewer) {
      this.Viewer.RemoveWidget();
    }
  };

  // Can we bind the dialog apply callback to an objects method?
  FillWidget.prototype.ShowPropertiesDialog = function () {
    this.Dialog.ColorInput.val(SAM.ConvertColorToHex(this.Shapes[0].OutlineColor));
    this.Dialog.LineWidthInput.val((this.Shapes[0].LineWidth).toFixed(2));

    this.Dialog.Show(true);
  };

  FillWidget.prototype.DialogApplyCallback = function () {
    var hexcolor = this.Dialog.ColorInput.val();
    for (var i = 0; i < this.Shapes.length; ++i) {
      this.Shapes[i].SetOutlineColor(hexcolor);
      this.Shapes[i].LineWidth = parseFloat(this.Dialog.LineWidthInput.val());
      this.Shapes[i].UpdateBuffers(this.Viewer.AnnotationView);
    }
    this.SetActive(false);
    if (window.SA) { SA.RecordState(); }
    this.Viewer.EventuallyRender();
  };

  SAM.FillWidget = FillWidget;
})();

// ==============================================================================
// Variation of pencil
// Free form loop
// I plan to be abble to add or remove regions from the loop with multiple strokes.
// It will be a state, just like the pencil widget is a state.

(function () {
    // Depends on the CIRCLE widget
  'use strict';

  var DRAWING = 0;
  var ACTIVE = 1;
  var WAITING = 2;

  function LassoWidget (layer, newFlag) {
    if (layer === null) {
      return;
    }

        // Keep track of annotation created by students without edit
        // permission.
    this.UserNoteFlag = !SA.Edit;
    this.Type = 'lasso';

    var self = this;
    this.Dialog = new SAM.Dialog(function () { self.DialogApplyCallback(); });
        // Customize dialog for a lasso.
    this.Dialog.Title.text('Lasso Annotation Editor');
    this.Dialog.Body.css({'margin': '1em 2em'});
        // Color
    this.Dialog.ColorDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .addClass('sa-view-annotation-modal-div');
    this.Dialog.ColorLabel =
            $('<div>')
            .appendTo(this.Dialog.ColorDiv)
            .text('Color:')
            .addClass('sa-view-annotation-modal-input-label');
    this.Dialog.ColorInput =
            $('<input type="color">')
            .appendTo(this.Dialog.ColorDiv)
            .val('#30ff00')
            .addClass('sa-view-annotation-modal-input');

        // Line Width
    this.Dialog.LineWidthDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .addClass('sa-view-annotation-modal-div');
    this.Dialog.LineWidthLabel =
            $('<div>')
            .appendTo(this.Dialog.LineWidthDiv)
            .text('Line Width:')
            .addClass('sa-view-annotation-modal-input-label');
    this.Dialog.LineWidthInput =
            $('<input type="number">')
            .appendTo(this.Dialog.LineWidthDiv)
            .addClass('sa-view-annotation-modal-input')
            .keypress(function (event) { return event.keyCode !== 13; });

        // Area
    this.Dialog.AreaDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .addClass('sa-view-annotation-modal-div');
    this.Dialog.AreaLabel =
            $('<div>')
            .appendTo(this.Dialog.AreaDiv)
            .text('Area:')
            .addClass('sa-view-annotation-modal-input-label');
    this.Dialog.Area =
            $('<div>')
            .appendTo(this.Dialog.AreaDiv)
            .addClass('sa-view-annotation-modal-input');

        // Get default properties.
    if (localStorage.LassoWidgetDefaults) {
      var defaults = JSON.parse(localStorage.LassoWidgetDefaults);
      if (defaults.Color) {
        this.Dialog.ColorInput.val(SAM.ConvertColorToHex(defaults.Color));
      }
      if (defaults.LineWidth) {
        this.Dialog.LineWidthInput.val(defaults.LineWidth);
      }
    }

    this.Layer = layer;
    this.Popup = new SAM.WidgetPopup(this);
    this.Layer.AddWidget(this);

    this.Loop = new SAM.Polyline();
    this.Loop.OutlineColor = [0.0, 0.0, 0.0];
    this.Loop.SetOutlineColor(this.Dialog.ColorInput.val());
    this.Loop.FixedSize = false;
    this.Loop.LineWidth = 0;
    this.Loop.Closed = true;
    this.Stroke = false;

    this.ActiveCenter = [0, 0];

    if (newFlag) {
      this.SetStateToDrawing();
    } else {
      this.State = WAITING;
    }
  }

  LassoWidget.prototype.Draw = function (view) {
    this.Loop.Draw(view);
    if (this.Stroke) {
      this.Stroke.Draw(view);
    }
  };

  LassoWidget.prototype.Serialize = function () {
    var obj = {};
    obj.type = 'lasso';
    obj.user_note_flag = this.UserNoteFlag;
    obj.lineColor = SAM.ConvertColorToHex(this.Loop.OutlineColor);
    obj.lineWidth = this.Loop.GetLineWidth();
    obj.points = [];
    for (var j = 0; j < this.Loop.Points.length; ++j) {
      obj.points.push([this.Loop.Points[j][0], this.Loop.Points[j][1]]);
    }
    obj.closedloop = true;

    return obj;
  };

    // Load a widget from a json object (origin MongoDB).
  LassoWidget.prototype.Load = function (obj) {
    this.UserNoteFlag = obj.user_note_flag;
    if (obj.lineColor !== undefined) {
      this.Loop.OutlineColor = SAM.ConvertColor(obj.lineColor);
    }
    if (obj.lineWidth !== undefined) {
      this.Loop.LineWidth = obj.lineWidth;
    }
    var points = [];
    if (obj.points !== undefined) {
      points = obj.points;
    }
    if (obj.shape !== undefined) {
      points = obj.shapes[0];
    }

    for (var n = 0; n < points.length; n++) {
      this.Loop.Points[n] = [parseFloat(points[n][0]),
        parseFloat(points[n][1])];
    }
    this.ComputeActiveCenter();
    this.Loop.UpdateBuffers(this.Layer.AnnotationView);
  };

  LassoWidget.prototype.HandleMouseWheel = function (event) {
    if (this.State === DRAWING ||
             this.State === ACTIVE) {
      if (!this.Loop) { return true; }
      var tmp = 0;

      if (event.deltaY) {
        tmp = event.deltaY;
      } else if (event.wheelDelta) {
        tmp = event.wheelDelta;
      }

      var minWidth = 1.0 / this.Layer.GetPixelsPerUnit();

            // Wheel event seems to be in increments of 3.
            // depreciated mousewheel had increments of 120....
      var lineWidth = this.Loop.GetLineWidth();
      lineWidth = lineWidth || minWidth;
      if (tmp > 0) {
        lineWidth *= 1.1;
      } else if (tmp < 0) {
        lineWidth /= 1.1;
      }
      if (lineWidth <= minWidth) {
        lineWidth = 0.0;
      }
      this.Dialog.LineWidthInput.val(lineWidth);
      this.Loop.SetLineWidth(lineWidth);
      this.Loop.UpdateBuffers(this.Layer.AnnotationView);

      this.Layer.EventuallyDraw();
      return false;
    }
    return true;
  };

  LassoWidget.prototype.Deactivate = function () {
    this.Popup.StartHideTimer();
    this.Layer.DeactivateWidget(this);
    this.State = WAITING;
    this.Loop.SetActive(false);
    if (this.Stroke) {
      this.Stroke.SetActive(false);
    }
    if (this.DeactivateCallback) {
      this.DeactivateCallback();
    }
    this.Layer.EventuallyDraw();
  };

  LassoWidget.prototype.HandleKeyDown = function (event) {
    if (this.State === DRAWING) {
            // escape key (or space or enter) to turn off drawing
      if (event.keyCode === 27 || event.keyCode === 32 || event.keyCode === 13) {
        this.Deactivate();
        return false;
      }
    }
  };

  LassoWidget.prototype.HandleMouseDown = function (event) {
    var x = event.offsetX;
    var y = event.offsetY;

    if (event.which === 1) {
      // Start drawing.
      // Stroke is a temporary line for interaction.
      // When interaction stops, it is converted/merged with loop.
      this.Stroke = new SAM.Polyline();
      this.Stroke.OutlineColor = [0.0, 0.0, 0.0];
      this.Stroke.SetOutlineColor(this.Loop.OutlineColor);
      // this.Stroke.SetOutlineColor(this.Dialog.ColorInput.val());
      this.Stroke.FixedSize = false;
      this.Stroke.LineWidth = 0;

      var pt = this.Layer.GetCamera().ConvertPointViewerToWorld(x, y);
      this.Stroke.Points = [];
      this.Stroke.Points.push([pt[0], pt[1]]); // avoid same reference.
      return false;
    }
    return true;
  };

  LassoWidget.prototype.HandleMouseUp = function (event) {
        // Middle mouse deactivates the widget.
    if (event.which === 2) {
            // Middle mouse was pressed.
      this.Deactivate();
    }

        // A stroke has just been finished.
    if (event.which === 1 && this.State === DRAWING) {
      var spacing = this.Layer.GetCamera().GetSpacing();
            // this.Decimate(this.Stroke, spacing);
      this.Stroke.Decimate(spacing);
      if (this.Loop && this.Loop.Points.length > 0) {
        this.CombineStroke();
      } else {
        this.Stroke.Closed = true;
        this.Stroke.UpdateBuffers(this.Layer.AnnotationView);
        this.Loop = this.Stroke;
        this.Stroke = false;
      }
      this.ComputeActiveCenter();
      this.Layer.EventuallyDraw();

      if (this.UserNoteFlag && SA.notesWidget) { SA.notesWidget.EventuallySaveUserNote(); }
      if (window.SA) { SA.RecordState(); }
    }
    return false;
  };

  LassoWidget.prototype.HandleDoubleClick = function (event) {
    if (this.State === DRAWING) {
      this.Deactivate();
      return false;
    }
    if (this.State === ACTIVE) {
      this.SetStateToDrawing();
      return false;
    }
    return true;
  };

  LassoWidget.prototype.SetStateToDrawing = function () {
    this.State = DRAWING;
        // When drawing, the cursor is enough indication.
        // We keep the lines the normal color. Yellow is too hard to see.
    this.Loop.SetActive(false);
    this.Popup.Hide();
    this.Layer.GetParent().css(
            {'cursor': 'url(' + SAM.ImagePathUrl + 'select_lasso.png) 5 30,crosshair'});
    this.Layer.EventuallyDraw();
  };

  LassoWidget.prototype.HandleMouseMove = function (event) {
    var x = event.offsetX;
    var y = event.offsetY;

    if (event.which === 1 && this.State === DRAWING) {
      var shape = this.Stroke;
      var pt = this.Layer.GetCamera().ConvertPointViewerToWorld(x, y);
      shape.Points.push([pt[0], pt[1]]); // avoid same reference.
      shape.UpdateBuffers(this.Layer.AnnotationView);
      if (SA.notesWidget && !this.UserNoteFlag) { SA.notesWidget.MarkAsModified(); } // hack
      if (this.UserNoteFlag && SA.notesWidget) { SA.notesWidget.EventuallySaveUserNote(); }
      this.Layer.EventuallyDraw();
      return false;
    }

    if (this.State === ACTIVE &&
            event.which === 0) {
            // Deactivate
      this.SetActive(this.CheckActive(event));
      return false;
    }
    return true;
  };

  LassoWidget.prototype.ComputeActiveCenter = function () {
    var sx = 0.0;
    var sy = 0.0;
    var shape = this.Loop;
    for (var j = 0; j < shape.Points.length; ++j) {
      sx += shape.Points[j][0];
      sy += shape.Points[j][1];
    }

    this.ActiveCenter[0] = sx / shape.Points.length;
    this.ActiveCenter[1] = sy / shape.Points.length;
  };

    // This also shows the popup if it is not visible already.
  LassoWidget.prototype.PlacePopup = function () {
    var pt = this.Loop.FindPopupPoint(this.Layer.GetCamera());
    pt = this.Layer.GetCamera().ConvertPointWorldToViewer(pt[0], pt[1]);

    pt[0] += 20;
    pt[1] -= 10;

    this.Popup.Show(pt[0], pt[1]);
  };

    // Just returns whether the widget thinks it should be active.
    // Layer is responsible for seting it to active.
  LassoWidget.prototype.CheckActive = function (event) {
    if (this.State === DRAWING) { return; }

    var x = event.offsetX;
    var y = event.offsetY;
    var pt = this.Layer.GetCamera().ConvertPointViewerToWorld(x, y);

    var width = this.Loop.GetLineWidth() / 2;
        // Tolerance: 5 screen pixels.
    var minWidth = 10.0 / this.Layer.GetPixelsPerUnit();
    if (width < minWidth) { width = minWidth; }

    if (this.Loop.PointOnShape(pt, width)) {
      return true;
    } else {
      return false;
    }
  };

  LassoWidget.prototype.GetActive = function () {
    return this.State !== WAITING;
  };

    // Setting to active always puts state into "active".
    // It can move to other states and stay active.
  LassoWidget.prototype.SetActive = function (flag) {
    if (flag) {
      if (this.State === WAITING) {
        this.State = ACTIVE;
        this.Loop.SetActive(true);
        this.PlacePopup();
        this.Layer.EventuallyDraw();
      }
    } else {
      if (this.State !== WAITING) {
        this.Deactivate();
        this.Layer.DeactivateWidget(this);
      }
    }
    this.Layer.EventuallyDraw();
  };

    // It would be nice to put this as a superclass method, or call the
    // layer.RemoveWidget method instead.
  LassoWidget.prototype.RemoveFromLayer = function () {
    if (this.Layer) {
      this.RemoveWidget(this);
    }
  };

    // Can we bind the dialog apply callback to an objects method?
  LassoWidget.prototype.ShowPropertiesDialog = function () {
    this.Dialog.ColorInput.val(SAM.ConvertColorToHex(this.Loop.OutlineColor));
    this.Dialog.LineWidthInput.val((this.Loop.LineWidth).toFixed(2));

    var area = this.ComputeArea();
    var areaString = '' + area.toFixed(2);
    if (this.Loop.FixedSize) {
      areaString += ' pixels^2';
    } else {
      areaString += ' units^2';
    }
    this.Dialog.Area.text(areaString);
    this.Dialog.Show(true);
  };

  LassoWidget.prototype.DialogApplyCallback = function () {
    var hexcolor = this.Dialog.ColorInput.val();
    this.Loop.SetOutlineColor(hexcolor);
    this.Loop.LineWidth = parseFloat(this.Dialog.LineWidthInput.val());
    this.Loop.UpdateBuffers(this.Layer.AnnotationView);
    this.SetActive(false);
    if (window.SA) { SA.RecordState(); }
    this.Layer.EventuallyDraw();

    localStorage.LassoWidgetDefaults = JSON.stringify({Color: hexcolor, LineWidth: this.Loop.LineWidth});
    if (SAM.NotesWidget && !this.UserNoteFlag) { SAM.NotesWidget.MarkAsModified(); } // hack
    if (this.UserNoteFlag && SA.notesWidget) { SA.notesWidget.EventuallySaveUserNote(); }
  };

    /*
    // The real problem is aliasing.  Line is jagged with high frequency sampling artifacts.
    // Pass in the spacing as a hint to get rid of aliasing.
    LassoWidget.prototype.Decimate = function(shape, spacing) {
        // Keep looping over the line removing points until the line does not change.
        var modified = true;
        var sanityCheck = 0;
        while (modified) {
            modified = false;
            var newPoints = [];
            newPoints.push(shape.Points[0]);
            // Window of four points.
            var i = 3;
            while (i < shape.Points.length) {
                // Debugging a hang.  I do not think it occurs in decimate, but it might.
                if (++sanityCheck > 100000) {
                    alert("Decimate is takeing too long.");
                    return;
                }
                var p0 = shape.Points[i];
                var p1 = shape.Points[i-1];
                var p2 = shape.Points[i-2];
                var p3 = shape.Points[i-3];
                // Compute the average of the center two.
                var cx = (p1[0] + p2[0]) * 0.5;
                var cy = (p1[1] + p2[1]) * 0.5;
                // Find the perendicular normal.
                var nx = (p0[1] - p3[1]);
                var ny = -(p0[0] - p3[0]);
                var mag = Math.sqrt(nx*nx + ny*ny);
                nx = nx / mag;
                ny = ny / mag;
                mag = Math.abs(nx*(cx-shape.Points[i-3][0]) + ny*(cy-shape.Points[i-3][1]));
                // Mag metric does not distinguish between line and a stroke that double backs on itself.
                // Make sure the two point being merged are between the outer points 0 and 3.
                var dir1 = (p0[0]-p1[0])*(p3[0]-p1[0]) + (p0[1]-p1[1])*(p3[1]-p1[1]);
                var dir2 = (p0[0]-p2[0])*(p3[0]-p2[0]) + (p0[1]-p2[1])*(p3[1]-p2[1]);
                if (mag < spacing && dir1 < 0.0 && dir2 < 0.0) {
                    // Replace the two points with their average.
                    newPoints.push([cx, cy]);
                    modified = true;
                    // Skip the next point the window will have one old merged point,
                    // but that is ok because it is just used as reference and not altered.
                    i += 2;
                } else {
                    //  No modification.  Just move the window one.
                    newPoints.push(shape.Points[i-2]);
                    ++i;
                }
            }
            // Copy the remaing point / 2 points
            i = i-2;
            while (i < shape.Points.length) {
                newPoints.push(shape.Points[i]);
                ++i;
            }
            shape.Points = newPoints;
        }

        shape.UpdateBuffers(this.Layer.AnnotationView);
    }
    */
  LassoWidget.prototype.CombineStroke = function () {
        // This algorithm was desinged to have the first point be the same as the last point.
        // To generalize polylineWidgets and lassoWidgets, I changed this and put a closed
        // flag (which implicitely draws the last segment) in polyline.
        // It is easier to temporarily add the extra point and them remove it, than change the algorithm.
    this.Loop.Points.push(this.Loop.Points[0]);

        // Find the first and last intersection points between stroke and loop.
    var intersection0;
    var intersection1;
    for (var i = 1; i < this.Stroke.Points.length; ++i) {
      var pt0 = this.Stroke.Points[i - 1];
      var pt1 = this.Stroke.Points[i];
      var tmp = this.FindIntersection(pt0, pt1);
      if (tmp) {
                // I need to insert the intersection in the stroke so
                // one stroke segment does not intersect loop twice.
        this.Stroke.Points.splice(i, 0, tmp.Point);
        if (intersection0 === undefined) {
          intersection0 = tmp;
          intersection0.StrokeIndex = i;
        } else {
                    // If a point was added before first intersection,
                    // its index needs to be updated too.
          if (tmp.LoopIndex < intersection0.LoopIndex) {
            intersection0.LoopIndex += 1;
          }
          intersection1 = tmp;
          intersection1.StrokeIndex = i;
        }
      }
    }

    var sanityCheck = 0;

    // If we have two intersections, clip the loop with the stroke.
    if (intersection1 !== undefined) {
      // We will have two parts.
      // Build both loops keeing track of their lengths.
      // Keep the longer part.
      var points0 = [];
      var len0 = 0.0;
      var points1 = [];
      var len1 = 0.0;
      var dx;
      var dy;
      // Add the clipped stroke to both loops.
      for (i = intersection0.StrokeIndex; i < intersection1.StrokeIndex; ++i) {
        points0.push(this.Stroke.Points[i]);
        points1.push(this.Stroke.Points[i]);
      }
      // Now the two new loops take different directions around the original loop.
      // Decreasing
      i = intersection1.LoopIndex;
      while (i !== intersection0.LoopIndex) {
        if (++sanityCheck > 1000000) {
          alert('Combine loop 1 is taking too long.');
          return;
        }
        points0.push(this.Loop.Points[i]);
        dx = this.Loop.Points[i][0];
        dy = this.Loop.Points[i][1];
        // decrement around loop.  First and last loop points are the same.
        if (--i === 0) {
          i = this.Loop.Points.length - 1;
        }
        // Integrate distance.
        dx -= this.Loop.Points[i][0];
        dy -= this.Loop.Points[i][1];
        len0 += Math.sqrt(dx * dx + dy * dy);
      }
      // Duplicate the first point in the loop
      points0.push(intersection0.Point);

      // Increasing
      i = intersection1.LoopIndex;
      while (i !== intersection0.LoopIndex) {
        if (++sanityCheck > 1000000) {
          alert('Combine loop 2 is taking too long.');
          return;
        }
        points1.push(this.Loop.Points[i]);
        dx = this.Loop.Points[i][0];
        dy = this.Loop.Points[i][1];
        // increment around loop.  First and last loop points are the same.
        if (++i === this.Loop.Points.length - 1) {
          i = 0;
        }
        // Integrate distance.
        dx -= this.Loop.Points[i][0];
        dy -= this.Loop.Points[i][1];
        len1 += Math.sqrt(dx * dx + dy * dy);
      }
      // Duplicate the first point in the loop
      points1.push(intersection0.Point);

      if (len0 > len1) {
        this.Loop.Points = points0;
      } else {
        this.Loop.Points = points1;
      }

      if (window.SA) { SA.RecordState(); }
    }

    // Remove the extra point added at the begining of this method.
    this.Loop.Points.pop();
    this.Loop.UpdateBuffers(this.Layer.AnnotationView);
    this.ComputeActiveCenter();

    this.Stroke = false;
    this.Layer.EventuallyDraw();
  };

  // transform all points so p0 is origin and p1 maps to (1,0)
  // Returns false if no intersection,
  // If there is an intersection, it adds that point to the loop.
  // It returns {Point: newPt, LoopIndex: i} .
  LassoWidget.prototype.FindIntersection = function (p0, p1) {
    var best = false;
    var p = [(p1[0] - p0[0]), (p1[1] - p0[1])];
    var mag = Math.sqrt(p[0] * p[0] + p[1] * p[1]);
    if (mag < 0.0) {
      return false;
    }
    p[0] = p[0] / mag;
    p[1] = p[1] / mag;

    var m0 = this.Loop.Points[0];
    var n0 = [(m0[0] - p0[0]) / mag, (m0[1] - p0[1]) / mag];
    var k0 = [(n0[0] * p[0] + n0[1] * p[1]), (n0[1] * p[0] - n0[0] * p[1])];

    for (var i = 1; i < this.Loop.Points.length; ++i) {
      var m1 = this.Loop.Points[i];
      // Avoid an infinite loop inserting points.
      if (p0 === m0 || p0 === m1) {
        continue;
      }
      var n1 = [(m1[0] - p0[0]) / mag, (m1[1] - p0[1]) / mag];
      var k1 = [(n1[0] * p[0] + n1[1] * p[1]), (n1[1] * p[0] - n1[0] * p[1])];
      if ((k1[1] >= 0.0 && k0[1] <= 0.0) || (k1[1] <= 0.0 && k0[1] >= 0.0)) {
        var k = k0[1] / (k0[1] - k1[1]);
        var x = k0[0] + k * (k1[0] - k0[0]);
        if (x > 0 && x <= 1) {
          var newPt = [(m0[0] + k * (m1[0] - m0[0])), (m0[1] + k * (m1[1] - m0[1]))];
          if (!best || x < best.k) {
            best = {Point: newPt, LoopIndex: i, k: x};
          }
        }
      }
      m0 = m1;
      n0 = n1;
      k0 = k1;
    }
    if (best) {
      this.Loop.Points.splice(best.LoopIndex, 0, best.Point);
    }

    return best;
  };

  // This is not actually needed!  So it is not used.
  LassoWidget.prototype.IsPointInsideLoop = function (x, y) {
    // Sum up angles.  Inside poitns will sum to 2pi, outside will sum to 0.
    var angle = 0.0;
    var pt0 = this.Loop.Points[this.Loop.length - 1];
    for (var i = 0; i < this.Loop.length; ++i) {
      var pt1 = this.Loop.Points[i];
      var v0 = [pt0[0] - x, pt0[1] - y];
      var v1 = [pt1[0] - x, pt1[1] - y];
      var mag0 = Math.sqrt(v0[0] * v0[0] + v0[1] * v0[1]);
      var mag1 = Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1]);
      angle += Math.arcsin((v0[0] * v1[1] - v0[1] * v1[0]) / (mag0 * mag1));
    }

    return (angle > 3.14 || angle < -3.14);
  };

  LassoWidget.prototype.ComputeArea = function () {
    var area = 0.0;
    // Use the active center. It should be more numerical stable.
    // Iterate over triangles
    var vx1 = this.Loop.Points[0][0] - this.ActiveCenter[0];
    var vy1 = this.Loop.Points[0][1] - this.ActiveCenter[1];
    for (var j = 1; j < this.Loop.Points.length; ++j) {
      // Area of triangle is 1/2 magnitude of cross product.
      var vx2 = vx1;
      var vy2 = vy1;
      vx1 = this.Loop.Points[j][0] - this.ActiveCenter[0];
      vy1 = this.Loop.Points[j][1] - this.ActiveCenter[1];
      area += (vx1 * vy2) - (vx2 * vy1);
    }

    if (area < 0) {
      area = -area;
    }
    return area;
  };

  SAM.LassoWidget = LassoWidget;
})();

// ==============================================================================
// A replacement for the right click option to get the properties menu.
// This could be multi touch friendly.

(function () {
  'use strict';

  function WidgetPopup (widget, layer) {
    this.Widget = widget;
    this.Visible = false;
    this.HideTimerId = 0;

    var parent = layer.GetParent();

        // buttons to replace right click.
    var self = this;

        // We cannot append this to the canvas, so just append
        // it to the view panel, and add the viewport offset for now.
        // I should probably create a div around the canvas.
        // This is this only place I need viewport[0], [1] and I
        // was thinking of getting rid of the viewport offset.
    this.ButtonDiv =
            $('<div>').appendTo(parent)
            .hide()
            .css({'position': 'absolute',
              'z-index': '1'})
            .mouseenter(function () { self.CancelHideTimer(); })
            .mouseleave(function () { self.StartHideTimer(); });
    this.DeleteButton = $('<img>').appendTo(this.ButtonDiv)
            .css({'height': '20px'})
            .attr('src', SA.ImagePathUrl + 'deleteSmall.png')
            .on('click touchstart', function () { self.DeleteCallback(); });
    this.PropertiesButton = $('<img>').appendTo(this.ButtonDiv)
            .css({'height': '20px'})
            .attr('src', SA.ImagePathUrl + 'Menu.jpg')
            .on('click touchstart', function () { self.PropertiesCallback(); });

    this.HideCallback = undefined;
  }

    // Used to hide an interacotrs handle with the popup.
    // TODO:  Let the AnnotationLayer manage the "active" widget.
    // The popup should not be doing this (managing its own timer)
  WidgetPopup.prototype.SetHideCallback = function (callback) {
    this.HideCllback = callback;
  };

  WidgetPopup.prototype.DeleteCallback = function () {
    if (this.Widget.UserNoteFlag && SA.notesWidget) { SA.notesWidget.EventuallySaveUserNote(); }
    this.Widget.SetActive(false);
    this.Hide();

        // Messy.  Maybe closure callback can keep track of the layer.
    this.Widget.Layer.EventuallyDraw();
    this.Widget.Layer.RemoveWidget(this.Widget);

    if (window.SA) { SA.RecordState(); }
  };

  WidgetPopup.prototype.PropertiesCallback = function () {
    this.Hide();
    this.Widget.ShowPropertiesDialog();
  };

    // ------------------------------------------------------------------------------
  WidgetPopup.prototype.Show = function (x, y) {
    this.CancelHideTimer(); // Just in case: Show trumps previous hide.
    this.ButtonDiv.css({
      'left': x + 'px',
      'top': y + 'px'})
            .show();
  };

    // When some other event occurs, we want to hide the pop up quickly
  WidgetPopup.prototype.Hide = function () {
    this.CancelHideTimer(); // Just in case: Show trumps previous hide.
    this.ButtonDiv.hide();
    if (this.HideCallback) {
      (this.HideCallback)();
    }
  };

  WidgetPopup.prototype.StartHideTimer = function () {
    if (!this.HideTimerId) {
      var self = this;

      if (SAM.detectMobile()) {
        this.HideTimerId = setTimeout(function () { self.HideTimerCallback(); }, 1500);
      } else {
        this.HideTimerId = setTimeout(function () { self.HideTimerCallback(); }, 800);
      }
    }
  };

  WidgetPopup.prototype.CancelHideTimer = function () {
    if (this.HideTimerId) {
      clearTimeout(this.HideTimerId);
      this.HideTimerId = 0;
    }
  };

  WidgetPopup.prototype.HideTimerCallback = function () {
    this.ButtonDiv.hide();
    this.HideTimerId = 0;
  };

  SAM.WidgetPopup = WidgetPopup;
})();

// cross hairs was created as an anchor for text.
// Just two lines that cross at a point.
// I am not goint to support line width, or fillColor.
// Shape seems to define lines in a loop, so I will create a loop for now.

(function () {
  'use strict';

  function CrossHairs () {
    SAM.Shape.call(this);
    this.Length = 50; // Length of the crosing lines
    this.Width = 1; // Width of the cross hair lines.
    this.Origin = [10000, 10000]; // position in world coordinates.
    this.FillColor = [0, 0, 0];
    this.OutlineColor = [1, 1, 1];
    this.PointBuffer = [];
  }
  CrossHairs.prototype = new SAM.Shape();

  CrossHairs.prototype.destructor = function () {
        // Get rid of the buffers?
  };

  CrossHairs.prototype.UpdateBuffers = function (view) {
    this.PointBuffer = [];
    var cellData = [];
    var halfLength = (this.Length * 0.5) + 0.5;
    var halfWidth = (this.Width * 0.5) + 0.5;

    this.Matrix = mat4.create();
    mat4.identity(this.Matrix);

    this.PointBuffer.push(-halfWidth);
    this.PointBuffer.push(-halfWidth);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(-halfLength);
    this.PointBuffer.push(-halfWidth);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(-halfLength);
    this.PointBuffer.push(halfWidth);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(-halfWidth);
    this.PointBuffer.push(halfWidth);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(-halfWidth);
    this.PointBuffer.push(halfLength);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(halfWidth);
    this.PointBuffer.push(halfLength);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(halfWidth);
    this.PointBuffer.push(halfWidth);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(halfLength);
    this.PointBuffer.push(halfWidth);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(halfLength);
    this.PointBuffer.push(-halfWidth);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(halfWidth);
    this.PointBuffer.push(-halfWidth);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(halfWidth);
    this.PointBuffer.push(-halfLength);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(-halfWidth);
    this.PointBuffer.push(-halfLength);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(-halfWidth);
    this.PointBuffer.push(-halfWidth);
    this.PointBuffer.push(0.0);

    cellData.push(1);
    cellData.push(2);
    cellData.push(7);

    cellData.push(1);
    cellData.push(7);
    cellData.push(8);

    cellData.push(4);
    cellData.push(5);
    cellData.push(10);

    cellData.push(4);
    cellData.push(10);
    cellData.push(11);

    if (view.gl) {
      this.VertexPositionBuffer = view.gl.createBuffer();
      view.gl.bindBuffer(view.gl.ARRAY_BUFFER, this.VertexPositionBuffer);
      view.gl.bufferData(view.gl.ARRAY_BUFFER, new Float32Array(this.PointBuffer), view.gl.STATIC_DRAW);
      this.VertexPositionBuffer.itemSize = 3;
      this.VertexPositionBuffer.numItems = this.PointBuffer.length / 3;

      this.CellBuffer = view.gl.createBuffer();
      view.gl.bindBuffer(view.gl.ELEMENT_ARRAY_BUFFER, this.CellBuffer);
      view.gl.bufferData(view.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cellData), view.gl.STATIC_DRAW);
      this.CellBuffer.itemSize = 1;
      this.CellBuffer.numItems = cellData.length;
    }
  };

  SAM.CrossHairs = CrossHairs;
})();

(function () {
  'use strict';

  function Arrow () {
    SAM.Shape.call(this);
    this.Width = 10; // width of the shaft and size of the head
    this.Length = 50; // Length of the arrow in pixels
    this.Orientation = 45.0; // in degrees, counter clockwise, 0 is left
    this.Origin = [10000, 10000]; // Tip position in world coordinates.
    this.OutlineColor = [0, 0, 0];
    this.ZOffset = -0.1;
  }
  Arrow.prototype = new SAM.Shape();

  Arrow.prototype.destructor = function () {
    // Get rid of the buffers?
  };

  // This has to be in viewer coordinates bedcause we do not have the camera.
  // Point is in world coordinates.
  // Point origin is anchor and units pixels.
  Arrow.prototype.PointInShape = function (x, y) {
    // Rotate point so arrow lies along the x axis.
    var tmp = -(this.Orientation * Math.PI / 180.0);
    var ct = Math.cos(tmp);
    var st = Math.sin(tmp);
    var xNew = x * ct + y * st;
    var yNew = -x * st + y * ct;

    // Now we have to scale from global pixels to screen pixels.
    tmp = this.Width / 2.0;
    // Had to bump the y detection up by 3x because of unclickability on the iPad.
    if (xNew > 0.0 && xNew < this.Length * 1.3 && yNew < tmp * 3 && yNew > -tmp * 3) {
      return true;
    }
  };

  Arrow.prototype.UpdateBuffers = function (view) {
    this.PointBuffer = [];
    var cellData = [];
    var hw = this.Width * 0.5;
    var w2 = this.Width * 2.0;

    this.Matrix = mat4.create();
    mat4.identity(this.Matrix);

    this.PointBuffer.push(0.0);
    this.PointBuffer.push(0.0);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(w2);
    this.PointBuffer.push(this.Width);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(w2);
    this.PointBuffer.push(hw);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(this.Length);
    this.PointBuffer.push(hw);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(this.Length);
    this.PointBuffer.push(-hw);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(w2);
    this.PointBuffer.push(-hw);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(w2);
    this.PointBuffer.push(-this.Width);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(0.0);
    this.PointBuffer.push(0.0);
    this.PointBuffer.push(0.0);

    if (view.gl) {
      // Now create the triangles
      cellData.push(0);
      cellData.push(1);
      cellData.push(2);

      cellData.push(0);
      cellData.push(2);
      cellData.push(5);

      cellData.push(0);
      cellData.push(5);
      cellData.push(6);

      cellData.push(2);
      cellData.push(3);
      cellData.push(4);

      cellData.push(2);
      cellData.push(4);
      cellData.push(5);

      this.VertexPositionBuffer = view.gl.createBuffer();
      view.gl.bindBuffer(view.gl.ARRAY_BUFFER, this.VertexPositionBuffer);
      view.gl.bufferData(view.gl.ARRAY_BUFFER, new Float32Array(this.PointBuffer), view.gl.STATIC_DRAW);
      this.VertexPositionBuffer.itemSize = 3;
      this.VertexPositionBuffer.numItems = this.PointBuffer.length / 3;

      this.CellBuffer = view.gl.createBuffer();
      view.gl.bindBuffer(view.gl.ELEMENT_ARRAY_BUFFER, this.CellBuffer);
      view.gl.bufferData(view.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cellData), view.gl.STATIC_DRAW);
      this.CellBuffer.itemSize = 1;
      this.CellBuffer.numItems = cellData.length;
    }
  };

  // Polar is a pain.
  // This positions the tail a point in viewer coordinates.
  // This only works for world coordinat system, constant size, constant orientation.
  Arrow.prototype.SetTailViewer = function (x, y, cam) {
    var dx, dy;
    if (this.FixedSize) {
      var tipViewer = cam.ConvertPointWorldToViewer(this.Origin[0], this.Origin[1]);
      dx = x - tipViewer[0];
      dy = y - tipViewer[1];
    } else {
      var tailWorld = cam.ConvertPointViewerToWorld(x, y);
      dx = tailWorld[0] - this.Origin[0];
      dy = tailWorld[1] - this.Origin[1];
    }
    this.Length = Math.sqrt(dx * dx + dy * dy);
    this.Orientation = -Math.atan2(dy, dx) * 180.0 / Math.PI;
  };

  // Polar is a pain.
  // This positions the tail a point in viewer coordinates.
  // This only works for world coordinat system, constant size, constant orientation.
  Arrow.prototype.GetTailViewer = function (cam) {
    var theta = -this.Orientation * Math.PI / 180.0;
    var x, y;
    if (this.FixedSize) {
      var tipViewer = cam.ConvertPointWorldToViewer(this.Origin[0], this.Origin[1]);
      x = tipViewer[0] + this.Length * Math.cos(theta);
      y = tipViewer[1] + this.Length * Math.sin(theta);
      return [x, y];
    } else {
      x = this.Origin[0] + this.Length * Math.cos(theta);
      y = this.Origin[1] + this.Length * Math.sin(theta);
      var tailViewer = cam.ConvertPointWorldToViewer(x, y);
      return tailViewer;
    }
  };

  SAM.Arrow = Arrow;
})();

// ==============================================================================
// This widget will first be setup to define an arrow.
// Layer will forward events to the arrow.
// TODO: Active hover: circles cursor.

(function () {
  'use strict';

  // The arrow has just been created and is following the mouse.
  // I have to differentiate from DRAG because
  // dragging while just created cannot be relative.  It places the tip on the mouse.
  var NEW = 0;
  var NEW_DRAG_TAIL = 1;
  var DRAG = 2; // The whole arrow is being dragged.
  var DRAG_TIP = 3;
  var DRAG_TAIL = 4;
  var INACTIVE = 5; // The normal (resting) state.
  var ACTIVE = 6; // Mouse is receiving events.
  var HOVER = 7;  // Mouse is over the widget
  var DIALOG = 8; // Properties dialog is up

  // We might get rid of the new flag by passing in a null layer.
  function ArrowWidget (layer) {
    if (layer === null) {
      return null;
    }
    this.Layer = layer;
    this.Type = 'arrow';
    this.State = INACTIVE;

    // This method gets called if the active state of this widget turns on or off.
    // This is used to turn off the pencil button in the Panel.
    this.StateChangeCallback = undefined;
    // This is used by the annotationPanel to transfer draing mode to a new selected widget.
    this.SelectedCallback = undefined;

    // Wait to create this until the first move event.
    this.Arrow = new SAM.Arrow();
    this.Arrow.Origin = [0, 0];
    this.Arrow.SetFillColor([0.0, 0.0, 0.0]);
    this.Arrow.OutlineColor = [1.0, 1.0, 1.0];
    this.Arrow.Length = 50;
    this.Arrow.Width = 8;
    // Note: If the user clicks before the mouse is in the
    // canvas, this will behave odd.
    this.TipPosition = [0, 0];
    this.TipOffset = [0, 0];

    // Circle is to show an active tip and base.
    this.CircleTip = new SAM.Circle();
    this.CircleTip.SetFillColor([1, 1, 0]);
    this.CircleTip.SetOutlineColor([0.0, 0.0, 0.0]);
    this.CircleTip.Radius = 5;
    this.CircleTip.LineWidth = 1;
    this.CircleTip.PositionCoordinateSystem = 1; // Shape.VIEWER;
    // this.Circle.ZOffset = -0.05;

    this.CircleTail = new SAM.Circle();
    this.CircleTail.SetFillColor([1, 1, 0]);
    this.CircleTail.SetOutlineColor([0.0, 0.0, 0.0]);
    this.CircleTail.Radius = 5;
    this.CircleTail.PositionCoordinateSystem = 1; // Shape.VIEWER;

    // Get default properties.
    if (localStorage.ArrowWidgetDefaults) {
      var defaults = JSON.parse(localStorage.ArrowWidgetDefaults);
      if (defaults.Color) {
        this.Arrow.SetFillColor(defaults.Color);
      }
      if (defaults.Width) {
        this.Arrow.Width = defaults.Width;
      }
    }
  }

  // Not used yet, but might be useful.
  ArrowWidget.prototype.SetCreationCamera = function (cam) {
    // Lets save the zoom level (sort of).
    // Load will overwrite this for existing annotations.
    // This will allow us to expand annotations into notes.
    this.CreationCamera = cam.Serialize();
  };

  ArrowWidget.prototype.SetModifiedCallback = function (callback) {
    this.ModifiedCallback = callback;
  };

  // Called when the widget is modified.
  ArrowWidget.prototype.Modified = function () {
    if (this.ModifiedCallback) {
      this.ModifiedCallback(this);
    }
  };

  ArrowWidget.prototype.SetSelectedCallback = function (callback) {
    this.SelectedCallback = callback;
  };

  // This callback gets called when ever the active state changes,
  // even if caused by an external call. This widget is passed as a argument.
  // This is used to turn off the pencil button in the Panel.
  ArrowWidget.prototype.SetStateChangeCallback = function (callback) {
    this.StateChangeCallback = callback;
  };

  // Called when the state changes.
  ArrowWidget.prototype.StateChanged = function () {
    if (this.StateChangeCallback) {
      this.StateChangeCallback(this);
    }
  };

  // Sets state to "NEW"
  ArrowWidget.prototype.SetStateToDrawing = function () {
    // if (this.Layer) {
    // this.StateChanged();
    this.State = NEW;
    // return;
    // }
    // this.State = INACTIVE;
  };

  ArrowWidget.prototype.GetActive = function () {
    if (this.State === INACTIVE) {
      return false;
    }
    return true;
  };

  ArrowWidget.prototype.SetActive = function (flag) {
    if (flag === this.GetActive()) {
      return;
    }

    if (flag) {
      this.State = ACTIVE;
    } else {
      this.State = INACTIVE;
    }
    this.StateChanged();
    this.Layer.EventuallyDraw();
  };

  ArrowWidget.prototype.Draw = function () {
    var view = this.Layer.GetView();
    this.Arrow.Draw(view);
    if (this.State !== INACTIVE && this.State !== NEW && this.State !== DRAG) {
      var pts = this.GetViewPoints();
      this.CircleTip.Origin = pts[0];
      this.CircleTail.Origin = pts[1];
      this.CircleTip.Draw(view);
      this.CircleTail.Draw(view);
    }
  };

  ArrowWidget.prototype.Serialize = function () {
    if (this.Arrow === undefined) {
      return null;
    }

    var obj = {};
    obj.type = 'arrow';
    obj.origin = this.Arrow.Origin;
    obj.fillColor = SAM.ConvertColorToHex(this.Arrow.FillColor);
    obj.lineColor = SAM.ConvertColorToHex(this.Arrow.OutlineColor);
    obj.length = this.Arrow.Length;
    obj.width = this.Arrow.Width;
    obj.orientation = this.Arrow.Orientation;
    obj.fixedsize = this.Arrow.FixedSize;
    obj.fixedorientation = this.Arrow.FixedOrientation;

    return obj;
  };

  // Load a widget from a json object (origin MongoDB).
  ArrowWidget.prototype.Load = function (obj) {
    this.Arrow.Origin = [parseFloat(obj.origin[0]), parseFloat(obj.origin[1])];
    this.TipPosition = [parseFloat(obj.origin[0]), parseFloat(obj.origin[1])];
    this.Arrow.FillColor = [parseFloat(obj.fillcolor[0]), parseFloat(obj.fillcolor[1]), parseFloat(obj.fillcolor[2])];
    this.Arrow.OutlineColor = SAM.ConvertColor(obj.lineColor);
    this.Arrow.Length = parseFloat(obj.length);
    this.Arrow.Width = parseFloat(obj.width);
    this.Arrow.Orientation = parseFloat(obj.orientation);

    if (obj.fixedsize === undefined) {
      this.Arrow.FixedSize = false;
    } else {
      this.Arrow.FixedSize = (obj.fixedsize === 'true');
    }

    if (obj.fixedorientation === undefined) {
      this.Arrow.FixedOrientation = false;
    } else {
      this.Arrow.FixedOrientation = (obj.fixedorientation === 'true');
    }

    this.Arrow.UpdateBuffers(this.Layer.AnnotationView);
  };

  // When we toggle fixed size, we have to convert the length of the arrow
  // between viewer and world.
  ArrowWidget.prototype.SetFixedSize = function (fixedSizeFlag) {
    if (this.Arrow.FixedSize === fixedSizeFlag) {
      return;
    }
    var pixelsPerUnit = this.Layer.GetPixelsPerUnit();

    if (fixedSizeFlag) {
      // Convert length from world to viewer.
      this.Arrow.Length *= pixelsPerUnit;
      this.Arrow.Width *= pixelsPerUnit;
    } else {
      this.Arrow.Length /= pixelsPerUnit;
      this.Arrow.Width /= pixelsPerUnit;
    }
    this.Arrow.FixedSize = fixedSizeFlag;
    this.Arrow.UpdateBuffers(this.Layer.AnnotationView);
    this.Layer.EventuallyDraw();
  };

  // Selects the widget if the arrow is fuly contained in the selection rectangle.
  ArrowWidget.prototype.ApplySelect = function (selection) {
    var viewPts = this.GetViewPoints();
    if (selection.ViewerPointInSelection(viewPts[0][0], viewPts[0][1]) &&
        selection.ViewerPointInSelection(viewPts[1][0], viewPts[1][1])) {
      this.SetSelected(true);
      return true;
    }
    this.SetSelected(false);
    return false;
  };

  // Returns true if the mouse is over the arrow.
  ArrowWidget.prototype.HandleSelect = function () {
    if (this.State === DIALOG) {
      return;
    }
    var event = this.Layer.Event;
    var x = event.offsetX;
    var y = event.offsetY;

    if (this.PointViewerInArrow(x, y)) {
      this.Arrow.Selected = true;
      return this;
    }
    this.Arrow.Selected = false;
  };

  ArrowWidget.prototype.HandleMouseDown = function (layer) {
    if (this.State === INACTIVE || this.State === ACTIVE) {
      // Widget only responds when mouse is hovering over it,
      // otherwise, let the viewer do its thing.
      return true;
    }

    var event = layer.Event;
    if (event.which !== 1) {
      return false;
    }
    if (this.State === NEW) {
      this.TipPosition = [this.Layer.MouseX, this.Layer.MouseY];
      // Creation behaves differently.  It is not selected.
      // When finished, it goes in active.
      this.State = NEW_DRAG_TAIL;
      this.CircleTail.Selected = true;
      this.CircleTail.SetFillColor([1, 1, 0]);
    }
    if (this.State === HOVER) {
      if (this.CircleTip.Selected) {
        this.State = DRAG_TIP;
      } else if (this.CircleTail.Selected) {
        this.State = DRAG_TAIL;
      } else {
        this.State = DRAG;
      }
      var x = event.offsetX;
      var y = event.offsetY;
      var cam = this.Layer.GetCamera();
      this.LastMouseWorld = cam.ConvertPointViewerToWorld(x, y);
    }
    return false;
  };

  ArrowWidget.prototype.HandleMouseUp = function (layer) {
    if (this.State === INACTIVE || this.State === ACTIVE) {
      // Widget only responds when mouse is hovering over it,
      // otherwise, let the viewer do its thing.
      return true;
    }
    if (this.State === NEW_DRAG_TAIL) {
      this.State = INACTIVE;
      this.StateChanged();
      this.Layer.EventuallyDraw();
      this.Modified();
      return false;
    }

    var event = layer.Event;
    if (this.State === ACTIVE && event.which === 3) {
      // Right mouse was pressed.
      // Pop up the properties dialog.
      // Which one should we popup?
      // Add a ShowProperties method to the widget. (With the magic of javascript).
      this.ShowPropertiesDialog();
    }
    this.State = HOVER;
    this.Modified();
    return false;
  };

  ArrowWidget.prototype.PointViewerInArrow = function (x, y) {
    var pts = this.GetViewPoints();
    var vx = (pts[1][0] - pts[0][0]);
    var vy = (pts[1][1] - pts[0][1]);
    var vm = Math.sqrt(vx * vx + vy * vy);
    var nx = vx / vm;
    var ny = vy / vm;
    var mx = x - pts[0][0];
    var my = y - pts[0][1];
    var mm = Math.sqrt(mx * mx + my * my);
    var d = nx * mx + ny * my;
    var tx = mx - nx * d;
    var ty = my - ny * d;
    var tm = Math.sqrt(tx * tx + ty * ty);
    var widthViewer = this.Arrow.Width * vm / this.Arrow.Length;
    if (mm > vm || tm > (widthViewer / 2) + 2) {
      return false;
    }
    return true;
  };

  ArrowWidget.prototype.HandleMouseMove = function (layer) {
    if (this.State === INACTIVE) {
      return true;
    }
    var event = layer.Event;
    var x = this.Layer.MouseX;
    var y = this.Layer.MouseY;

    if (event.which === 1 && this.State === ACTIVE) {
      // If only active, left the viewer do its thing.
      return true;
    }

    // Hover logic.
    if (this.State === ACTIVE || this.State === HOVER) {
      var cursor = '';
      if (this.PointViewerInArrow(x, y)) {
        cursor = 'move';
        this.State = HOVER;
      } else {
        this.State = ACTIVE;
      }

      // Now deal with control point hovering.
      var dx = x - this.CircleTip.Origin[0];
      var dy = y - this.CircleTip.Origin[1];
      if (dx * dx + dy * dy < Math.pow(this.CircleTip.Radius, 2)) {
        this.CircleTip.Selected = true;
        cursor = 'move';
        this.State = HOVER;
      } else {
        this.CircleTip.Selected = false;
      }
      dx = x - this.CircleTail.Origin[0];
      dy = y - this.CircleTail.Origin[1];
      if (dx * dx + dy * dy < Math.pow(this.CircleTail.Radius, 2)) {
        this.CircleTail.Selected = true;
        cursor = 'move';
        this.State = HOVER;
      } else {
        this.CircleTail.Selected = false;
      }
      this.Layer.GetParent().css({'cursor': cursor});
      this.Layer.EventuallyDraw();

      return false;
    }

    var cam = this.Layer.GetCamera();
    var mouseWorld = cam.ConvertPointViewerToWorld(x, y);
    if (this.State === NEW) {
      // Just have the tip follow the mouse.
      this.Arrow.Origin = mouseWorld;
      this.Layer.EventuallyDraw();
      return false;
    }

    if (event.which !== 1) {
      return false;
    }

    if (this.State === DRAG) {
      // Tip follows its relative position to the mouse.
      dx = mouseWorld[0] - this.LastMouseWorld[0];
      dy = mouseWorld[1] - this.LastMouseWorld[1];
      this.Arrow.Origin[0] += dx;
      this.Arrow.Origin[1] += dy;
    } else if (this.State === DRAG_TAIL || this.State === NEW_DRAG_TAIL) {
      // Tail follows mouse, but tip stays fixed.
      this.Arrow.SetTailViewer(x, y, cam);
      this.Arrow.UpdateBuffers(this.Layer.AnnotationView);
    } else if (this.State === DRAG_TIP) {
      // Tip follows mouse, but tail does not move.
      // var tailViewer = this.Arrow.GetTailViewer(cam);
      var pts = this.GetViewPoints();
      var tailViewer = pts[1];
      this.Arrow.Origin = mouseWorld;
      this.Arrow.SetTailViewer(tailViewer[0], tailViewer[1], cam);
      this.Arrow.UpdateBuffers(this.Layer.AnnotationView);
    }
    this.LastMouseWorld = mouseWorld;
    this.Layer.EventuallyDraw();
    return false;
  };

  // Return points 1 and 2 in view (screen) coordinates.
  ArrowWidget.prototype.GetViewPoints = function () {
    var cam = this.Layer.GetCamera();
    var pt1 = this.Arrow.Origin;
    var tmp = -this.Arrow.Orientation * Math.PI / 180.0;
    var dx = this.Arrow.Length * Math.cos(tmp);
    var dy = this.Arrow.Length * Math.sin(tmp);

    var vpt1 = cam.ConvertPointWorldToViewer(pt1[0], pt1[1]);
    if (this.Arrow.FixedSize) {
      var vpt2 = [vpt1[0] + dx, vpt1[1] + dy];
    } else {
      var pt2 = [pt1[0] + dx, pt1[1] + dy];
      vpt2 = cam.ConvertPointWorldToViewer(pt2[0], pt2[1]);
    }

    return [vpt1, vpt2];
  };

  // TODO: Repurpose for dragging
  ArrowWidget.prototype.CheckActive = function () {
    var viewport = this.Layer.GetViewport();
    var cam = this.Layer.GetCamera();
    // TODO: Should not be accessing this without a getter.
    var m = cam.ImageMatrix;
    // Compute tip point in screen coordinates.
    var x = this.Arrow.Origin[0];
    var y = this.Arrow.Origin[1];
    // Convert from world coordinate to view (-1->1);
    var h = (x * m[3] + y * m[7] + m[15]);
    var xNew = (x * m[0] + y * m[4] + m[12]) / h;
    var yNew = (x * m[1] + y * m[5] + m[13]) / h;
    // Convert from view to screen pixel coordinates.
    xNew = (xNew + 1.0) * 0.5 * viewport[2] + viewport[0];
    yNew = (yNew + 1.0) * 0.5 * viewport[3] + viewport[1];
    yNew = viewport[3] - yNew;

    console.log('origin: ' + xNew + ', ' + yNew + ', mouse: ' + this.Layer.MouseX + ', ' + this.Layer.MouseY);

    // Use this point as the origin.
    x = this.Layer.MouseX - xNew;
    y = this.Layer.MouseY - yNew;
    // Rotate so arrow lies along the x axis.
    var tmp = -this.Arrow.Orientation * Math.PI / 180.0;
    var ct = Math.cos(tmp);
    var st = Math.sin(tmp);
    xNew = x * ct + y * st;
    yNew = -x * st + y * ct;

    var length = this.Arrow.Length;
    var halfWidth = this.Arrow.Width / 2.0;
    if (!this.Arrow.FixedSize) {
      var pixelsPerUnit = this.Layer.GetPixelsPerUnit();
      length *= pixelsPerUnit;
      halfWidth *= pixelsPerUnit;
    }

    this.ActiveTail = false;
    if (xNew > 0.0 && xNew < length && yNew > -halfWidth && yNew < halfWidth) {
      this.SetActive(true);
      // Save the position along the arrow to decide which drag behavior to use.
      if (xNew > length - halfWidth) {
        this.ActiveTail = true;
      }
      return true;
    } else {
      this.SetActive(false);
      return false;
    }
  };

  // Returns true if selected
  // This is sort of ugly.  Change it to delete directly if possible.
  // Return value will let the layer clean up.
  ArrowWidget.prototype.DeleteSelected = function () {
    return this.Arrow.DeleteSelected();
  };

  ArrowWidget.prototype.IsEmpty = function () {
    if (this.State === NEW) {
      return true;
    }
    return this.Arrow.IsEmpty();
  };

  // I am divorcing selected from active.
  ArrowWidget.prototype.IsSelected = function () {
    return this.Arrow.Selected;
  };

  ArrowWidget.prototype.SetSelected = function (flag) {
    this.Arrow.SetSelected(flag);
    if (flag && this.SelectedCallback) {
      this.SelectedCallback(this);
    }
  };

  // I need this because old schemes cannot use "Load"
  ArrowWidget.prototype.SetColor = function (hexColor) {
    this.Arrow.SetFillColor(hexColor);
    this.Layer.EventuallyDraw();
  };

  ArrowWidget.prototype.InitPropertiesDialog = function () {
    var self = this;

    this.Dialog = new SAM.Dialog(this.Layer.GetParent().parent());
    this.Dialog.SetApplyCallback(function () { self.DialogApplyCallback(); });
    // Customize dialog for an arrow.
    this.Dialog.Title.text('Arrow Properties');
    this.Dialog.Body.css({'margin': '1em 2em'});
    // Color
    this.Dialog.ColorDiv =
            $('<div>')
            .css({'height': '24px'})
            .appendTo(this.Dialog.Body)
            .addClass('sa-view-annotation-modal-div');
    this.Dialog.ColorLabel =
            $('<div>')
            .appendTo(this.Dialog.ColorDiv)
            .text('Color:')
            .addClass('sa-view-annotation-modal-input-label');
    this.Dialog.ColorInput =
            $('<input type="color">')
            .appendTo(this.Dialog.ColorDiv)
            .val('#30ff00')
            .addClass('sa-view-annotation-modal-input');

    // Width
    this.Dialog.WidthDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .addClass('sa-view-annotation-modal-div');
    this.Dialog.WidthLabel =
            $('<div>')
            .appendTo(this.Dialog.WidthDiv)
            .text('Shaft Width:')
            .addClass('sa-view-annotation-modal-input-label');
    this.Dialog.WidthInput =
            $('<input type="number">')
            .appendTo(this.Dialog.WidthDiv)
            .addClass('sa-view-annotation-modal-input')
            .keypress(function (event) { return event.keyCode !== 13; });
  };

  // Can we bind the dialog apply callback to an objects method?
  ArrowWidget.prototype.ShowPropertiesDialog = function () {
    if (this.Dialog === undefined) {
      this.InitPropertiesDialog();
    }
    this.WidgetPropertiesToDialog();
    var self = this;
    this.Dialog.SetApplyCallback(function () { self.DialogApplyCallback(); });
    this.Dialog.SetCloseCallback(function () { self.DialogCloseCallback(); });
    this.Dialog.Show(true);
    this.State = DIALOG;
  };

  ArrowWidget.prototype.DialogApplyCallback = function () {
    // Transfer properties fromt he dialog GUI to the widget.
    this.DialogPropertiesToWidget();
    // View bindings kept the dialog text input from working.
    if (!this.Layer) {
      return;
    }
    this.SetActive(false);
    this.Layer.EventuallyDraw();
  };

  ArrowWidget.prototype.DialogCloseCallback = function () {
    this.SetActive(false);
    this.Layer.EventuallyDraw();
  };

  // Fill the dialog values from the widget values.
  ArrowWidget.prototype.WidgetPropertiesToDialog = function () {
    this.Dialog.ColorInput.val(SAM.ConvertColorToHex(this.Arrow.FillColor));
    this.Dialog.WidthInput.val((this.Arrow.Width).toFixed(2));
  };

  // Copy the properties of the dialog into the widget
  ArrowWidget.prototype.DialogPropertiesToWidget = function () {
    var modified = false;

    // Get the color
    var hexcolor = SAM.ConvertColorToHex(this.Dialog.ColorInput.val());
    if (hexcolor !== this.Arrow.FillColor) {
      modified = true;
      this.Arrow.SetFillColor(hexcolor);
      this.Arrow.ChooseOutlineColor();
      modified = true;
    }

    var width = parseFloat(this.Dialog.WidthInput.val());
    if (width !== this.Arrow.Width) {
      this.Arrow.Width = width;
      modified = true;
    }

    if (modified) {
      // Save values in local storage as defaults for next time.
      localStorage.ArrowWidgetDefaults = JSON.stringify({
        Color: hexcolor,
        Width: width});
      this.Modified();
      this.Arrow.UpdateBuffers(this.Layer.AnnotationView);
    }
  };

  SAM.ArrowWidget = ArrowWidget;
})();


(function () {
  'use strict';

  function Circle () {
    SAM.Shape.call(this);
    this.Radius = 10; // Radius in pixels
    this.Origin = [10000, 10000]; // Center in world coordinates.
    this.OutlineColor = new Array(3);
    this.OutlineColor.fill(0);
    this.PointBuffer = [];
  }
  Circle.prototype = new SAM.Shape();

    // I know javascript does not have desctuctors.
    // I was thinking of calling this explicilty to hasten freeing of resources.
  Circle.prototype.destructor = function () {
    // Get rid of the buffers?
  };

  Circle.prototype.UpdateBuffers = function (view) {
    this.PointBuffer = [];
    var cellData = [];
    var lineCellData = [];
    var i;
    var theta;
    var numEdges = Math.floor(this.Radius / 2) + 10;
        // NOTE: numEdges logic will not work in world coordinates.
        // Limit numEdges to 180 to mitigate this issue.
    if (numEdges > 50 || !this.FixedSize) {
      numEdges = 50;
    }

    this.Matrix = mat4.create();
    mat4.identity(this.Matrix);

    if (view.gl) {
      if (this.LineWidth === 0) {
        for (i = 0; i <= numEdges; ++i) {
          theta = i * 2 * 3.14159265359 / numEdges;
          this.PointBuffer.push(this.Radius * Math.cos(theta));
          this.PointBuffer.push(this.Radius * Math.sin(theta));
          this.PointBuffer.push(0.0);
        }

        // Now create the triangles
        // It would be nice to have a center point,
        // but this would mess up the outline.
        for (i = 2; i < numEdges; ++i) {
          cellData.push(0);
          cellData.push(i - 1);
          cellData.push(i);
        }

        this.VertexPositionBuffer = view.gl.createBuffer();
        view.gl.bindBuffer(view.gl.ARRAY_BUFFER, this.VertexPositionBuffer);
        view.gl.bufferData(view.gl.ARRAY_BUFFER, new Float32Array(this.PointBuffer), view.gl.STATIC_DRAW);
        this.VertexPositionBuffer.itemSize = 3;
        this.VertexPositionBuffer.numItems = this.PointBuffer.length / 3;

        this.CellBuffer = view.gl.createBuffer();
        view.gl.bindBuffer(view.gl.ELEMENT_ARRAY_BUFFER, this.CellBuffer);
        view.gl.bufferData(view.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cellData), view.gl.STATIC_DRAW);
        this.CellBuffer.itemSize = 1;
        this.CellBuffer.numItems = cellData.length;
      } else {
        // var minRad = this.Radius - (this.LineWidth/2.0);
        // var maxRad = this.Radius + (this.LineWidth/2.0);
        var minRad = this.Radius;
        var maxRad = this.Radius + this.LineWidth;
        for (i = 0; i <= numEdges; ++i) {
          theta = i * 2 * 3.14159265359 / numEdges;
          this.PointBuffer.push(minRad * Math.cos(theta));
          this.PointBuffer.push(minRad * Math.sin(theta));
          this.PointBuffer.push(0.0);
          this.PointBuffer.push(maxRad * Math.cos(theta));
          this.PointBuffer.push(maxRad * Math.sin(theta));
          this.PointBuffer.push(0.0);
        }
        this.VertexPositionBuffer = view.gl.createBuffer();
        view.gl.bindBuffer(view.gl.ARRAY_BUFFER, this.VertexPositionBuffer);
        view.gl.bufferData(view.gl.ARRAY_BUFFER, new Float32Array(this.PointBuffer), view.gl.STATIC_DRAW);
        this.VertexPositionBuffer.itemSize = 3;
        this.VertexPositionBuffer.numItems = this.PointBuffer.length / 3;

        // Now create the fill triangles
        // It would be nice to have a center point,
        // but this would mess up the outline.
        for (i = 2; i < numEdges; ++i) {
          cellData.push(0);
          cellData.push((i - 1) * 2);
          cellData.push(i * 2);
        }
        this.CellBuffer = view.gl.createBuffer();
        view.gl.bindBuffer(view.gl.ELEMENT_ARRAY_BUFFER, this.CellBuffer);
        view.gl.bufferData(view.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cellData), view.gl.STATIC_DRAW);
        this.CellBuffer.itemSize = 1;
        this.CellBuffer.numItems = cellData.length;

        // Now the thick line
        for (i = 0; i < numEdges; ++i) {
          lineCellData.push(0 + i * 2);
          lineCellData.push(1 + i * 2);
          lineCellData.push(2 + i * 2);
          lineCellData.push(1 + i * 2);
          lineCellData.push(3 + i * 2);
          lineCellData.push(2 + i * 2);
        }
        this.LineCellBuffer = view.gl.createBuffer();
        view.gl.bindBuffer(view.gl.ELEMENT_ARRAY_BUFFER, this.LineCellBuffer);
        view.gl.bufferData(view.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(lineCellData), view.gl.STATIC_DRAW);
        this.LineCellBuffer.itemSize = 1;
        this.LineCellBuffer.numItems = lineCellData.length;
      }
    } else {
      for (i = 0; i <= numEdges; ++i) {
        theta = i * 2 * 3.14159265359 / numEdges;
        this.PointBuffer.push(this.Radius * Math.cos(theta));
        this.PointBuffer.push(this.Radius * Math.sin(theta));
        this.PointBuffer.push(0.0);
      }
    }
  };

  SAM.Circle = Circle;
})();


(function () {
  'use strict';

  // ==============================================================================
  // Mouse down defined the center.
  // Drag defines the radius.

  // The circle has just been created and is following the mouse.
  // I can probably merge this state with drag. (mouse up vs down though)
  var NEW_HIDDEN = 0;
  var NEW_DRAG = 1;
  var NEW_DRAG_RADIUS = 2;
  var DRAG = 3; // The whole circle is being dragged.
  var DRAG_RADIUS = 4;
  var DRAG_KEYPOINT = 5;
  var INACTIVE = 6; // Not responding to events at all
  var ACTIVE = 7; // Receive events.  Looking for a hover.
  var HOVER = 8; // Mouse is over the widget.
  var DIALOG = 9; // Properties dialog is up

  var CIRCUMFERENCE = 1;
  var INSIDE = 2;
  var CENTER = 3;

  var DEFAULT_LABEL;

  function CircleWidget (layer) {
    this.Layer = layer;

    // This is to save fields from loaded elements that we ignore.
    // That way we include them when we serialize.
    this.Element = {};

    // Get default properties.
    if (localStorage.CircleWidgetDefaults) {
      this.Defaults = JSON.parse(localStorage.CircleWidgetDefaults);
    } else {
      this.Defaults = {};
    }

    // This method gets called if anything is added, deleted or moved.
    this.ModifiedCallback = undefined;
    // This method gets called if the active state of this widget turns on or off.
    // This is used to turn off the pencil button in the Panel.
    this.StateChangeCallback = undefined;
    // This is used by the annotationPanel to transfer draing mode to a new selected widget.
    this.SelectedCallback = undefined;

    // Keep track of annotation created by students without edit
    // permission.
    this.Type = 'circle';

    this.Tolerance = 3.0;
    if (SAM.MOBILE_DEVICE) {
      this.Tolerance = 15.0;
    }

    this.Visibility = true;
    if (layer === null) {
      return;
    }

    // Lets save the zoom level (sort of).
    // Load will overwrite this for existing annotations.
    // This will allow us to expand annotations into notes.
    this.CreationCamera = layer.GetCamera().Serialize();

    var cam = layer.GetCamera();
    var viewport = layer.GetViewport();
    this.Circle = new SAM.Circle();
    this.Circle.Origin = new Array(2);
    this.Circle.Origin.fill(0);
    this.Circle.OutlineColor = new Array(3);
    this.Circle.SetOutlineColor('#00ff00');
    this.Circle.Radius = 50 * cam.Height / viewport[3];
    this.Circle.LineWidth = 5.0 * cam.Height / viewport[3];

    if (this.Defaults) {
      if (this.Defaults.Color) {
        this.Circle.OutlineColor = SAM.ConvertColor(this.Defaults.Color);
      }
      if (this.Defaults.LineWidth !== undefined) {
        // Only use the default if it is reasonable.
        if (this.Defaults.LineWidth === 0) {
          this.Circle.LineWidth = this.Defaults.LineWidth;
        } else {
          var tmp = this.Circle.LineWidth / this.Defaults.LineWidth;
          if (Math.max(tmp, 1 / tmp) < 10) {
            this.Circle.LineWidth = this.Defaults.LineWidth;
          }
        }
      }
      if (this.Defaults.Radius) {
        // Only use the default if it is reasonable.
        tmp = this.Circle.Radius / this.Defaults.Radius;
        if (Math.max(tmp, 1 / tmp) < 10) {
          this.Circle.Radius = this.Defaults.Radius;
        }
      }
    }

    this.Circle.FixedSize = false;

    // Note: If the user clicks before the mouse is in the
    // canvas, this will behave odd.

    // Cross hairs is to show an active center.
    this.Cross = new SAM.Circle();
    this.Cross.SetFillColor([1, 1, 0]);
    this.Cross.SetOutlineColor([0.0, 0.0, 0.0]);
    this.Cross.Radius = 5;
    this.Cross.LineWidth = 1;
    this.Cross.PositionCoordinateSystem = 1;

    if (DEFAULT_LABEL) {
      var text = new SAM.Text();
      text.BackgroundFlag = false;
      text.String = DEFAULT_LABEL;
      text.Position = this.Circle.Origin;
      this.Circle.Children['label'] = text;
    }

    this.State = INACTIVE;
  }

  CircleWidget.prototype.SetModifiedCallback = function (callback) {
    this.ModifiedCallback = callback;
  };

  CircleWidget.prototype.SetSelectedCallback = function (callback) {
    this.SelectedCallback = callback;
  };

  // I am divorcing selected from active.
  CircleWidget.prototype.IsSelected = function () {
    return this.Circle && this.Circle.Selected;
  };

  // This callback gets called when ever the active state changes,
  // even if caused by an external call. This widget is passed as a argument.
  // This is used to turn off the pencil button in the Panel.
  CircleWidget.prototype.SetStateChangeCallback = function (callback) {
    this.StateChangeCallback = callback;
  };

  // Called when the state changes.
  CircleWidget.prototype.StateChanged = function () {
    if (this.StateChangeCallback) {
      this.StateChangeCallback(this);
    }
  };

  // Sets state to "NEW" (dragging without mouse pressed
  CircleWidget.prototype.SetStateToDrawing = function () {
    this.State = NEW_HIDDEN;
  };

  // Called when the state changes.
  CircleWidget.prototype.Modified = function () {
    this.SaveDefaults();
    if (this.ModifiedCallback) {
      (this.ModifiedCallback)(this);
    }
  };

  // Called when the state changes.
  CircleWidget.prototype.SelectionChanged = function () {
    if (this.SelectedCallback) {
      (this.SelectedCallback)(this);
    }
  };

  // Not used yet, but might be useful.
  CircleWidget.prototype.SetCreationCamera = function (cam) {
    // Lets save the zoom level (sort of).
    // Load will overwrite this for existing annotations.
    // This will allow us to expand annotations into notes.
    this.CreationCamera = cam.Serialize();
  };

  // Selects the widget if the text is fuly contained in the selection rectangle.
  CircleWidget.prototype.ApplySelect = function (selection) {
    if (!this.Circle) {
      return;
    }
    var radius = this.Circle.Radius;
    var cam = this.Layer.GetCamera();
    var p = cam.ConvertPointWorldToViewer(this.Circle.Origin[0], this.Circle.Origin[1]);

    if (selection.ViewerPointInSelection(p[0] - radius, p[1] - radius) &&
        selection.ViewerPointInSelection(p[0] - radius, p[1] + radius) &&
        selection.ViewerPointInSelection(p[0] + radius, p[1] - radius) &&
        selection.ViewerPointInSelection(p[0] + radius, p[1] + radius)) {
      this.Circle.SetSelected(true);

      return true;
    }
    this.Circle.SetSelected(false);
    return false;
  };

  CircleWidget.prototype.DeleteSelected = function () {
    return this.Circle.DeleteSelected();
  };

  CircleWidget.prototype.IsEmpty = function () {
    if (this.State === NEW_HIDDEN || this.State === NEW_DRAG) {
      return true;
    }
    return this.Circle.IsEmpty();
  };

  CircleWidget.prototype.GetActive = function () {
    return this.State !== INACTIVE;
  };

  CircleWidget.prototype.SetActive = function (flag) {
    if (flag === false && this.State === NEW_DRAG) {
      // User is in the middle of dragging a circle)
      this.Cancel();
      return;
    }
    if (flag && this.State === INACTIVE) {
      this.State = HOVER;
      // Probably not right, but the widget probably became active because it was selected,
      // and the mouse is over the circle.
      this.Layer.GetParent().css({'cursor': 'move'});
      this.StateChanged();
    }
    if (!flag && this.State !== INACTIVE) {
      this.State = INACTIVE;
      this.StateChanged();
    }
    // TODO: Fix: Single select must be setting the state to inactive without calling this method.
    // Cursor was not changing back.
    if (!flag) {
      this.Layer.GetParent().css({'cursor': ''});
    }
    this.Layer.EventuallyDraw();
  };

  // I am not sure if this is used.  We have multiple selected states.
  // Default to the whole widget selected.
  CircleWidget.prototype.SetSelected = function (flag) {
    this.Circle.SetSelected(flag);

    if (flag && this.SelectedCallback) {
      (this.SelectedCallback)(this);
    }
    if (!flag) {
      // We can be selected without being active, but we cannot be
      // active without being selected.
      this.SetActive(false);
    }
  };

  CircleWidget.prototype.InitPropertiesDialog = function (layer) {
    var self = this;

    this.Dialog = new SAM.Dialog(this.Layer.GetParent().parent());
    this.Dialog.SetApplyCallback(function () { self.DialogApplyCallback(); });
    // Customize dialog for a circle.
    this.Dialog.Title.text('Circle Properties');
    this.Dialog.Body.css({'margin': '1em 2em', 'height': '14em'});
    // Radius
    this.Dialog.RadiusDiv =
            $('<div>')
            .css({'height': '24px'})
            .appendTo(this.Dialog.Body)
            .addClass('sa-view-annotation-modal-div');
    this.Dialog.RadiusLabel =
            $('<div>')
            .appendTo(this.Dialog.RadiusDiv)
            .text('Radius:')
            .addClass('sa-view-annotation-modal-input-label');
    this.Dialog.RadiusInput =
            $('<input type="number">')
            .appendTo(this.Dialog.RadiusDiv)
            .val(10)
            .addClass('sa-view-annotation-modal-input');

    // Center
    this.Dialog.CenterDiv =
            $('<div>')
            .css({'height': '24px'})
            .appendTo(this.Dialog.Body)
            .addClass('sa-view-annotation-modal-div');
    this.Dialog.CenterLabel =
            $('<div>')
            .appendTo(this.Dialog.CenterDiv)
            .text('Center:')
            .addClass('sa-view-annotation-modal-input-label');
    this.Dialog.CenterXInput =
            $('<input type="number">')
            .appendTo(this.Dialog.CenterDiv)
            .css({'width': '30%'})
            .val(0)
            .addClass('sa-view-annotation-modal-input');
    this.Dialog.CenterYInput =
            $('<input type="number">')
            .appendTo(this.Dialog.CenterDiv)
            .css({'width': '30%'})
            .val(0)
            .addClass('sa-view-annotation-modal-input');

    // Color
    this.Dialog.ColorDiv =
            $('<div>')
            .css({'height': '24px'})
            .appendTo(this.Dialog.Body)
            .addClass('sa-view-annotation-modal-div');
    this.Dialog.ColorLabel =
            $('<div>')
            .appendTo(this.Dialog.ColorDiv)
            .text('Color:')
            .addClass('sa-view-annotation-modal-input-label');
    this.Dialog.ColorInput =
            $('<input type="color">')
            .appendTo(this.Dialog.ColorDiv)
            .val('#30ff00')
            .addClass('sa-view-annotation-modal-input');

    // Line Width
    this.Dialog.LineWidthDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .addClass('sa-view-annotation-modal-div');
    this.Dialog.LineWidthLabel =
            $('<div>')
            .appendTo(this.Dialog.LineWidthDiv)
            .text('Line Width:')
            .addClass('sa-view-annotation-modal-input-label');
    this.Dialog.LineWidthInput =
            $('<input type="number">')
            .appendTo(this.Dialog.LineWidthDiv)
            .addClass('sa-view-annotation-modal-input')
            .keypress(function (event) { return event.keyCode !== 13; });

    // Label
    this.Dialog.LabelDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .addClass('sa-view-annotation-modal-div');
    this.Dialog.LabelLabel =
            $('<div>')
            .appendTo(this.Dialog.LabelDiv)
            .text('Label:')
            .addClass('sa-view-annotation-modal-input-label');
    this.Dialog.LabelInput =
            $('<input type="text">')
            .appendTo(this.Dialog.LabelDiv)
            .addClass('sa-view-annotation-modal-input')
            .keypress(function (event) { return event.keyCode !== 13; });

    // Area
    this.Dialog.AreaDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .addClass('sa-view-annotation-modal-div');
    this.Dialog.AreaLabel =
            $('<div>')
            .appendTo(this.Dialog.AreaDiv)
            .text('Area:')
            .addClass('sa-view-annotation-modal-input-label');
    this.Dialog.Area =
            $('<div>')
            .appendTo(this.Dialog.AreaDiv)
            .addClass('sa-view-annotation-modal-input');
  };

  CircleWidget.prototype.ShowPropertiesDialog = function () {
    if (this.Dialog === undefined) {
      this.InitPropertiesDialog();
    }
    this.WidgetPropertiesToDialog();
    var self = this;
    this.Dialog.SetApplyCallback(function () { self.DialogApplyCallback(); });
    this.Dialog.SetCloseCallback(function () { self.DialogCloseCallback(); });
    this.Dialog.Show(true);
    this.State = DIALOG;
  };

  CircleWidget.prototype.DialogApplyCallback = function (layer) {
    // Transfer properties fromt he dialog GUI to the widget.
    this.DialogPropertiesToWidget();
    // View bindings kept the dialog text input from working.
    if (!this.Layer) {
      return;
    }
    this.SetActive(false);
    this.Layer.EventuallyDraw();
    this.SetActive(false);
  };

  CircleWidget.prototype.DialogCloseCallback = function () {
    this.SetActive(false);
    this.Layer.EventuallyDraw();
    this.SetActive(false);
  };

  // Fill the dialog values from the widget values.
  CircleWidget.prototype.WidgetPropertiesToDialog = function () {
    this.Dialog.RadiusInput.val(Math.round(this.Circle.Radius));
    this.Dialog.CenterXInput.val(Math.round(this.Circle.Origin[0]));
    this.Dialog.CenterYInput.val(Math.round(this.Circle.Origin[1]));
    this.Dialog.ColorInput.val(SAM.ConvertColorToHex(this.Circle.OutlineColor));
    this.Dialog.LineWidthInput.val((this.Circle.LineWidth).toFixed(2));
    var label = '';
    if (this.Circle.Children.label && this.Circle.Children.label.String) {
      label = this.Circle.Children['label'].String;
    }
    this.Dialog.LabelInput.val(label);

    var area = (2.0 * Math.PI * this.Circle.Radius * this.Circle.Radius) * 0.25 * 0.25;
    var areaString = '';
    if (this.Circle.FixedSize) {
      areaString += area.toFixed(2);
      areaString += ' pixels^2';
    } else {
      if (area > 1000000) {
        areaString += (area / 1000000).toFixed(2);
        areaString += ' mm^2';
      } else {
        areaString += area.toFixed(2);
        areaString += ' um^2';
      }
    }
    this.Dialog.Area.text(areaString);
  };

  // I am having the two shapes share an origin/position point array.
  // That way code that just modifies oring will automatically change label.
  CircleWidget.prototype.SetOrigin = function (xy) {
    this.Circle.Origin = xy;
    if ('label' in this.Circle.Children) {
      this.Circle.Children.label.Position = xy;
    }
  };

  // Copy the properties of the dialog into the widget
  CircleWidget.prototype.DialogPropertiesToWidget = function () {
    var modified = false;

    var radius = parseInt(this.Dialog.RadiusInput.val());
    if (radius !== this.Circle.Radius) {
      this.Circle.Radius = radius;
      modified = true;
    }

    var cx = parseInt(this.Dialog.CenterXInput.val());
    var cy = parseInt(this.Dialog.CenterYInput.val());
    if (cx !== this.Circle.Origin[0] || cy !== this.Circle.Origin[1]) {
      this.Circle.Origin[0] = cx;
      this.Circle.Origin[1] = cy;
      modified = true;
    }

    // Get the color
    var hexcolor = SAM.ConvertColorToHex(this.Dialog.ColorInput.val());
    if (hexcolor !== this.Circle.OutlineColor) {
      modified = true;
      this.Circle.SetOutlineColor(hexcolor);
      modified = true;
    }

    var lineWidth = parseFloat(this.Dialog.LineWidthInput.val());
    if (lineWidth !== this.Circle.LineWidth) {
      this.Circle.LineWidth = lineWidth;
      modified = true;
    }

    var label = this.Dialog.LabelInput.val();
    label = label.trim();
    if (label === '') {
      DEFAULT_LABEL = undefined;
      delete this.Circle.Children.label;
    } else {
      if (!this.Circle.Children.label) {
        var text = new SAM.Text();
        text.BackgroundFlag = false;
        text.String = label;
        text.Position = this.Circle.Origin;
        this.Circle.Children['label'] = text;
        DEFAULT_LABEL = label;
      }
      this.Circle.Children.label.String = label;
      modified = true;
    }

    if (modified) {
      this.Modified();
      this.Circle.UpdateBuffers(this.Layer.AnnotationView);
    }
  };

  CircleWidget.prototype.SaveDefaults = function () {
    // Save values in local storage as defaults for next time.
    this.Defaults.Color = this.Circle.GetOutlineColor();
    this.Defaults.LineWidth = this.Circle.LineWidth;
    this.Defaults.Radius = this.Circle.Radius;

    localStorage.CircleWidgetDefaults = JSON.stringify(this.Defaults);
  };

  CircleWidget.prototype.Draw = function () {
    if (this.Visibility && this.State !== NEW_HIDDEN && this.Circle) {
      var view = this.Layer.GetView();
      this.Circle.Draw(view);
      if (this.State === ACTIVE || this.State === HOVER) {
        var origin = this.Circle.Origin;
        var cam = this.Layer.GetCamera();
        var pt = cam.ConvertPointWorldToViewer(origin[0], origin[1]);
        this.Cross.Origin = [pt[0], pt[1]];
        this.Cross.Draw(view);
      }
    }
  };

  CircleWidget.prototype.PasteCallback = function (layer, data, mouseWorldPt) {
    this.Load(data);
    // Place the widget over the mouse.
    // This would be better as an argument.
    this.SetOrigin([mouseWorldPt[0], mouseWorldPt[1]]);
    // TODO: Just have the caller draw.
    layer.EventuallyDraw();
  };

  CircleWidget.prototype.Serialize = function () {
    if (this.Circle === undefined) { return null; }
    var element = this.Element;
    element.type = 'circle';
    element.center = [this.Circle.Origin[0], this.Circle.Origin[1], 0];
    element.lineColor = SAM.ConvertColorToHex(this.Circle.OutlineColor);
    element.radius = this.Circle.Radius;
    element.lineWidth = this.Circle.LineWidth;
    // element.creation_camera = this.CreationCamera;

    if (this.Circle.Children.label && this.Circle.Children.label.String) {
      element.label = {'value': this.Circle.Children.label.String};
    }
    // Serialize the keypoints
    var childKey, child;
    for (childKey in this.Circle.Children) {
      child = this.Circle.Children[childKey];
      if (typeof (child) === 'object' && 'Radius' in child) {
        if (!('user' in element)) {
          element['user'] = {};
        }
        var user = element['user'];
        if (!('keypoints' in user)) {
          user['keypoints'] = [];
        }
        var keypoints = user['keypoints'];
        // This is an inefficient schema.  I have to search an array.
        // This will not add a new keypoint.
        for (var i = 0; i < keypoints.length; ++i) {
          var kp = keypoints[i];
          if (kp.category === childKey) {
            kp.xy = child.Origin;
          }
        }
      }
    }

    return element;
  };

  // Load a widget from a json object (origin MongoDB).
  // Layer is needed to update the bufferes.
  // TODO: delayed upldating bufferes until the first draw
  CircleWidget.prototype.Load = function (element) {
    this.Element = element;
    this.Circle.Origin[0] = Math.round(parseFloat(element.center[0]));
    this.Circle.Origin[1] = Math.round(parseFloat(element.center[1]));
    if (element['lineColor'] !== undefined) {
      this.Circle.OutlineColor = SAM.ConvertColor(element.lineColor);
    } else {
      this.Circle.OutlineColor[0] = 0.0;
      this.Circle.OutlineColor[1] = 1.0;
      this.Circle.OutlineColor[2] = 1.0;
    }
    this.Circle.Radius = Math.round(parseFloat(element.radius));
    this.Circle.LineWidth = 0;
    if (element.lineWidth) {
      this.Circle.LineWidth = parseFloat(element.lineWidth);
    }
    this.Circle.FixedSize = false;
    this.Circle.UpdateBuffers(this.Layer.AnnotationView);

    // How zoomed in was the view when the annotation was created.
    if (element.creation_camera !== undefined) {
      this.CreationCamera = element.CreationCamera;
    }

    if ('label' in element) {
      var str = element['label']['value'];
      var text = new SAM.Text();
      text.BackgroundFlag = false;
      text.String = str;
      text.Position = this.Circle.Origin;
      this.Circle.Children['label'] = text;
    }

    var circle, kp, idx;
    var keypoints;
    if ('user' in element) {
      var user = element['user'];
      if ('keypoints' in user) {
        keypoints = user['keypoints'];
        for (idx = 0; idx < keypoints.length; ++idx) {
          kp = keypoints[idx];
          circle = new SAM.Circle();
          if (kp['category'] === 'nose') {
            circle.SetFillColor([0.0, 1.0, 0]);
          } else if (kp['category'] === 'tail') {
            circle.SetFillColor([1.0, 0.0, 0]);
          } else if (kp['category'] === 'left_wingtip') {
            circle.SetFillColor([1.0, 0.0, 1.0]);
          } else if (kp['category'] === 'right_wingtip') {
            circle.SetFillColor([0.0, 1.0, 1.0]);
          } else {
            circle.SetFillColor([0.8, 0.8, 1]);
          }
          circle.SetOutlineColor([0.0, 0.0, 0.0]);
          circle.Radius = 2;
          circle.LineWidth = 1;
          circle.Origin = kp['xy'];
          this.Circle.Children[kp['category']] = circle;
        }
      } else if ('network_keypoints' in user) {
        keypoints = user['network_keypoints'];
        for (idx = 0; idx < keypoints.length; ++idx) {
          kp = keypoints[idx];
          circle = new SAM.Circle();
          if (kp['keypoint_category'] === 'nose') {
            circle.SetFillColor([0.5, 1.0, 0.5]);
          } else if (kp['keypoint_category'] === 'tail') {
            circle.SetFillColor([1.0, 0.5, 0.5]);
          } else {
            circle.SetFillColor([0.8, 0.8, 1]);
          }
          circle.SetOutlineColor([0.0, 0.0, 0.0]);
          circle.Radius = 2;
          circle.LineWidth = 1;
          circle.Origin = kp['xy'];
          this.Circle.Children[kp['keypoint_category']] = circle;
        }
      }
    }
  };

  CircleWidget.prototype.Cancel = function () {
    if (this.State === NEW_DRAG) {
      this.State = INACTIVE;
      // Circle has not been placed. Delete the circle.
      this.Circle.Selected = true;
      this.Layer.DeleteSelected();
    }
    this.SetActive(false);
  };

  CircleWidget.prototype.SetVisibility = function (vis) {
    this.Visibility = vis;
    this.Layer.EventuallyDraw();
  };

  CircleWidget.prototype.HandleKeyDown = function (layer) {
    if (layer.Event.keyCode === 86) {
      this.Visibility = !this.Visibility;
      layer.EventuallyDraw();
      return true;
    }

    if (this.State === INACTIVE) {
      return true;
    }

    // The dialog consumes all key events.
    if (this.State === DIALOG) {
      return false;
    }

    // Escape key
    if (event.keyCode === 27) {
      this.Cancel();
      return false;
    }

    // Copy
    if (event.keyCode === 67 && event.ctrlKey) {
      // control-c for copy
      // The extra identifier is not needed for widgets, but will be
      // needed if we have some other object on the clipboard.
      var clip = {Type: 'CircleWidget', Data: this.Serialize()};
      localStorage.ClipBoard = JSON.stringify(clip);
      return false;
    }

    return true;
  };

  CircleWidget.prototype.HandleMouseDown = function (layer) {
    if (this.State !== HOVER && this.State !== NEW_DRAG) {
      return true;
    }

    var event = layer.Event;
    if (event.which !== 1) {
      return false;
    }
    var cam = layer.GetCamera();
    if (this.State === NEW_DRAG) {
      // We need the viewer position of the circle center to drag radius.
      this.OriginViewer =
                cam.ConvertPointWorldToViewer(this.Circle.Origin[0],
                                              this.Circle.Origin[1]);
      this.State = NEW_DRAG_RADIUS;
    }
    if (this.State === HOVER) {
      var circlePart = this.MouseOverWhichPart(layer.Event);
      // Determine behavior from active radius.
      if (typeof (circlePart) === 'object') {
        this.State = DRAG_KEYPOINT;
        this.KeyPoint = circlePart;
      } else if (circlePart === CENTER) {
        this.State = DRAG;
      } else if (circlePart === CIRCUMFERENCE) {
        this.OriginViewer =
                    cam.ConvertPointWorldToViewer(this.Circle.Origin[0],
                                                  this.Circle.Origin[1]);
        this.State = DRAG_RADIUS;
      }
    }
    return false;
  };

  // returns false when it is finished doing its work.
  CircleWidget.prototype.HandleMouseUp = function (layer) {
    if (this.State === INACTIVE) {
      return true;
    }

    if (this.State === NEW_DRAG_RADIUS) {
      this.SetActive(false);
      this.Modified();
      this.Layer.EventuallyDraw();
    }

    if (this.State === DRAG || this.State === DRAG_RADIUS ||
        this.State === DRAG_KEYPOINT) {
      this.State = HOVER;
      this.Modified();
      this.Layer.EventuallyDraw();
      this.KeyPoint = undefined;
    }

    var event = layer.Event;
    if (this.State === HOVER && event.which === 3) {
      // Right mouse was pressed.
      // Pop up the properties dialog.
      // Which one should we popup?
      // Add a ShowProperties method to the widget. (With the magic of javascript).
      this.ShowPropertiesDialog();
    }

    return false;
  };

  // returns false when it is finished doing its work.
  CircleWidget.prototype.HandleMouseClick = function () {
    if (this.State === INACTIVE) {
      return true;
    }
    if (this.State === NEW_DRAG || this.State === NEW_DRAG_RADIUS) {
      this.SetActive(false);
      this.Modified();
      // A click to place bring up another circle for automatic / fast annotation.
      var widget = new SAM.CircleWidget(this.Layer);
      this.Layer.AddWidget(widget);
      widget.SetCreationCamera(this.Layer.GetCamera());
      widget.SetStateToDrawing();

      return false;
    }
    return true;
  };

  CircleWidget.prototype.HandleMouseMove = function (layer) {
    if (this.State === INACTIVE) {
      return true;
    }

    var event = layer.Event;
    var x = this.Layer.MouseX;
    var y = this.Layer.MouseY;

    // Hover logic.
    if (this.State === ACTIVE || this.State === HOVER) {
      var circlePart = this.MouseOverWhichPart(layer.Event);
      if (this.Circle.FillColor !== undefined && circlePart === INSIDE) {
        // Mouse if over a child keypoint.
        this.State = HOVER;
        this.Layer.GetParent().css({'cursor': 'move'});
        return false;
      }
      if (this.Circle.FillColor !== undefined && circlePart === INSIDE) {
        this.State = HOVER;
        this.Layer.GetParent().css({'cursor': 'move'});
        return false;
      }
      if (circlePart === CIRCUMFERENCE || circlePart === CENTER) {
        this.State = HOVER;
        this.Layer.GetParent().css({'cursor': 'move'});
        return false;
      }
      if (typeof (circlePart) === 'object' && 'Radius' in circlePart) {
        this.State = HOVER;
        this.Layer.GetParent().css({'cursor': 'move'});
        return false;
      }
      this.State = ACTIVE;
      this.Layer.GetParent().css({'cursor': ''});
      return true;
    }

    // Hack to fix weird state where mouse up is not called.
    if (event.which === 0 &&
        (this.State === NEW_DRAG_RADIUS || this.State === DRAG_RADIUS ||
         this.State === DRAG || this.State === DRAG_KEYPOINT)) {
      return this.HandleMouseUp(layer);
    }

    if (event.which === 0 && this.State === ACTIVE) {
      this.SetActive(this.CheckActive(event));
      return false;
    }

    var cam = layer.GetCamera();
    if (this.State === NEW_HIDDEN) {
      this.State = NEW_DRAG;
    }
    if (this.State === NEW_DRAG || this.State === DRAG) {
      if (SA && SA.notesWidget) { SA.notesWidget.MarkAsModified(); } // hack
      this.SetOrigin(cam.ConvertPointViewerToWorld(x, y));
      layer.EventuallyDraw();
    }

    if (this.State === DRAG_RADIUS || this.State === NEW_DRAG_RADIUS) {
      var viewport = layer.GetViewport();
      cam = layer.GetCamera();
      var dx = x - this.OriginViewer[0];
      var dy = y - this.OriginViewer[1];
      // Change units from pixels to world.
      this.Circle.Radius = Math.sqrt(dx * dx + dy * dy) * cam.Height / viewport[3];
      this.Circle.UpdateBuffers(layer.AnnotationView);
      if (SA && SA.notesWidget) { SA.notesWidget.MarkAsModified(); } // hack
      layer.EventuallyDraw();
    }

    if (this.State === DRAG_KEYPOINT) {
      if (SA && SA.notesWidget) { SA.notesWidget.MarkAsModified(); } // hack
      this.KeyPoint.Origin = cam.ConvertPointViewerToWorld(x, y);
      layer.EventuallyDraw();
    }

    if (this.State === INACTIVE) {
      this.CheckActive(event);
    }
    return false;
  };

  CircleWidget.prototype.HandleTouchPan = function (layer) {
    if (this.State === INACTIVE) {
      return true;
    }

    var event = layer.Event;
    var cam = layer.GetCamera();
    // TODO: Last mouse should net be in layer.
    var w0 = cam.ConvertPointViewerToWorld(layer.LastMouseX,
                                           layer.LastMouseY);
    var w1 = cam.ConvertPointViewerToWorld(event.offsetX, event.offsetY);

    // This is the translation.
    var dx = w1[0] - w0[0];
    var dy = w1[1] - w0[1];

    this.Circle.Origin[0] += dx;
    this.Circle.Origin[1] += dy;
    layer.EventuallyDraw();
    return false;
  };

  CircleWidget.prototype.HandleTouchPinch = function (layer) {
    if (this.State === INACTIVE) {
      return true;
    }

    this.Circle.Radius *= layer.PinchScale;
    this.Circle.UpdateBuffers(layer.AnnotationView);
    if (SA && SA.notesWidget) { SA.notesWidget.MarkAsModified(); } // hack
    layer.EventuallyDraw();
    return false;
  };

  CircleWidget.prototype.HandleTouchEnd = function (layer) {
    if (this.State === INACTIVE) {
      return true;
    }

    this.SetActive(false);
    return false;
  };

  // Returns the selected stroke or undefined.
  CircleWidget.prototype.HandleSelect = function () {
    if (this.State === NEW_HIDDEN || this.State === NEW_DRAG || this.State === DIALOG) {
      return false;
    }

    var circlePart = this.MouseOverWhichPart(this.Layer.Event);

    if (this.Circle.FillColor !== undefined && circlePart === INSIDE) {
      this.Circle.SetSelectede(true);
      return this;
    }
    if (circlePart === CIRCUMFERENCE || circlePart === CENTER) {
      this.Circle.SetSelected(true);
      return this;
    }
    // Handle clicking on the keypoints.
    if (typeof (circlePart) === 'object') {
      this.Circle.SetSelected(true);
      return this;
    }

    this.Circle.SetSelected(false);
    // hack to fix bug where circle remained active when no longer selected.
    this.SetActive(false);
    return false;
  };

  // Returns true or false.  Point is in viewer coordinates.
  CircleWidget.prototype.MouseOverWhichPart = function (event) {
    var pt = [event.offsetX, event.offsetY];
    var c, r, child, childKey, cam;
    var d, dx, dy;

    // Check the children (keypoints).
    for (childKey in this.Circle.Children) {
      child = this.Circle.Children[childKey];
      if (typeof (child) === 'object' && 'Radius' in child) {
        // Assume the child is a circle.
        c = child.Origin;
        r = child.Radius;
        if (!this.FixedSize) {
          cam = this.Layer.GetCamera();
          c = cam.ConvertPointWorldToViewer(c[0], c[1]);
          r = cam.ConvertScaleWorldToViewer(r);
        }
        dx = pt[0] - c[0];
        dy = pt[1] - c[1];
        d = Math.sqrt((dx * dx) + (dy * dy));
        if (Math.abs(d) < r + this.Tolerance) {
          return child;
        }
      }
    }

    c = this.Circle.Origin;
    r = this.Circle.Radius;
    var lineWidth = this.Circle.LineWidth;
    // Do the comparison in view coordinates.
    if (!this.FixedSize) {
      cam = this.Layer.GetCamera();
      c = cam.ConvertPointWorldToViewer(c[0], c[1]);
      r = cam.ConvertScaleWorldToViewer(r);
      lineWidth = cam.ConvertScaleWorldToViewer(lineWidth);
    }

    dx = pt[0] - c[0];
    dy = pt[1] - c[1];
    d = Math.sqrt(dx * dx + dy * dy);

    if (Math.abs(d - r) < this.Tolerance + lineWidth) {
      return CIRCUMFERENCE;
    }
    if (d < (2 * this.Tolerance + lineWidth)) {
      return CENTER;
    }
    if (d < r) {
      return INSIDE;
    }
    return 0;
  };

  SAM.CircleWidget = CircleWidget;
})();

// ==============================================================================
// Experment to manage multiple girder annotations in a single layer.

(function () {
  'use strict';

  function GroupWidget (viewer, newFlag) {
    if (viewer === null) {
      return;
    }
    this.Viewer = viewer;
    this.Viewer.AddWidget(this);
    this.Widgets = [];
    this.Active = false;
  }

  GroupWidget.prototype.Draw = function (view) {
    for (var i = 0; i < this.Widgets.length; ++i) {
      this.Widgets[i].Draw(view);
    }
  };

  GroupWidget.prototype.RemoveFromViewer = function () {
    if (this.Viewer) {
      this.Viewer.RemoveWidget(this);
    }
  };

  GroupWidget.prototype.HandleKeyPress = function (keyCode, shift) {
    for (var i = 0; i < this.Widgets.length; ++i) {
      var child = this.Widgets[i];
      if (child.HandleKeyPress) {
        if (!child.HandleKeyPress(keyCode, shift)) {
          return false;
        }
      }
    }
    return true;
  };

  GroupWidget.prototype.HandleMouseDown = function (event) {
    if (event.which !== 1) {
      return;
    }
    for (var i = 0; i < this.Widgets.length; ++i) {
      var child = this.Widgets[i];
      if (child.HandleMouseDown) {
        if (!child.HandleMouseDown(event)) {
          return false;
        }
      }
    }
    return true;
  };

  // returns false when it is finished doing its work.
  GroupWidget.prototype.HandleMouseUp = function (event) {
    for (var i = 0; i < this.Widgets.length; ++i) {
      var child = this.Widgets[i];
      if (child.HandleMouseDown) {
        child.HandleMouseUp(event);
      }
      return true;
    }
  };

  GroupWidget.prototype.HandleMouseMove = function (event) {
    for (var i = 0; i < this.Widgets.length; ++i) {
      var child = this.Widgets[i];
      if (child.HandleMouseMove) {
        if (!child.HandleMouseMove(event)) {
          return false;
        }
      }
    }
    return true;
  };

  GroupWidget.prototype.CheckActive = function (event) {
    for (var i = 0; i < this.Widgets.length; ++i) {
      var child = this.Widgets[i];
      if (child.CHeckActive) {
        if (child.CheckActive(event)) {
          this.Active = true;
          return true;
        }
      }
      this.Active = false;
      return false;
    }
  };

  // Multiple active states.  Active state is a bit confusing.
  GroupWidget.prototype.GetActive = function () {
    return this.Active;
  };

  // Setting to active always puts state into "active".
  // It can move to other states and stay active.
  GroupWidget.prototype.SetActive = function (flag) {
    alert('GroupWidget.SetActive not handled.');
  };

  SAM.GroupWidget = GroupWidget;
})();

// ==============================================================================
// Display a samller mask image ontop of a large image.
// Mask image will be an additional file in the image item.
// Not sure how to store the image in the annotation schema.

(function () {
  'use strict';

  // The cross has just been created and is following the mouse.
  // I can probably merge  this state with drag. (mouse up vs down though)
  var IMAGE_WIDGET_DRAG = 1; // The cross is being dragged.
  var IMAGE_WIDGET_WAITING = 3; // The normal (resting) state.
  var IMAGE_WIDGET_ACTIVE = 4; // Mouse is over the widget and it is receiving events.

  function ImageWidget (viewer, newFlag) {
    if (viewer === null) {
      return;
    }
    this.Viewer = viewer;
    this.Shape = new SAM.ImageAnnotation();
    this.Viewer.AddWidget(this);
    this.Viewer.AddShape(this.Shape);

    // New flag => widget is created in drag state.
    if (newFlag) {
      this.State = IMAGE_WIDGET_DRAG;
      this.Viewer.ActivateWidget(this);
      return;
    }

    this.State = IMAGE_WIDGET_WAITING;
  }

  ImageWidget.prototype.Draw = function (view) {
    this.Shape.Draw(view);
  };

  ImageWidget.prototype.RemoveFromViewer = function () {
    if (this.Viewer) {
      this.Viewer.RemoveWidget(this);
    }
  };

  ImageWidget.prototype.HandleKeyPress = function (keyCode, shift) {
    return false;
  };

  ImageWidget.prototype.HandleMouseDown = function (event) {
    if (event.which !== 1) {
      return;
    }
    if (this.State === IMAGE_WIDGET_DRAG) {
      // We need the viewer position of the IMAGE center to drag radius.
      this.OriginViewer = this.Viewer.ConvertPointWorldToViewer(this.Shape.Origin[0], this.Shape.Origin[1]);
      this.State = IMAGE_WIDGET_WAITING;
    }
    if (this.State === IMAGE_WIDGET_ACTIVE) {
      this.State = IMAGE_WIDGET_DRAG;
    }
  };

  // returns false when it is finished doing its work.
  ImageWidget.prototype.HandleMouseUp = function (event) {
    if (this.State === IMAGE_WIDGET_ACTIVE && event.which === 3) {
      // Right mouse was pressed.
      // Pop up the properties dialog.
      // this.State = IMAGE_WIDGET_PROPERTIES_DIALOG;
      // this.ShowPropertiesDialog();
    } else if (this.State === IMAGE_WIDGET_DRAG) {
      this.SetActive(false);
    }
  };

  ImageWidget.prototype.HandleMouseMove = function (event) {
    var x = this.Viewer.MouseX;
    var y = this.Viewer.MouseY;

    if (this.Viewer.MouseDown === false && this.State === IMAGE_WIDGET_ACTIVE) {
      this.CheckActive(event);
      return;
    }

    if (this.State === IMAGE_WIDGET_DRAG) {
      var tmp = this.Viewer.ConvertPointViewerToWorld(x, y);
      // Trying to preserve pointer so I do not need to update correlation points.
      this.Shape.Origin[0] = tmp[0];
      this.Shape.Origin[1] = tmp[1];
      this.Viewer.EventuallyRender();
    }

    if (this.State === IMAGE_WIDGET_WAITING) {
      this.CheckActive(event);
    }
  };

  ImageWidget.prototype.CheckActive = function (event) {
    // change dx and dy to vector from center of IMAGE.
    if (this.FixedSize) {
      alert('Fixed size not implemented');
      return;
    }

    var dx = event.worldX - this.Shape.Origin[0];
    var dy = event.worldY - this.Shape.Origin[1];

    // We need to scale to pixels
    var cam = this.Viewer.GetCamera();
    var viewport = this.Viewer.GetViewport();
    var k = viewport[3] / cam.Height;
    dx = dx * k;
    dy = dy * k;

    var d = Math.sqrt(dx * dx + dy * dy);
    var active = false;
    if (d < 3.0) {
      active = true;
    }

    this.SetActive(active);
    return active;
  };

  // Multiple active states.  Active state is a bit confusing.
  ImageWidget.prototype.GetActive = function () {
    if (this.State === IMAGE_WIDGET_WAITING) {
      return false;
    }
    return true;
  };

  // Setting to active always puts state into "active".
  // It can move to other states and stay active.
  ImageWidget.prototype.SetActive = function (flag) {
    if (flag === this.GetActive()) {
      return;
    }

    if (flag) {
      this.State = IMAGE_WIDGET_ACTIVE;
      this.Shape.Active = true;
      this.Viewer.ActivateWidget(this);
      this.Viewer.EventuallyRender();
    } else {
      this.State = IMAGE_WIDGET_WAITING;
      this.Shape.Active = false;
      this.Viewer.DeactivateWidget(this);
      this.Viewer.EventuallyRender();
    }
  };

  SAM.ImageWidget = ImageWidget;
})();

// Draw an image as an annotation object.  This simple drawing object
// is like a shape, but I am not subclassing shape because shape
// is about drawing vector graphics.

// We only support rendering in slide coordinate system for now.

(function () {
  'use strict';

  function ImageAnnotation () {
    this.Visibility = true;

        // Slide position of the upper left image corner.
    this.Origin = [0, 0];
    this.Image = undefined;

    this.Height = 5000;
  }

  ImageAnnotation.prototype.destructor = function () {
        // Get rid of the image.
  };

    // View (main view).
  ImageAnnotation.prototype.Draw = function (view) {
    if (!this.Visibility || !this.Image) {
      return;
    }

    var context = view.Context2d;
    context.save();
        // Identity (screen coordinates).
    context.setTransform(1, 0, 0, 1, 0, 0);
        // Change canvas coordinates to View (-1->1, -1->1).
    context.transform(0.5 * view.Viewport[2], 0.0,
                          0.0, -0.5 * view.Viewport[3],
                          0.5 * view.Viewport[2],
                          0.5 * view.Viewport[3]);

        // Change canvas coordinates to slide (world). (camera: slide to view).
    var m = view.Camera.GetWorldMatrix();
    var h = 1.0 / m[15];
    context.transform(m[0] * h, m[1] * h,
                      m[4] * h, m[5] * h,
                      m[12] * h, m[13] * h);

        // Change canvas to image coordinate system.
    var scale = this.Height / this.Image.height;
    context.transform(scale, 0,
                          0, scale,
                          this.Origin[0], this.Origin[1]);

    // context.drawImage(this.Image, 0, 0);
    context.fillRect(100, 100, 500, 300);

    context.restore();
  };

  SAM.ImageAnnotation = ImageAnnotation;
})();

// Since there is already a rectangle widget (for axis aligned rectangle)
// renaming this as Rect, other possible name is OrientedRectangle

(function () {
  'use strict';

  // Bits for WhichDrag (not the best way to encode this state).
  var DRAG_X0 = 1;
  var DRAG_X1 = 2;
  var DRAG_Y0 = 4;
  var DRAG_Y1 = 8;
  var SYMMETRIC = 16; // Lock the position of the center
  // var ASPECT = 32;    // Lock the aspect ratio
  // These two are only used alone.  However, they are drag features.
  var CENTER = 64;
  var ROTATE = 128;

  var NEW = 0;         // Newly created and waiting to be placed.
  var INACTIVE = 1;    // Not resposnsive tp mouse events
  var ACTIVE = 2;      // Mouse is receiving move events, but mouse is not over.
  var HOVER = 3;       // Mouse is over the widget and it is receiving events.
  var DRAG = 4;        // Mouse is down and dragging part of widget. Modified by WhichDrag.
  var DIALOG = 5;      // Properties dialog is up

  // enum for part identification.
  var CORNER = 0;
  var EDGE = 1;

  // Remember the last size to use for the next.
  var DEFAULT_WIDTH = -1;
  var DEFAULT_HEIGHT = -1;

  var DEFAULT_LABEL;

  function Rect () {
    SAM.Shape.call(this);

    this.Width = 50;
    this.Height = 50;
    this.Orientation = 0; // Angle with respect to x axis ?
    this.Origin = new Array(2); // Center in world coordinates.
    this.Origin.fill(10000);
    this.OutlineColor = new Array(3);
    this.OutlineColor.fill(0);
    this.PointBuffer = [];
  }

  Rect.prototype = new SAM.Shape();

  Rect.prototype.destructor = function () {
    // Get rid of the buffers?
  };

  // Rect.prototype.Draw = function(view) {
  //   if (this.Image) {
  //     view.Context2d.drawImage(this.Image, 0,0);
  //   }
  //   SAM.Shape.prototype.Draw.call(this, view);
  // }

  Rect.prototype.UpdateBuffers = function (view) {
    this.PointBuffer = [];

    this.Matrix = mat4.create();
    mat4.identity(this.Matrix);
    mat4.rotateZ(this.Matrix, this.Orientation / 180.0 * 3.14159);

    this.PointBuffer.push(1 * this.Width / 2.0);
    this.PointBuffer.push(1 * this.Height / 2.0);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(-1 * this.Width / 2.0);
    this.PointBuffer.push(1 * this.Height / 2.0);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(-1 * this.Width / 2.0);
    this.PointBuffer.push(-1 * this.Height / 2.0);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(1 * this.Width / 2.0);
    this.PointBuffer.push(-1 * this.Height / 2.0);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(1 * this.Width / 2.0);
    this.PointBuffer.push(1 * this.Height / 2.0);
    this.PointBuffer.push(0.0);
  };

  function RectWidget (layer) {
    if (layer === null) {
      return null;
    }
    this.Layer = layer;
    this.Type = 'rect';
    this.Visibility = true;
    // Keep track of annotation created by students without edit
    // permission.
    this.UserNoteFlag = !SA.Edit;

    // This method gets called if the active state of this widget turns on or off.
    // This is used to turn off the pencil button in the Panel.
    this.StateChangeCallback = undefined;
    // This is used by the annotationPanel to transfer draing mode to a new selected widget.
    this.SelectedCallback = undefined;

    this.Tolerance = 0.05;
    if (SAM.detectMobile()) {
      this.Tolerance = 0.1;
    }

    var cam = this.Layer.GetCamera();
    var viewport = this.Layer.GetViewport();
    this.Shape = new Rect();
    // TODO: Correct the mix or orientation and rotation.
    this.Shape.Orientation = cam.GetImageRotation();
    this.Shape.Origin.fill(0);
    this.Shape.SetOutlineColor([0.0, 0.0, 0.0]);
    if (DEFAULT_WIDTH > 0) {
      this.Shape.Height = DEFAULT_HEIGHT;
      this.Shape.Width = DEFAULT_WIDTH;
    } else {
      this.Shape.Height = 50.0 * cam.Height / viewport[3];
      this.Shape.Width = 50.0 * cam.Height / viewport[3];
    }
    this.Shape.LineWidth = 0;
    this.Shape.FixedSize = false;

    // This is a handle for translation.
    this.CenterCircle = new SAM.Circle();
    this.CenterCircle.SetFillColor([1, 1, 0]);
    this.CenterCircle.SetOutlineColor([0.0, 0.0, 0.0]);
    this.CenterCircle.Radius = 5;
    this.CenterCircle.LineWidth = 1;
    this.CenterCircle.PositionCoordinateSystem = 1;

    this.Rotatable = true;

    // Circle is a handle for rotation.
    this.RotateCircle = new SAM.Circle();
    this.RotateCircle.SetFillColor([1, 1, 0]);
    this.RotateCircle.SetOutlineColor([0.0, 0.0, 0.0]);
    this.RotateCircle.Radius = 5;
    this.RotateCircle.LineWidth = 1;
    this.RotateCircle.PositionCoordinateSystem = 1;

    // Get default properties.
    if (localStorage.RectWidgetDefaults) {
      var defaults = JSON.parse(localStorage.RectWidgetDefaults);
      if (defaults.Color) {
        this.Shape.SetOutlineColor(defaults.Color);
      }
    }

    if (DEFAULT_LABEL) {
      var text = new SAM.Text();
      text.BackgroundFlag = false;
      text.String = DEFAULT_LABEL;
      text.Position = this.Circle.Origin;
      this.Circle.Children['label'] = text;
    }

    // Note: If the user clicks before the mouse is in the
    // canvas, this will behave odd.

    this.Layer.GetParent().css({'cursor': 'default'});
    this.State = INACTIVE;
    this.WhichDrag = 0;      // Bits
  }

  RectWidget.prototype.SetOrigin = function (x, y) {
    this.Shape.Origin[0] = x;
    this.Shape.Origin[1] = y;
    if (this.Shape.Children.Label) {
      this.Shape.Children.Label = this.Shape.Origin;
    }
  };

  // Not used yet, but might be useful.
  RectWidget.prototype.SetCreationCamera = function (cam) {
    // Lets save the zoom level (sort of).
    // Load will overwrite this for existing annotations.
    // This will allow us to expand annotations into notes.
    this.CreationCamera = cam.Serialize();
  };

  RectWidget.prototype.SetModifiedCallback = function (callback) {
    this.ModifiedCallback = callback;
  };

  // Called when the widget is modified.
  RectWidget.prototype.Modified = function () {
    if (this.ModifiedCallback) {
      this.ModifiedCallback(this);
    }
  };

  RectWidget.prototype.SetSelectedCallback = function (callback) {
    this.SelectedCallback = callback;
  };

  // This callback gets called when ever the active state changes,
  // even if caused by an external call. This widget is passed as a argument.
  // This is used to turn off the pencil button in the Panel.
  RectWidget.prototype.SetStateChangeCallback = function (callback) {
    this.StateChangeCallback = callback;
  };

  // Called when the state changes.
  RectWidget.prototype.StateChanged = function () {
    if (this.StateChangeCallback) {
      this.StateChangeCallback(this);
    }
  };

  // Bad name "drawing".  New widget dragging.
  RectWidget.prototype.SetStateToDrawing = function () {
    this.State = NEW;
    this.Shape.Visibility = false;
    // Do not render mouse "cursor" unti it moves and we know its location.
    this.Visibility = false;
    this.Layer.GetParent().css({'cursor': 'move'});
  };

  // Returns true if selected
  // This is sort of ugly.  Change it to delete directly if possible.
  // Return value will let the layer clean up.
  RectWidget.prototype.DeleteSelected = function () {
    return this.Shape.DeleteSelected();
  };

  RectWidget.prototype.IsEmpty = function () {
    if (this.State === NEW) {
      return true;
    }
    return this.Shape.IsEmpty();
  };

  // I am divorcing selected from active.
  RectWidget.prototype.IsSelected = function () {
    return this.Shape.Selected;
  };

  RectWidget.prototype.SetSelected = function (flag) {
    this.Shape.SetSelected(flag);
    if (flag && this.SelectedCallback) {
      (this.SelectedCallback)(this);
    }
    if (!flag) {
      // We can be selected without being active, but we cannot be
      // active without being selected.
      this.SetActive(false);
    }
  };

  // Selects the widget if the shape is fuly contained in the selection rectangle.
  RectWidget.prototype.ApplySelect = function (selection) {
    var pts = this.GetCornerPoints();
    var bds = [pts[0][0], pts[0][0], pts[0][1], pts[0][1]];
    for (var i = 1; i < 4; ++i) {
      bds[0] = Math.min(bds[0], pts[i][0]);
      bds[1] = Math.max(bds[1], pts[i][0]);
      bds[2] = Math.min(bds[2], pts[i][1]);
      bds[3] = Math.max(bds[3], pts[i][1]);
    }
    if (selection.ViewerPointInSelection(bds[0], bds[2]) &&
        selection.ViewerPointInSelection(bds[0], bds[3]) &&
        selection.ViewerPointInSelection(bds[1], bds[2]) &&
        selection.ViewerPointInSelection(bds[1], bds[3])) {
      this.SetSelected(true);
      return true;
    }
    this.SetSelected(false);
    return false;
  };

  // Tolerance in screen pixels
  RectWidget.prototype.GetTolerance = function () {
    var width = this.Shape.GetLineWidth();
    // Tolerance: 5 screen pixels.
    var minWidth = 20.0 / this.Layer.GetPixelsPerUnit();
    if (width < minWidth) { width = minWidth; }
    return width;
  };

  // Returns true if the mouse is over the rectangle.
  RectWidget.prototype.HandleSelect = function () {
    if (this.State === DIALOG) {
      return;
    }
    // Check to see if a stroke was clicked.
    // var x = this.Layer.MouseX;
    // var y = this.Layer.MouseY;
    var z = this.Layer.ZTime;
    if (this.Shape.Origin.length > 2 && this.Shape.Origin[2] !== z) {
      return false;
    }

    // var pt = this.Layer.GetCamera().ConvertPointViewerToWorld(x, y);

    var part = this.PointOnWhichPart();
    if (part !== undefined) {
      this.SetSelected(true);
      return true;
    } else {
      this.SetSelected(false);
    }

    return false;
  };

  // Threshold above is the only option for now.
  RectWidget.prototype.SetThreshold = function (threshold) {
    if (this.confidence !== undefined) {
      this.Visibility = this.confidence >= threshold;
    }
  };

  RectWidget.prototype.Draw = function () {
    if (this.Visibility === false) {
      return;
    }
    var view = this.Layer.GetView();
    if (this.Layer.ZTime !== undefined && this.Shape.Origin.length > 2) {
      if (this.Layer.ZTime !== this.Shape.Origin[2]) {
        return;
      }
    }
    this.Shape.Draw(view);
    if (this.State !== INACTIVE && this.State !== NEW && this.State !== DRAG) {
      var pts = this.GetCornerPoints();
      this.CenterCircle.Origin = pts[4];
      this.CenterCircle.Draw(view);
      // var cam = this.Layer.GetCamera();
      if (this.Rotatable) {
        this.RotateCircle.Origin = pts[0];
        this.RotateCircle.Draw(view);
      }
    }
  };

  RectWidget.prototype.PasteCallback = function (data, layer, mouseWorldPt) {
    this.Load(data);
    // Place the widget over the mouse.
    // This would be better as an argument.
    this.SetOrigin(mouseWorldPt[0], mouseWorldPt[1]);
    layer.EventuallyDraw();
    this.Modified();
  };

  RectWidget.prototype.Serialize = function () {
    if (this.Shape === undefined) { return null; }
    var obj = {
      'type': 'rectangle',
      'center': this.Shape.Origin,
      'width': this.Shape.Width,
      'height': this.Shape.Height,
      'rotation': this.Shape.GetOrientation(),
      // caller might handle this already.
      'lineWidth': this.Shape.LineWidth,
      'lineColor': SAM.ConvertColorToHex(this.Shape.OutlineColor)
    };
    if (obj.center.length === 2) {
      obj.center.push(0);
    }

    if (this.Shape.Children.label && this.Shape.Children.label.String) {
      obj.label = {'value': this.Shape.Children.label.String};
    }
    if ('UserImageUrl' in this.Shape) {
      obj.user = {'imageUrl': this.Shape.UserImageUrl};
    }

    return obj;
  };

  // Load a widget from a json object (origin MongoDB).
  RectWidget.prototype.Load = function (obj) {
    this.UserNoteFlag = obj.user_note_flag;
    this.SetOrigin(parseFloat(obj.center[0]),
                   parseFloat(obj.center[1]));
    if (obj.center.length > 2) {
      this.Shape.Origin[2] = parseFloat(obj.center[2]);
    }

    if (obj.lineColor) {
      this.Shape.OutlineColor = SAM.ConvertColor(obj.lineColor);
    }
    this.Shape.Width = parseFloat(obj.width);
    if (obj.confidence) {
      this.confidence = parseFloat(obj.confidence);
    }
    if (obj.height) {
      this.Shape.Height = parseFloat(obj.height);
    }
    if (obj.rotation) {
      this.Shape.Orientation = parseFloat(obj.rotation);
    }
    if (obj.lineWidth !== undefined) {
      this.Shape.LineWidth = parseFloat(obj.lineWidth);
    }
    this.Shape.FixedSize = false;
    this.Shape.UpdateBuffers(this.Layer.AnnotationView);

    // How zoomed in was the view when the annotation was created.
    if (obj.creation_camera !== undefined) {
      this.CreationCamera = obj.CreationCamera;
    }

    if ('label' in obj) {
      var str = obj['label']['value'];
      // I universally inserted label "test" before the label was rendered.
      if (str !== 'test') {
        var text = new SAM.Text();
        text.BackgroundFlag = false;
        text.String = str;
        text.Position = this.Shape.Origin;
        this.Shape.Children['label'] = text;
      }
    }

    if ('user' in obj) {
      var user = obj.user;
      if ('imageUrl' in user) {
        this.Shape.UserImageUrl = user.imageUrl;
        this.Shape.Image = new Image();
        var self = this;
        $(self.Shape.Image).one('load', function () {
          var width = self.Shape.Image.width;
          var height = self.Shape.Image.height;
          var hiddenCanvas = $('<canvas width=' + width + '  height=' + height + '>');
          var ctx = hiddenCanvas[0].getContext('2d');
          ctx.drawImage(self.Shape.Image, 0, 0);
          ctx.beginPath();
          ctx.lineWidth = '100';
          ctx.strokeStyle = 'blue';
          ctx.arc(500, 500, 300, 0, 2 * Math.PI);
          ctx.stroke();
          ctx.clearRect(200, 200, 300, 300);
          self.Shape.Image.src = hiddenCanvas[0].toDataURL();
        });

        this.Shape.Image.src = user.imageUrl;
        // On loaded, render?
      }
    }
  };

  RectWidget.prototype.SetVisibility = function (vis) {
    this.Visibility = vis;
    this.Layer.EventuallyDraw();
  };

  RectWidget.prototype.HandleKeyDown = function (layer) {
    if (layer.Event.keyCode === 86) {
      this.Visibility = !this.Visibility;
      layer.EventuallyDraw();
      return true;
    }

    if (!this.Visibility || this.State === INACTIVE) {
      return true;
    }

    // The dialog consumes all key events.
    if (this.State === DIALOG) {
      return false;
    }

    var event = layer.Event;
    if (this.State === NEW) {
      // escape key (or space or enter) to turn off drawing
      if (event.keyCode === 27 || event.keyCode === 32 || event.keyCode === 13) {
        this.Modified();
        this.Deactivate();
                // this widget was temporary, All rects created have been copied.
        this.Layer.RemoveWidget(this);
        return false;
      }
    }

    // Copy
    if (event.keyCode === 67 && event.ctrlKey) {
      // control-c for copy
      // The extra identifier is not needed for widgets, but will be
      // needed if we have some other object on the clipboard.
      var clip = {Type: 'RectWidget', Data: this.Serialize()};
      localStorage.ClipBoard = JSON.stringify(clip);
      return false;
    }

    return true;
  };

  RectWidget.prototype.HandleMouseDown = function (layer) {
    if (!this.Visibility || this.State === INACTIVE) {
      return true;
    }
    if (this.State === NEW) {
      this.WhichDrag = DRAG_X0 + DRAG_Y0 + SYMMETRIC;
    }
    if (this.State === HOVER) {
      // var part = this.PointOnWhichPart();
      this.State = DRAG;
      this.LastMouse = layer.GetMouseWorld();
      // Which drag is already set by mouse move.
    }

    return false;
  };

  RectWidget.prototype.HandleMouseMove = function (layer) {
    if (this.State === INACTIVE) {
      return true;
    }
    var event = layer.Event;

    // Dragging is complicated enough that we have to compute reactangle
    // from the mouse movement vector (and not contraints).
    var worldPt0 = this.LastMouseWorld;
    var worldPt1 = this.Layer.GetMouseWorld();
    if (worldPt0 === undefined) {
      worldPt0 = worldPt1;
    }
    this.LastMouseWorld = worldPt1;
    var dx = worldPt1[0] - worldPt0[0];
    var dy = worldPt1[1] - worldPt0[1];
    var x = worldPt1[0] - this.Shape.Origin[0];
    var y = worldPt1[1] - this.Shape.Origin[1];

    // Mouse moving with no button pressed:
    if (event.which === 0) {
      // This keeps the rectangle from being drawn in the wrong place
      // before we get our first event.
      if (this.State === NEW) {
        this.Shape.Visibility = true;
        this.WhichDrag = CENTER;
        // THis is ignored until the mouse is pressed.
        this.Visibility = true;
        // Center follows mouse.
        this.SetOrigin(worldPt1[0], worldPt1[1]);
        this.Layer.EventuallyDraw();
        return false;
      }
      if (this.State === ACTIVE || this.State === HOVER) {
        var part = this.PointOnWhichPart();
        if (part === undefined) {
          this.State = ACTIVE;
          this.Layer.GetParent().css({'cursor': ''});
          return false;
        }
        this.State = HOVER;
        if (part[0] === CORNER) {
          switch (part[1]) {
            case 0:
              if (this.Rotatable) {
                this.Layer.GetParent().css({'cursor': 'pointer'});
                this.WhichDrag = ROTATE;
              } else {
                this.Layer.GetParent().css({'cursor': 'nw-resize'});
                this.WhichDrag = DRAG_X0 + DRAG_Y0;
              }
              break;
            case 1:
              this.Layer.GetParent().css({'cursor': 'ne-resize'});
              this.WhichDrag = DRAG_X1 + DRAG_Y0;
              break;
            case 2:
              this.Layer.GetParent().css({'cursor': 'se-resize'});
              this.WhichDrag = DRAG_X1 + DRAG_Y1;
              break;
            case 3:
              this.Layer.GetParent().css({'cursor': 'sw-resize'});
              this.WhichDrag = DRAG_X0 + DRAG_Y1;
              break;
            case 4:
              this.Layer.GetParent().css({'cursor': 'move'});
              this.WhichDrag = CENTER;
          }
        }
        if (part[0] === EDGE) {
          switch (part[1]) {
            case 0:
              this.Layer.GetParent().css({'cursor': 'ns-resize'});
              this.WhichDrag = DRAG_Y0;
              break;
            case 1:
              this.Layer.GetParent().css({'cursor': 'ew-resize'});
              this.WhichDrag = DRAG_X1;
              break;
            case 2:
              this.Layer.GetParent().css({'cursor': 'ns-resize'});
              this.WhichDrag = DRAG_Y1;
              break;
            case 3:
              this.Layer.GetParent().css({'cursor': 'ew-resize'});
              this.WhichDrag = DRAG_X0;
              break;
          }
        }
        return false;
      }
    }

    if (event.which !== 1) { return false; }

    // For transforming between world and box coordinate systems.
    var rotation = this.Shape.GetRotation();
    var c = Math.cos(rotation);
    var s = Math.sin(rotation);
    if (this.State === NEW || this.State === DRAG) {
      if (this.WhichDrag & CENTER) {
        // Special case with no modifiers.  Just translate the whole rectangle.
        this.SetOrigin(worldPt1[0], worldPt1[1]);
        this.Layer.EventuallyDraw();
        this.Modified();
        return false;
      }
      if (this.WhichDrag & ROTATE) {
        // Special case with no modifiers.  Just translate the whole rectangle.
        // Compute two vectors, then rotate to align them.
        var v0 = [-this.Shape.Width, -this.Shape.Height];
        var mag = Math.sqrt(v0[0] * v0[0] + v0[1] * v0[1]);
        v0[0] = v0[0] / mag;
        v0[1] = v0[1] / mag;
        var v1 = [x, y];
        mag = Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1]);
        v1[0] = v1[0] / mag;
        v1[1] = v1[1] / mag;
        c = v0[0] * v1[0] + v0[1] * v1[1];
        s = v0[0] * v1[1] - v0[1] * v1[0];
        this.Shape.Orientation = -Math.atan2(s, c) * 180 / Math.PI;
        this.Layer.EventuallyDraw();
        this.Modified();
        return false;
      }
      if (this.WhichDrag & SYMMETRIC) {
        var rx = c * x - s * y;
        var ry = s * x + c * y;
        if (this.WhichDrag & (DRAG_X1 + DRAG_X0)) {
          this.Shape.Width = 2 * rx;
        }
        if (this.WhichDrag & (DRAG_Y1 + DRAG_Y0)) {
          this.Shape.Height = 2 * ry;
        }
      } else {
        // Draging when not symmetric is a pain.
        // ------ This is not finihsed. -----------
        // Rotate mouse vector to be in rectangles coordinate system.
        // Position of the mouse in box coordinates.
        // Constrain the mouse vector based on axes being modified.
        // Transform the detla mouse to rectangle coordinate system.
        var rdx = (c * dx) - (s * dy);
        var rdy = (s * dx) + (c * dy);
        if (this.WhichDrag & DRAG_X1) {
          this.Shape.Width += rdx;
        } else if (this.WhichDrag & DRAG_X0) {
          this.Shape.Width -= rdx;
        } else {
          // This axis is not being maodified.  Ignore it.
          rdx = 0;
        }
        if (this.WhichDrag & DRAG_Y1) {
          this.Shape.Height += rdy;
        } else if (this.WhichDrag & DRAG_Y0) {
          this.Shape.Height -= rdy;
        } else {
          // This axis is not being maodified.  Ignore it.
          rdy = 0;
        }
        // Rotate the constrained mouse back to world coordinate system.
        dx = (c * rdx) + (s * rdy);
        dy = (-s * rdx) + (c * rdy);
        // Center is moving half as fast as the mouse.
        this.SetOrigin(this.Shape.Origin[0] + dx / 2.0,
                       this.Shape.Origin[1] + dy / 2.0);
      }
    }

    DEFAULT_WIDTH = this.Shape.Width;
    DEFAULT_HEIGHT = this.Shape.Height;
    this.Modified();
    this.Shape.UpdateBuffers();
    this.Layer.EventuallyDraw();
    return false;
  };

  // returns false when it is finished doing its work.
  RectWidget.prototype.HandleMouseUp = function () {
    if (!this.Visibility || this.State === INACTIVE) {
      return true;
    }
    if (this.State === NEW) {
      this.SetActive(false);
    }
    if (this.State === DRAG) {
      this.State = HOVER;
    }
    // Interaction can make these negative.
    this.Shape.Width = Math.abs(this.Shape.Width);
    this.Shape.Height = Math.abs(this.Shape.Height);
    this.Layer.EventuallyDraw();

    return false;
  };

  // returns false when it is finished doing its work.
  RectWidget.prototype.HandleMouseClick = function () {
    if (!this.Visibility || this.State === INACTIVE) {
      return true;
    }
    if (this.State === NEW) {
      this.SetActive(false);
      this.Modified();
      return false;
    }
    return true;
  };

  // Multiple active states. Active state is a bit confusing.
  RectWidget.prototype.GetActive = function () {
    if (this.State === INACTIVE) {
      return false;
    }
    return true;
  };

  RectWidget.prototype.SetActive = function (flag) {
    if (flag === this.GetActive()) {
      return;
    }

    if (flag) {
      this.State = ACTIVE;
    } else {
      this.State = INACTIVE;
    }
    this.StateChanged();
    this.Layer.EventuallyDraw();
  };

  // Can we bind the dialog apply callback to an objects method?
  RectWidget.prototype.ShowPropertiesDialog = function () {
    if (this.Dialog === undefined) {
      this.InitPropertiesDialog();
    }
    this.WidgetPropertiesToDialog();
    var self = this;
    this.Dialog.SetApplyCallback(function () { self.DialogApplyCallback(); });
    this.Dialog.SetCloseCallback(function () { self.DialogCloseCallback(); });
    this.Dialog.Show(true);
    this.State = DIALOG;
  };

  RectWidget.prototype.DialogApplyCallback = function () {
    this.DialogPropertiesToWidget();
    this.SetActive(false, this.Layer);
    this.Layer.EventuallyDraw();
  };

  RectWidget.prototype.DialogCloseCallback = function () {
    this.SetActive(false);
    this.Layer.EventuallyDraw();
  };

  // Fill the dialog values from the widget values.
  RectWidget.prototype.WidgetPropertiesToDialog = function () {
    this.Dialog.ColorInput.val(SAM.ConvertColorToHex(this.Shape.OutlineColor));
    this.Dialog.LineWidthInput.val((this.Shape.LineWidth).toFixed(2));

    var label = '';
    if (this.Shape.Children.label && this.Shape.Children.label.String) {
      label = this.Shape.Children['label'].String;
    }
    this.Dialog.LabelInput.val(label);

    var area = this.Shape.Width * this.Shape.Height;
    var areaString = '';
    if (this.Shape.FixedSize) {
      areaString += area.toFixed(2);
      areaString += ' pixels^2';
    } else {
      if (area > 1000000) {
        areaString += (area / 1000000).toFixed(2);
        areaString += ' mm^2';
      } else {
        areaString += area.toFixed(2);
        areaString += ' um^2';
      }
    }
    this.Dialog.Area.text(areaString);
  };

  // Copy the properties of the dialog into the widget
  RectWidget.prototype.DialogPropertiesToWidget = function () {
    var modified = true;

    var hexcolor = this.Dialog.ColorInput.val();
    this.Shape.SetOutlineColor(hexcolor);
    this.Shape.LineWidth = parseFloat(this.Dialog.LineWidthInput.val());
    this.Shape.UpdateBuffers(this.Layer.AnnotationView);

    var label = this.Dialog.LabelInput.val();
    label = label.trim();
    if (label === '') {
      DEFAULT_LABEL = undefined;
      delete this.Shape.Children.label;
    } else {
      if (!this.Shape.Children.label) {
        var text = new SAM.Text();
        text.BackgroundFlag = false;
        text.String = label;
        text.Position = this.Shape.Origin;
        this.Shape.Children['label'] = text;
        DEFAULT_LABEL = label;
      }
      this.Shape.Children.label.String = label;
      modified = true;
    }

    if (modified) {
      // Save values in local storage as defaults for next time.
      localStorage.RectWidgetDefaults = JSON.stringify({
        Color: hexcolor,
        Width: this.Shape.LineWidth});
      this.Modified();
      this.Shape.UpdateBuffers(this.Layer.AnnotationView);
    }
  };

  // Get Corner points in the viewer coordinate system.
  // [ uperLeft, upperRight, lowerRight, lowerRight]
  RectWidget.prototype.GetCornerPoints = function () {
    var cam = this.Layer.GetCamera();
    var theta = this.Shape.GetRotation();
    var c = Math.cos(theta);
    var s = Math.sin(theta);
    var origin = this.Shape.Origin;
    var rw = this.Shape.Width / 2.0;
    var rh = this.Shape.Height / 2.0;

    var x, y;
    x = c * rw + s * rh;
    y = -s * rw + c * rh;
    var pt0 = [origin[0] - x, origin[1] - y];
    pt0 = cam.ConvertPointWorldToViewer(pt0[0], pt0[1]);
    var pt2 = [origin[0] + x, origin[1] + y];
    pt2 = cam.ConvertPointWorldToViewer(pt2[0], pt2[1]);

    rw = -rw;
    x = c * rw + s * rh;
    y = -s * rw + c * rh;
    var pt1 = [origin[0] - x, origin[1] - y];
    pt1 = cam.ConvertPointWorldToViewer(pt1[0], pt1[1]);
    var pt3 = [origin[0] + x, origin[1] + y];
    pt3 = cam.ConvertPointWorldToViewer(pt3[0], pt3[1]);

    var pt4 = [
      (pt0[0] + pt2[0]) * 0.5,
      (pt0[1] + pt2[1]) * 0.5];

    return [pt0, pt1, pt2, pt3, pt4];
  };

  // Points are order upperLeft, uuperRight, lowerRight, lowerLeft, center
  RectWidget.prototype.PointOnWhichPart = function () {
    var dx, dy;
    var event = this.Layer.Event;
    var x = event.offsetX;
    var y = event.offsetY;
    var tolerance = this.Shape.LineWidth + 3;
    var cornerTolerance2 = (tolerance + 2) * (tolerance + 2);
    var corners = this.GetCornerPoints();
    // First, check the corners.
    for (var i = 0; i < 5; ++i) {
      var corner = corners[i];
      dx = x - corner[0];
      dy = y - corner[1];
      if (dx * dx + dy * dy < cornerTolerance2) {
        return [CORNER, i];
      }
    }
    // Now check the edges.
    var corner0 = corners[3];
    for (i = 0; i < 4; ++i) {
      var corner1 = corners[i];
      if (this.Shape.IntersectPointLine([x, y], corner0, corner1, tolerance) !== undefined) {
        // Chance the edge index to start on top edge (=0).
        return [EDGE, (i + 3) % 4];
      }
      corner0 = corner1;
    }
    return undefined;
  };

  RectWidget.prototype.InitPropertiesDialog = function () {
    var self = this;
    this.Dialog = new SAM.Dialog(this.Layer.GetParent().parent());
    this.Dialog.SetApplyCallback(function () { self.DialogApplyCallback(); });
    // Customize dialog for a circle.
    this.Dialog.Title.text('Rect Annotation Editor');
    // Color
    this.Dialog.ColorDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.ColorLabel =
            $('<div>')
            .appendTo(this.Dialog.ColorDiv)
            .text('Color:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.ColorInput =
            $('<input type="color">')
            .appendTo(this.Dialog.ColorDiv)
            .val('#30ff00')
            .css({'display': 'table-cell'});

    // Line Width
    this.Dialog.LineWidthDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.LineWidthLabel =
            $('<div>')
            .appendTo(this.Dialog.LineWidthDiv)
            .text('Line Width:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.LineWidthInput =
            $('<input type="number">')
            .appendTo(this.Dialog.LineWidthDiv)
            .css({'display': 'table-cell'})
            .keypress(function (event) { return event.keyCode !== 13; });

    // Label
    this.Dialog.LabelDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .addClass('sa-view-annotation-modal-div');
    this.Dialog.LabelLabel =
            $('<div>')
            .appendTo(this.Dialog.LabelDiv)
            .text('Label:')
            .addClass('sa-view-annotation-modal-input-label');
    this.Dialog.LabelInput =
            $('<input type="text">')
            .appendTo(this.Dialog.LabelDiv)
            .addClass('sa-view-annotation-modal-input')
            .keypress(function (event) { return event.keyCode !== 13; });

    // Area
    this.Dialog.AreaDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.AreaLabel =
            $('<div>')
            .appendTo(this.Dialog.AreaDiv)
            .text('Area:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.Area =
            $('<div>')
            .appendTo(this.Dialog.AreaDiv)
            .css({'display': 'table-cell'});

    // Bounds
    this.Dialog.BoundsDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.BoundsLabel =
            $('<div>')
            .appendTo(this.Dialog.BoundsDiv)
            .text('Bounds:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.Bounds =
            $('<div>')
            .appendTo(this.Dialog.BoundsDiv)
            .css({'display': 'table-cell'});
  };

  SAM.Rect = Rect;
  SAM.RectWidget = RectWidget;
})();

// This widget just implements a 1 time selection of a rectangle on the screen.
// It draws the rectangle as a dom box (not in the canvas).
// I made it a first class widget and make it active (events are fowarded).
// I will choose the second, but this widget is meant to be
// temporary and not serialize to database.
// Since the rectangle may not be axis aligned withthe world, I added
// methods to check if a point is in the rectangle.

(function () {
  'use strict';

  var INACTIVE = 0;     // Normal inactive resting state.
  var START = 1;        // waiting for the first mouse down to place point1.
  var DRAG = 2;         // Mouse is down and user is dragging point2.
  var FINISH = 3;       // Mouse is up and the rectangle is finished.

  function RectSelectWidget (layer) {
    this.Layer = layer;
    SAM.Shape.call(this);

    this.State = INACTIVE;

    this.Point1 = undefined;
    this.Point2 = undefined;

    this.Rectangle = $('<div>')
      .css({
        'position': 'absolute',
        'border': '1px dashed #FF0'})
      .hide();
    this.FinishCallback = undefined;
    this.Camera = new SAM.Camera();
  }

  RectSelectWidget.prototype.SetFinishCallback = function (callback) {
    this.FinishCallback = callback;
  };

  // TODO: GET RID OF THIS (USE SetActive instead)
  // Starts the process of dragging a rectangle (just changes the cursor.
  RectSelectWidget.prototype.SetStateToDrawing = function () {
    this.State = START;
    this.Layer.GetParent().css({'cursor': 'nw-resize'});
  };

  RectSelectWidget.prototype.IsEmpty = function () {
    return true;
  };

  // Starts the process of dragging a rectangle (just changes the cursor.
  RectSelectWidget.prototype.SetActive = function (flag) {
    if (!flag && this.State !== INACTIVE) {
      this.State = INACTIVE;
      this.Layer.GetParent().css({'cursor': ''});
    }
    if (flag && this.State === INACTIVE) {
      this.State = START;
      this.Layer.GetParent().css({'cursor': 'nw-resize'});
    }
  };

  RectSelectWidget.prototype.Draw = function () {
    if (this.State === DRAG) {
      var x = Math.min(this.Point1[0], this.Point2[0]);
      var y = Math.min(this.Point1[1], this.Point2[1]);
      var w = Math.abs(this.Point1[0] - this.Point2[0]);
      var h = Math.abs(this.Point1[1] - this.Point2[1]);
      this.Rectangle
        .css({
          'left': x.toString() + 'px',
          'top': y.toString() + 'px',
          'width': w.toString() + 'px',
          'height': h.toString() + 'px'})
        .show();
    }
  };

  RectSelectWidget.prototype.HandleMouseDown = function () {
    // Should we allow multiple selections, or a single use?
    if (this.State !== START) {
      return true;
    }
    this.State = DRAG;
    this.Rectangle.appendTo(this.Layer.GetParent());
    var event = this.Layer.Event;
    var x = event.offsetX;
    var y = event.offsetY;
    this.Point1 = [x, y];
    this.Point2 = [x, y];
    this.Draw();
    return false;
  };

  RectSelectWidget.prototype.HandleMouseMove = function () {
    if (this.State !== DRAG) {
      return true;
    }
    var event = this.Layer.Event;
    var x = event.offsetX;
    var y = event.offsetY;
    this.Point2 = [x, y];
    this.Draw();
    return false;
  };

  RectSelectWidget.prototype.HandleMouseUp = function () {
    if (this.State !== DRAG) {
      return true;
    }
    this.State = FINISH;
    this.Layer.GetParent().css({'cursor': ''});
    this.Rectangle.hide().remove();
    // Compute the world coordinates of the points.
    var x1 = Math.min(this.Point1[0], this.Point2[0]);
    var y1 = Math.min(this.Point1[1], this.Point2[1]);
    var x2 = Math.max(this.Point1[0], this.Point2[0]);
    var y2 = Math.max(this.Point1[1], this.Point2[1]);

    this.Point1 = [x1, y1];
    this.Point2 = [x2, y2];

    this.Camera.DeepCopy(this.Layer.GetCamera());
    if (this.FinishCallback) {
      this.FinishCallback(this);
    }
    return false;
  };

  RectSelectWidget.prototype.ViewerPointInSelection = function (x, y) {
    if (x > this.Point1[0] && x < this.Point2[0] &&
        y > this.Point1[1] && y < this.Point2[1]) {
      return true;
    }
    return false;
  };

  RectSelectWidget.prototype.WorldPointInSelection = function (x, y) {
    var viewerPt = this.Camera.ConvertPointWorldToViewer(x, y);
    return this.ViewerPointInSelection(viewerPt[0], viewerPt[1]);
  };

  SAM.RectSelectWidget = RectSelectWidget;
})();

// No rotation for now. No direct interaction for now.
// No properties dialog for now.
// Only the world / slide conrdinate system supported.
// Does nto supprot fixed size

// How are we going to store them in girder annotations?

(function () {
  // Depends on the CIRCLE widget
  'use strict';

  // use shape api, bu this is simpler so do not subclass.
  function RectSet () {
    this.Scale = 1.0;
    // a single array [x,y,x,y,x,y...]
    this.Centers = [];
    this.Widths = [];
    this.Heights = [];
    this.Labels = [];
    this.Confidences = [];
    this.Vectors = [];
    this.Visibilities = undefined;
    // Hack to hide rects below a specific confidence.
    this.Threshold = 0.0;

    // Add metadata to be stored for a given rectangle
    this.Metadata = [];
    // For now, one can be active.  Highlight one
    this.ActiveIndex = -1;
  }

  RectSet.prototype.GetLength = function () {
    return this.Widths.length;
  };

  RectSet.prototype.GetCenter = function (idx) {
    idx = idx << 1;
    return [this.Centers[idx], this.Centers[idx + 1]];
  };

  RectSet.prototype.SetCenter = function (idx, pt) {
    idx = idx * 2;
    this.Centers[idx] = pt[0];
    this.Centers[idx + 1] = pt[1];
  };

  // Set the size (width,height) of all the rectangles.
  RectSet.prototype.SetShape = function (shape) {
    for (var i = 0; i < this.Widths.length; ++i) {
      this.Widths[i] = shape[0];
      this.Heights[i] = shape[1];
    }
  };

  // Set the size (width,height) of all the rectangles.
  RectSet.prototype.SetScale = function (scale) {
    var k = scale / this.Scale;
    this.Scale = scale;
    for (var i = 0; i < this.Widths.length; ++i) {
      this.Widths[i] *= k;
      this.Heights[i] *= k;
    }
  };

  RectSet.prototype.SetMetadata = function (idx, metadataObj) {
    this.Metadata[idx] = metadataObj;
  };

  RectSet.prototype.GetMetadata = function (idx) {
    return this.Metadata[idx];
  };

  // Helper for ground truth.
  RectSet.prototype.CopyRectangle = function (source, inIdx, outIdx) {
    if (outIdx === undefined) {
      outIdx = this.Labels.length;
    }
    var inTmp = inIdx * 2;
    var outTmp = outIdx * 2;
    this.Centers[outTmp] = source.Centers[inTmp];
    this.Centers[outTmp + 1] = source.Centers[inTmp + 1];
    this.Widths[outIdx] = source.Widths[inIdx];
    this.Heights[outIdx] = source.Heights[inIdx];
    this.Labels[outIdx] = source.Labels[inIdx];
    this.Confidences[outIdx] = source.Confidences[inIdx];
    this.Metadata[outIdx] = source.Metadata[inIdx];
  };

  RectSet.prototype.AddRectangle = function (center, width, height) {
    var outIdx = this.Labels.length;
    this.Centers[outIdx * 2] = center[0];
    this.Centers[outIdx * 2 + 1] = center[1];
    this.Widths[outIdx] = width;
    this.Heights[outIdx] = height;
    this.Labels[outIdx] = '';
    this.Confidences[outIdx] = 1.0;
    // Default Metadata is empty
    this.Metadata[outIdx] = {};
    return this.Widths.length - 1;
  };

  RectSet.prototype.DeleteRectangle = function (index) {
    if (index < 0 || index >= this.Widths.length) {
      return;
    }

    this.Centers.splice(2 * index, 2);
    this.Widths.splice(index, 1);
    this.Heights.splice(index, 1);
    this.Labels.splice(index, 1);
    this.Confidences.splice(index, 1);
    this.Metadata.splice(index, 1);
    if (this.ActiveIndex === index) {
      this.ActiveIndex = -1;
    }
  };

  RectSet.prototype.SetOutlineColor = function (c) {
    this.Color = SAM.ConvertColorToHex(c);
  };

  // do not worry about webGl for now.  Only canvas drawing.
  // webgl would support more rects I assume.
  RectSet.prototype.Draw = function (view) {
    // 2d Canvas ( saving is probably not necessary ) -----------
    view.Context2d.save();

    // We only support image coordinate system for now.
    var cam = view.GetCamera();
    var t = cam.GetImageToViewerTransform();
    view.Context2d.setTransform(t[0], t[1], t[2], t[3], t[4], t[5]);

    var pixelSize = cam.ConvertScaleViewerToImage(1);
    var cIdx = 0;
    var x, y, vx, vy;

    // draw the vectors
    view.Context2d.beginPath();
    for (var i = 0; i < this.Vectors.length; ++i) {
      if ((!this.Visibilities || this.Visibilities[i]) &&
          (this.Confidences[i] >= this.Threshold)) {
        vx = this.Vectors[cIdx];
        x = this.Centers[cIdx++];
        vy = this.Vectors[cIdx];
        y = this.Centers[cIdx++];

        view.Context2d.moveTo(x, y);
        view.Context2d.lineTo(x + vx, y + vy);
      } else {
        cIdx += 2;
      }
    }
    view.Context2d.strokeStyle = '#ff00ff';
    view.Context2d.lineWidth = pixelSize * 3;
    view.Context2d.stroke();

    cIdx = 0;
    view.Context2d.lineWidth = pixelSize * 2;
    for (i = 0; i < this.Widths.length; ++i) {
      if ((!this.Visibilities || this.Visibilities[i]) &&
          (this.Confidences[i] >= this.Threshold)) {
        var hw = this.Widths[i] / 2;
        var hh = this.Heights[i] / 2;
        x = this.Centers[cIdx++];
        y = this.Centers[cIdx++];

        view.Context2d.beginPath();
        if (this.LabelColors && this.LabelColors[this.Labels[i]]) {
          view.Context2d.strokeStyle = this.LabelColors[this.Labels[i]];
        } else if (this.Color) {
          view.Context2d.strokeStyle = this.Color;
        } else {
          if (this.Confidences[i] === 0) {
            view.Context2d.strokeStyle = '#ff0000';
          } else {
            var r = Math.floor(this.Confidences[i] * 255);
            view.Context2d.strokeStyle = '#' + r.toString(16) + 'ff00';
          }
        }
        view.Context2d.moveTo(x - hw, y - hh);
        view.Context2d.lineTo(x + hw, y - hh);
        view.Context2d.lineTo(x + hw, y + hh);
        view.Context2d.lineTo(x - hw, y + hh);
        view.Context2d.lineTo(x - hw, y - hh);

        view.Context2d.stroke();

        if (i === this.ActiveIndex) {
          // mark the rectangle
          view.Context2d.beginPath();
          view.Context2d.strokeStyle = '#00ffff';
          view.Context2d.moveTo((x - hw), y);
          view.Context2d.lineTo((x - hw / 2), y);
          view.Context2d.moveTo((x + hw), y);
          view.Context2d.lineTo((x + hw / 2), y);
          view.Context2d.moveTo(x, (y - hh));
          view.Context2d.lineTo(x, (y - hh / 2));
          view.Context2d.moveTo(x, (y + hh));
          view.Context2d.lineTo(x, (y + hh / 2));
          view.Context2d.stroke();
        }
      } else {
        cIdx += 2;
      }
    }

    view.Context2d.restore();
  };

  function RectSetWidget (layer, newFlag) {
    this.Visibility = true;
    // Keep track of annotation created by students without edit
    // permission.
    this.UserNoteFlag = !SA.Edit;

    if (layer === null) {
      return;
    }

    this.Shape = new RectSet();
    if (layer) {
      layer.AddWidget(this);
    }
    this.Active = false;
  }

  RectSetWidget.prototype.GetLength = function () {
    return this.Shape.Widths.length;
  };

  RectSetWidget.prototype.IsEmpty = function () {
    return this.GetLength() === 0;
  };

  // Prioritizing by confidence does not work because they all have such high (equal) confidences.
  // Lets prioritize by area instead
  RectSetWidget.prototype.ComputeVisibilities = function (layer) {
    var rectSet = this.Shape;
    if (rectSet.Visibilities === undefined) {
      rectSet.Visibilities = Array(rectSet.Confidences.length);
      rectSet.Hash = new SAM.SpatialHash();
      var bds = layer.GetViewer().GetOverViewBounds();
      rectSet.Hash.Build(rectSet, bds);
    }
    var visibilities = rectSet.Visibilities;
    visibilities.fill(true);

    // Rectangles are reverse sorted by confidnece
    for (var i = 0; i < visibilities.length; ++i) {
      if (visibilities[i] === true && rectSet.Confidences[i] >= rectSet.Threshold) {
        var width = rectSet.Widths[i];
        var height = rectSet.Heights[i];
        var area1 = width * height;
        var center = rectSet.GetCenter(i);
        // Get all the other rects overlapping this one.
        var indexes = rectSet.Hash.GetOverlapping(center, width, height, 0.3);
        for (var j = 0; j < indexes.length; ++j) {
          var rect2Idx = indexes[j];
          if (rect2Idx !== i && visibilities[rect2Idx] &&
              rectSet.Confidences[rect2Idx] >= rectSet.Threshold) {
            // which should we hide?  Look at area to decide
            var area2 = rectSet.Widths[rect2Idx] * rectSet.Heights[rect2Idx];
            if (area1 < area2) {
              visibilities[i] = false;
            } else {
              visibilities[rect2Idx] = false;
            }
          }
        }
      }
    }
  };

  // note: this assumes rects are squares.
  // I assume that the annotations are fixed and do not change after this
  // is called.  This can be called multiple times
  // (when threshold or size changes).
  // Remove overlapping annoations (visibility = false).
  // greedy: first supresses later)
  RectSetWidget.prototype.ComputeVisibilitiesConfidence = function (layer) {
    var rectSet = this.Shape;
    if (rectSet.Visibilities === undefined) {
      rectSet.Visibilities = Array(rectSet.Confidences.length);
      rectSet.Hash = new SAM.SpatialHash();
      var bds = layer.GetViewer().GetOverViewBounds();
      rectSet.Hash.Build(rectSet, bds);
    }
    var visibilities = rectSet.Visibilities;
    visibilities.fill(false);

    // Rectangles are reverse sorted by confidnece
    for (var i = 0; i < visibilities.length; ++i) {
      if (visibilities[i] === false && rectSet.Confidences[i] >= rectSet.Threshold) {
        var width = rectSet.Widths[i];
        var height = rectSet.Heights[i];
        var center = rectSet.GetCenter(i);
        // Get all the other rects overlapping this one.
        var indexes = rectSet.Hash.GetOverlapping(center, width, height, 0.3);
        var alone = true;
        for (var j = 0; j < indexes.length; ++j) {
          var rect2Idx = indexes[j];
          // Odd: Make them visible one by one.
          if (rect2Idx < i && visibilities[rect2Idx]) {
            // found a visibile neighbor.
            alone = false;
          }
        }
        visibilities[i] = alone;
      }
    }
  };

  // Change the visiblities and colors to indicate change.
  // This assume that the visibilities have been computed already.
  // and hash has been built too.
  RectSet.prototype.ChangeDetectionVisibilities = function (rectSet1, rectSet2,
                                                            overlapThresh) {
    var visibilities1 = rectSet1.Visibilities;
    var visibilities2 = rectSet2.Visibilities;

    for (var i = 0; i < visibilities1.length; ++i) {
      if (visibilities1[i]) {
        var c = rectSet1.GetCenter(i);
        var w = rectSet1.Widths[i];
        var h = rectSet1.Widths[i];
        var indexes = rectSet2.Hash.GetOverlapping(c, w, h, 0.3);
        for (var j = 0; j < indexes.length; ++j) {
          visibilities2[indexes[j]] = false;
          visibilities1[i] = false;
        }
      }
    }
  };

  // Sort by confidences
  // Note: Not used yet.
  RectSetWidget.prototype.Sort = function (lowToHigh) {
    // Create an array to sort that also keeps the indexes.
    var sortable = new Array(this.Confidences.length);
    var reverse = 1;
    if (lowToHigh) {
      reverse = -1;
    }
    for (var i = 0; i < sortable.length; ++i) {
      sortable[i] = {conf: reverse * this.Confidences[i], idx: i};
    }
    sortable.sort(function (a, b) {
      if (a.conf > b.conf) {
        return 1;
      }
      if (a.conf < b.conf) {
        return -1;
      }
      // a must be equal to b
      return 0;
    });
    // Update all arrays.
    var newConfidences = new Array(this.Confidences.length);
    var newCenters = new Array(this.Centers.length);
    var newLabels = new Array(this.Centers.length);
    var newMetadata = new Array(this.Metadata.length);
    for (i = 0; i < newConfidences.length; ++i) {
      var i2 = sortable[i].idx;
      newLabels[i] = this.Labels[i2];
      newMetadata[i] = this.Metadata[i2];
      newConfidences[i] = this.Confidences[i2];
      i2 = i2 * 2;
      newCenters[2 * i] = this.Centers[i2];
      newCenters[2 * i + 1] = this.Centers[i2 + 1];
    }
    this.Centers = newCenters;
    this.Confidences = newConfidences;
    this.Labels = newLabels;
    this.Metadata = newMetadata;
  };

  // Threshold above is the only option for now.
  RectSetWidget.prototype.SetThreshold = function (threshold) {
    this.Shape.Threshold = threshold;
  };

  RectSetWidget.prototype.Draw = function (layer) {
    if (this.Visibility) {
      this.Shape.Draw(layer.GetView());
    }
  };

  RectSetWidget.prototype.Serialize = function () {
    if (this.Shape === undefined) { return null; }

    var obj = {type: 'rect_set'};
    if (this.UserNoteFlag !== undefined) {
      obj.user_note_flag = this.UserNoteFlag;
    }
    if (this.Shape.Color) {
      obj.color = SAM.ConvertColor(this.Shape.Color);
    }
    if (this.Label) {
      obj.label = this.Label;
    }
    var num = this.Shape.Widths.length;
    obj.confidences = new Array(num);
    obj.widths = new Array(num);
    obj.heights = new Array(num);
    obj.labels = new Array(num);
    obj.metadata = new Array(num);
    obj.centers = new Array(num * 2);
    for (var i = 0; i < num; ++i) {
      obj.widths[i] = this.Shape.Widths[i];
      obj.heights[i] = this.Shape.Heights[i];
      obj.confidences[i] = this.Shape.Confidences[i];
      obj.centers[i] = this.Shape.Centers[i];
      obj.centers[i + num] = this.Shape.Centers[i + num];
      obj.labels[i] = this.Shape.Labels[i];
      obj.metadata[i] = this.Shape.Metadata[i];
    }
    return obj;
  };

  // Load a widget from a json object (origin MongoDB).
  RectSetWidget.prototype.Load = function (obj) {
    this.UserNoteFlag = obj.user_note_flag;
    if (obj.label) {
      this.Label = obj.label;
    }
    if (obj.color) {
      this.Shape.Color = [
        parseFloat(obj.color[0]),
        parseFloat(obj.color[1]),
        parseFloat(obj.color[2])];
    }
    var num = obj.widths.length;
    this.Shape.Confidences = new Array(num);
    this.Shape.Labels = new Array(num);
    this.Shape.Widths = new Array(num);
    this.Shape.Heights = new Array(num);
    this.Shape.Centers = new Array(num * 2);
    if (obj.vectors) {
      this.Shape.Vectors = new Array(num * 2);
    }
    this.Shape.Metadata = new Array(num);
    for (var i = 0; i < num; ++i) {
      this.Shape.Widths[i] = parseFloat(obj.widths[i]);
      this.Shape.Heights[i] = parseFloat(obj.heights[i]);
      this.Shape.Confidences[i] = parseFloat(obj.confidences[i]);
      if (obj.labels) {
        this.Shape.Labels[i] = obj.labels[i];
      } else {
        this.Shape.Labels[i] = '';
      }
      if (obj.metadata) {
        this.Shape.Metadata[i] = obj.metadata[i];
      } else {
        this.Shape.Metadata[i] = {};
      }
      this.Shape.Centers[i] = parseFloat(obj.centers[i]);
      this.Shape.Centers[i + num] = parseFloat(obj.centers[i + num]);
      if (obj.vectors) {
        this.Shape.Vectors[i] = parseFloat(obj.vectors[i]);
        this.Shape.Vectors[i + num] = parseFloat(obj.vectors[i + num]);
      }
    }
  };

  RectSetWidget.prototype.HandleDoubleClick = function (layer) {
    return true;
  };

  RectSetWidget.prototype.HandleMouseUp = function (layer) {
    return true;
  };

  RectSetWidget.prototype.HandleMouseMove = function (layer) {
    return true;
  };

  RectSetWidget.prototype.HandleMouseWheel = function (layer) {
    return true;
  };

  RectSetWidget.prototype.HandleTouchPan = function (layer) {
    return true;
  };

  RectSetWidget.prototype.HandleTouchPinch = function (layer) {
    return true;
  };

  RectSetWidget.prototype.HandleTouchEnd = function (layer) {
    return true;
  };

  RectSetWidget.prototype.CheckActive = function (layer) {
    return this.Active;
  };

  // Multiple active states. Active state is a bit confusing.
  RectSetWidget.prototype.GetActive = function () {
    return this.Active;
  };

  // Does notning now.
  RectSetWidget.prototype.SetActive = function (flag, layer) {
    if (!this.Visibility) {
      this.Visibility = true;
    }
    if (flag === this.GetActive()) {
      return;
    }
    this.Active = flag;
    layer.EventuallyDraw();
  };

  RectSetWidget.prototype.RemoveFromLayer = function (layer) {
    if (layer) {
      layer.RemoveWidget(this);
    }
    layer = null;
  };

  RectSetWidget.prototype.Deactivate = function (layer) {
  };

  RectSetWidget.prototype.PlacePopup = function (layer) {
  };

  RectSetWidget.prototype.ShowPropertiesDialog = function (layer) {
  };

  SAM.RectSetWidget = RectSetWidget;
  SAM.RectSet = RectSet;
})();

(function () {
  'use strict';

  var WAITING = 3; // The normal (resting) state.
  var ACTIVE = 4; // Mouse is over the widget and it is receiving events.
  var PROPERTIES_DIALOG = 5; // Properties dialog is up

  var DRAG = 6;
  var DRAG_LEFT = 7;
  var DRAG_RIGHT = 8;
  var DRAG_TOP = 9;
  var DRAG_BOTTOM = 10;
  // Worry about corners later.

  function Grid () {
    SAM.Shape.call(this);
    // Dimension of grid bin
    this.BinWidth = 20.0;
    this.BinHeight = 20.0;
    // Number of grid bins in x and y
    this.Dimensions = [10, 8];
    this.Orientation = 0; // Angle with respect to x axis ?
    this.Origin = [10000, 10000]; // middle.
    this.OutlineColor = [0, 0, 0];
    this.PointBuffer = [];
    this.ActiveIndex = undefined;
  }

  Grid.prototype = new SAM.Shape();

  Grid.prototype.UpdateBuffers = function (view) {
    // TODO: Having a single poly line for a shape is to simple.
    // Add cell arrays.
    this.PointBuffer = [];

    // Matrix is computed by the draw method in Shape superclass.
    // TODO: Used to detect first initialization.
    // Get this out of this method.
    this.Matrix = mat4.create();
    mat4.identity(this.Matrix);
    // mat4.rotateZ(this.Matrix, this.Orientation / 180.0 * 3.14159);

    if (this.Dimensions[0] < 1 || this.Dimensions[1] < 1 ||
            this.BinWidth <= 0.0 || this.BinHeight <= 0.0) {
      return;
    }

    var totalWidth = this.BinWidth * this.Dimensions[0];
    var totalHeight = this.BinHeight * this.Dimensions[1];
    var halfWidth = totalWidth / 2;
    var halfHeight = totalHeight / 2;

    // Draw all of the x polylines.
    var x = this.Dimensions[1] % 2 ? 0 : totalWidth;
    var y = 0;
    this.PointBuffer.push(x - halfWidth);
    this.PointBuffer.push(y - halfHeight);
    this.PointBuffer.push(0.0);

    for (var i = 0; i < this.Dimensions[1]; ++i) {
      // shuttle back and forth.
      x = x ? 0 : totalWidth;
      this.PointBuffer.push(x - halfWidth);
      this.PointBuffer.push(y - halfHeight);
      this.PointBuffer.push(0.0);
      y += this.BinHeight;
      this.PointBuffer.push(x - halfWidth);
      this.PointBuffer.push(y - halfHeight);
      this.PointBuffer.push(0.0);
    }
    // shuttle back and forth.
    x = x ? 0 : totalWidth;
    this.PointBuffer.push(x - halfWidth);
    this.PointBuffer.push(y - halfHeight);
    this.PointBuffer.push(0.0);

    // Draw all of the y lines.
    for (i = 0; i < this.Dimensions[0]; ++i) {
      // shuttle up and down.
      y = y ? 0 : totalHeight;
      this.PointBuffer.push(x - halfWidth);
      this.PointBuffer.push(y - halfHeight);
      this.PointBuffer.push(0.0);
      x += this.BinWidth;
      this.PointBuffer.push(x - halfWidth);
      this.PointBuffer.push(y - halfHeight);
      this.PointBuffer.push(0.0);
    }
    y = y ? 0 : totalHeight;
    this.PointBuffer.push(x - halfWidth);
    this.PointBuffer.push(y - halfHeight);
    this.PointBuffer.push(0.0);
  };

  function GridWidget (layer, newFlag) {
        // Keep track of annotation created by students without edit
        // permission.
    this.UserNoteFlag = !SA.Edit;

    var self = this;
    this.Dialog = new SAM.Dialog(function () { self.DialogApplyCallback(); });
        // Customize dialog for a circle.
    this.Dialog.Title.text('Grid Annotation Editor');

        // Grid Size
        // X
    this.Dialog.BinWidthDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.BinWidthLabel =
            $('<div>')
            .appendTo(this.Dialog.BinWidthDiv)
            .text('Bin Width:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.BinWidthInput =
            $('<input>')
            .appendTo(this.Dialog.BinWidthDiv)
            .css({'display': 'table-cell'})
            .keypress(function (event) { return event.keyCode !== 13; });
        // Y
    this.Dialog.BinHeightDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.BinHeightLabel =
            $('<div>')
            .appendTo(this.Dialog.BinHeightDiv)
            .text('Bin Height:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.BinHeightInput =
            $('<input>')
            .appendTo(this.Dialog.BinHeightDiv)
            .css({'display': 'table-cell'})
            .keypress(function (event) { return event.keyCode !== 13; });

        // Orientation
    this.Dialog.RotationDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.RotationLabel =
            $('<div>')
            .appendTo(this.Dialog.RotationDiv)
            .text('Rotation:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.RotationInput =
            $('<input>')
            .appendTo(this.Dialog.RotationDiv)
            .css({'display': 'table-cell'})
            .keypress(function (event) { return event.keyCode !== 13; });

        // Color
    this.Dialog.ColorDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.ColorLabel =
            $('<div>')
            .appendTo(this.Dialog.ColorDiv)
            .text('Color:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.ColorInput =
            $('<input type="color">')
            .appendTo(this.Dialog.ColorDiv)
            .val('#30ff00')
            .css({'display': 'table-cell'});

        // Line Width
    this.Dialog.LineWidthDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.LineWidthLabel =
            $('<div>')
            .appendTo(this.Dialog.LineWidthDiv)
            .text('Line Width:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.LineWidthInput =
            $('<input type="number">')
            .appendTo(this.Dialog.LineWidthDiv)
            .css({'display': 'table-cell'})
            .keypress(function (event) { return event.keyCode !== 13; });

    this.Tolerance = 0.05;
    if (SAM.MOBILE_DEVICE) {
      this.Tolerance = 0.1;
    }

    if (layer === null) {
      return;
    }

        // Lets save the zoom level (sort of).
        // Load will overwrite this for existing annotations.
        // This will allow us to expand annotations into notes.
    this.CreationCamera = layer.GetCamera().Serialize();

    this.Layer = layer;
    this.Popup = new SAM.WidgetPopup(this);
    var cam = layer.AnnotationView.Camera;
    var viewport = layer.AnnotationView.Viewport;
    this.Grid = new Grid();
    this.Grid.Origin = [0, 0];
    this.Grid.OutlineColor = [0.0, 0.0, 0.0];
    this.Grid.SetOutlineColor('#0A0F7A');
        // Get the default bin size from the layer scale bar.
    if (layer.ScaleWidget) {
      this.Grid.BinWidth = layer.ScaleWidget.LengthWorld;
    } else {
      this.Grid.BinWidth = 30 * cam.Height / viewport[3];
    }
    this.Grid.BinHeight = this.Grid.BinWidth;
    this.Grid.LineWidth = 2.0 * cam.Height / viewport[3];
    this.Grid.FixedSize = false;

    var width = 0.8 * viewport[2] / layer.GetPixelsPerUnit();
    this.Grid.Dimensions[0] = Math.floor(width / this.Grid.BinWidth);
    var height = 0.8 * viewport[3] / layer.GetPixelsPerUnit();
    this.Grid.Dimensions[1] = Math.floor(height / this.Grid.BinHeight);
    this.Grid.UpdateBuffers(this.Layer.AnnotationView);

    this.Text = new SAM.Text();
        // Shallow copy is dangerous
    this.Text.Position = this.Grid.Origin;
    this.Text.String = SAM.DistanceToString(this.Grid.BinWidth * 0.25e-6);
    this.Text.Color = [0.0, 0.0, 0.5];
    this.Text.Anchor = [0, 0];
    this.Text.UpdateBuffers(this.Layer.AnnotationView);

        // Get default properties.
    if (localStorage.GridWidgetDefaults) {
      var defaults = JSON.parse(localStorage.GridWidgetDefaults);
      if (defaults.Color) {
        this.Dialog.ColorInput.val(SAM.ConvertColorToHex(defaults.Color));
        this.Grid.SetOutlineColor(this.Dialog.ColorInput.val());
      }
      if (defaults.LineWidth !== undefined) {
        this.Dialog.LineWidthInput.val(defaults.LineWidth);
        this.Grid.LineWidth = defaults.LineWidth;
      }
    }

    this.Layer.AddWidget(this);

    this.State = WAITING;
  }

    // sign specifies which corner is origin.
    // gx, gy is the point in grid pixel coordinates offset from the corner.
  GridWidget.prototype.ComputeCorner = function (xSign, ySign, gx, gy) {
        // Pick the upper left most corner to display the grid size text.
    var xRadius = this.Grid.BinWidth * this.Grid.Dimensions[0] / 2;
    var yRadius = this.Grid.BinHeight * this.Grid.Dimensions[1] / 2;
    xRadius += gx;
    yRadius += gy;
    var x = this.Grid.Origin[0];
    var y = this.Grid.Origin[1];
        // Choose the corner from 0 to 90 degrees in the window.
    var roll = (this.Layer.GetCamera().GetImageRotation() -
                    this.Grid.Orientation) / 90; // range 0-4
    roll = Math.round(roll);
        // Modulo that works with negative numbers;
    roll = ((roll % 4) + 4) % 4;
    var c = Math.cos(3.14156 * this.Grid.Orientation / 180.0);
    var s = Math.sin(3.14156 * this.Grid.Orientation / 180.0);
    var dx, dy;
    if (roll === 0) {
      dx = xSign * xRadius;
      dy = ySign * yRadius;
    } else if (roll === 3) {
      dx = xSign * xRadius;
      dy = -ySign * yRadius;
    } else if (roll === 2) {
      dx = -xSign * xRadius;
      dy = -ySign * yRadius;
    } else if (roll === 1) {
      dx = -xSign * xRadius;
      dy = ySign * yRadius;
    }
    x = x + c * dx + s * dy;
    y = y + c * dy - s * dx;

    return [x, y];
  };

  GridWidget.prototype.Draw = function (view) {
    this.Grid.Draw(view);

        // Corner in grid pixel coordinates.
    var x = -(this.Grid.BinWidth * this.Grid.Dimensions[0] / 2);
    var y = -(this.Grid.BinHeight * this.Grid.Dimensions[1] / 2);
    this.Text.Anchor = [0, 20];
    this.Text.Orientation = (this.Grid.Orientation -
                                 this.Layer.GetCamera().GetImageRotation());
        // Modulo that works with negative numbers;
    this.Text.Orientation = ((this.Text.Orientation % 360) + 360) % 360;
        // Do not draw text upside down.
    if (this.Text.Orientation > 90 && this.Text.Orientation < 270) {
      this.Text.Orientation -= 180.0;
      this.Text.Anchor = [this.Text.PixelBounds[1], 0];
            // x += this.Text.PixelBounds[1]; // wrong units (want world
            // pixels , this is screen pixels).
    }
        // Convert to world Coordinates.
    var radians = this.Grid.Orientation * Math.PI / 180;
    var c = Math.cos(radians);
    var s = Math.sin(radians);
    var wx = c * x + s * y;
    var wy = c * y - s * x;
    this.Text.Position = [this.Grid.Origin[0] + wx, this.Grid.Origin[1] + wy];

    this.Text.Draw(view);
  };

    // This needs to be put in the layer.
    // GridWidget.prototype.RemoveFromViewer = function() {
    //    if (this.Viewer) {
    //        this.Viewer.RemoveWidget(this);
    //    }
    // };

  GridWidget.prototype.PasteCallback = function (data, mouseWorldPt, camera) {
    this.Load(data);
        // Keep the pasted grid from rotating when the camera changes.
    var dr = this.Layer.GetCamera().GetImageRotation() -
        camera.GetImageRotation();
    this.Grid.Orientation += dr;
        // Place the widget over the mouse.
        // This would be better as an argument.
    this.Grid.Origin = [mouseWorldPt[0], mouseWorldPt[1]];
    this.Text.Position = [mouseWorldPt[0], mouseWorldPt[1]];

    if (this.UserNoteFlag && SA.notesWidget) { SA.notesWidget.EventuallySaveUserNote(); }
    if (SAM.NotesWidget && !this.UserNoteFlag) { SAM.NotesWidget.MarkAsModified(); } // Hack
    this.Layer.EventuallyDraw();
  };

  GridWidget.prototype.Serialize = function () {
    if (this.Grid === undefined) { return null; }
    var obj = {};
    obj.type = 'grid';
    obj.user_note_flag = this.UserNoteFlag;
    obj.origin = this.Grid.Origin;
    obj.lineColor = SAM.ConvertColorToHex(this.Grid.OutlineColor);
    obj.bin_width = this.Grid.BinWidth;
    obj.bin_height = this.Grid.BinHeight;
    obj.dimensions = this.Grid.Dimensions;
    obj.orientation = this.Grid.Orientation;
    obj.lineWidth = this.Grid.LineWidth;
    obj.creation_camera = this.CreationCamera;
    return obj;
  };

    // Load a widget from a json object (origin MongoDB).
  GridWidget.prototype.Load = function (obj) {
    this.UserNoteFlag = obj.user_note_flag;
    this.Grid.Origin[0] = parseFloat(obj.origin[0]);
    this.Grid.Origin[1] = parseFloat(obj.origin[1]);
    this.Grid.OutlineColor = SAM.CovertColor(obj.lineColor);
    if (obj.width) { this.Grid.BinWidth = parseFloat(obj.width); }
    if (obj.height) { this.Grid.BinHeight = parseFloat(obj.height); }
    if (obj.bin_width) { this.Grid.BinWidth = parseFloat(obj.bin_width); }
    if (obj.bin_height) { this.Grid.BinHeight = parseFloat(obj.bin_height); }
    this.Grid.Dimensions[0] = parseInt(obj.dimensions[0]);
    this.Grid.Dimensions[1] = parseInt(obj.dimensions[1]);
    this.Grid.Orientation = parseFloat(obj.orientation);
    this.Grid.LineWidth = parseFloat(obj.lineWidth);
    this.Grid.FixedSize = false;
    this.Grid.UpdateBuffers(this.Layer.AnnotationView);

    this.Text.String = SAM.DistanceToString(this.Grid.BinWidth * 0.25e-6);
        // Shallow copy is dangerous
    this.Text.Position = this.Grid.Origin;
    this.Text.UpdateBuffers(this.Layer.AnnotationView);

        // How zoomed in was the view when the annotation was created.
    if (obj.creation_camera !== undefined) {
      this.CreationCamera = obj.CreationCamera;
    }
  };

  GridWidget.prototype.HandleKeyPress = function (keyCode, shift) {
        // The dialog consumes all key events.
    if (this.State === PROPERTIES_DIALOG) {
      return false;
    }

        // Copy
    if (event.keyCode === 67 && event.ctrlKey) {
            // control-c for copy
            // The extra identifier is not needed for widgets, but will be
            // needed if we have some other object on the clipboard.
            // The camera is needed so grid does not rotate when pasting in
            // another stack section.
      var clip = {Type: 'GridWidget',
        Data: this.Serialize(),
        Camera: this.Layer.GetCamera().Serialize()};
      localStorage.ClipBoard = JSON.stringify(clip);
      return false;
    }

    return true;
  };

  GridWidget.prototype.HandleDoubleClick = function (event) {
    return true;
  };

  GridWidget.prototype.HandleMouseDown = function (event) {
    if (event.which !== 1) {
      return true;
    }
    var cam = this.Layer.GetCamera();
    this.DragLast = cam.ConvertPointViewerToWorld(event.offsetX, event.offsetY);
    return false;
  };

    // returns false when it is finished doing its work.
  GridWidget.prototype.HandleMouseUp = function (event) {
    this.SetActive(false);
    if (window.SA) { SA.RecordState(); }
    if (this.UserNoteFlag && SA.notesWidget) { SA.notesWidget.EventuallySaveUserNote(); }
    if (SAM.NotesWidget && !this.UserNoteFlag) { SAM.NotesWidget.MarkAsModified(); } // Hack

    return true;
  };

    // Orientation is a pain,  we need a world to shape transformation.
  GridWidget.prototype.HandleMouseMove = function (event) {
    if (event.which === 1) {
      var cam = this.Layer.GetCamera();
      var world =
                cam.ConvertPointViewerToWorld(event.offsetX, event.offsetY);
      var dx, dy;
      if (this.State === DRAG) {
        dx = world[0] - this.DragLast[0];
        dy = world[1] - this.DragLast[1];
        this.DragLast = world;
        this.Grid.Origin[0] += dx;
        this.Grid.Origin[1] += dy;
      } else {
                // convert mouse from world to Grid coordinate system.
        dx = world[0] - this.Grid.Origin[0];
        dy = world[1] - this.Grid.Origin[1];
        var c = Math.cos(3.14156 * this.Grid.Orientation / 180.0);
        var s = Math.sin(3.14156 * this.Grid.Orientation / 180.0);
        var x = c * dx - s * dy;
        var y = c * dy + s * dx;
                // convert from shape to integer grid indexes.
        x = (0.5 * this.Grid.Dimensions[0]) + (x / this.Grid.BinWidth);
        y = (0.5 * this.Grid.Dimensions[1]) + (y / this.Grid.BinHeight);
        var ix = Math.round(x);
        var iy = Math.round(y);
                // Change grid dimemsions
        dx = dy = 0;
        var changed = false;
        if (this.State === DRAG_RIGHT) {
          dx = ix - this.Grid.Dimensions[0];
          if (dx) {
            this.Grid.Dimensions[0] = ix;
                        // Compute the change in the center point origin.
            dx = 0.5 * dx * this.Grid.BinWidth;
            changed = true;
          }
        } else if (this.State === DRAG_LEFT) {
          if (ix) {
            this.Grid.Dimensions[0] -= ix;
                        // Compute the change in the center point origin.
            dx = 0.5 * ix * this.Grid.BinWidth;
            changed = true;
          }
        } else if (this.State === DRAG_BOTTOM) {
          dy = iy - this.Grid.Dimensions[1];
          if (dy) {
            this.Grid.Dimensions[1] = iy;
                        // Compute the change in the center point origin.
            dy = 0.5 * dy * this.Grid.BinHeight;
            changed = true;
          }
        } else if (this.State === DRAG_TOP) {
          if (iy) {
            this.Grid.Dimensions[1] -= iy;
                        // Compute the change in the center point origin.
            dy = 0.5 * iy * this.Grid.BinHeight;
            changed = true;
          }
        }
        if (changed) {
                    // Rotate the translation and apply to the center.
          x = c * dx + s * dy;
          y = c * dy - s * dx;
          this.Grid.Origin[0] += x;
          this.Grid.Origin[1] += y;
          this.Grid.UpdateBuffers(this.Layer.AnnotationView);
        }
      }
      this.Layer.EventuallyDraw();
      return;
    }

    if (event.which === 0) {
            // Update the active state if theuser is not interacting.
      this.SetActive(this.CheckActive(event));
    }

    return true;
  };

  GridWidget.prototype.HandleMouseWheel = function (event) {
        /*
        var x = event.offsetX;
        var y = event.offsetY;

        if (this.State === ACTIVE) {
            if(this.NormalizedActiveDistance < 0.5) {
                var ratio = 1.05;
                var direction = 1;
                if(event.wheelDelta < 0) {
                     ratio = 0.95;
                    direction = -1;
                }
                if(event.shiftKey) {
                    this.Grid.Length = this.Grid.Length * ratio;
                }
                if(event.ctrlKey) {
                    this.Grid.BinWidth = this.Grid.BinWidth * ratio;
                }
                if(!event.shiftKey && !event.ctrlKey) {
                    this.Grid.Orientation = this.Grid.Orientation + 3 * direction;
                 }

                this.Grid.UpdateBuffers(this.Layer.AnnotationView);
                this.PlacePopup();
                this.Layer.EventuallyDraw();
            }
        }
        */
  };

  GridWidget.prototype.HandleTouchPan = function (event) {
        /*
          w0 = this.Viewer.ConvertPointViewerToWorld(EVENT_MANAGER.LastMouseX,
          EVENT_MANAGER.LastMouseY);
          w1 = this.Viewer.ConvertPointViewerToWorld(event.offsetX,event.offsetY);

          // This is the translation.
          var dx = w1[0] - w0[0];
          var dy = w1[1] - w0[1];

          this.Grid.Origin[0] += dx;
          this.Grid.Origin[1] += dy;
          this.Layer.EventuallyDraw();
        */
    return true;
  };

  GridWidget.prototype.HandleTouchPinch = function (event) {
        // this.Grid.UpdateBuffers(this.Layer.AnnotationView);
        // this.Layer.EventuallyDraw();
    return true;
  };

  GridWidget.prototype.HandleTouchEnd = function (event) {
    if (this.UserNoteFlag && SA.notesWidget) { SA.notesWidget.EventuallySaveUserNote(); }
    if (SAM.NotesWidget && !this.UserNoteFlag) { SAM.NotesWidget.MarkAsModified(); } // Hack
    this.SetActive(false);
  };

  GridWidget.prototype.CheckActive = function (event) {
    var x, y;
    if (this.Grid.FixedSize) {
      x = event.offsetX;
      y = event.offsetY;
    } else {
      x = event.worldX;
      y = event.worldY;
    }
    x = x - this.Grid.Origin[0];
    y = y - this.Grid.Origin[1];
    // Rotate to grid.
    var c = Math.cos(3.14156 * this.Grid.Orientation / 180.0);
    var s = Math.sin(3.14156 * this.Grid.Orientation / 180.0);
    var rx = c * x - s * y;
    var ry = c * y + s * x;

    // Convert to grid coordinates (0 -> dims)
    x = (0.5 * this.Grid.Dimensions[0]) + (rx / this.Grid.BinWidth);
    y = (0.5 * this.Grid.Dimensions[1]) + (ry / this.Grid.BinHeight);
    var ix = Math.round(x);
    var iy = Math.round(y);
    if (ix < 0 || ix > this.Grid.Dimensions[0] ||
            iy < 0 || iy > this.Grid.Dimensions[1]) {
      this.SetActive(false);
      return false;
    }

    // x,y get the residual in pixels.
    x = (x - ix) * this.Grid.BinWidth;
    y = (y - iy) * this.Grid.BinHeight;

    // Compute the screen pixel size for tollerance.
    var tolerance = 5.0 / this.Layer.GetPixelsPerUnit();

    if (Math.abs(x) < tolerance || Math.abs(y) < tolerance) {
      this.ActiveIndex = [ix, iy];
      return true;
    }

    return false;
  };

    // Multiple active states. Active state is a bit confusing.
  GridWidget.prototype.GetActive = function () {
    if (this.State === WAITING) {
      return false;
    }
    return true;
  };

  GridWidget.prototype.Deactivate = function () {
    this.Layer.AnnotationView.Parent.css({'cursor': 'default'});
    this.Popup.StartHideTimer();
    this.State = WAITING;
    this.Grid.Active = false;
    this.Layer.DeactivateWidget(this);
    if (this.DeactivateCallback) {
      this.DeactivateCallback();
    }
    this.Layer.EventuallyDraw();
  };

    // Setting to active always puts state into "active".
    // It can move to other states and stay active.
  GridWidget.prototype.SetActive = function (flag) {
    if (flag) {
      this.State = ACTIVE;
      this.Grid.Active = true;

      if (!this.ActiveIndex) {
        console.log('No active index');
        return;
      }
      if (this.ActiveIndex[0] === 0) {
        this.State = DRAG_LEFT;
        this.Layer.AnnotationView.Parent.css({'cursor': 'col-resize'});
      } else if (this.ActiveIndex[0] === this.Grid.Dimensions[0]) {
        this.State = DRAG_RIGHT;
        this.Layer.AnnotationView.Parent.css({'cursor': 'col-resize'});
      } else if (this.ActiveIndex[1] === 0) {
        this.State = DRAG_TOP;
        this.Layer.AnnotationView.Parent.css({'cursor': 'row-resize'});
      } else if (this.ActiveIndex[1] === this.Grid.Dimensions[1]) {
        this.State = DRAG_BOTTOM;
        this.Layer.AnnotationView.Parent.css({'cursor': 'row-resize'});
      } else {
        this.State = DRAG;
        this.Layer.AnnotationView.Parent.css({'cursor': 'move'});
      }

            // Compute the location for the pop up and show it.
      this.PlacePopup();
    } else {
      this.Deactivate();
    }
    this.Layer.EventuallyDraw();
  };

    // This also shows the popup if it is not visible already.
  GridWidget.prototype.PlacePopup = function () {
        // Compute corner has its angle backwards.  I do not see how this works.
    var pt = this.ComputeCorner(1, -1, 0, 0);
    var cam = this.Layer.GetCamera();
    pt = cam.ConvertPointWorldToViewer(pt[0], pt[1]);
    this.Popup.Show(pt[0] + 10, pt[1] - 30);
  };

  GridWidget.prototype.ShowPropertiesDialog = function () {
    this.Dialog.ColorInput.val(SAM.ConvertColorToHex(this.Grid.OutlineColor));
    this.Dialog.LineWidthInput.val((this.Grid.LineWidth).toFixed(2));
        // convert 40x scan pixels into meters
    this.Dialog.BinWidthInput.val(SAM.DistanceToString(this.Grid.BinWidth * 0.25e-6));
    this.Dialog.BinHeightInput.val(SAM.DistanceToString(this.Grid.BinHeight * 0.25e-6));
    this.Dialog.RotationInput.val(this.Grid.Orientation);

    this.Dialog.Show(true);
  };

  GridWidget.prototype.DialogApplyCallback = function () {
    var hexcolor = this.Dialog.ColorInput.val();
    this.Grid.SetOutlineColor(hexcolor);
    this.Grid.LineWidth = parseFloat(this.Dialog.LineWidthInput.val());
    this.Grid.BinWidth = SAM.StringToDistance(this.Dialog.BinWidthInput.val()) * 4e6;
    this.Grid.BinHeight = SAM.StringToDistance(this.Dialog.BinHeightInput.val()) * 4e6;
    this.Grid.Orientation = parseFloat(this.Dialog.RotationInput.val());
    this.Grid.UpdateBuffers(this.Layer.AnnotationView);
    this.SetActive(false);

    this.Text.String = SAM.DistanceToString(this.Grid.BinWidth * 0.25e-6);
    this.Text.UpdateBuffers(this.Layer.AnnotationView);

    if (window.SA) { SA.RecordState(); }
    this.Layer.EventuallyDraw();

    if (this.UserNoteFlag && SA.notesWidget) { SA.notesWidget.EventuallySaveUserNote(); }
    if (SAM.NotesWidget && !this.UserNoteFlag) { SAM.NotesWidget.MarkAsModified(); } // Hack
    localStorage.GridWidgetDefaults = JSON.stringify({Color: hexcolor, LineWidth: this.Grid.LineWidth});
  };

  SAM.GridWidget = GridWidget;
})();

(function () {
  'use strict';

  var WAITING = 3; // The normal (resting) state.
  var ACTIVE = 4; // Mouse is over the widget and it is receiving events.

  // view argument is the main view (needed to get the spacing...)
  // Viewer coordinates.
  // Horizontal or vertical
  function Scale () {
    SAM.Shape.call(this);
    // Dimension of scale element
    this.BinLength = 100.0; // unit length in screen pixels
    this.TickSize = 6; // Screen pixels
    this.NumberOfBins = 1;
    this.Orientation = 0; // 0 or 90
    this.Origin = [10000, 10000]; // middle.
    this.OutlineColor = [0, 0, 0];
    this.PointBuffer = [];
    this.PositionCoordinateSystem = SAM.Shape.VIEWER;
  }

  Scale.prototype = new SAM.Shape();

  Scale.prototype.destructor = function () {
    // Get rid of the buffers?
  };

  Scale.prototype.UpdateBuffers = function (view) {
    // TODO: Having a single poly line for a shape is to simple.
    // Add cell arrays.
    this.PointBuffer = [];

    // Matrix is computed by the draw method in Shape superclass.
    // TODO: Used to detect first initialization.
    // Get this out of this method.
    this.Matrix = mat4.create();
    mat4.identity(this.Matrix);

    // Draw all of the x lines.
    var x = 0;
    var y = this.TickSize;
    this.PointBuffer.push(x);
    this.PointBuffer.push(y);
    this.PointBuffer.push(0.0);
    y = 0;
    this.PointBuffer.push(x);
    this.PointBuffer.push(y);
    this.PointBuffer.push(0.0);

    for (var i = 0; i < this.NumberOfBins; ++i) {
      x += this.BinLength;
      this.PointBuffer.push(x);
      this.PointBuffer.push(y);
      this.PointBuffer.push(0.0);
      y = this.TickSize;
      this.PointBuffer.push(x);
      this.PointBuffer.push(y);
      this.PointBuffer.push(0.0);
      y = 0;
      this.PointBuffer.push(x);
      this.PointBuffer.push(y);
      this.PointBuffer.push(0.0);
    }
  };

  function ScaleWidget () {
    this.PixelsPerMeter = 0;
    this.Shape = new Scale();
    this.Shape.OutlineColor = [0.0, 0.0, 0.0];
    this.Shape.Origin = [200, 15];
    this.Shape.BinLength = 200;
    this.Shape.FixedSize = true;

    this.Text = new SAM.Text();
    this.Text.PositionCoordinateSystem = SAM.Shape.VIEWER;
    this.Text.Position = [200, 0];
    this.Text.String = '';
    this.Text.Color = [0.0, 0.0, 0.0];
    // I want the anchor to be the center of the text.
    // This is a hackl estimate.
    this.Text.Anchor = [20, 0];

    this.State = WAITING;
  }

  // Change the length of the scale based on the camera.
  ScaleWidget.prototype.Update = function (view) {
    if (!view) { return; }
    // Compute the number of screen pixels in a meter.
    var scale = Math.round(
      view.GetPixelsPerUnit() / view.GetMetersPerUnit());
    if (this.PixelsPerMeter === scale) {
      return;
    }

    // Save the scale so we know when to regenerate.
    this.PixelsPerMeter = scale;
    var target = 200; // pixels
    var e = 0;
        // Note: this assumes max bin length is 1 meter.
    var binLengthViewer = this.PixelsPerMeter;
        // keep reducing the length until it is reasonable.
    while (binLengthViewer > target) {
      binLengthViewer = binLengthViewer / 10;
      --e;
    }
    // Now compute the units from e.
    this.Units = 'nm';
    var factor = 1e-9;
    if (e >= -6) {
      this.Units = '\xB5m';
      factor = 1e-6;
    }
    if (e >= -3) {
      this.Units = 'mm';
      factor = 1e-3;
    }
    if (e >= -2) {
      this.Units = 'cm';
      factor = 1e-2;
    }
    if (e >= 0) {
      this.Units = 'm';
      factor = 1;
    }
    if (e >= 3) {
      this.Units = 'km';
      factor = 1000;
    }
    // Length is set to the viewer pixel length of a tick / unit.
    this.Shape.BinLength = binLengthViewer;
    // Now add bins to get close to the target length.
    this.Shape.NumberOfBins = Math.floor(target / binLengthViewer);
    // compute the length of entire scale bar (units: viewer pixels).
    var scaleLengthViewer = binLengthViewer * this.Shape.NumberOfBins;
    var scaleLengthMeters = scaleLengthViewer / this.PixelsPerMeter;
    // Compute the label.
    // The round should not change the value, only get rid of numerical error.
    var labelNumber = Math.round(scaleLengthMeters / factor);
    this.Label = labelNumber.toString() + this.Units;

    // Save the length of the scale bar in world units.
    // World (highest res image) pixels default to 0.25e-6 meters.
    this.LengthWorld = scaleLengthMeters * 4e6;

    // Update the label text and position
    this.Text.String = this.Label;
    this.Text.UpdateBuffers(view);
    this.Text.Position = [this.Shape.Origin[0] + (scaleLengthViewer / 2),
      this.Shape.Origin[1] - 15];

    this.Shape.UpdateBuffers(view);
  };

  ScaleWidget.prototype.Draw = function (view) {
    if (!view || !view.HasUnits()) {
      return;
    }
    // Update the scale if zoom changed.
    this.Update(view);
    this.Shape.Draw(view);
    this.Text.Draw(view);
  };

    // This needs to be put in the Viewer.
    // ScaleWidget.prototype.RemoveFromViewer = function() {
    //    if (this.Layer) {
    //        this.RemoveWidget(this);
    //    }
    // };

  ScaleWidget.prototype.HandleKeyPress = function (keyCode, shift) {
    return true;
  };

  ScaleWidget.prototype.HandleDoubleClick = function (event) {
    return true;
  };

  ScaleWidget.prototype.HandleMouseDown = function (event) {
        /*
        if (event.which !== 1) {
            return true;
        }
        this.DragLast = this.Layer.ConvertPointViewerToWorld(event.offsetX, event.offsetY);
        */
    return false;
  };

    // returns false when it is finished doing its work.
  ScaleWidget.prototype.HandleMouseUp = function (event) {
        /*
        this.SetActive(false);
        if (window.SA) {SA.RecordState();}
        */
    return true;
  };

    // Orientation is a pain,  we need a world to shape transformation.
  ScaleWidget.prototype.HandleMouseMove = function (event) {
        /*
        if (event.which === 1) {
            var world =
                this.Layer.ConvertPointViewerToWorld(event.offsetX, event.offsetY);
            var dx, dy;
            if (this.State === DRAG) {
                dx = world[0] - this.DragLast[0];
                dy = world[1] - this.DragLast[1];
                this.DragLast = world;
                this.Shape.Origin[0] += dx;
                this.Shape.Origin[1] += dy;
            } else {
                // convert mouse from world to Shape coordinate system.
                dx = world[0] - this.Shape.Origin[0];
                dy = world[1] - this.Shape.Origin[1];
                var c = Math.cos(3.14156* this.Shape.Orientation / 180.0);
                var s = Math.sin(3.14156* this.Shape.Orientation / 180.0);
                var x = c*dx - s*dy;
                var y = c*dy + s*dx;
                // convert from shape to integer scale indexes.
                x = (0.5*this.Shape.Dimensions[0]) + (x /
                  this.Shape.Width);
                y = (0.5*this.Shape.Dimensions[1]) + (y /
                  this.Shape.Height);
                var ix = Math.round(x);
                var iy = Math.round(y);
                // Change scale dimemsions
                dx = dy = 0;
                var changed = false;
                if (this.State === DRAG_RIGHT) {
                    dx = ix - this.Shape.Dimensions[0];
                    if (dx) {
                        this.Shape.Dimensions[0] = ix;
                        // Compute the change in the center point origin.
                        dx = 0.5 * dx * this.Shape.Width;
                        changed = true;
                    }
                } else if (this.State === DRAG_LEFT) {
                    if (ix) {
                        this.Shape.Dimensions[0] -= ix;
                        // Compute the change in the center point origin.
                        dx = 0.5 * ix * this.Shape.Width;
                        changed = true;
                    }
                } else if (this.State === DRAG_BOTTOM) {
                    dy = iy - this.Shape.Dimensions[1];
                    if (dy) {
                        this.Shape.Dimensions[1] = iy;
                        // Compute the change in the center point origin.
                        dy = 0.5 * dy * this.Shape.Height;
                        changed = true;
                    }
                } else if (this.State === DRAG_TOP) {
                    if (iy) {
                        this.Shape.Dimensions[1] -= iy;
                        // Compute the change in the center point origin.
                        dy = 0.5 * iy * this.Shape.Height;
                        changed = true;
                    }
                }
                if (changed) {
                    // Rotate the translation and apply to the center.
                    x = c*dx + s*dy;
                    y = c*dy - s*dx;
                    this.Shape.Origin[0] += x;
                    this.Shape.Origin[1] += y;
                    this.Shape.UpdateBuffers(this.Layer.AnnotationView);
                }
            }
            eventuallyRender();
            return
        }

        this.CheckActive(event);
*/
    return true;
  };

  ScaleWidget.prototype.HandleMouseWheel = function (event) {
        /*
        var x = event.offsetX;
        var y = event.offsetY;

        if (this.State === ACTIVE) {
            if(this.NormalizedActiveDistance < 0.5) {
                var ratio = 1.05;
                var direction = 1;
                if(event.wheelDelta < 0) {
                     ratio = 0.95;
                    direction = -1;
                }
                if(event.shiftKey) {
                    this.Shape.BinLength = this.Shape.BinLength * ratio;
                }
                if(event.ctrlKey) {
                    this.Shape.Width = this.Shape.Width * ratio;
                }
                if(!event.shiftKey && !event.ctrlKey) {
                    this.Shape.Orientation = this.Shape.Orientation + 3 * direction;
                 }

                this.Shape.UpdateBuffers(this.Layer.AnnotationView);
                this.PlacePopup();
                eventuallyRender();
            }
        }
        */
  };

  ScaleWidget.prototype.HandleTouchPan = function (event) {
        /*
          w0 = this.Layer.ConvertPointViewerToWorld(EVENT_MANAGER.LastMouseX,
          EVENT_MANAGER.LastMouseY);
          w1 = this.Layer.ConvertPointViewerToWorld(event.offsetX,event.offsetY);

          // This is the translation.
          var dx = w1[0] - w0[0];
          var dy = w1[1] - w0[1];

          this.Shape.Origin[0] += dx;
          this.Shape.Origin[1] += dy;
          eventuallyRender();
        */
    return true;
  };

  ScaleWidget.prototype.HandleTouchPinch = function (event) {
        // this.Shape.UpdateBuffers(this.Layer.AnnotationView);
        // eventuallyRender();
    return true;
  };

  ScaleWidget.prototype.HandleTouchEnd = function (event) {
    this.SetActive(false);
  };

  ScaleWidget.prototype.CheckActive = function (event) {
        /*
        var x,y;
        if (this.Shape.FixedSize) {
            x = event.offsetX;
            y = event.offsetY;
            pixelSize = 1;
        } else {
            x = event.worldX;
            y = event.worldY;
        }
        x = x - this.Shape.Origin[0];
        y = y - this.Shape.Origin[1];
        // Rotate to scale.
        var c = Math.cos(3.14156* this.Shape.Orientation / 180.0);
        var s = Math.sin(3.14156* this.Shape.Orientation / 180.0);
        var rx = c*x - s*y;
        var ry = c*y + s*x;

        // Convert to scale coordinates (0 -> dims)
        x = (0.5*this.Shape.Dimensions[0]) + (rx / this.Shape.Width);
        y = (0.5*this.Shape.Dimensions[1]) + (ry / this.Shape.Height);
        var ix = Math.round(x);
        var iy = Math.round(y);
        if (ix < 0 || ix > this.Shape.Dimensions[0] ||
            iy < 0 || iy > this.Shape.Dimensions[1]) {
            this.SetActive(false);
            return false;
        }

        // x,y get the residual in pixels.
        x = (x - ix) * this.Shape.Width;
        y = (y - iy) * this.Shape.Height;

        // Compute the screen pixel size for tollerance.
        var tolerance = 5.0 / this.Layer.GetPixelsPerUnit();

        if (Math.abs(x) < tolerance || Math.abs(y) < tolerance) {
            this.SetActive(true);
            if (ix === 0) {
                this.State = DRAG_LEFT;
                thisLayer.AnnotationView.Parent.css({'cursor':'col-resize'});
            } else if (ix === this.Shape.Dimensions[0]) {
                this.State = DRAG_RIGHT;
                this.Layer.AnnotationView.Parent.css({'cursor':'col-resize'});
            } else if (iy === 0) {
                this.State = DRAG_TOP;
                this.Viewer.AnnotationView.Parent.css({'cursor':'row-resize'});
            } else if (iy === this.Shape.Dimensions[1]) {
                this.State = DRAG_BOTTOM;
                this.Layer.MainView.Parent.css({'cursor':'row-resize'});
            } else {
                this.State = DRAG;
                this.Layer.MainView.Parent.css({'cursor':'move'});
            }
            return true;
        }
        */
    this.SetActive(false);
    return false;
  };

    // Multiple active states. Active state is a bit confusing.
  ScaleWidget.prototype.GetActive = function () {
    if (this.State === WAITING) {
      return false;
    }
    return true;
  };

  ScaleWidget.prototype.Deactivate = function () {
    // this.View.Parent.css({'cursor': 'default'});
    // this.Popup.StartHideTimer();
    this.State = WAITING;
    this.Shape.Active = false;
    // this.Layer.DeactivateWidget(this);
    // if (this.DeactivateCallback) {
    //   this.DeactivateCallback();
    // }
    this.Layer.EventuallyDraw();
  };

    // Setting to active always puts state into "active".
    // It can move to other states and stay active.
  ScaleWidget.prototype.SetActive = function (flag) {
    if (flag === this.GetActive()) {
      return;
    }

    if (flag) {
      this.State = ACTIVE;
      this.Shape.Active = true;
      // this.Layer.ActivateWidget(this);
      // this.Layer.EventuallyDraw();
      // Compute the location for the pop up and show it.
    } else {
      this.Deactivate();
    }
    // this.Layer.EventuallyDraw();
  };

  SAM.ScaleWidget = ScaleWidget;
})();

(function () {
  'use strict';

  function Dialog (parent) {
    parent = parent || 'body';
    if (!SAM.DialogOverlay) {
      SAM.DialogOverlay = $('<div>')
                .appendTo(parent)
                .css({
                  'position': 'fixed',
                  'left': '0px',
                  'width': '100%',
                  'background-color': '#AAA',
                  'opacity': '0.4',
                  'z-index': '1010'})
                .saFullHeight()
                .hide();
    }

    this.Dialog =
            $('<div>')
            .appendTo(parent)
            .css({'z-index': '1011'})
            .addClass('sa-view-dialog-div');

    this.Row1 = $('<div>')
            .addClass('sa-view-dialog-title')
            .appendTo(this.Dialog)
            .css({'width': '100%',
              'height': '2.5em',
              'box-sizing': 'border-box'});
    this.Title = $('<div>')
            .appendTo(this.Row1)
            .css({'float': 'left'})
            .addClass('sa-view-dialog-title')
            .text('Title');
    this.CloseButton = $('<div>')
            .appendTo(this.Row1)
            .css({'float': 'right'})
            .addClass('sa-view-dialog-close')
            .text('Close');

    this.Body =
            $('<div>')
            .appendTo(this.Dialog)
            .css({'width': '100%',
              'box-sizing': 'border-box',
              'margin-bottom': '30px'});

    this.ApplyButtonDiv = $('<div>')
            .appendTo(this.Dialog)
            .addClass('sa-view-dialog-apply-div');
    this.ApplyButton = $('<button>')
            .appendTo(this.ApplyButtonDiv)
            .addClass('sa-view-dialog-apply-button')
            .text('Apply');
  }

  Dialog.prototype.SetApplyCallback = function (callback) {
    var self = this;
    // Return true needed to hide the spectrum color picker.
    self.ApplyButton.click(function (e) {
      // hack
      SA.ContentEditableHasFocus = false;
      self.Hide();
      (callback)();
      return true;
    });
  };

  Dialog.prototype.SetCloseCallback = function (callback) {
    var self = this;
    // Return true needed to hide the spectrum color picker.
    this.CloseButton.click(function (e) {
      SA.ContentEditableHasFocus = false;
      self.Hide();
      (callback)();
      return true;
    });
  };

  Dialog.prototype.Show = function (modal) {
        // hack
    SA.ContentEditableHasFocus = true;
    var self = this;
    SAM.DialogOverlay.show();
    this.Dialog.fadeIn(300);

    if (modal) {
      SAM.DialogOverlay.off('click.dialog');
    } else {
      SAM.DialogOverlay.on(
                'click.dialog',
                function (e) { self.Hide(); });
    }
    SAM.ContentEditableHasFocus = true; // blocks viewer events.
  };

  Dialog.prototype.Hide = function () {
    SAM.DialogOverlay.off('click.dialog');
    SAM.DialogOverlay.hide();
    this.Dialog.fadeOut(300);
    SAM.ContentEditableHasFocus = false;
  };

  SAM.Dialog = Dialog;
})();

// ==============================================================================
// Iterate over ractangle annotations.
// Right now, add an arrow for each.

// Load arrows on page load and next image.
// Save arrows on next image.

// TODO: Merge this with annotation editor.  Copied from that class, and much of the code is the same.

(function () {
  'use strict';

  // action states
  var KEY_UP = 0;
  // var KEY_DOWN = 1;
  // var KEY_USED_ADVANCE = 2;
  // var KEY_USED_NO_ADVANCE = 3;

  var GirderAnnotationIterator = function (parent, viewer, itemId, classes) {
    // when iterating, only show the current rect.
    this.HighlightedRect = new SAM.Rect();
    this.HighlightedRect.OutlineColor = [1, 1, 0];

    // quick hack to add arrows.
    this.ArrowMode = true;

    // Make an anntoation layer a helper object.
    this.ViewerParent = viewer.GetDiv();
    this.Layer = new SAM.AnnotationLayer(this.ViewerParent);
    this.Layer.SetCamera(viewer.GetCamera());
    viewer.AddLayer(this);

    if (this.ArrowMode) {
      this.ArrowLayer = new SAM.AnnotationLayer(this.ViewerParent);
      this.ArrowLayer.SetCamera(viewer.GetCamera());
      this.LoadItemArrows(itemId, 'plane-nose', this.ArrowLayer);
    }

    this.Viewer = viewer;
    this.ActiveClassIndex = 0;
    this.ItemId = itemId;
    this.CreateClasses(classes);

    // Combined key click action.
    this.ActionState = KEY_UP;

    this.InitializeGui(parent, 'GirderAnnotationIterator');

    // Mode: stepping through ( and processing events).
    this.IteratorIndex = -1;

    // active class is highlighted in the gui.
    // It is the class used for clicks
    this.SetActiveClassIndex(0);
  };

  // Since we have to make forwarding methods, just use the layer as a helper object.
  GirderAnnotationIterator.prototype.EventuallyDraw = function () {
    if (!this.RenderPending) {
      this.RenderPending = true;
      var self = this;
      window.requestAnimationFrame(
        function () {
          self.RenderPending = false;
          self.Draw();
        });
    }
    // this.Layer.EventuallyDraw();
  };
  GirderAnnotationIterator.prototype.GetView = function () {
    return this.Layer.GetView();
  };
  GirderAnnotationIterator.prototype.GetCamera = function () {
    return this.Layer.GetCamera();
  };
  GirderAnnotationIterator.prototype.Remove = function () {
    // We are moving to the next slide in the folder and this object is being
    // discarded. Save the arrows.
    // this.Save();

    this.LayerControl.remove();
    this.InstructionsHeading.remove();
    this.InstructionsUL.remove();

    this.Layer.Remove();
    if (this.ArrowLayer) {
      this.ArrowLayer.Remove();
    }
    this.Viewer.RemoveLayer(this);
  };
  GirderAnnotationIterator.prototype.UpdateSize = function () {
    this.Layer.UpdateSize();
    if (this.ArrowLayer) {
      this.ArrowLayer.UpdateSize();
    }
  };

  GirderAnnotationIterator.prototype.CreateClasses = function (classNames) {
    var numClasses = classNames.length;
    this.Classes = [];
    for (var i = 0; i < numClasses; ++i) {
      var classObj = {
        label: classNames[i],
        index: i};
      this.Classes.push(classObj);
      // assign colors to the labels
      // detections will be yellow
      // Detection class is yellow.
      if (i === 0) {
        classObj.color = '#FFFF00';
      } else if (i === 1) { // Second (false positive) is red
        classObj.color = '#FF0000';
      } else if (i === 2) { // last (true positive) is green
        classObj.color = '#00FF00';
      } else {
        // the rest will range from purple to cyan
        var k = (i - 3) / (numClasses - 4);
        this.Classes[i].color = SAM.ConvertColorToHex([k, 1 - k, 1]);
      }
      this.RequestAnnotationFromName(classObj);
    }
  };

  GirderAnnotationIterator.prototype.RequestAnnotationFromName = function (classObj) {
    if (!window.girder) {
      window.alert('Could not find girder client');
      return;
    }
    var self = this;
    girder.rest.restRequest({
      url: 'annotation?itemId=' + this.ItemId + '&name=' + classObj.label + '&limit=1',
      method: 'GET'
    }).done(function (data) {
      if (data.length > 0) {
        // The annotation exists.  Reuest it.
        classObj.annotation_id = data[0]['_id'];
        self.RequestAnnotationFromId(classObj);
      } else {
        // Annotation does not exist yet.  Make it.
        var annot = {
          'elements': [],
          'name': classObj.label};
        // Make a new annotation in the database.
        girder.rest.restRequest({
          url: 'annotation?itemId=' + self.ItemId,
          method: 'POST',
          contentType: 'application/json',
          data: JSON.stringify(annot)
        }).done(function (retAnnot) {
          // This has the girder id.
          classObj.annotation_id = retAnnot['_id'];
          self.LoadAnnotation(retAnnot, classObj);
        });
      }
    });
  };

  GirderAnnotationIterator.prototype.RequestAnnotationFromId = function (classObj) {
    if (!window.girder) {
      window.alert('Could not find girder client');
      return;
    }
    var self = this;
    girder.rest.restRequest({
      url: 'annotation/' + classObj.annotation_id,
      method: 'GET',
      contentType: 'application/json'
    }).done(function (data) {
      self.LoadAnnotation(data, classObj);
    });
  };

  // TODO: Share this code (to parse girder data) with girderWidget.
  GirderAnnotationIterator.prototype.LoadAnnotation = function (data, classObj) {
    // Used for saving the annotation back to girder.
    classObj.annotation = data.annotation;

    // Put all the rectangles into one set.
    var setObj = {};
    setObj.type = 'rect_set';
    setObj.centers = [];
    setObj.widths = [];
    setObj.heights = [];
    setObj.confidences = [];
    setObj.labels = [];

    var annot = data.annotation;
    for (var i = 0; i < annot.elements.length; ++i) {
      var element = annot.elements[i];

      if (element.type === 'rectangle') {
        setObj.widths.push(element.width);
        setObj.heights.push(element.height);
        setObj.centers.push(element.center[0]);
        setObj.centers.push(element.center[1]);
        if (element.scalar === undefined) {
          element.scalar = 1.0;
        }
        setObj.confidences.push(element.scalar);
        // ignore the database label because we use our own
        setObj.labels.push(classObj.label);
      }
    }

    var widget = new SAM.RectSetWidget();
    widget.Load(setObj);
    widget.Hash = new SpatialHash();
    var bds = this.Viewer.GetOverViewBounds();
    widget.Hash.Build(widget.Shape, bds);

    // We want to color by labels (not widget)
    var shape = widget.Shape;
    if (!shape.LabelColors) {
      shape.LabelColors = {};
      // Colors setup in contructor.
      for (i = 0; i < this.Classes.length; ++i) {
        shape.LabelColors[this.Classes[i].label] = this.Classes[i].color;
      }
    }

    classObj.widget = widget;
    widget.Shape.SetOutlineColor(classObj.color);
    this.EventuallyDraw();
  };

  // Use the last size, or one from the active widgets.
  // Limit by sensible sizes for the viewer.
  GirderAnnotationIterator.prototype.GetSquareSize = function () {
    // if (localStorage.GirderAnnotationIteratorDefaults) {
    //   var defaults = JSON.parse(localStorage.GirderAnnotationIteratorDefaults);
    var size = 64;
    if (this.SquareSize) {
      // Default to the last size applied
      size = this.SquareSize;
    } else if (this.Classes.length > 0) {
      // Look to previous annotations for a size/
      var classObj = this.Classes[this.ActiveClassIndex];
      if (classObj.widget) {
        var rectSet = classObj.widget.Shape;
        if (rectSet.Heights.length > 0) {
          size = rectSet.Heights[0];
        }
      }
    }
    // Constrain the size to be visible.
    var cam = this.GetCamera();
    var viewHeight = cam.GetHeight();
    if (size > viewHeight / 0.75) {
      size = viewHeight / 0.75;
      this.SquareSize = size;
    }
    // Use pixel size to limit the smaller rect.
    var viewPixelSize = cam.GetSpacing();
    if (size < viewPixelSize * 10) {
      size = viewPixelSize * 10;
      this.SquareSize = size;
    }

    return size;
  };

  // Returns true if it was a valid class index.
  GirderAnnotationIterator.prototype.SetActiveClassIndex = function (idx) {
    if (idx < 0 || idx >= this.Classes.length) {
      return false;
    }
    this.Classes[this.ActiveClassIndex].gui
            .css({'background-color': '#FFF'});
    this.ActiveClassIndex = idx;
    this.Classes[idx].gui
            .css({'background-color': '#DEF'});
    this.SetCursorColor(this.ViewerParent, this.Classes[idx].color);
    if (!this.IteratorClass) {
      var selectedClass = this.Classes[idx];
      this.ActiveLabel.text(selectedClass.label);
    }
    return false;
  };

  GirderAnnotationIterator.prototype.GetActive = function () {
    // return this.IteratorIndex > -1;
    return true;
  };

  // TODO: Clean this up.  Probably put the widgets in the layer.
  GirderAnnotationIterator.prototype.Draw = function () {
    this.Layer.Draw();
    var view = this.Layer.GetView();
    this.HighlightedRect.Draw(view);
    if (this.ArrowLayer) {
      this.ArrowLayer.Draw();
    }

    for (var i = 0; i < this.Classes.length; ++i) {
      if (this.Classes[i].widget) {
        this.Classes[i].widget.Draw(this.Layer);
      }
    }
  };

  GirderAnnotationIterator.prototype.HandleMouseDown = function (event) {
    if (this.ArrowLayer) {
      return this.ArrowLayer.HandleMouseDown(event);
    }
    return true;
  };

  GirderAnnotationIterator.prototype.HandleMouseUp = function (event) {
    if (this.ArrowLayer) {
      return this.ArrowLayer.HandleMouseUp(event);
    }
    return true;
  };

  GirderAnnotationIterator.prototype.HandleMouseClick = function (event) {
    // We even give inactive layers a chance to claim the selection.
    // It is a way to find which group a mark belongs to.
    var selectedWidget = this.ArrowLayer.HandleSelect(event);
    if (selectedWidget === this.SelectedWidget) {
      return;
    }
    if (this.SelectedWidget) {
      this.SelectedWidget.SetActive(false);
      this.SelectedWidget.SetSelected(false);
    }
    if (selectedWidget) {
      selectedWidget.SetActive(true);
      this.SelectedWidget = selectedWidget;
      return false;
    }
    this.SelectedWidget = undefined;
    return true;
  };

  // Highlight on hover.
  GirderAnnotationIterator.prototype.HandleMouseMove = function (event) {
    if (this.ArrowLayer) {
      return this.ArrowLayer.HandleMouseMove(event);
    }
    return true;
  };

  // Make the annotation larger and smaller with the mouse wheel.
  // TODO: Remove this legacy function
  GirderAnnotationIterator.prototype.HandleMouseWheel = function (event) {
    return true;
  };

  // Stepping through the detection sequence.
  // -1 is none
  GirderAnnotationIterator.prototype.SetIteratorIndex = function (idx) {
    // Highlight the current
    this.SetHighlightedRect(this.IteratorClass, idx);
    this.IteratorIndex = idx;
    if (idx === -1) {
      this.IteratorClass = undefined;
    }
    // Animate to put this rec in the middle of the view.
    this.UpdateActiveView();
  };

  // The highlighted rect (sometimes the same as the
  // iteration index / rect).
  GirderAnnotationIterator.prototype.SetHighlightedRect = function (classObj, idx) {
    var widget = classObj.widget;
    var rectSet = widget.Shape;

    widget.Visibility = false;
    this.HighlightedRect.Visibility = true;
    this.HighlightedRect.Width = rectSet.Widths[idx];
    this.HighlightedRect.Height = rectSet.Heights[idx];
    this.HighlightedRect.Orientation = 0; // rectSet.Orientations[idx];
    var x = rectSet.Centers[idx * 2];
    var y = rectSet.Centers[idx * 2 + 1];
    this.HighlightedRect.Origin = [x, y];
    // this.OutlineColor = [0, 0, 0];
    this.HighlightedRect.UpdateBuffers();

    this.EventuallyDraw();
  };

  GirderAnnotationIterator.prototype.HandleKeyDown = function (event) {
    if (this.IteratorClass) {
      return false;
    }
    if (this.ArrowLayer) {
      return this.ArrowLayer.HandleMouseUp(event);
    }
    return true;
  };

  GirderAnnotationIterator.prototype.HandleKeyUp = function (event) {
    if (this.IteratorClass) {
      // iterating
      if (event.keyCode === 46 || event.keyCode === 8) { // delete key
        if (this.ArrowLayer) {
          this.ArrowLayer.DeleteSelected();
          this.ArrowLayer.EventuallyDraw();
        }
        event.preventDefault();
        return false;
      }

      // Escape key stops iteration.
      if (event.keyCode === 27) { // escape
        this.Stop();
        return false;
      }

      // Forward and backward.
      if (this.IteratorClass) {
        if (event.keyCode === 37) {
          // Left cursor key
          this.ChangeCurrent(-1);
          return false;
        } else if (event.keyCode === 39 || event.keyCode === 32) {
          // Right cursor key (or space bar)
          this.ChangeCurrent(1);
          return false;
        }
      }
    }

    if (this.ArrowLayer) {
      return this.ArrowLayer.HandleMouseUp(event);
    }
    return true;
  };

  // Animate to the new current rect.
  GirderAnnotationIterator.prototype.UpdateActiveView = function () {
    if (this.IteratorClass === undefined ||
        this.IteratorClass.widget === undefined) {
      return true;
    }

    var rectSet = this.IteratorClass.widget.Shape;

    // Change the index / confidence label.
    var idx = this.IteratorIndex;
    if (idx < 0) {
      var selectedClass = this.Classes[this.ActiveClassIndex];
      this.ActiveLabel.text(selectedClass.label);
      return;
    } else {
      this.ActiveLabel.text(idx.toString() + ' of ' +
                            rectSet.Labels.length.toString() + ', ' +
                            rectSet.Confidences[idx].toPrecision(2) +
                            ', ' + rectSet.Labels[idx]);
    }

    var viewer = this.Viewer;
    // viewer.ZoomTarget = this.Layer.GetCamera().GetHeight();
    viewer.RollTarget = this.GetCamera().GetWorldRoll();
    viewer.TranslateTarget = rectSet.GetCenter(this.IteratorIndex);
    viewer.AnimateLast = new Date().getTime();
    viewer.AnimateDuration = 200.0;
    viewer.EventuallyRender(true);
  };

  GirderAnnotationIterator.prototype.HandleArrowFinished = function (widget) {
    this.ArrowWidget = undefined;
  };

  GirderAnnotationIterator.prototype.StartArrow = function (widget) {
    if (this.SelectedWidget) {
      this.SelectedWidget.SetActive(false);
      this.SelectedWidget.SetSelected(false);
    }
    var self = this;
    if (!this.ArrowWidget) {
      this.ArrowWidget = new SAM.ArrowWidget(this.ArrowLayer);
      this.ArrowWidget.SetColor('#00ffff');
      this.ArrowWidget.Arrow.Width = 2.0;
      this.ArrowLayer.AddWidget(this.ArrowWidget);
      this.ArrowWidget.SetStateToDrawing();
      this.ArrowWidget.SetStateChangeCallback(
        function (widget) { self.HandleArrowFinished(widget); });
    }
  };

  GirderAnnotationIterator.prototype.LoadItemArrows = function (itemId, name, layer) {
    var self = this;
    girder.rest.restRequest({
      url: 'annotation?itemId=' + itemId + '&name=' + name + '&limit=1',
      method: 'GET'
    }).done(function (data) {
      if (data.length > 0) {
        // The annotation exists.  Reuest it.
        self.ArrowAnnotationId = data[0]['_id'];
        girder.rest.restRequest({
          url: 'annotation/' + self.ArrowAnnotationId,
          method: 'GET',
          contentType: 'application/json'
        }).done(function (data) {
          self.LoadAnnotationArrows(data);
        });
      } else {
        // Annotation does not exist yet.  Make an empty one.
        var annot = {
          'elements': [],
          'name': name};
        self.ArrowAnnotation = annot;
        // Make a new annotation in the database.
        girder.rest.restRequest({
          url: 'annotation?itemId=' + itemId,
          method: 'POST',
          contentType: 'application/json',
          data: JSON.stringify(annot)
        }).done(function (retAnnot) {
          // This has the girder id.
          self.ArrowAnnotationId = retAnnot['_id'];
        });
      }
    });
  };

  // TODO: Share this code (to parse girder data) with girderWidget.
  GirderAnnotationIterator.prototype.LoadAnnotationArrows = function (data, classObj) {
    // Used for saving the annotation back to girder.
    this.ArrowAnnotation = data.annotation;

    var annot = data.annotation;
    for (var i = 0; i < annot.elements.length; ++i) {
      var element = annot.elements[i];
      var dx = element.points[1][0] - element.points[0][0];
      var dy = element.points[1][1] - element.points[0][1];
      var length = Math.sqrt(dx * dx + dy * dy);
      var orientation = Math.atan2(dy, dx) * 180 / Math.PI;

      if (element.type === 'arrow') {
        var obj = {
          origin: element.points[0],
          length: length,
          width: element.lineWidth,
          orientation: orientation,
          fillcolor: SAM.ConvertColor(element.fillColor),
          outlinecolor: SAM.ConvertColor(element.lineColor)
        };
        var widget = new SAM.ArrowWidget(this.ArrowLayer);
        widget.Load(obj);
        this.ArrowLayer.AddWidget(widget);
      }
    }

    this.EventuallyDraw();
  };

  // Forward = 1, backward = -1
  GirderAnnotationIterator.prototype.ChangeCurrent = function (direction) {
    if (this.IteratorClass.widget === undefined) {
      return true;
    }
    var rectSet = this.IteratorClass.widget.Shape;
    var index = this.IteratorIndex;
    var confThresh = this.GetConfidenceThreshold();

    // loop to skip rects below the threshold
    while (true) {
      index += direction;
      if (index < 0 || index >= rectSet.Widths.length) {
        this.Stop();
        return;
      }
      if (rectSet.Confidences[index] >= confThresh) {
        if (this.ArrowMode) {
          this.StartArrow();
        }
        this.SetIteratorIndex(index);
        return;
      }
    }
  };

  GirderAnnotationIterator.prototype.HandleClick = function (event) {
    return true;
  };

  // Initialize the gui / dom
  GirderAnnotationIterator.prototype.InitializeGui = function (parent, label) {
    var self = this;

    // The wrapper div that controls a single layer.
    this.LayerControl = $('<div>')
      .appendTo(parent)
      .css({
        'border': '1px solid #CCC',
        'width': '100%'
      });

    this.ActiveLabel = $('<div>')
      .appendTo(this.LayerControl)
      .prop('title', 'Start sorting detections')
      .attr('contenteditable', 'false')
      .text('');

    var buttonContainer = $('<p>')
      .appendTo(this.LayerControl);
    this.StartStopButton = $('<button>')
      .appendTo(buttonContainer)
      .text('Start')
      .css({'background-color': '#5F5'})
      .prop('title', 'Start sorting detections')
      // .button()
      .css({'width': '5em'})
      .on('click', function () { self.StartStop(); });
    $('<button>')
      .appendTo(buttonContainer)
      .text('Save')
      .prop('title', 'Save annotations to server')
      .click(function () { self.Save(); });

    // Wrapper for the confidence slider.
    var confWrapper = $('<div>')
      .appendTo(this.LayerControl)
      .css({
        'border': '1px solid #CCC',
        'width': '100%',
        'height': '50px'
      });

    this.Slider = $('<input type="range" min="0" max="100">')
      .appendTo(confWrapper)
      .on('input',
          function () {
            self.SliderCallback();
          });

    $('<div>')
      .appendTo(confWrapper)
      .html('0%')
      .css({ 'float': 'left' });
    $('<div>')
      .appendTo(confWrapper)
      .html('Confidence')
      .css({
        'float': 'right',
        'position': 'relative',
        'left': '-50%',
        'text-align': 'left'});
    $('<div>')
      .appendTo(confWrapper)
      .html('100%')
      .css({ 'float': 'right' });

    var classContainer = $('<p>')
      .appendTo(this.LayerControl);
    for (var i = 0; i < this.Classes.length; ++i) {
      this.MakeClassButton(classContainer, i);
    }

    // Instructions
    this.InstructionsHeading = $('<h4>')
      .appendTo(parent)
      .text('Instructions');
    this.InstructionsUL = $('<ul>')
      .appendTo(parent);
    var browsingLI = $('<li>')
      .appendTo(this.InstructionsUL)
      .text('Browsing');
    var browsingUL = $('<ul>')
      .appendTo(browsingLI);
    $('<li>')
      .appendTo(browsingUL)
      .text('Arrow keys: pan screen');
    $('<li>')
      .appendTo(browsingUL)
      .text('Left mouse drag: pan');
    $('<li>')
      .appendTo(browsingUL)
      .text('Scroll wheel: zoom');
    $('<li>')
      .appendTo(browsingUL)
      .text('"<" button: previous image');
    $('<li>')
      .appendTo(browsingUL)
      .text('">" button: next image');
    $('<li>')
      .appendTo(browsingUL)
      .text('"Start" button: iterate over all planes');

    var iteratingLI = $('<li>')
      .appendTo(this.InstructionsUL)
      .text('Iterating');
    var iteratingUL = $('<ul>')
      .appendTo(iteratingLI);
    $('<li>')
      .appendTo(iteratingUL)
      .text('Space bar: advance to next plane');
    $('<li>')
      .appendTo(iteratingUL)
      .text('Right arrow key: advance to next plane');
    $('<li>')
      .appendTo(iteratingUL)
      .text('Left arrow key: back to previos plane');
    $('<li>')
      .appendTo(iteratingUL)
      .text('A new arrow is automatically triggerd when you advance');
    $('<li>')
      .appendTo(iteratingUL)
      .text("Mouse down: place the arrow's tip");
    $('<li>')
      .appendTo(iteratingUL)
      .text("Drag with mouse down: place the arrow's base");
    $('<li>')
      .appendTo(iteratingUL)
      .text('Mouse up: finish the arrow');
    $('<li>')
      .appendTo(iteratingUL)
      .text('Click on an arrow to make it dragable');
  };

  GirderAnnotationIterator.prototype.MakeClassButton = function (classContainer, index) {
    var self = this;
    var classObj = this.Classes[index];
    classObj.gui = $('<div>')
            .appendTo(classContainer)
            .text((index).toString() + ': ' + classObj.label)
            .css({'color': classObj.color})
            .click(function () { self.SetActiveClassIndex(index); });
  };

  GirderAnnotationIterator.prototype.UpdateHash = function () {
    var bds = this.Viewer.GetOverViewBounds();
    for (var i = 0; i < this.Classes.length; ++i) {
      var widget = this.Classes[i].widget;
      widget.Hash.Build(widget.Shape, bds);
    }
  };

  GirderAnnotationIterator.prototype.GetConfidenceThreshold = function () {
    return parseInt(this.Slider.val()) / 100.0;
  };

  // Confidence threshold slider.
  GirderAnnotationIterator.prototype.SliderCallback = function () {
    var visValue = this.GetConfidenceThreshold();
    for (var i = 0; i < this.Classes.length; ++i) {
      if (this.Classes[i].widget) {
        this.Classes[i].widget.SetThreshold(visValue);
      }
    }
    this.EventuallyDraw();
    // In case we are iterating and the curent becomes invisible.
    this.CheckIteratorVisibility();
  };

  GirderAnnotationIterator.prototype.CheckIteratorVisibility = function () {
    if (!this.IteratorClass || this.IteratorIndex < 0) {
      return;
    }
    // In case the first is not visible.
    var rectSet = this.IteratorClass.widget.Shape;
    var confThresh = this.GetConfidenceThreshold();
    if (rectSet.Confidences[this.IteratorIndex] < confThresh) {
      this.ChangeCurrent(1);
    }
  };

  GirderAnnotationIterator.prototype.Stop = function () {
    this.SetIteratorIndex(-1);
    this.InteractorClass = undefined;
    this.StartStopButton
      .text('Start')
      .css({'background-color': '#5F5'})
      .prop('title', 'Start sorting detections');
  };

  // Start iterating over the selected class.
  GirderAnnotationIterator.prototype.Start = function () {
    this.Viewer.Focus();
    // zoom in
    var viewer = this.Viewer;
    viewer.ZoomTarget = 500;
    this.IteratorClass = this.Classes[this.ActiveClassIndex];
    if (this.IteratorClass.widget.Shape.GetLength() < 1) {
      window.alert('No annotations in ' + this.IteratorClass.label);
      this.IteratorClass = undefined;
      return;
    }
    this.SetIteratorIndex(0);
    // In case the first is not visible.
    this.CheckIteratorVisibility();
    this.StartStopButton
      .text('Stop')
      .css({'background-color': '#F55'})
      .prop('title', 'Stop sorting detections');

    if (this.ArrowMode) {
      this.StartArrow();
    }
  };

  // Stop iterating.
  GirderAnnotationIterator.prototype.StartStop = function () {
    if (this.IteratorClass) {
      // Currently interating: Stop action
      this.Stop();
    } else {
      // Not interating yet:  Start action
      this.Start();
    }
  };

  // Move labeled rects in detections to classes.
  // Called before annotations are saved to the database
  GirderAnnotationIterator.prototype.SplitDetections = function () {
    // Build an object to make indexing classes easier.
    var shapes = {};
    for (var i = 0; i < this.Classes.length; ++i) {
      shapes[this.Classes[i].label] = this.Classes[i];
      // Create a new rectSet for each class.
      // Best way to deal with the shuffle.
      this.Classes[i].newRectSet = new SAM.RectSet();
      this.Classes[i].newRectSet.LabelColors = this.Classes[i].widget.Shape.LabelColors;
      this.Classes[i].newRectSet.Threshold = this.Classes[i].widget.Shape.Threshold;
    }

    for (i = 0; i < this.Classes.length; ++i) {
      var inRectSet = this.Classes[i].widget.Shape;
      for (var inIdx = 0; inIdx < inRectSet.GetLength(); ++inIdx) {
        var label = inRectSet.Labels[inIdx];
        var outRectSet = shapes[label].newRectSet;
        outRectSet.CopyRectangle(inRectSet, inIdx,
                                 outRectSet.GetLength());
      }
    }

    // Now keep the new rect sets and dispose of the old.
    for (i = 0; i < this.Classes.length; ++i) {
      this.Classes[i].widget.Shape = this.Classes[i].newRectSet;
      delete this.Classes[i].newRectSet;
    }

    this.UpdateHash();
  };

  GirderAnnotationIterator.prototype.Save = function () {
    // Save arrows in the database
    var annotation = this.ArrowAnnotation;
    annotation.elements = this.ArrowLayerToGirderElements(this.ArrowLayer);
    SA.PushProgress();
    girder.rest.restRequest({
      url: 'annotation/' + this.ArrowAnnotationId,
      method: 'PUT',
      data: JSON.stringify(annotation),
      contentType: 'application/json'
    }).done(function () { SA.PopProgress(); });
  };

  // returns an elements array.
  GirderAnnotationIterator.prototype.ArrowLayerToGirderElements = function (layer) {
    var returnElements = [];

    for (var idx = 0; idx < layer.GetNumberOfWidgets(); ++idx) {
      var widget = layer.GetWidget(idx).Serialize();
      var pt1 = [widget.origin[0], widget.origin[1], 0];
      var pt2 = [widget.origin[0], widget.origin[1], 0];
      var theta = widget.orientation * Math.PI / 180.0;
      pt2[0] += widget.length * Math.cos(theta);
      pt2[1] += widget.length * Math.sin(theta);
      var points = [pt1, pt2];
      var element = {
        'type': 'arrow',
        'lineWidth': widget.width,
        'fillColor': SAM.ConvertColorToHex(widget.fillcolor),
        'lineColor': SAM.ConvertColorToHex(widget.outlinecolor),
        'points': points};
      returnElements.push(element);
    }
    return returnElements;
  };

  // Converts rectSetWidget into girder annotation elements.
  // returns an elements array.
  GirderAnnotationIterator.prototype.RectSetToGirderElements = function (rectSetWidget) {
    var returnElements = [];

    var widget = rectSetWidget.Serialize();
    var num = widget.widths.length;
    for (var j = 0; j < num; ++j) {
      var element = {'type': 'rectangle',
        'label': {'value': widget.labels[j]},
        'center': [widget.centers[2 * j], widget.centers[2 * j + 1], 0],
        'height': widget.heights[j],
        'width': widget.widths[j],
        'rotation': 0,
        'scalar': widget.confidences[j]};
      returnElements.push(element);
    }
    return returnElements;
  };

  // Now we are always active.  We have interaction state === ITERATING to
  // indicate cycling through annotations one by one.
  GirderAnnotationIterator.prototype.SetActive = function (active) {
    if (active === this.Active) {
      return;
    }
    this.Active = active;
    this.EventuallyDraw();
  };

  GirderAnnotationIterator.prototype.SetCursorColor = function (element, color) {
    // create off-screen canvas
    var cursor = document.createElement('canvas');
    var ctx = cursor.getContext('2d');

    cursor.width = 16;
    cursor.height = 24;

    // draw an arrow

    // ctx.lineWidth = 1;
    ctx.moveTo(0, 18);
    ctx.lineTo(0, 0); // tip
    ctx.lineTo(12, 12);
    ctx.lineTo(7, 13);
    ctx.lineTo(11, 21);
    ctx.lineTo(8, 22);
    ctx.lineTo(4, 14);
    ctx.closePath();

    ctx.fillStyle = color;
    ctx.fill();
    ctx.strokeStyle = '#000';
    ctx.stroke();

    // set image as cursor (modern browsers can take PNGs as cursor).
    element[0].style.cursor = 'url(' + cursor.toDataURL() + '), auto';
  };

  // 2d
  // I am extending the annotations from simple points to rectangles with
  // different sizes.  Each item will be added to multiple bins.
  // This serves two purposes.
  // Given a point, find the (best) picked renctanlge.
  // Given a rectangle find all rectangle that overlap
  function SpatialHash () {
    // Must be initialized before use.
  }

  SpatialHash.prototype.Initialize = function (bounds, size) {
    this.Origin = [bounds[0], bounds[2]];
    this.BinSize = Math.sqrt((bounds[1] - bounds[0]) * (bounds[3] - bounds[2]) / (size + 1));
    this.XDim = Math.ceil((bounds[1] - bounds[0]) / this.BinSize);
    this.YDim = Math.ceil((bounds[3] - bounds[2]) / this.BinSize);
    this.Grid = new Array(this.YDim);
    for (var y = 0; y < this.YDim; ++y) {
      var row = new Array(this.XDim);
      for (var x = 0; x < this.XDim; ++x) {
        row[x] = [];
      }
      this.Grid[y] = row;
    }
  };

  SpatialHash.prototype.Add = function (center, w, h, idx) {
    var x, y;
    x = center[0] - (w / 2);
    var col1 = Math.floor((x - this.Origin[0]) / this.BinSize);
    col1 = Math.max(Math.min(col1, this.XDim - 1), 0);
    x = center[0] + (w / 2);
    var col2 = Math.floor((x - this.Origin[0]) / this.BinSize);
    col2 = Math.max(Math.min(col2, this.XDim - 1), 0);

    y = center[1] - (h / 2);
    var row1 = Math.floor((y - this.Origin[1]) / this.BinSize);
    row1 = Math.max(Math.min(row1, this.YDim - 1), 0);
    y = center[1] + (h / 2);
    var row2 = Math.floor((y - this.Origin[1]) / this.BinSize);
    row2 = Math.max(Math.min(row2, this.YDim - 1), 0);

    for (var r = row1; r <= row2; ++r) {
      for (var c = col1; c <= col2; ++c) {
        this.Grid[r][c].push(idx);
      }
    }
  };

  // This object does not detect when the rect widget changes.
  SpatialHash.prototype.Build = function (rectSet, bounds) {
    this.RectSet = rectSet;
    var numRects = rectSet.GetLength();
    this.Initialize(bounds, numRects);
    for (var idx = 0; idx < numRects; ++idx) {
      var tmp = idx << 1;
      this.Add([rectSet.Centers[tmp], rectSet.Centers[tmp + 1]],
               rectSet.Widths[idx], rectSet.Heights[idx], idx);
    }
  };

  // Returns the index of the best rect for the point selected.
  // Returns -1 if there are no rects containing the point.
  SpatialHash.prototype.Get = function (pt, confThresh) {
    // Find binds touching this square.
    // Transform bounds to grid indexes  (keep in range).
    var x = Math.max(Math.min(
      Math.floor((pt[0] - this.Origin[0]) / this.BinSize), this.XDim - 1), 0);
    var y = Math.max(Math.min(
      Math.floor((pt[1] - this.Origin[1]) / this.BinSize), this.YDim - 1), 0);

    var bin = this.Grid[y][x];

    // Find the closest entry to location in these bins.
    var best;
    for (var i = 0; i < bin.length; ++i) {
      var rectIdx = bin[i];
      var conf = this.RectSet.Confidences[rectIdx];
      var w = this.RectSet.Widths[rectIdx];
      var h = this.RectSet.Heights[rectIdx];
      var cx = this.RectSet.Centers[rectIdx << 1];
      var cy = this.RectSet.Centers[(rectIdx << 1) + 1];
      var dx = Math.abs(cx - pt[0]);
      var dy = Math.abs(cy - pt[1]);
      if (dx < w / 2 && dy < h / 2 && confThresh <= conf) {
        var dist = Math.max(dx, dy);
        if (!best || dist <= best.dist) {
          best = {
            dist: dist,
            index: rectIdx,
            center: [cx, cy],
            width: w,
            height: h};
        }
      }
    }
    return best;
  };

  // For changed detection
  // Returns a list of all rectangles that overlap the input rectangle by
  // the specified threshold fraction.
  SpatialHash.prototype.GetOverlapping = function (center, width, height,
                                                   overlapThresh) {
    var overlapping = [];
    var hw1 = width / 2;
    var hh1 = height / 2;
    var cx1 = center[0];
    var cy1 = center[1];
    var area1 = width * height;

    // Loop over bins touching the input rectangle
    var x, y;
    x = center[0] - hw1;
    var col1 = Math.floor((x - this.Origin[0]) / this.BinSize);
    col1 = Math.max(Math.min(col1, this.XDim - 1), 0);
    x = center[0] + hw1;
    var col2 = Math.floor((x - this.Origin[0]) / this.BinSize);
    col2 = Math.max(Math.min(col2, this.XDim - 1), 0);

    y = center[1] - hh1;
    var row1 = Math.floor((y - this.Origin[1]) / this.BinSize);
    row1 = Math.max(Math.min(row1, this.YDim - 1), 0);
    y = center[1] + hh1;
    var row2 = Math.floor((y - this.Origin[1]) / this.BinSize);
    row2 = Math.max(Math.min(row2, this.YDim - 1), 0);

    for (var r = row1; r <= row2; ++r) {
      for (var c = col1; c <= col2; ++c) {
        var bin = this.Grid[r][c];
        // compare all the rectangles referenced by this bin
        for (var i = 0; i < bin.length; ++i) {
          var rectIdx = bin[i];
          var hw2 = this.RectSet.Widths[rectIdx] / 2;
          var hh2 = this.RectSet.Heights[rectIdx] / 2;
          var area2 = hw2 * hh2 * 4.0;
          var cx2 = this.RectSet.Centers[rectIdx << 1];
          var cy2 = this.RectSet.Centers[(rectIdx << 1) + 1];
          // Compute the intersection.
          var xMin = Math.max(cx1 - hw1, cx2 - hw2);
          var xMax = Math.min(cx1 + hw1, cx2 + hw2);
          var yMin = Math.max(cy1 - hh1, cy2 - hh2);
          var yMax = Math.min(cy1 + hh1, cy2 + hh2);
          var dx = Math.max(0, xMax - xMin);
          var dy = Math.max(0, yMax - yMin);
          var overlap = (dx * dy) / Math.min(area1, area2);
          if (overlap > overlapThresh) {
            var found = false;
            // SHould be few overlapping.  Linear search should be fine.
            for (var j = 0; j < overlapping.length && !found; ++j) {
              if (overlapping[j] === rectIdx) {
                found = true;
              }
            }
            if (!found) {
              overlapping.push(rectIdx);
            }
          }
        }
      }
    }

    return overlapping;
  };

  SAM.SpatialHash = SpatialHash;
  SAM.GirderAnnotationIterator = GirderAnnotationIterator;
})();

// GUI to navigate a stack and manager views.
// I will try to keep loading to "on demand" as much as possible.
// Put a section transform in the camera.
// Connect section bounds to camera section transform.
// Restrict viewer to bounds of section.
// Startup in the middle of the first bounds.

// TODO: If we can, delay creating the saSection until the cache root is loaded.

// TODO: Make sure that the annotation (stored in slide coordiantes) get
// transformed to section coordinates before they are rendered.

// NOTE: Three different sections.

//   metaSection: loaded from the girder item metadata.
//   stackSection: object internal to this class.
//   saSection: Object slide atlas uses to manage sections.
// TODO: Merge these in the future if possible.

// Loading is a bit confusing (due to load on demand requirements):
// Initialize (block / serialized)
// 1: LoadFolder (called externally): Just gets the number of items in the folder.
// 2: LoadFolderImageIds (chunked recursively):
//      Gets the itemIds and meta data.  Creates the instance stack array.
//      Section objects have bounds an transform, imageId.
//      calls LoadStackMetaData to asynchronously load other item info.
// Initialize (non blocking/ asynchonous, throttled)
// 1: LoadStackMetaData:
//      Choose a (high priority) section that needs metadata loaded.
//      Call CreateSaSection to load the metadata
//      (with a recursive callback to LoadStackMetaData)
// 2: CreateSaSection: Loads the image tile meta data if necesary.
//      No: Just call CreateSaSectionFromCache
//      Yes: GirderRequest->LoadItem
// 3: LoadItem: .....

(function () {
    // Depends on the CIRCLE widget
  'use strict';

  function GirderStackWidget (parent, display, overlay, apiRoot) {
    // We need a common center to treat as the center for the stack.
    // This is used to compute the transforms from the section centers.
    this.VolumeCenter = undefined;

    this.SectionIndex = -1;
    // Stuff needs to be initialized on the first render.
    this.First = true;
    this.ApiRoot = apiRoot;
    // List of stackSections
    this.Stack = [];
    // dictionary to share caches when multiple sections on one slide
    this.Caches = {};
    this.Display = display;
    // Have the viewer call this objects event methods.
    display.AddLayer(this);
    // For debugging (place two section on top of each other to judge alignment.
    // this.Overlay = overlay;

    var self = this;
    // THese event bindings do not work.
    this.SliderDiv = $('<div>')
      .appendTo(parent)
      .css({
        // 'background-color': '#fff',
        // 'opacity': '0.2',
        'position': 'absolute',
        'left': '0px',
        'bottom': '5px',
        'width': '100%',
        'z-index': '1000'})
      .on('keyup', function (e) { self.HandleKeyUp(e); })
      .hover(
        function () {
          self.SliderDiv.focus();
          // self.SliderDiv.css({'opacity': '1'});
        },
        function () {
          self.SliderDiv.blur();
          // self.SliderDiv.css({'opacity': '0.2'});
        });
    this.SliderDiv
      .slider({
        start: function (e, ui) { self.StartCallback(ui.value); },
        slide: function (e, ui) { self.SlideCallback(ui.value); },
        stop: function (e, ui) { self.StopCallback(ui.value); }
      });

    this.SlideLabel = $('<div>')
      .appendTo(this.SliderDiv)
      .css({
        'position': 'absolute',
        'top': '-25px',
        'text-align': 'center',
        'color': '#ddf',
        'text-shadow': '2px 2px #000'})
      .hide();
  }

  GirderStackWidget.prototype.SetAnnotationName = function (name) {
    this.AnnotationName = name;
  };

  GirderStackWidget.prototype.StartCallback = function (value) {
    this.SlideLabel.text(this.SectionIndex.toString());
    var x = 100 * value / (this.Stack.length - 1);
    this.SlideLabel.css({'left': x + '%'});
    this.SlideLabel.show();
  };

  GirderStackWidget.prototype.SlideCallback = function (value) {
    // TODO: Display the thumbnail (instead of the whold slide).
    // Does rending the whole image while sliding  cause too many tiles
    // requests?
    this.SetSectionIndex(value);
    var x = 100 * value / (this.Stack.length - 1);
    this.SlideLabel.text(value.toString());
    this.SlideLabel.css({'left': x + '%'});
  };

  GirderStackWidget.prototype.StopCallback = function (value) {
    this.SetSectionIndex(value);
    this.SlideLabel.text(value.toString());
    this.SlideLabel.hide();
  };

  GirderStackWidget.prototype.HandleKeyUp = function (e) {
    if (e.keyCode === 33 || e.keyCode === 80) {
      // page up or p
      this.Previous();
      return false;
    } else if (e.keyCode === 34 || e.keyCode === 32 || e.keyCode === 78) {
      // page down, space or n
      this.Next();
      return false;
    }
    return true;
  };

  GirderStackWidget.prototype.Next = function () {
    this.SetSectionIndex(this.SectionIndex + 1);
  };

  GirderStackWidget.prototype.Previous = function () {
    this.SetSectionIndex(this.SectionIndex - 1);
  };

  // Load all the images in a folder as a stack.
  GirderStackWidget.prototype.LoadFolder = function (folderId) {
    var self = this;
    this.Stack = [];
    // This just gets the number of items.
    // All we need to start is the number of images in the folder.
    // However, the folder may contain non image items (like this stack).
    this.ErrorCount = 0;
    if (window.girder) {
      girder.rest.restRequest({
        url: ('folder/' + folderId + '/details'),
        method: 'GET',
        contentType: 'application/json'
      }).done(function (resp) {
        // Just serialize loading the item info
        var length = resp.nItems;
        var limit = 100;
        self.LoadFolderImageIds(folderId, 0, limit, length);
      });
    }
  };

  // ============================================================================
  // Load all the images in a folder as a stack.
  // All this does is get the ids of the images in the folder.
  // Image data is loaded on demand
  GirderStackWidget.prototype.LoadFolderImageIds = function (folderId,
                                                             offset, limit, length) {
    var self = this;
    if (offset >= length) {
      // We have received all the ImageIds in the stack
      if (this.Stack.length > 0) {
        this.SetSectionIndex(0);
        // Get meta data for all images in the stack.
        this.ErrorCount = 0;
        this.LoadStackMetaData();
      }
      return;
    }

    // Get the next bite.
    girder.rest.restRequest({
      url: 'item?folderId=' + folderId + '&limit=' + limit +
        '&offset=' + offset + '&sort=lowerName&sortdir=1',
      method: 'GET',
      contentType: 'application/json',
      error: function (error, status) {
        self.ErrorCount += 1;
        if (self.ErrorCount < 100) {
          console.error(error.status + ' ' + error.statusText, error.responseText);
          // try again:
          self.LoadFolderImageIds(folderId, offset, limit, length);
        } else {
          console.log('Too many errors loading folder');
        }
      }
    }).done(function (resp) {
      for (var j = 0; j < resp.length; ++j) {
        var item = resp[j];
        var stackSection;
        // TODO: Handle small images too.
        if (item.largeImage) {
          if (item.meta && item.meta.sections) {
            // Add all the sections listed in the meta data.
            var metaSections = item.meta.sections;
            for (var sIdx = 0; sIdx < metaSections.length; ++sIdx) {
              var metaSection = metaSections[sIdx];
              stackSection = {imageId: item._id};
              if (metaSection.trans) {
                stackSection.transform = metaSection.trans;
              }
              if (metaSection.bounds) {
                // These bounds are in image coordinate ssytem.
                stackSection.bounds = [
                  metaSection.bounds[0],
                  metaSection.bounds[2],
                  metaSection.bounds[1],
                  metaSection.bounds[3]];
              }
              self.Stack.push(stackSection);
            }
          } else {
            // Just add a single section (the whole slide)
            stackSection = {imageId: resp[j]._id};
            self.Stack.push(stackSection);
          }
        }
      }
      // Serialize the bites.
      self.LoadFolderImageIds(folderId, offset + limit, limit, length);
    });
  };

  // Load section meta-data from the stack item.
  // This is a second path that allows editing of the sequence.
  GirderStackWidget.prototype.LoadSections = function (sectionData) {
    var self = this;
    this.Stack = [];

    if (sectionData.length > 0) {
      this.SetSectionIndex(0);
    }

    for (var idx = 0; idx < sectionData.length; ++idx) {
      var metaSection = sectionData[idx];
      var stackSection = {imageId: metaSection.itemId};
      if (metaSection.trans) {
        stackSection.transform = metaSection.trans;
      }
      if (metaSection.bounds) {
        // These bounds are in image coordinate ssytem.
        stackSection.bounds = [
          metaSection.bounds[0],
          metaSection.bounds[2],
          metaSection.bounds[1],
          metaSection.bounds[3]];
      }
      self.Stack.push(stackSection);
    }
    this.LoadStackMetaData();
  };

  // Does everything necessary to load the section into the viewer.
  // Does nothing if the section is not loaded from the datbase yet.
  GirderStackWidget.prototype.SetSectionIndex = function (index) {
    if (index >= this.Stack.length) {
      index = this.Stack.length - 1;
    }
    if (index < 0) {
      return;
    }
    if (this.SectionIndex === index) {
      return;
    }
    console.log('stack index ' + index.toString());
    this.SectionIndex = index;
    // Tell annotation what time to display.
    var num = this.Display.GetNumberOfLayers();
    for (var i = 0; i < num; ++i) {
      var layer = this.Display.GetLayer(i);
      if (layer && layer.SetTime) {
        layer.SetTime(index);
      }
    }

    this.RenderSection(this.Stack[index]);
  };

  // The section images must be loaded before this call.
  GirderStackWidget.prototype.RenderSection = function (stackSection) {
    if (stackSection.SaSection === undefined) {
      return;
    }

    var cache = this.Caches[stackSection.imageId];
    if (cache === undefined || !cache.RootsLoaded) {
      // The load callback will render if the section is current.
      return;
    }
    // Here display is just a viewer.
    // We can only initialize the slide when all the image ids are loaded
    // and we know the length of the stack.  This will change with multiple
    // sections per image.
    if (this.First) {
      delete this.First;
      this.SliderDiv.slider('option', 'max', this.Stack.length - 1);
      // Only reset the camera on the first render.
      this.Display.SetCamera([
        (stackSection.bounds[0] + stackSection.bounds[1]) / 2,
        (stackSection.bounds[2] + stackSection.bounds[3]) / 2],
                             0, (stackSection.bounds[3] - stackSection.bounds[2]));
    }
    // Let the SlideAtlas sections deal with the transformations
    this.Display.SetSection(stackSection.SaSection);
    if (cache.Annotation) {
      var annotLayer = this.Display.GetAnnotationLayer();
      DisplayAnnotation(annotLayer, cache.Annotation);
    }
    this.Display.EventuallyRender();

    // get the next section for the overlay
    if (this.Overlay) {
      var idx = this.Stack.indexOf(stackSection);
      if (idx !== -1 && idx < this.Stack.length - 1) {
        var nextSection = this.Stack[idx + 1];
        cache = this.Caches[nextSection.imageId];
        if (cache === undefined || !cache.RootsLoaded) {
          return;
        }
        this.Overlay.SetSection(nextSection.SaSection);
      }
      this.Overlay.DrawTiles();
    }
  };

  // ============================================================================
  // Load minimal meta data for every section.  Throttle and Prioritize.
  // It would be silly to make a general purpose queue when we know all the
  // images that have to be loaded.  Just load them serially but compute a
  // priority based on the current image index.
  // Assume the stack is static.
  GirderStackWidget.prototype.LoadStackMetaData = function () {
    if (this.ErrorCount > 100) {
      console.error('Too many errors loading item tile info.');
      return;
    }
    if (this.Stack.length === 0) {
      return;
    }
    // Find the next highest priority image info to load.
    var self = this;
    // Find the highest priority section whose image has not been loaded.
    var startIdx = Math.max(this.SectionIndex, 0);
    // Multiple section can have the same image id.
    var foundSection = this.Stack[startIdx];
    if (foundSection.SaSection) {
      // already loaded
      foundSection = undefined;
    }

    var radius = 1;
    // Tolerate overshoot with startIdx+radius
    while (!foundSection && radius < this.Stack.length) {
      // Look forward.
      var idx = startIdx + radius;
      if (idx >= 0 && idx < this.Stack.length) {
        foundSection = this.Stack[idx];
        if (foundSection.SaSection) {
          // already loaded
          foundSection = undefined;
        }
      }
      // Look backward
      idx = startIdx - radius;
      if (!foundSection && idx >= 0 && idx < this.Stack.length) {
        foundSection = this.Stack[idx];
        if (foundSection.SaSection) {
          // already loaded
          foundSection = undefined;
        }
      }
      ++radius;
    }

    if (foundSection) {
      // Recursively call this method to throttle requests.
      this.CreateSaSection(foundSection,
                           function () { self.LoadStackMetaData(); });
    }
  };

  // This gets called to create the saSection.  It may need to make a cache
  // and get the image data from the server to do it.
  GirderStackWidget.prototype.CreateSaSection = function (stackSection, callback) {
    var cache = this.Caches[stackSection.imageId];
    if (cache) {
      // we have the cache already
      this.CreateSaSectionFromCache(stackSection, cache);
      if (callback) {
        (callback)();
      }
      return;
    }

    // We need to request image data from the server to setup the cache.
    var self = this;
    girder.rest.restRequest({
      url: 'item/' + stackSection.imageId + '/tiles',
      method: 'GET',
      contentType: 'application/json',
      error: function (error, status) {
        console.error(error.status + ' ' + error.statusText, error.responseText);
        this.ErrorCount += 1;
        if (callback) {
          (callback)();
        }
      }
    }).done(function (resp) {
      self.LoadItem(resp, stackSection, callback);
    });
  };

  // This is only called once per item.
  GirderStackWidget.prototype.LoadItem = function (resp, stackSection, callback) {
    var w = resp.sizeX;
    var h = resp.sizeY;

    // If the item did not have bounds meta data, set bounds to be the
    // whole slide.
    if (stackSection.bounds === undefined) {
      stackSection.bounds = [0, w - 1, 0, h - 1];
    }
    // Get / setup the cache.
    var cache = new SA.Cache();
    this.Caches[stackSection.imageId] = cache;
    var tileSource = new GirderTileSource(w, h, resp.tileWidth, resp.tileHeight,
                                          0, resp.levels - 1,
                                          this.ApiRoot,
                                          stackSection.imageId,
                                          [0, w - 1, 0, h - 1]);
    cache.SetTileSource(tileSource);
    // Setup the slideAtlas section
    var saSection = new SA.Section();
    saSection.AddCache(cache);
    stackSection.SaSection = saSection;

    cache.SetTileSource(tileSource);
    // Request the lowest resolution tile from girder.
    var self = this;
    cache.LoadRoots(
      function () {
        cache.RootsLoaded = true;
        // If the current section uses this cache. render it.
        if (self.SectionIndex !== -1) {
          var currentSection = self.Stack[self.SectionIndex];
          if (stackSection.imageId === currentSection.imageId) {
            self.RenderSection(currentSection);
          }
        }
      });
    this.CreateSaSectionFromCache(stackSection, cache);

    // Load annotation if necessary.
    // Associated it with the cache.
    // TODO: REnder when load if section is current.
    if (this.AnnotationName) {
      girder.rest.restRequest({
        url: 'annotation?itemId=' + stackSection.imageId + '&name=' + this.AnnotationName,
        method: 'GET',
        contentType: 'application/json',
        error: function (error, status) {
          console.error(error.status + ' ' + error.statusText, error.responseText);
        }
      }).done(function (resp) {
        if (resp.length > 0) {
          var annotId = resp[0]['_id'];
          girder.rest.restRequest({
            url: 'annotation/' + annotId,
            method: 'GET',
            contentType: 'application/json',
            error: function (error, status) {
              console.error(error.status + ' ' + error.statusText, error.responseText);
            }
          }).done(function (resp) {
            cache.Annotation = resp.annotation;
          });
        }
      });
    }

    // This serializes the requests. Starts loading the next after the
    // current is finished.
    if (callback) {
      (callback)();
    }
  };

  GirderStackWidget.prototype.CreateSaSectionFromCache = function (stackSection, cache) {
    // If the girder meta data did not set up the section defaults, do it
    // here. The center is the first pass at the transformation.
    var image = cache.GetImageData();
    if (stackSection.bounds === undefined) {
      stackSection.bounds = [0, image.dimensions[0] - 1, 0, image.dimensions[1] - 1];
    }
    var bds = stackSection.bounds;
    var center = [
      (bds[0] + bds[1]) * 0.5,
      (bds[2] + bds[3]) * 0.5];
    if (!this.VolumeCenter) {
      this.VolumeCenter = center;
    }
    // Set a default center to the middle of the bounds.
    if (stackSection.transform === undefined) {
      stackSection.transform = [
        1, 0, 0, 1,
        center[0] - this.VolumeCenter[0],
        center[1] - this.VolumeCenter[1]];
    }

    // Setup the slideAtlas section
    var saSection = new SA.Section();
    saSection.AddCache(cache);
    // First set the world to image transformation.
    saSection.SetTransform(stackSection.transform);

    // Now set the slide atla section bounds. They are best kept in world
    // coordinate system because they are used for interaction.
    // The stackSection bounds are in image coodindate system (for now).
    // TODO: fix this:  Since we only have translation, hack in the
    // conversion to world coordinate system.
    var tmp = SAM.InvertTransform(stackSection.transform);
    saSection.Bounds = SAM.TransformBounds(tmp, bds);

    stackSection.SaSection = saSection;
  };

  var GirderTileSource = function (width, height,
                                   tileWidth, tileHeight,
                                   minLevel, maxLevel,
                                   apiRoot, imageId,
                                   bounds) {
    this.height = height;
    this.width = width;
    this.TileWidth = tileWidth;
    this.TileHeight = tileHeight;
    this.apiRoot = apiRoot;
    this.imageId = imageId;
    this.bounds = bounds;
    this.maxLevel = maxLevel;
  };

  GirderTileSource.prototype.getTileUrl = function (level, x, y, z) {
    return this.apiRoot + '/item/' + this.imageId +
      '/tiles/zxy/' + level + '/' + x + '/' + y;
  };

  // TODO: Copied from girderWidget.  Share code!!!!!!!!!!!!!!!!
  // Move the annotation info to the layer widgets and draw.
  // Converts annotObj from girder to slideAtlas
  var DisplayAnnotation = function (annotLayer, girderAnnot) {
    annotLayer.SetVisibility(true);
    annotLayer.Reset();

    // Put all the rectangles into one set.
    var setObj = {};
    setObj.type = 'rect_set';
    setObj.centers = [];
    setObj.widths = [];
    setObj.heights = [];
    setObj.confidences = [];
    setObj.labels = [];

    var annot = girderAnnot;
    for (var i = 0; i < annot.elements.length; ++i) {
      var element = annot.elements[i];
      var obj = {};

      if (element.type === 'view') {
                // Set the camera / view.
        var cam = annotLayer.GetCamera();
        cam.SetWorldFocalPoint(element.center);
        cam.SetHeight(element.height);
        if (element.rotation) {
          cam.SetWorldRoll(element.rotation);
        } else {
          cam.SetWorldRoll(0);
        }
        // Ignore width for now because it is determined by the
        // viewport.
        cam.ComputeMatrix();
        // How to handle forcing viewer to render?
        // I could have a callback.
        // I could also make a $('.sa-viewer').EventuallyRender();
        // or $('.sa-viewer').saViewer('EventuallyRender');
        if (annotLayer.Viewer) {
          annotLayer.Viewer.EventuallyRender();
        }
      }
      if (element.type === 'circle') {
        obj.type = element.type;
        obj.lineColor = SAM.ConvertColor(element.lineColor);
        obj.lineWidth = element.lineWidth;
        obj.origin = element.center;
        obj.radius = element.radius;
        annotLayer.LoadWidget(obj);
      }
      if (element.type === 'arrow') {
        obj.type = 'text';
        obj.string = element.label.value;
        obj.color = SAM.ConvertColor(element.fillColor);
        obj.size = element.label.fontSize;
        obj.position = element.points[0].slice(0);
        obj.offset = element.points[1].slice(0);
        obj.offset[0] -= obj.position[0];
        obj.offset[1] -= obj.position[1];
        annotLayer.LoadWidget(obj);
      }
      if (element.type === 'rectanglegrid') {
        obj.type = 'grid';
        obj.lineColor = SAM.ConvertColor(element.lineColor);
        obj.lineWidth = element.lineWidth;
        obj.origin = element.center;
        obj.bin_width = element.width / element.widthSubdivisions;
        obj.bin_height = element.height / element.heightSubdivisions;
        obj.orientation = element.rotation;
        obj.dimensions = [element.widthSubdivisions, element.heightSubdivisions];
        annotLayer.LoadWidget(obj);
      }
      if (element.type === 'rectangle') {
        if (element.type === 'rectangle') { // switch behavior to ....
          setObj.widths.push(element.width);
          setObj.heights.push(element.height);
          setObj.centers.push(element.center[0]);
          setObj.centers.push(element.center[1]);
          if (element.scalar === undefined) {
            element.scalar = 1.0;
          }
          setObj.confidences.push(element.scalar);
          if (element.vector === undefined) {
            element.vector = [0, 0, 0];
          }
          if (setObj.vectors === undefined) {
            setObj.vectors = [];
          }
          setObj.vectors.push(element.vector[0]);
          setObj.vectors.push(element.vector[1]);
          if (element.label) {
            setObj.labels.push(element.label.value);
          } else {
            setObj.labels.push('');
          }
        } else {
          obj.type = 'rect';
          obj.lineColor = SAM.ConvertColor(element.lineColor);
          obj.lineWidth = element.lineWidth;
          obj.origin = element.center;
          obj.width = element.width;
          obj.length = element.height;
          obj.orientation = element.rotation;
          annotLayer.LoadWidget(obj);
        }
      }
      if (element.type === 'polyline') {
        obj.type = element.type;
        obj.closedloop = element.closed;
        obj.lineColor = SAM.ConvertColor(element.lineColor);
        obj.lineWidth = element.lineWidth;
        obj.points = element.points;
        annotLayer.LoadWidget(obj);
      }
    }

    if (setObj.widths.length > 0) {
      annotLayer.LoadWidget(setObj);
    }

    annotLayer.EventuallyDraw();
  };

  SAM.GirderStackWidget = GirderStackWidget;
})();

// export { GirderStackWidget }


(function () {
  // Depends on the CIRCLE widget
  'use strict';

  var d3 = 'not loaded';

  function GirderRocWidget (parent, positives, negatives, apiRoot) {
    this.ChipSize = 128;
    this.MaxChips = 200;
    this.Positives = positives;
    this.Negatives = negatives;
    this.NumPositives = positives.length;
    this.NumNegatives = negatives.length;
    // Combine the two lists, but label them first.
    for (var i = 0; i < positives.length; ++i) {
      positives[i].positive = true;
    }
    for (i = 0; i < negatives.length; ++i) {
      negatives[i].positive = false;
    }
    this.Detections = positives.concat(negatives);
    this.Detections.sort(
      function (a, b) {
        return b.element.scalar - a.element.scalar;
      });

    this.Container = $('<div>')
      .appendTo(parent)
      .css({
        'width': '100%',
        'margin-right': '30px'});

    this.RocDiv = $('<div>')
      .appendTo(this.Container)
      .css({
        'width': '100%',
        'position': 'relative'});
    this.LightBoxDiv = $('<div>')
      .appendTo(this.Container)
      .css({
        'width': '100%',
        'min-height': '500px',
        'position': 'relative'});

    this.FalsePositiveDiv = $('<div>')
      .appendTo(this.LightBoxDiv)
      .css({
        'border': '1px solid #AAA',
        'position': 'absolute',
        'left': '0px',
        'width': '50%',
        'top': '0px'});
    this.FalseNegativeDiv = $('<div>')
      .appendTo(this.LightBoxDiv)
      .css({
        'position': 'absolute',
        'left': '50%',
        'width': '50%',
        'top': '0px'});

    var self = this;
    this.SliderDiv = $('<div>')
      .appendTo(this.RocDiv)
      .css({
        'position': 'absolute',
        'left': '0px',
        'bottom': '0px',
        'width': '100%',
        'z-index': '10'})
       // .on('keyup', function (e) { self.HandleKeyUp(e); })
      .hover(
        function () {
          self.SliderDiv.focus();
          // self.SliderDiv.css({'opacity': '1'});
        },
        function () {
          self.SliderDiv.blur();
          // self.SliderDiv.css({'opacity': '0.2'});
        });
    this.SliderDiv
      .slider({
        start: function (e, ui) {},
        slide: function (e, ui) {
          var thresh = 1.0 - ui.value / 100.0;
          self.UpdateThreshold(thresh);
        },
        stop: function (e, ui) {}
      });

    this.DrawGraph();

    // Make the thumbnails / chips.
    this.InitializeChips();
    this.UpdateThreshold(1.0);
  }

  GirderRocWidget.prototype.UpdateThreshold = function (thresh) {
    // Find the point for this threshold.
    // TODO: Search from last point.
    var i = 0;
    var x = 0;
    var y = 0;
    for (i = 0; i < this.Points.length; ++i) {
      if (this.Points[i][2] < thresh) {
        x = this.Points[i][0];
        y = this.Points[i][1];
        break;
      }
    }
    console.log(thresh);
    x = this.XScale(x);
    y = this.YScale(y);
    this.Dot
      .attr('cx', x)
      .attr('cy', y);

    this.ThreshLabel
      .attr('x', x)
      .attr('y', y)
      .text(thresh.toFixed(2));

    // Update chip visibility.
    // TODO: Incremental update
    for (i = 0; i < this.Detections.length; ++i) {
      var d = this.Detections[i];
      if (d.imgDiv) {
        if (d.positive) {
          if (d.element.scalar <= thresh) {
            d.imgDiv.show();
          } else {
            d.imgDiv.hide();
          }
        } else {
          if (d.element.scalar >= thresh) {
            d.imgDiv.show();
          } else {
            d.imgDiv.hide();
          }
        }
      }
    }
  };

  GirderRocWidget.prototype.GetImageUrl = function (imageId, left, top, width, height, targetHeight) {
    var magnification = 40.0 * targetHeight / height;
    if (magnification > 40) {
      magnification = 40;
    }
    return 'api/v1/item/' + imageId + '/tiles/region?magnification=' + magnification +
           '&left=' + left + '&top=' + top + '&regionWidth=' + width + '&regionHeight=' + height +
           '&units=base_pixels&exact=false&encoding=JPEG&jpegQuality=95&jpegSubsampling=0';
  };

  GirderRocWidget.prototype.InitializeChips = function () {
    this.Positives.sort(
      function (a, b) {
        return a.element.scalar - b.element.scalar;
      });
    this.Negatives.sort(
      function (a, b) {
        return b.element.scalar - a.element.scalar;
      });
    this.Positives = this.Positives.slice(0, this.MaxChips);
    this.Negatives = this.Negatives.slice(0, this.MaxChips);

    for (var i = 0; i < this.Positives.length; ++i) {
      this.CreateChip(this.Positives[i], this.FalseNegativeDiv);
    }
    for (i = 0; i < this.Negatives.length; ++i) {
      this.CreateChip(this.Negatives[i], this.FalsePositiveDiv);
    }
  };

  GirderRocWidget.prototype.CreateChip = function (chip, parent) {
    var imageId = chip.imageId;
    var e = chip.element;
    if (e.type === 'rectangle') {
      var left = Math.round(e.center[0] - e.width / 2);
      var top = Math.round(e.center[1] - e.height / 2);
      // Use closure to keep track of images state?
      var imgDiv = $('<div>')
          .appendTo(parent)
          .addClass('img-div')
          .css({
            'height': (this.ChipSize + 8).toString() + 'px',
            'width': (this.ChipSize + 8).toString() + 'px',
            'margin': '1px',
            'display': 'inline-block',
            'position': 'relative',
            'cursor': 'crosshair',
            'border': '4px solid #EEE'})
          // needed to receive key events
          .attr('tabindex', '0');
      var img = $('<img>')
        .appendTo(imgDiv)
        .addClass('img-chip')
          .css({
            'height': this.ChipSize.toString() + 'px',
            'width': this.ChipSize.toString() + 'px',
            'cursor': 'crosshair'})
        .attr('tabindex', '0')
        .prop('src', this.GetImageUrl(imageId, left, top, 920, 920, this.ChipSize));
      chip.imgDiv = imgDiv;
      chip.img = img;
    }
  };

  // Initialize and draw the graph.
  GirderRocWidget.prototype.DrawGraph = function () {
    this.Points = [];
    var negCount = 0;
    var posCount = 0;

    var stride = Math.round(this.Detections.length / 100);

    for (var i = 0; i < this.Detections.length; ++i) {
      var d = this.Detections[i];
      if (stride === 0 || i % stride === 0) {
        this.Points.push([negCount, posCount, d.element.scalar]);
      }
      if (d.positive) {
        ++posCount;
      } else {
        ++negCount;
      }
    }
    // Add the last point.
    this.Points.push([negCount, posCount]);

    // Draw the d3 graph
    var margin = {top: 20, right: 20, bottom: 50, left: 70};
    var width = 600 - margin.left - margin.right;
    var height = 400 - margin.top - margin.bottom;

    var xScale = d3.scale.linear()
      .domain([0, this.NumNegatives])
      .range([0, width]);
    var yScale = d3.scale.linear()
      .domain([0, this.NumPositives])
      .range([height, 0]);

    var xAxis = d3.svg.axis()
      .scale(xScale)
      .orient('bottom')
      .ticks(5);
      // .style({'stroke-width': '1.5px'});
    var yAxis = d3.svg.axis()
      .scale(yScale)
      .orient('left')
      .ticks(5);
      // .style({'stroke-width': '1.5px'});

    // append the svg obgect to the body of the page
    // appends a 'group' element to 'svg'
    // moves the 'group' element to the top left margin

    var svg = d3.select(this.RocDiv[0]).append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
      .append('g')
        .attr('transform',
              'translate(' + margin.left + ',' + margin.top + ')');

    var valueline = d3.svg.line()
      .x(function (d) { return xScale(d[0]); })
      .y(function (d) { return yScale(d[1]); });

    svg.append('path')
      .attr('class', 'line')
      .attr('fill', 'none')
      .attr('stroke', 'blue')
      .attr('d', valueline(this.Points));

    svg.append('g')
        .attr('class', 'x axis')
        .attr('stroke-width', '1')
        .attr('transform', 'translate(0,' + height + ')')
        .call(xAxis)
      .append('text')
        .style('text-anchor', 'end')
        .attr('transform', 'translate(' + width + ', 0)')
        .attr('dy', '-.55em')
        .text('False Positives');

    svg.append('g')
        .attr('class', 'y axis')
        .attr('stroke-width', '1')
        .call(yAxis)
      .append('text')
        .attr('transform', 'rotate(-90)')
        .attr('y', 6)
        .attr('dy', '.71em')
        .style('text-anchor', 'end')
        .text('True Positives');

    this.XScale = xScale;
    this.YScale = yScale;
    this.Dot = svg.append('circle')
      .attr('cx', '0')
      .attr('cy', height.toString())
      .attr('r', '30')
      .attr('stroke', 'black')
      .attr('stroke-width', '1')
      .attr('fill', 'yellow')
      .attr('r', '10');
    this.ThreshLabel = svg.append('text')
      .attr('x', '0')
      .attr('y', '0')
      .attr('dy', '-20')
      .style('text-anchor', 'middle')
      .text('0.0');
  };

  SAM.GirderRocWidget = GirderRocWidget;
})();

// export { GirderRocWidget }

// ==============================================================================
// View Object
// Viewport (x_lowerleft, y_lowerleft, width, height)
// A view has its own camera and list of tiles to display.
// Views can share a cache for tiles.

(function () {
  'use strict';

  function View (parent, useWebGL) {
    this.Viewport = [0, 0, 100, 100];

    // Should widgets use shapes?
    // Should views be used independently to viewers?
    this.ShapeList = [];

    // connectome: remove Cache ivar.
    this.Camera = new SAM.Camera();
    this.OutlineColor = [0, 0.5, 0];
    this.OutlineMatrix = mat4.create();
    this.OutlineCamMatrix = mat4.create();

    this.Parent = parent;
    if (parent) {
      this.Parent = parent;
    } else {
      // USed for off screen rendering. (Can we depreciate off screen feature in girder viewer?)
      this.Parent = $('<div>');
    }
    // 2d canvas
    // Add a new canvas.
    this.Canvas = $('<canvas>');

    if (!useWebGL) {
      this.Context2d = this.Canvas[0].getContext('2d');
    }

    this.Canvas
      .appendTo(this.Parent)
      .css({
        'position': 'absolute',
        'left': '0%',
        'top': '0%',
        'width': '100%',
        'height': '100%'});

    this.Parent
      .addClass('sa-view-canvas-div');
  }

  // Try to remove all global and circular references to this view.
  View.prototype.Delete = function () {
    this.Parent.off('mousedown.viewer');
    this.Parent.off('mousemove.viewer');
    this.Parent.off('wheel.viewer');
    this.Parent.off('touchstart.viewer');
    this.Parent.off('touchmove.viewer');
    this.Parent.off('touchend.viewer');
    this.Parent.off('keydown.viewer');
    this.Parent.off('wheel.viewer');
    delete this.ShapeList;
    // delete this.Section;
    delete this.Camera;
    // delete this.Tiles;
    delete this.Parent;
    delete this.Canvas;
  };

  View.prototype.GetCamera = function () {
    return this.Camera;
  };

  // For shared camera with viewer.
  View.prototype.SetCamera = function (cam) {
    this.Camera = cam;
  };

  // Get raw image data from the view.
  View.prototype.GetImageData = function () {
    // interesting: When does it need to be set?
    // ctx.imageSmoothingEnabled = true;
    // useful for debugging
    // ctx.putImageData(imagedata, dx, dy);
    var cam = this.Camera;
    var width = Math.floor(cam.ViewportWidth);
    var height = Math.floor(cam.ViewportHeight);
    var ctx = this.Context2d;
    var data = ctx.getImageData(0, 0, width, height);
    data.Camera = new SAM.Camera();
    data.Camera.DeepCopy(this.Camera);
    // This will ne slow (wrapper class, or tack on methods)
    Object.setPrototypeOf(data, new SAM.ImageData());
    data.IncX = 4;
    // Super has height and width which should be imutable.
    data.width = width;
    data.height = height;
    data.IncY = data.IncX * data.width;
    return data;
  };

  // Get the current scale factor between pixels and world units.
  // World unit is the highest resolution image pixel.
  // Returns the size of a world pixel in screen pixels.
  // factor: screen/world
  // The default world pixel = 0.25e-6 meters
  View.prototype.GetPixelsPerUnit = function () {
    // Determine the scale difference between the two coordinate systems.
    var m = this.Camera.GetWorldMatrix();

    // Convert from world coordinate to view (-1->1);
    return 0.5 * this.Viewport[2] / (m[3] + m[15]); // m[3] for x, m[7] for height
  };

  View.prototype.HasUnits = function () {
    var cache = this.GetCache();
    if (!cache || !cache.Image || !cache.Image.units) { return false; }
    return cache.Image.units !== 'Units';
  };

  View.prototype.GetMetersPerUnit = function () {
    var cache = this.GetCache();
    var dist;
    if (!cache) {
      dist = {value: 250,
        units: 'nm'};
    } else {
      dist = {value: cache.Image.spacing[0],
        units: cache.Image.units};
    }
    SAM.ConvertToMeters(dist);
    return dist.value;
  };

  // TODO: Get rid of these since the user can manipulate the parent / canvas
  // div which can be passed into the constructor.
  // View.prototype.appendTo = function (j) {
  //  return this.Parent.appendTo(j);
  // };

  // View.prototype.remove = function (j) {
  //  return this.Parent.remove(j);
  // };

  // View.prototype.css = function (j) {
  //  return this.Parent.css(j);
  // };

  // TODO: Get rid of this.
  View.prototype.GetViewport = function () {
    return this.Viewport;
  };

  View.prototype.GetWidth = function () {
    return this.Parent.width();
  };

  View.prototype.GetHeight = function () {
    return this.Parent.height();
  };

  View.prototype.UpdateSize = function () {
    this.UpdateCanvasSize();
  };

  // The canvasDiv changes size, the width and height of the canvas and
  // camera need to follow.  I am going to make this the resize callback.
  View.prototype.UpdateCanvasSize = function () {
    if (!this.Parent.is(':visible')) {
      return false;
    }

    var pos = this.Parent.position();
    // var width = this.Parent.innerWidth();
    // var height = this.Parent.innerHeight();
    var width = this.Parent.width();
    var height = this.Parent.height();
    // resizable is making width 0 intermitently ????
    if (width <= 0 || height <= 0) { return false; }

    this.SetViewport([pos.left, pos.top, width, height]);

    return true;
  };

  // This is meant to be called internally by UpdateCanvasSize.
  // However, if the parent(canvasDiv) is hidden, it might need to be
  // set explcitly.
  // TODO: Change this to simply width and height.
  View.prototype.SetViewport = function (viewport) {
    var width = viewport[2];
    var height = viewport[3];

    this.Canvas.attr('width', width.toString());
    this.Canvas.attr('height', height.toString());

    // TODO: Get rid of this ivar
    this.Viewport = viewport;

    // TODO: Just set the width and height of the camera.
    // There is no reason, the camera needs to know the
    // the position of the cameraDiv.
    this.Camera.SetViewport(viewport);
  };

  View.prototype.CaptureImage = function () {
    var url = this.Canvas[0].toDataURL();
    var newImg = document.createElement('img'); // create
    newImg.src = url;
    return newImg;
  };

  // Legacy
  // A list of shapes to render in the view
  View.prototype.AddShape = function (shape) {
    this.ShapeList.push(shape);
  };

  // NOTE: AnnotationLayer has the api where the shapes draw themselves (with
  // reference to this view.  I like that better than the view knowing
  // how to draw all these things.
  View.prototype.DrawShapes = function () {
    if (!this.Parent.is(':visible')) {
      return;
    }
    for (var i = 0; i < this.ShapeList.length; i++) {
      this.ShapeList[i].Draw(this);
    }
  };

  View.prototype.Clear = function () {
    this.Context2d.save();
    this.Context2d.setTransform(1, 0, 0, 1, 0, 0);
    // TODO: get width and height from the canvas.
    this.Context2d.clearRect(0, 0, this.Viewport[2], this.Viewport[3]);
    this.Context2d.restore();
  };

  View.prototype.DrawHistory = function (windowHeight) {
    if (this.gl) {
      alert('Drawing history does not work with webGl yet.');
    } else {
      var ctx = this.Context2d;
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);

      // Start with a transform that flips the y axis.
      ctx.setTransform(1, 0, 0, -1, 0, this.Viewport[3]);

      // Map (-1->1, -1->1) to the viewport.
      // Origin of the viewport does not matter because drawing is relative
      // to this view's canvas.
      ctx.transform(0.5 * this.Viewport[2], 0.0,
                          0.0, 0.5 * this.Viewport[3],
                          0.5 * this.Viewport[2],
                          0.5 * this.Viewport[3]);

      // ctx.fillRect(0.0,0.1,0.5,0.5); // left, right, width, height

      // The camera maps the world coordinate system to (-1->1, -1->1).
      var cam = this.Camera;
      var m = cam.GetWorldMatrix();
      var h = 1.0 / m[15];
      ctx.transform(m[0] * h, m[1] * h,
                    m[4] * h, m[5] * h,
                    m[12] * h, m[13] * h);

      var timeLine = SA.recorderWidget.TimeLine;
      for (var i = 0; i < timeLine.length; ++i) {
        cam = timeLine[i].ViewerRecords[0].Camera;
        var height = cam.Height;
        var width = cam.Width;
        // camer roll is already in radians.
        var c = Math.cos(cam.GetWorldRoll());
        var s = Math.sin(cam.GetWorldRoll());
        ctx.save();
        // transform to put focal point at 0,0
        var fp = cam.GetWorldFocalPoint();
        ctx.transform(c, -s,
                      s, c,
                      fp[0], fp[1]);

        // Compute the zoom factor for opacity.
        var opacity = 2 * windowHeight / height;
        if (opacity > 1.0) { opacity = 1.0; }

        ctx.fillStyle = 'rgba(0,128,0,' + opacity + ')';
        ctx.fillRect(-width / 2, -height / 2, width, height); // left, right, width, height
        ctx.stroke();
        ctx.restore();
      }
      ctx.restore();
    }
  };

  // Draw a cross hair in the center of the view.
  View.prototype.DrawFocalPoint = function () {
    if (this.gl) {
      alert('Drawing focal point does not work with webGl yet.');
    } else {
      var x = this.Viewport[2] * 0.5;
      var y = this.Viewport[3] * 0.5;
      var ctx = this.Context2d;
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.strokeStyle = 'rgba(255,255,200,100)';
      ctx.fillStyle = 'rgba(0,0,50,100)';

      ctx.beginPath();
      ctx.fillRect(x - 30, y - 1, 60, 3);
      ctx.rect(x - 30, y - 1, 60, 3);
      ctx.fillRect(x - 1, y - 30, 3, 60);
      ctx.rect(x - 1, y - 30, 3, 60);

      var r = y / 2;
      ctx.beginPath();
      ctx.moveTo(x - r, y - r + 30);
      ctx.lineTo(x - r, y - r);
      ctx.lineTo(x - r + 30, y - r);
      ctx.moveTo(x + r, y - r + 30);
      ctx.lineTo(x + r, y - r);
      ctx.lineTo(x + r - 30, y - r);
      ctx.moveTo(x + r, y + r - 30);
      ctx.lineTo(x + r, y + r);
      ctx.lineTo(x + r - 30, y + r);
      ctx.moveTo(x - r, y + r - 30);
      ctx.lineTo(x - r, y + r);
      ctx.lineTo(x - r + 30, y + r);
      ctx.stroke();

      ++r;
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(0,0,50,100)';
      ctx.moveTo(x - r, y - r + 30);
      ctx.lineTo(x - r, y - r);
      ctx.lineTo(x - r + 30, y - r);
      ctx.moveTo(x + r, y - r + 30);
      ctx.lineTo(x + r, y - r);
      ctx.lineTo(x + r - 30, y - r);
      ctx.moveTo(x + r, y + r - 30);
      ctx.lineTo(x + r, y + r);
      ctx.lineTo(x + r - 30, y + r);
      ctx.moveTo(x - r, y + r - 30);
      ctx.lineTo(x - r, y + r);
      ctx.lineTo(x - r + 30, y + r);
      ctx.stroke();
      ctx.restore();
    }
  };

  // Draw a cross hair at each correlation point.
  // pointIdx is 0 or 1.  It indicates which correlation point should be drawn.
  View.prototype.DrawCorrelations = function (correlations, pointIdx) {
    if (this.gl) {
      alert('Drawing correlations does not work with webGl yet.');
    } else {
      var ctx = this.Context2d;
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.strokeStyle = 'rgba(200,255,255,100)';
      ctx.fillStyle = 'rgba(255,0,0,100)';
      for (var i = 0; i < correlations.length; ++i) {
        var wPt = correlations[i].GetPoint(pointIdx);
        var m = this.Camera.GetWorldMatrix();
        // Change coordinate system from world to -1->1
        var x = (wPt[0] * m[0] + wPt[1] * m[4] + m[12]) / m[15];
        var y = (wPt[0] * m[1] + wPt[1] * m[5] + m[13]) / m[15];
        // Transform coordinate system from -1->1 to canvas
        x = (1.0 + x) * this.Viewport[2] * 0.5;
        y = (1.0 - y) * this.Viewport[3] * 0.5;

        ctx.beginPath();
        ctx.fillRect(x - 20, y - 1, 40, 3);
        ctx.rect(x - 20, y - 1, 40, 3);
        ctx.fillRect(x - 1, y - 20, 3, 40);
        ctx.rect(x - 1, y - 20, 3, 40);

        ctx.stroke();
      }
      ctx.restore();
    }
  };

  // NOTE: Not used anymore. Viewer uses a DOM.
  View.prototype.DrawCopyright = function (copyright) {
    if (copyright === undefined) {
      return;
    }
    if (this.gl) {
      // not implemented yet.
    } else {
      this.Context2d.setTransform(1, 0, 0, 1, 0, 0);
      this.Context2d.font = '18px Arial';
      var x = this.Viewport[2] * 0.5 - 50;
      var y = this.Viewport[3] - 10;
      this.Context2d.fillStyle = 'rgba(128,128,128,0.5)';
      this.Context2d.fillText(copyright, x, y);
      // this.Context2d.strokeStyle = "rgba(255,255,255,0.5)";
      // this.Context2d.strokeText(copyright,x,y);
    }
  };

  // I think this was only used for webgl.  Not used anymore
  View.prototype.DrawOutline = function (backgroundFlag) {
    if (this.gl) {
      var program = SA.polyProgram;
      this.gl.useProgram(program);

      this.gl.viewport(this.Viewport[0],
                             this.Viewport[3] - this.Viewport[1],
                             this.Viewport[2],
                             this.Viewport[3]);

      // Draw a line around the viewport, so move (0,0),(1,1) to (-1,-1),(1,1)
      mat4.identity(this.OutlineCamMatrix);
      this.OutlineCamMatrix[0] = 2.0; // width x
      this.OutlineCamMatrix[5] = 2.0; // width y
      this.OutlineCamMatrix[10] = 0;
      this.OutlineCamMatrix[12] = -1.0;
      this.OutlineCamMatrix[13] = -1.0;
      var viewFrontZ = this.Camera.ZRange[0] + 0.001;
      var viewBackZ = this.Camera.ZRange[1] - 0.001;
      this.OutlineCamMatrix[14] = viewFrontZ; // front plane

      mat4.identity(this.OutlineMatrix);

      this.gl.uniformMatrix4fv(program.mvMatrixUniform, false, this.OutlineMatrix);

      if (backgroundFlag) {
        // White background fill
        this.OutlineCamMatrix[14] = viewBackZ; // back plane
        this.gl.uniformMatrix4fv(program.pMatrixUniform, false, this.OutlineCamMatrix);
        this.gl.uniform3f(program.colorUniform, 1.0, 1.0, 1.0);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, SA.squarePositionBuffer);
        this.gl.vertexAttribPointer(program.vertexPositionAttribute,
                                            SA.squarePositionBuffer.itemSize,
                                            this.gl.FLOAT, false, 0, 0);
        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, SA.squarePositionBuffer.numItems);
      }

      // outline
      this.OutlineCamMatrix[14] = viewFrontZ; // force in front
      this.gl.uniformMatrix4fv(program.pMatrixUniform, false, this.OutlineCamMatrix);
      this.gl.uniform3f(program.colorUniform, this.OutlineColor[0], this.OutlineColor[1], this.OutlineColor[2]);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, SA.squareOutlinePositionBuffer);
      this.gl.vertexAttribPointer(program.vertexPositionAttribute,
                                        SA.squareOutlinePositionBuffer.itemSize,
                                        this.gl.FLOAT, false, 0, 0);
      this.gl.drawArrays(this.gl.LINE_STRIP, 0, SA.squareOutlinePositionBuffer.numItems);
    }
  };

    // =================================================
    // Extend the image data returned by the canvas.

  function ImageData () {
    this.IncX = 1;
    this.IncY = 1;
  }

  ImageData.prototype.GetIntensity = function (x, y) {
    if (!this.data) { return 0; }
    x = Math.round(x);
    y = Math.round(y);
    var idx = x * this.IncX + y * this.IncY;
    return (this.data[idx] + this.data[idx + 1] + this.data[idx + 2]) / 3;
  };

  ImageData.prototype.InBounds = function (x, y) {
    if (!this.data) { return false; }
    return (x >= 0 && x < this.width && y >= 0 && y < this.height);
  };

  // Mark edges visited so we do not create the same contour twice.
  // I cannot mark the pixel cell because two contours can go through the same cell.
  // Note:  I have to keep track of both the edge and the direction the contour leaves
  // the edge.  The backward direction was to being contoured because the starting
  // edge was already marked.  The order of the points here matters.  Each point
  // marks 4 edges.
  ImageData.prototype.MarkEdge = function (x0, y0, x1, y1) {
    if (!this.EdgeMarks) {
      var numTemplates = Math.round((this.width) * (this.height));
      this.EdgeMarks = new Array(numTemplates);
      for (var i = 0; i < numTemplates; ++i) {
        this.EdgeMarks[i] = 0;
      }
    }

    var edge = 0;
    if (x0 !== x1) {
      edge = (x0 < x1) ? 1 : 4;
    } else if (y0 !== y1) {
      edge = (y0 < y1) ? 2 : 8;
    }

    var idx = x0 + y0 * (this.width);
    var mask = this.EdgeMarks[idx];
    if (mask & edge) {
      return true;
    }
    this.EdgeMarks[idx] = mask | edge;
    return false;
  };

  SAM.ImageData = ImageData;
  SAM.View = View;
})();

// This is created by the girder plugin to create anntotation layers.
// This manages a list of annotation layers as divs on the left side of the viewer window.

// Added: currently visible annotations names to the "localStorage" so they remain open when stepping
// through images with the navigator.

// Each layer is a group of vector annotations that can be turned on and off together.
// Layers first started off as markup,  but I am extending this to include a raster mask layer.

// Notes:
// LayerGuis, are annotationLayerGui objects that manaage an annotation layer and GUI

// TODO:
// I want layerGui to own the tools, but the tools have to be available before the first layer is created.
// Make a default layerGui that is not visible until it has its first annotation

// TODO:
// Click Select circle not working
// Cannot navigate viewer with touch.

(function () {
  'use strict';

  function LayerPanel (viewer, itemId) {
    this.Viewer = viewer;
    this.Parent = viewer.GetDiv();
    this.ItemId = itemId;
    this.LayerGuis = [];
    this.ModifiedCount = 0;
    this.EditingLayerGui = undefined;

    this.Viewer.ScaleOn();

    // Because of loading on demand, the easiest way to restore
    // visibile annotations from local storage is to load a list
    // here.
    this.RestoreVisibilityFromLocalStorage();

    // Create a parent div to hold all of the annotation labels
    // Warning: These are duplicated in layerPanel
    this.Margin = 6;
    this.ToolDivHeight = 70;

    // Holds the annotation buttons.  The tool div acutally floats in the viewer.
    this.Div = $('<div>')
      // Have to use this parent, or events are blocked.
      .appendTo(this.Parent)
      .attr('id', 'saAnnotationPanel')
      .hover(function () { $(this).css({'opacity': '1'}); },
             function () { $(this).css({'opacity': '0.6'}); })
      .css({
        'position': 'absolute',
        'left': '3px',
        'top': (5 * this.Margin + this.ToolDivHeight) + 'px',
        'bottom': (2 * this.Margin) + 'px',
        'opacity': '0.6',
        'z-index': '2'});

    // Test
    /*
    var self = this;
    var obj = {'item_id': "5cd437d71841c12368df8519",
               'name': "test.txt",
               'data': "Hello World"};
    girder.rest.restRequest({
      url: 'item/' + obj.item_id + '/tiles',
      method: 'GET'
    }).done(function (data) {
      obj.sizeX = data.sizeX;
      obj.sizeY = data.sizeY;
      self.TestUploadFile(obj);
    });
    */

    this.Parent = viewer.GetDiv();
    this.InitializeHelp(this.Parent.parent());

    // The pannel should probably not be managing this navigation widget.
    // I am putting it here as a temporary home.
    if (itemId) {
      this.InitializeNavigation(viewer.GetDiv(), itemId);
      this.Initialize(this.Div, itemId);
    }

    // To get event calls from the viewer.
    this.Viewer.AddLayer(this);
  }

  LayerPanel.prototype.TestUploadFile = function (obj) {
    var self = this;
    girder.rest.restRequest({
      url: 'item/' + obj.item_id + '/files',
      method: 'GET'
    }).done(function (data) {
      for (var idx = 0; idx < data.length; ++idx) {
        if (data[idx].name === obj.name) {
          obj.file_id = data[idx]._id;
          break;
        }
      }
      self.TestUploadFile2(obj);
    });
  };

  LayerPanel.prototype.TestUploadFile2 = function (obj) {
    var self = this;
    var params;
    if ('file_id' in obj) {
      params = {
        'size': obj.data.length
      };
      girder.rest.restRequest({
        url: 'file/' + obj.file_id + '/contents',
        params: params,
        method: 'PUT'
      }).done(function (data) {
        obj.upload_id = data._id;
        self.TestUploadFile3(obj);
      });
    } else {
      params = {
        'parentType': 'item',
        'parentId': obj.item_id,
        'name': 'test.txt',
        'size': obj.data.length,
        // 'mimeType':'image/png'
        'mimeType': 'text/plain'
      };
      girder.rest.restRequest({
        url: 'file',
        params: params,
        method: 'POST'
      }).done(function (data) {
        obj.upload_id = data._id;
        self.TestUploadFile3(obj);
      });
    }
  };

  LayerPanel.prototype.TestUploadFile3 = function (obj) {
    var params = {
      'offset': 0,
      'uploadId': obj.upload_id
    };
    girder.rest.restRequest({
      url: 'file/chunk',
      params: params,
      method: 'POST',
      data: obj.data
    }).done(function (data) {
      console.log('upload sucessful ' + data['_id']);
    });
  };

  // onresize callback.  Canvas width and height and the camera need
  // to be synchronized with the canvas div.
  LayerPanel.prototype.UpdateSize = function () {
    for (var i = 0; i < this.LayerGuis.length; ++i) {
      var layerGui = this.LayerGuis[i];
      var layer = layerGui.layer;
      if (layer && layer.UpdateSize) {
        layer.UpdateSize();
      }
    }
  };

  LayerPanel.prototype.Draw = function () {
    for (var i = 0; i < this.LayerGuis.length; ++i) {
      var layerGui = this.LayerGuis[i];
      var layer = layerGui.Layer;
      if (layer && layer.Draw) {
        layer.Draw();
      }
    }
  };

  LayerPanel.prototype.Reset = function () {
    for (var i = 0; i < this.LayerGuis.length; ++i) {
      var layerGui = this.LayerGuis[i];
      var layer = layerGui.layer;
      if (layer && layer.Reset) {
        layer.Reset();
      }
    }
  };

  LayerPanel.prototype.InitializeNavigation = function (parent, itemId) {
    var nav = new SA.GirderNavigationWidget(parent, itemId);
    var self = this;
    nav.SetChangeItemCallback(function (itemId) { self.ChangeItem(itemId); });
  };

  // This call back pattern is all because we load on demand.
  // Gets the annotation being edited. If one is not editing, look for one
  // with the default name (users last name).  If none are found, one is created.
  // The tools use this method.
  LayerPanel.prototype.WithEditingLayerCall = function (callback) {
    if (!this.EditingLayerGui) {
      this.EditingLayerGui = this.GetDefaultLayerGui();
    }

    // Make sure it is loaded before executing the callback.
    var layerGui = this.EditingLayerGui;
    layerGui.AfterLoad(function () {
      layerGui.DisplayAnnotation();
      layerGui.EditOn();
      (callback)(layerGui);
    });
  };

  // ===============================================================================
  // TODO: The information has to find a different home.
  LayerPanel.prototype.InitializeHelp = function (parent) {
    var helpDiv = $('<div>')
        .appendTo(parent)
        .css({
          'position': 'absolute',
          'left': '3px',
          'top': '3px',
          'min-height': '300px',
          'min-width': '200px',
          'background-color': '#fff',
          'border': '1px solid #666666',
          'z-index': '400'})
        .hide()
        .on('mouseleave',
            function (e) {
              helpDiv.hide();
            });
    // var helpCloseButton =
    $('<div>')
      .appendTo(helpDiv)
      .prop('title', 'close')
      .addClass('sa-view-button')
      .css({
        'position': 'absolute',
        'right': '3px',
        'top': '3px',
        'height': '24px',
        'color': '#000',
        'z-index': '300'})
      .text('close')
      .on('click touchend',
          function (e) {
            helpDiv.hide();
          });

    var fullScreenOnDiv = $('<div>')
        .appendTo(helpDiv)
        .css({'width': '100%'});
    $('<img>')
      .appendTo(fullScreenOnDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'fullScreen32.png')
      .css({'height': '24px'});
    $('<p>')
      .appendTo(fullScreenOnDiv)
      .css({'display': 'inline-block'})
      .text('Expand the viewer to fullscreen.');

    var fullScreenOffDiv = $('<div>')
        .appendTo(helpDiv)
        .css({'width': '100%'});
    $('<img>')
      .appendTo(fullScreenOffDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'fullScreenOff32.png')
      .css({'height': '24px'});
    $('<p>')
      .appendTo(fullScreenOffDiv)
      .css({'display': 'inline-block'})
      .text('Exit fullscreen');

    var textDiv = $('<div>')
        .appendTo(helpDiv)
        .css({'width': '100%'});
    $('<img>')
      .appendTo(textDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'Text.png')
      .css({'height': '24px'});
    $('<p>')
      .appendTo(textDiv)
      .css({'display': 'inline-block'})
      .text('Text tool: Select text to drag it.');

    var arrowDiv = $('<div>')
        .appendTo(helpDiv)
        .css({'width': '100%'});
    $('<img>')
      .appendTo(arrowDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'Arrow.png')
      .css({'height': '24px'});
    $('<p>')
      .appendTo(arrowDiv)
      .css({'display': 'inline-block'})
      .text('Arrow tool: draw an arrow. Mouse press places the tip. Mouse drag places the end.');

    var pencilDiv = $('<div>')
        .appendTo(helpDiv)
        .css({'width': '100%'});
    $('<img>')
      .appendTo(pencilDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'Pencil-icon.png')
      .css({'height': '24px'});
    $('<p>')
      .appendTo(pencilDiv)
      .css({'display': 'inline-block'})
      .text('Pencil tool: draw lines on the slide. Click on a line to select it.');

    var openDiv = $('<div>')
        .appendTo(helpDiv)
        .css({'width': '100%'});
    $('<img>')
      .appendTo(openDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'open_lasso.png')
      .css({
        'height': '24px',
        'margin-left': '24px'});
    $('<p>')
      .appendTo(openDiv)
      .css({'display': 'inline-block'})
      .text('Open pencil mode: Simple open strokes.');

    var closedDiv = $('<div>')
        .appendTo(helpDiv)
        .css({'width': '100%'});
    $('<img>')
      .appendTo(closedDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'select_lasso.png')
      .css({
        'height': '24px',
        'margin-left': '24px'});
    $('<p>')
      .appendTo(closedDiv)
      .css({'display': 'inline-block'})
      .text('Closed pencil mode: Draw closed loops that can be modified with subsequent strokes. Editing strokes must cross the loop twice.');

    // Selection -------------------------------------------------------------------
    $('<hr>')
      .appendTo(helpDiv);
    $('<p>')
      .appendTo(helpDiv)
      .css({'display': 'inline-block'})
      .text('Click on any annotation to select it. The delete key deletes selected annotations. When one annotation is selected it can be edited.');

    var rectSelectDiv = $('<div>')
        .appendTo(helpDiv)
        .css({'width': '100%'});
    $('<img>')
      .appendTo(rectSelectDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'rect_select.png')
      .css({'height': '24px'});
    $('<p>')
      .appendTo(rectSelectDiv)
      .css({'display': 'inline-block'})
      .text('The rectancle selection tool allows multiple annotations to be selected at once.');

    var propertiesDiv = $('<div>')
        .appendTo(helpDiv)
        .css({'width': '100%'});
    $('<img>')
      .appendTo(propertiesDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'Menu.jpg')
      .css({'height': '24px'});
    $('<p>')
      .appendTo(propertiesDiv)
      .css({'display': 'inline-block'})
      .text('Show the selected annotation\'s property dialog.');

    // Annotation buttons ---------------------------------------------------------
    $('<hr>')
      .appendTo(helpDiv);

    var annotationButtonDiv = $('<div>')
        .appendTo(helpDiv)
        .css({'width': '100%'});
    $('<img>')
      .appendTo(annotationButtonDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'AnnotationButton.jpg')
      .css({'height': '24px'});
    $('<p>')
      .appendTo(annotationButtonDiv)
      .css({'display': 'inline-block'})
      .text('Annotation buttons represent markup collections. YOu can click the name to change it.');

    var visibilityDiv = $('<div>')
        .appendTo(helpDiv)
        .css({'width': '100%'});
    $('<img>')
      .appendTo(visibilityDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'eyeClosed32.png')
      .css({
        'height': '24px',
        'margin-left': '24px'});
    $('<img>')
      .appendTo(visibilityDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'eyeOpen32.png')
      .css({'height': '24px'});
    $('<p>')
      .appendTo(visibilityDiv)
      .css({'display': 'inline-block'})
      .text('The visibility toggle hides or shows all the markups in the annotation group.');

    var editDiv = $('<div>')
        .appendTo(helpDiv)
        .css({'width': '100%'});
    $('<img>')
      .appendTo(editDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'edit_up.png')
      .css({
        'height': '24px',
        'margin-left': '24px'});
    $('<img>')
      .appendTo(editDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'edit_down.png')
      .css({'height': '24px'});
    $('<p>')
      .appendTo(editDiv)
      .css({'display': 'inline-block'})
      .text('The edit toggle selects a single annotation group for editing.');

    var deleteDiv = $('<div>')
        .appendTo(helpDiv)
        .css({'width': '100%'});
    $('<img>')
      .appendTo(deleteDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'remove.png')
      .css({
        'height': '24px',
        'margin-left': '24px'});
    $('<p>')
      .appendTo(deleteDiv)
      .css({'display': 'inline-block'})
      .text('Delete a selected annotation. If no annotation is selected, the whole annotation group will be deleted.');

    // Toggle the help window on and off.
    // var helpButton =
    $('<img>')
      .appendTo(parent)
      .prop('title', 'help')
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'question32.png')
      .css({
        'position': 'absolute',
        'left': '35px',
        'top': '2px',
        'height': '24px',
        'z-index': '300'})
      .on('click touchend',
          function (e) {
            helpDiv.show();
          });
  };

  // ===============================================================================
  // Call back from navigation to update the annotation to match the viewer item.
  LayerPanel.prototype.ChangeItem = function (itemId) {
    // Change the image in the viewer.
    var self = this;

    this.ItemId = itemId;

    // There is contention trying to restore annotation visibility in the next item.
    // Deleting Annotation Buttons erases local storage of the visible names.
    // Probably a better solution than this is to have two set visibility methods.
    // Only the one used by the gui changes local storage values.
    // For now, save and restore the cached names.
    var savedNames = this.LocalStorageVisibleAnnotationNames.splice(0);

    // Now for the annotation stuff.
    this.DeleteAnnotationButtons();
    this.LocalStorageVisibleAnnotationNames = savedNames;
    this.Initialize(this.Div, itemId);
    girder.rest.restRequest({
      url: 'item/' + itemId + '/tiles',
      method: 'GET'
    }).done(function (data) {
      self.LoadItemToViewer(itemId, data);
    });
  };

  // Now update the annotation GUI
  LayerPanel.prototype.DeleteAnnotationButtons = function () {
    this.EditingLayerGui = undefined;
    for (var i = 0; i < this.LayerGuis.length; ++i) {
      var layerGui = this.LayerGuis[i];
      layerGui.EditOff();
      layerGui.VisibilityOff();
      if (layerGui.Div) {
        layerGui.Div.remove();
      }
    }
    this.LayerGuis = [];
  };

  LayerPanel.prototype.RestoreVisibilityFromLocalStorage = function () {
    this.LocalStorageVisibleAnnotationNames = [];
    var str = localStorage.getItem('SAAnnotationVisibility');
    if (str) {
      this.LocalStorageVisibleAnnotationNames = JSON.parse(str);
    }
  };

  LayerPanel.prototype.SaveVisibilityInLocalStorage = function () {
    // Start with the list in storage already.
    var names = this.LocalStorageVisibleAnnotationNames;

    // Only modify the names this view has.
    // I had a problem where one section did not have an annotation name,
    // So the annotation would turn off when I did not want it to.
    for (var idx = 0; idx < this.LayerGuis.length; ++idx) {
      var layerGui = this.LayerGuis[idx];
      var name = layerGui.Name;
      var nameIdx = names.indexOf(name);
      // Toggle
      if (layerGui.Visible && nameIdx === -1) {
        names.push(layerGui.Name);
      }
      if (!layerGui.Visible && nameIdx !== -1) {
        names.splice(nameIdx, 1);
      }
    }

    localStorage.setItem('SAAnnotationVisibility', JSON.stringify(names));
    this.LocalStorageVisibleAnnotationNames = names;
  };

  LayerPanel.prototype.LoadItemToViewer = function (itemId, data) {
    // TODO: if a viewer already exists, do we render again?
    // SlideAtlas bundles its own version of jQuery, which should attach itself to 'window.$' when it's sourced
    // The 'this.$el' still uses the Girder version of jQuery, which will not have 'saViewer' registered on it.
    var tileSource = {
      height: data.sizeY,
      width: data.sizeX,
      tileWidth: data.tileWidth,
      tileHeight: data.tileHeight,
      minLevel: 0,
      maxLevel: data.levels - 1,
      units: 'mm',
      spacing: [data.mm_x, data.mm_y],
      getTileUrl: function (level, x, y, z) {
        // Drop the 'z' argument
        var apiroot = 'api/v1';
        return apiroot + '/item/' + itemId + '/tiles/zxy/' + level + '/' + x + '/' + y;
      }
    };
    if (!data.mm_x) {
      // tileSource.units = 'pixels';
      tileSource.spacing = [1, 1];
    }

    var note = SA.TileSourceToNote(tileSource);
    this.Viewer.SetNote(note, 0, true);
    // Viewer.prototype.SetViewerRecord(viewerRecord, lockCamera);
  };

  LayerPanel.prototype.Initialize = function (parent, itemId) {
    // The multiple nested annotation button divs are to get the scrollbar
    // on the left, but keep the text left justified.
    this.ScrollDiv = $('<div>')
      .appendTo(parent)
      .attr('id', 'saAnnotationButtons')
      .css({
        'direction': 'rtl',
        'overflow-y': 'auto'
        // 'position': 'absolute',
        // 'left': (3 * this.Margin) + 'px',
        // 'top': (10 * this.Margin) + 'px',
        // 'bottom': (5* this.Margin) + 'px',
        // 'width': '30%',
        // 'opacity': '0.4',
        // 'z-index': '2'
      });

    // A container for the list of buttons.
    this.ButtonDiv = $('<div>')
      .appendTo(this.ScrollDiv)
      .on('mousemove touchmove', function () { return true; })
      .css({'direction': 'ltr'});

    // Get a list of annotations and populate the button div.
    // But first, get info about the user (to manage sharing).
    var self = this;
    girder.rest.restRequest({
      url: 'user/me',
      method: 'GET'
    }).done(function (data) {
      if (!data) {
        self.UserData = {_id: '0000', login: 'guest'};
      } else {
        self.UserData = data;
      }
      if (itemId) { // This check is probably unnecessary
        self.RequestGirderImageItem(itemId);
      }
    });
  };

  // Get a list of annotations and make the buttons.
  // Do not get or load the annotation data yet.
  LayerPanel.prototype.RequestGirderImageItem = function (itemId) {
    // I think data is the wrong place to pass these parameters.
    var data = {
      'limit': 50,
      'offset': 0,
      'sort': 'lowerName',
      'sortdir': 0};

    var self = this;
    // This gives an array of {_id: '....',annotation:{name: '....'},itemId: '....'}
    girder.rest.restRequest({
      url: 'annotation?itemId=' + itemId,
      method: 'GET',
      data: JSON.stringify(data)
    }).done(function (data) {
      self.LoadGirderItemAnnotations(data);
    });
  };
  // Just the meta data for the items.  Make buttons from the meta data.
  LayerPanel.prototype.LoadGirderItemAnnotations = function (data) {
    // TODO: Figure out the edit button (hide it if the user does not have access.)
    for (var i = 0; i < data.length; ++i) {
      var layerGui = new SAM.AnnotationLayerGui(data[i], this);
      this.LayerGuis.push(layerGui);
    }

    // If the user has write access, we need a default layerGui.
    // First we have to see if we have write access to the folder containing this item.
    // We get the folder from the item ........
    if (this.ItemId) {
      var self = this;
      girder.rest.restRequest({
        url: 'item/' + this.ItemId,
        method: 'GET'
      }).done(function (data) {
        self.CheckItemDataAccessTools(data);
      });
    }
  };
  LayerPanel.prototype.CheckItemDataAccessTools = function (data) {
    // First we have to see if we have write access to the folder containing this item.
    var self = this;
    girder.rest.restRequest({
      url: 'folder/' + data.folderId,
      method: 'GET'
    }).done(function (data) {
      self.CheckFolderDataAccessTools(data);
    });
  };
  LayerPanel.prototype.CheckFolderDataAccessTools = function (data) {
    if (data._accessLevel === 0) {
      // No access, skip creating the tools (which are confusing to have
      // if annoation cannot be saved.
      return;
    }

    this.InitializeDefaultToolPanel();
  };

  // This is done when this object is first created, and
  // when the dafault layerGui name is changed.
  LayerPanel.prototype.InitializeDefaultToolPanel = function () {
    this.DefaultToolPanel = new SAM.AnnotationToolPanel(this);
    this.DefaultToolPanel.Show();
  };

  LayerPanel.prototype.GetDefaultLayerName = function () {
    return this.UserData.login;
  };

  // Find or make a deafult GUI (user name).  Return it.
  LayerPanel.prototype.GetDefaultLayerGui = function () {
    var layerGui;
    var defaultLayerName = this.GetDefaultLayerName();
    for (var idx = 0; idx < this.LayerGuis.length; ++idx) {
      layerGui = this.LayerGuis[idx];
      if (layerGui.Name === defaultLayerName) {
        return layerGui;
      }
    }

    // Setting the ToolPanel is deferred until it starts editing.
    layerGui = new SAM.AnnotationLayerGui(
      {'annotation': {'name': defaultLayerName}, 'creatorId': this.UserData._id},
      this);
    this.LayerGuis.push(layerGui);
    return layerGui;
  };

  // ===========================================================================
  // Forward events to layers.

  // onresize callback.  Canvas width and height and the camera need
  // to be synchronized with the canvas div.
  LayerPanel.prototype.UpdateSize = function () {
    for (var i = 0; i < this.LayerGuis.length; ++i) {
      var layerGui = this.LayerGuis[i];
      var layer = layerGui.layer;
      if (layer && layer.UpdateSize) {
        layer.UpdateSize();
      }
    }
  };

  LayerPanel.prototype.Draw = function () {
    for (var i = 0; i < this.LayerGuis.length; ++i) {
      var layerGui = this.LayerGuis[i];
      var layer = layerGui.Layer;
      if (layer && layer.Draw) {
        layer.Draw();
      }
    }
  };

  LayerPanel.prototype.Reset = function () {
    for (var i = 0; i < this.LayerGuis.length; ++i) {
      var layerGui = this.LayerGuis[i];
      var layer = layerGui.layer;
      if (layer && layer.Reset) {
        layer.Reset();
      }
    }
  };

  // TODO: Try to put this into annotationLayerGui (if it makes sense).
  LayerPanel.prototype.HandleTouchStart = function (event) {
    if (this.CheckForIPadPencil(event)) {
      // User is drawing with a pencil.  Make sure a layer is editable.
      this.WithEditingLayerCall(
        function (layerGui) {
          // A small hack.
          layerGui.SelectedWidgets = [layerGui.Layer.GetIPadPencilWidget()];
          layerGui.Layer.HandleTouchStart(event);
        });
      return false;
    }
    if (this.EditingLayerGui) {
      var layer = this.EditingLayerGui.Layer;
      if (layer && layer.HandleTouchStart) {
        return layer.HandleTouchStart(event);
      }
    }
    return true;
  };

  LayerPanel.prototype.HandleTouchMove = function (event) {
    this.CheckForIPadPencil(event);
    if (this.EditingLayerGui) {
      var layer = this.EditingLayerGui.Layer;
      if (layer && layer.HandleTouchMove) {
        return layer.HandleTouchMove(event);
      }
    }
    return true;
  };

  LayerPanel.prototype.HandleTouchEnd = function (event) {
    // No touches for end events so we cannot check for ipad pencil.
    if (this.EditingLayerGui) {
      var layer = this.EditingLayerGui.Layer;
      if (layer && layer.HandleTouchEnd) {
        // To cache pencil editing.
        this.EditingLayerGui.UpdateToolVisibility();
        return layer.HandleTouchEnd(event);
      }
    }
    return true;
  };

  LayerPanel.prototype.HandleMouseDown = function (event) {
    if (this.EditingLayerGui) {
      var layer = this.EditingLayerGui.Layer;
      if (layer && layer.HandleMouseDown) {
        return layer.HandleMouseDown(event);
      }
    }
    return true;
  };

  LayerPanel.prototype.HandleMouseUp = function (event) {
    if (this.EditingLayerGui) {
      var layer = this.EditingLayerGui.Layer;
      if (layer && layer.HandleMouseUp) {
        return layer.HandleMouseUp(event);
      }
    }
    return true;
  };

  LayerPanel.prototype.HandleMouseMove = function (event) {
    if (this.EditingLayerGui) {
      var layer = this.EditingLayerGui.Layer;
      if (layer && layer.HandleMouseMove) {
        return layer.HandleMouseMove(event);
      }
    }
    return true;
  };

  LayerPanel.prototype.HandleMouseWheel = function (event) {
    if (this.EditingLayerGui) {
      var layer = this.EditingLayerGui.Layer;
      if (layer && layer.HandleMouseWheel) {
        return layer.HandleMouseWheel(event);
      }
    }
    return true;
  };

  LayerPanel.prototype.HandleKeyDown = function (event) {
    if (!this.EditingLayerGui) {
      return true;
    }
    var layer = this.EditingLayerGui.Layer;
    // Handle the delete key special
    // Multiple widgets ( in the layer being edit) can be deleted.
    if (event.keyCode === 46 || event.keyCode === 8) { // delete key
      if (this.EditingLayerGui) {
        this.EditingLayerGui.DeleteSelected();
        // TODO: SHould this be in "DeleteSelected"?
        layer.EventuallyDraw();
        event.preventDefault();
        return false;
      }
    }

    if (layer && layer.HandleKeyDown) {
      return layer.HandleKeyDown(event);
    }

    return true;
  };

  // I am going to use click / tap to select markup.
  // How can we enforce only one selected at a time (for click)?
  // First one to consume the click stops propagation.
  // The problem is:  What should we do if one is already selected?
  // Event propagation will turn anyones off in the early layers.
  // After event propagation is stoped,  Loop through the rest
  // un selecting them.
  // NOTE: Select opperates on all layers.  It will choose a new "EditingLayerGui".
  LayerPanel.prototype.HandleMouseClick = function (event) {
    if (this.EditingLayerGui) {
      // See if a widget in the editing wants to handle the click.
      var layer = this.EditingLayerGui.Layer;
      if (layer && layer.HandleMouseClick) {
        if (!layer.HandleMouseClick(event)) {
          // false means the event was consumed.
          return false;
        }
      }

      // This selection path (for an editing layer) is to avoid an
      // undesireable behavior. Accidentally clicking an annotation in
      // a different layer Changed the new layer to take editing focus.
      // New annotations end up in the wrong layer.

      var selectedWidgets = [];
      if (layer.HandleSelect) {
        selectedWidgets = layer.HandleSelect(event);
      }
      // The Gui needs to know which widgets are selected.
      // I do not think I want the layer to keep a pointer to the gui.
      this.EditingLayerGui.SetSelectedWidgets(selectedWidgets);
      // Returning false stops propagation of the event.
      return selectedWidgets.length === 0;
    }

    // This selection path is to turn editing on for a layer.
    // The layer is choosen by which widget is picked.

    // TODO: Get rid of the multiple strokes in a single pencil widget.
    // It was a bad idea. It is 'hard' because lasso interaction editing of loops
    // depends on the two strokes to be in the same widget.  I do not want to
    // Break everything by rewritting this widget again.  I need to detect
    // If the same stroke was selected again (to show the popup).
    // This is the best way to trigger the popup. Ha,  it is not. I am getting
    // rid of the popup anyway.  I will just put a popup button in the option
    // panel.

    for (var i = 0; i < this.LayerGuis.length; ++i) {
      var layerGui = this.LayerGuis[i];
      layer = layerGui.Layer;
      if (!layer) {
        continue;
      }
      if (layer.HandleSelect) {
        selectedWidgets = layer.HandleSelect(event);
        if (selectedWidgets.length > 0) {
          this.SetEditingLayerGui(layerGui);
          this.EditingLayerGui.SetSelectedWidgets(selectedWidgets);
          return false;
        }
      }
    }

    return true;
  };

  // The EditinlayerGui is always set. If non are checked by the user,
  // then use the default layer. The tools of the layer being edited are
  // displayed in this layer panel
  LayerPanel.prototype.SetEditingLayerGui = function (layerGui) {
    if (this.EditingLayerGui === layerGui) {
      return;
    }
    this.DefaultToolPanel.Hide();

    // This check is only used on the first call after this object has been created.
    if (this.EditingLayerGui) {
      this.EditingLayerGui.GetToolPanel().Hide();
      this.EditingLayerGui.EditOff();
    }
    if (layerGui === undefined) {
      this.DefaultToolPanel.Show();
    } else {
      layerGui.GetToolPanel().Show();
    }
    this.EditingLayerGui = layerGui;
  };

  // This adds a pencil ivar (= true) for events generated by the iPad pencil.
  LayerPanel.prototype.CheckForIPadPencil = function (event, debug) {
    if (SAM.MOBILE_DEVICE === 'iPad' && event.touches && event.touches.length === 1) {
      var touch = event.touches[0];
      // iPad pencil generates a force.
      if (touch.force && !isNaN(touch.force) && touch.force !== 0) {
        if (debug) {
          print('event force = ' + touch.force);
        }
        event.pencil = true;
        // Hack
        // TODO: Trigger this on selected stroke.
        this.PencilOpenClosedToggle.show();
        return true;
      } else {
        if (debug) {
          if (touch.force === undefined) {
            print('No force in event');
          } else {
            print('non qualified event force = ' + touch.force);
          }
        }
      }
    }
    return false;
  };

  SAM.LayerPanel = LayerPanel;
})();

// AnnotationLayer holds the view and annotations in a girder annotation object.
// This class (AnnotationLayerGui) holds the GUI button that controls the name,
// visibiltiy button, and edit/save button.  Each annotation layer has one of these objects.

(function () {
  'use strict';

  // This is a helper object that manages one annoation layer.
  function AnnotationLayerGui (metadata, layerPanel) {
    // This is needed because EditOn, has to turn off any other layers editing.
    this.LayerPanel = layerPanel;
    this.Viewer = this.LayerPanel.Viewer;
    // Only widgets in a single layer can be selected at the same time.
    this.SelectedWidgets = [];

    this.ActiveColor = '#7CF';
    this.DefaultColor = '#DDD';
    this.ButtonSize = '16px';
    if (SAM.MOBILE_DEVICE === 'iPad') {
      this.ButtonSize = '24px';
    }

    // For now, users can only see their own annotations.
    // if (metadata.creatorId !== this.LayerPanel.UserData._id) {
    //  return;
    // }
    var self = this;
    var div = $('<div>')
      .appendTo(layerPanel.ButtonDiv)
      .css({
        'display': 'table',
        'min-width': (2 * this.Radius) + 'px',
        'min-height': (2 * this.Radius) + 'px',
        'margin': '2px',
        'background-color': this.DefaultColor,
        'opacity': '0.7',
        'border': '1px solid #666666',
        'border-radius': '2px'
      });
    // Block the viewer from getting events
    // when the buttons and toggles are pressed.
    // This also blocks content editable for the button.
    // Try putting this one level doewn.
    // div.on('mousedown mousemove mouseup touchstart touchend',
    // function () { return false; });

    // Button is for the label and to make it current.
    var nameButton = $('<div>')
        .appendTo(div)
        .css({
          'display': 'inline',
          'position': 'static',
          'padding-left': '4px',
          'padding-right': '4px'})
        .text(metadata.annotation.name);

    nameButton.hover(
      function () {
        $(this).css({'background-color': this.ActiveColor,
          'cursor': 'text'});
      },
      function () {
        $(this).css({'background-color': this.DefaultColor,
          'cursor': 'pointer'});
      });

    // Check is for visibility
    var visToggle = $('<img>')
        .appendTo(div)
        .attr('type', 'image')
        .attr('src', SA.ImagePathUrl + 'eyeClosed32.png')
        .css({
          'display': 'inline',
          'width': this.ButtonSize,
          'height': this.ButtonSize,
          'cursor': 'pointer',
          'position': 'static',
          'margin': '1px',
          'background-color': this.DefaultColor,
          'border': '1px solid #555'});

    // Edit
    var editToggle = $('<img>')
        .appendTo(div)
        .addClass('saEditToggle')
        .attr('type', 'image')
        .attr('src', SA.ImagePathUrl + 'edit_up.png')
        .css({
          'display': 'inline',
          'width': this.ButtonSize,
          'height': this.ButtonSize,
          'cursor': 'pointer',
          'position': 'relative',
          'margin': '1px',
          'background-color': '#fff',
          'border': '1px solid #555'});

    // Delete
    var deleteButton = $('<img>')
        .appendTo(div)
        .attr('type', 'image')
        .attr('src', SA.ImagePathUrl + 'remove.png')
        .css({
          'display': 'inline',
          'width': this.ButtonSize,
          'height': this.ButtonSize,
          'cursor': 'pointer',
          'position': 'relative',
          'color': 'red',
          'margin': '1px',
          'background-color': '#DDD',
          'border': '1px solid #555'})
        .hide();

    // var slider = $('<div>')
    //  .appendTo(div)
    //  .css({'width': '10em',
    //        'margin': '5px'});

    this.GirderAnnotId = metadata._id;
    this.CreatorId = metadata.creatorId;
    this.Data = undefined; //  load on demand
    this.Div = div;
    this.VisToggle = visToggle;
    this.Visible = false;
    this.EditToggle = editToggle;
    this.Editing = false;
    this.NameButton = nameButton;
    this.DeleteButton = deleteButton;
    this.Name = metadata.annotation.name;
    this.Modified = false;

    // Block the viewer from getting events
    // when the buttons and toggles are pressed.
    visToggle.on('mousedown mousemove mouseup touchmove touchend',
                 function () { return false; });
    editToggle.on('mousedown mousemove mouseup touchmove touchend',
                 function () { return false; });
    deleteButton.on('mousedown mousemove mouseup touchmove touchend',
                 function () { return false; });
    nameButton.on('mousedown mousemove mouseup touchmove touchend',
                 function () { return false; });

    // If this is active (which imples checked), unchecking
    // will also deactivate the annotation button.
    visToggle.hover(
      function () {
        $(this).css({'background-color': this.ActiveColor});
      },
      function () {
        $(this).css({'background-color': this.DefaultColor});
      });
    visToggle.on(
      'click touchstart',
      function () {
        if (self.Visible) {
          self.VisibilityOff();
        } else {
          self.AfterLoad(function () { self.VisibilityOn(); });
        }
      });

    editToggle.on(
      'click touchstart',
      function () {
        if (self.Editing) {
          self.EditOff();
        } else {
          self.AfterLoad(function () { self.EditOn(); });
        }
        return false;
      });

    // The user can only activate his own annotations
    if (metadata.creatorId === this.LayerPanel.UserData._id) {
      this.EditNameOff();
      deleteButton.on(
        'click touchstart',
        function () {
          self.DeleteCallback();
          return false;
        });
    }

    // Restore any visible annotations from a previous session.
    if (this.LayerPanel.LocalStorageVisibleAnnotationNames.indexOf(this.Name) > -1) {
      this.AfterLoad(function () {
        self.VisibilityOn();
      });
    }
  }

  AnnotationLayerGui.prototype.MakeAnnotationLayer = function (viewer) {
    // Create an annotation layer by default.
    // viewer.GetDiv() is Same as this.Parent
    var annotationLayer = new SAM.AnnotationLayer(viewer.GetDiv());
    // Only for the text widget (dialog).
    // It needs this reference to turn off events to make the text input work.
    annotationLayer.SetViewer(viewer);
    // Lets just shallow copy the viewers camera to synchronize all layer views..
    annotationLayer.SetCamera(viewer.GetCamera());

    // TODO: Get rid of this.  master view is passed to draw.
    // Hack so the scale widget can get the spacing.
    annotationLayer.ScaleWidget.View = this.MainView;
    // Hack only used for girder testing.
    annotationLayer.SetViewer(viewer);
    annotationLayer.UpdateSize();
    this.Layer = annotationLayer;

    // I am not sure that this is still used.
    var self = this;
    annotationLayer.SetActivatedCallback(function () { self.EditOn(); });
    annotationLayer.SetModifiedCallback(function () { self.AnnotationModified(); });

    return annotationLayer;
  };

  AnnotationLayerGui.prototype.GetToolPanel = function () {
    if (!this.ToolPanel) {
      if (this.Name === this.LayerPanel.GetDefaultLayerName()) {
        this.ToolPanel = this.LayerPanel.DefaultToolPanel;
      } else if (this.Data.annotation.elements.length > 0 &&
          this.Data.annotation.elements[0].user &&
          this.Data.annotation.elements[0].user.imageUrl) {
        this.ToolPanel = new SAM.MaskToolPanel(this.LayerPanel);
      } else {
        this.ToolPanel = new SAM.AnnotationToolPanel(this.LayerPanel);
      }
      this.ToolPanel.SetLayerGui(this);
    }
    return this.ToolPanel;
  };

  // Only one editable at a time (or none)
  AnnotationLayerGui.prototype.EditOn = function () {
    if (this.Editing) {
      this.UpdateToolVisibility();
      return;
    }
    this.Editing = true;

    // Wait as long as possible before creating and setting the tool panel.
    // create it now.  SetEditinglayerGui needs to tool panel.
    this.GetToolPanel();

    // Make the name editable.
    var self = this;
    this.NameButton
      .on('click touchstart', function () {
        self.AfterLoad(function () { self.EditNameOn(); });
        return false;
      });

    this.EditToggle
      .attr('src', SA.ImagePathUrl + 'edit_down.png');
    // Make the delete button visible.
    this.DeleteButton.show();

    // Turn the new on on.
    this.LayerPanel.SetEditingLayerGui(this);
    // Change the color of the GUI.
    this.Div.css({'background-color': this.ActiveColor});
    // Make the markup visible
    this.VisibilityOn();

    this.UpdateToolVisibility();
  };

  AnnotationLayerGui.prototype.EditOff = function () {
    if (!this.Editing) {
      return;
    }
    this.Editing = false;

    this.EditToggle
      .attr('src', SA.ImagePathUrl + 'edit_up.png');

    // Deactivate any widgets in the layer.
    if (this.Layer) {
      this.Layer.SetSelected(false);
      this.Layer.Deactivate();
      this.Layer.EventuallyDraw();
    }
    // Disable editing of the name.
    this.EditNameOff();
    this.NameButton.off('click touchstart');

    // Save the annotation if anything changed.
    if (this.Modified) {
      this.RecordAndSave();
    }
    // Hide the delete button
    this.DeleteButton.hide();
    // Turn the background to the default.
    if (this.LayerPanel.EditingLayerGui === this) {
      this.Div.css({'background-color': this.DefaultColor});
      this.LayerPanel.SetEditingLayerGui(undefined);
    }

    this.UpdateToolVisibility();
  };

  // Called when the user draws something.
  AnnotationLayerGui.prototype.AnnotationModified = function () {
    if (!this.Modified) {
      // For wanr when leaing page with modified annotations.
      // I do not think the count is necessary.
      this.LayerPanel.ModifiedCount += 1; // ????
    }
    this.Modified = true;
    // Change the background color of the edit toggle to show that is is modified.
    if (this.LayerPanel.UserData.login !== 'guest') {
      this.EditToggle.css({'background-color': '#F55'});
    }

    // Save after 30 seconds regardless of additional markup.
    var self = this;
    if (!this.SaveTimerId) {
      console.log('Save in 30 seconds');
      this.SaveTimerId = setTimeout(function () { self.RecordAndSave(); }, 30000);
    }

    window.onbeforeunload = function (event) {
      console.log('Leaving page ' + self.LayerPanel.ModifiedCount);
      return true;
    };
  };

  AnnotationLayerGui.prototype.VisibilityOn = function () {
    if (this.Visible) {
      return;
    }
    this.Visible = true;
    this.VisToggle
      .attr('src', SA.ImagePathUrl + 'eyeOpen32.png');
    this.DisplayAnnotation();

    // Record the visibility of this annotation in local storage.
    this.LayerPanel.SaveVisibilityInLocalStorage();
  };

  AnnotationLayerGui.prototype.VisibilityOff = function () {
    if (!this.Visible) {
      return;
    }
    this.Visible = false;
    this.VisToggle
      .attr('src', SA.ImagePathUrl + 'eyeClosed32.png');
    this.Layer.SetVisibility(false);

    // Editing annots must be visible.
    this.EditOff();
    // Record the visibility of this annotation in local storage.
    this.LayerPanel.SaveVisibilityInLocalStorage();
  };

  // There are two modes for name editing.  This is the inner mode.
  // When the mouse if over the button, make the div content editable.
  AnnotationLayerGui.prototype.EditNameOn = function () {
    var self = this;
    this.EditOn();

    // Get rid of the events blocking viewer interaction
    // but also blocking content editable.
    this.Viewer.InteractionOff();
    this.NameButton.off();
    this.NameButton.attr('tabindex', '1');
    // Sometimes the leave even does not fire, and the viewer appears non functional
    this.LayerPanel.Div.on('mousedown.namebutton', function () { self.EditNameOff(); });
    this.LayerPanel.Div.on('mouseleave.namebutton', function () { self.EditNameOff(); });
    this.Viewer.GetDiv().on('mousedown.namebutton', function () { self.EditNameOff(); });

    this.NameButton
      .attr('contentEditable', true);
    this.NameButton.focus();
  };

  AnnotationLayerGui.prototype.EditNameOff = function () {
    // console.log('edit name off');

    var self = this;
    // Did the name change?
    var name = this.NameButton.text();
    if (name !== this.Name) {
      // Yes,  schedule the change to be saved on the server.
      this.Name = name;
      this.AnnotationModified();
    }

    this.Viewer.InteractionOn();

    this.LayerPanel.Div.off('mousedown.namebutton');
    this.LayerPanel.Div.off('mouseleave.namebutton');
    this.Viewer.GetDiv().off('mousedown.namebutton');

    this.NameButton
      .attr('contentEditable', false)
      .css({'cursor': 'pointer'})
      .on('click touchstart', function () {
        self.AfterLoad(function () { self.EditNameOn(); });
        return false;
      });

    // Turn viewer event blocking on again.
    this.NameButton.on('mousedown mousemove mouseup touchstart touchend',
                       function () { return false; });

    if (this.Name !== this.LayerPanel.GetDefaultLayerName()) {
      this.LayerPanel.InitializeDefaultToolPanel();
    }
  };

  // This call back pattern is all because we load on demand.
  // Call a method after an annotation is loaded.
  AnnotationLayerGui.prototype.AfterLoad = function (callback) {
    // guest annotation
    if (this.GirderAnnotId === undefined) {
      (callback)();
      return;
    }
    if (this.Data) {
      (callback)();
    } else {
      // We need to load the annotation first.
      var self = this;
      $('body').css({'cursor': 'wait'});
      girder.rest.restRequest({
        url: 'annotation/' + this.GirderAnnotId,
        method: 'GET',
        contentType: 'application/json'
      }).done(function (data) {
        $('body').css({'cursor': ''});
        self.Data = data;
        (callback)();
      });
    }
  };

  // Call back from deleteButton.
  AnnotationLayerGui.prototype.DeleteCallback = function () {
    if (!this.LayerPanel.EditingLayerGui) {
      return;
    }
    this.Delete();
  };

  AnnotationLayerGui.prototype.Delete = function () {
    if (!this.LayerPanel.EditingLayerGui.Layer.IsSelected()) {
      if (!confirm('Do you want to delete the entire annotation group?' + this.Name)) {
        return;
      }
      if (this.SaveTimerId) {
        clearTimeout(this.SaveTimerId);
        this.SaveTimerId = undefined;
      }
      // Visibility and editing off.
      this.VisibilityOff();

      if (!this.GirderAnnotId) {
        // Not Saved yet.
        this.DeleteAnnotationGui();
        return;
      }

      // Delete it from the database before deleting the GUI.
      var self = this;
      girder.rest.restRequest({
        url: 'annotation/' + this.GirderAnnotId,
        method: 'DELETE',
        contentType: 'application/json'
      }).done(function (ret) {
        self.DeleteAnnotationGui();
      });
    }
  };

  AnnotationLayerGui.prototype.DeleteAnnotationGui = function () {
    // Break these links which will allow the default tool panel to
    // create another layerGUi if it is used.
    if (this.ToolPanel) {
      this.ToolPanel.SetLayerGui(undefined);
      this.ToolPanel = undefined;
    }
    // Visibility and editing off.
    this.VisibilityOff();
    // Remove the buttons
    this.Div.remove();
    // Take it out of the annotation panel.
    var idx = this.LayerPanel.LayerGuis.indexOf(this);
    this.LayerPanel.LayerGuis.splice(idx, 1);
  };

  // TODO: Load annotations into a 'group'.  Manage separate groups.
  // Move the annotation info to the layer widgets and draw.
  AnnotationLayerGui.prototype.DisplayAnnotation = function () {
    // If there is no layer, we have to create one
    if (!this.Layer) {
      var layer = this.MakeAnnotationLayer(this.Viewer);
      layer.Reset();

      // Put all the rectangles into one set.
      var setObj = {};
      setObj.type = 'rect_set';
      setObj.centers = [];
      setObj.widths = [];
      setObj.heights = [];
      setObj.confidences = [];
      setObj.labels = [];

      if (!this.Data) {
        return;
      }

      var annot = this.Data.annotation;
      for (var i = 0; i < annot.elements.length; ++i) {
        var element = annot.elements[i];
        var obj = {};

        if (element.type === 'view') {
          // Set the camera / view.
          var cam = this.Layer.GetCamera();
          cam.SetWorldFocalPoint(element.center);
          cam.SetHeight(element.height);
          if (element.rotation) {
            cam.SetWorldRoll(element.rotation);
          } else {
            cam.SetWorldRoll(0);
          }
          // Ignore width for now because it is determined by the
          // viewport.
          cam.ComputeMatrix();
          // How to handle forcing viewer to render?
          // I could have a callback.
          // I could also make a $('.sa-viewer').EventuallyRender();
          // or $('.sa-viewer').saViewer('EventuallyRender');
          if (this.Layer.Viewer) {
            this.Layer.Viewer.EventuallyRender();
          }
        }
        if (element.type === 'circle') {
          this.Layer.LoadWidget(element);
        }
        if (element.type === 'rect') {
          this.Layer.LoadWidget(element);
        }
        if (element.type === 'arrow') {
          if (element.label) {
            obj.type = 'text';
            obj.string = element.label.value;
            obj.color = SAM.ConvertColor(element.fillColor);
            obj.size = element.label.fontSize;
            obj.position = element.points[0].slice(0);
            obj.offset = element.points[1].slice(0);
            obj.offset[0] -= obj.position[0];
            obj.offset[1] -= obj.position[1];
            obj.visibility = element.points[0][2];
            this.Layer.LoadWidget(obj);
          } else {
            obj.type = 'arrow';
            obj.origin = element.points[0].slice(0);
            obj.fillColor = element.fillColor;
            obj.lineColor = element.lineColor;
            var dx = element.points[1][0] - element.points[0][0];
            var dy = element.points[1][1] - element.points[0][1];
            var length = Math.sqrt((dx * dx) + (dy * dy));
            obj.length = length;
            // The upper left origin causes orientation to be negative.
            obj.orientation = -Math.atan2(dy / length, dx / length) * 180 / Math.PI;
            if (element.lineWidth !== undefined) {
              obj.width = element.lineWidth;
            } else {
              obj.width = 10;
            }
            obj.fixedsize = 'false';
            obj.fixedorientation = 'false';
            this.Layer.LoadWidget(obj);
          }
        }
        if (element.type === 'rectanglegrid') {
          obj.type = 'grid';
          obj.lineColor = SAM.ConvertColor(element.lineColor);
          obj.lineWidth = element.lineWidth;
          obj.origin = element.center;
          obj.bin_width = element.width / element.widthSubdivisions;
          obj.bin_height = element.height / element.heightSubdivisions;
          obj.orientation = element.rotation;
          obj.dimensions = [element.widthSubdivisions, element.heightSubdivisions];
          this.Layer.LoadWidget(obj);
        }
        if (element.type === 'rectangle') {
          // Switch to rect set versus individual rects. if false
          var keepRectSets = false;
          if (keepRectSets && element.type === 'rectangle') { // switch behavior to ....
            setObj.widths.push(element.width);
            setObj.heights.push(element.height);
            setObj.centers.push(element.center[0]);
            setObj.centers.push(element.center[1]);
            if (element.scalar === undefined) {
              element.scalar = 1.0;
            }
            setObj.confidences.push(element.scalar);
            if (element.label) {
              setObj.labels.push(element.label.value);
            } else {
              setObj.labels.push('');
            }
          } else {
            this.Layer.LoadWidget(element);
          }
        }
        if (element.type === 'polyline') {
          // Make a pencil instead.
          obj.type = 'pencil';
          obj.lineColor = SAM.ConvertColor(element.lineColor);
          obj.lineWidth = element.lineWidth;
          obj.shapes = [element.points];
          obj.closedFlags = [element.closed];
          this.Layer.LoadWidget(obj);
        }
      }

      if (setObj.widths.length > 0) {
        this.Layer.LoadWidget(setObj);
      }
    }

    this.Layer.SetVisibility(true);
    this.Layer.EventuallyDraw();
  };

  // Records and saves an annotation. Will create a new one if this obj has no id.
  AnnotationLayerGui.prototype.RecordAndSave = function () {
    var self = this;
    if (this.SaveTimerId) {
      clearTimeout(self.SaveTimerId);
      self.SaveTimerId = undefined;
    }

    // console.log('Save annotation');
    if (!this.Data) {
      this.Data = {annotation: {elements: []}};
    }
    // Read markup and put into data object.
    this.Data.annotation.elements = this.RecordAnnotation();
    this.Data.annotation.name = this.Name;

    // Change the color of the edit toggle to yellow, to show we are saving.
    this.EditToggle.css({'background-color': '#FF5'});

    if (!this.GirderAnnotId) {
      if (this.Layer.IsEmpty()) {
        // Do not save a new annotation if it is empty.
        this.AnnotationSaved();
        return;
      }
      // A new annotation
      girder.rest.restRequest({
        url: 'annotation?itemId=' + this.LayerPanel.ItemId,
        method: 'POST',
        contentType: 'application/json',
        data: JSON.stringify(this.Data.annotation)
      }).done(function (retAnnot) {
        // Saving has finished.
        // This has the girder id.
        self.GirderAnnotId = self.Data._id = retAnnot._id;
        self.AnnotationSaved();
      });
    } else {
      // Save a modified annotation.
      girder.rest.restRequest({
        url: 'annotation/' + this.GirderAnnotId,
        method: 'PUT',
        contentType: 'application/json',
        data: JSON.stringify(this.Data.annotation)
      }).done(function (retAnnot) {
        // This has the girder id.
        self.AnnotationSaved();
      });
    }
  };

  // Called when the annotation is saved successfully..
  AnnotationLayerGui.prototype.AnnotationSaved = function () {
    if (this.Modified) {
      this.LayerPanel.ModifiedCount -= 1; // ???
    }
    this.Modified = false;
    this.Div.css({'border': '1px solid #666'});
    this.EditToggle.css({'background-color': '#FFF'});
    if (this.LayerPanel.ModifiedCount === 0) {
      window.onbeforeunload = undefined;
    }
  };

  // Converts annotation layer widgets into girder annotation elements.
  // returns an elements array.
  AnnotationLayerGui.prototype.RecordAnnotation = function () {
    var returnElements = [];
    var i;
    var j;
    var k;
    var points;

    // record the view.
    var element;
    for (i = 0; i < this.Layer.GetNumberOfWidgets(); ++i) {
      if (!this.Layer.GetWidget(i).Serialize) {
        continue;
      }
      var widget = this.Layer.GetWidget(i).Serialize();
      if (widget.type === 'circle') {
        element = widget;
      }
      if (widget.type === 'rectangle') {
        element = widget;
      }
      if (widget.type === 'text') {
        // Will not keep scale feature..
        points = [widget.position, widget.offset];
        points[1][0] += widget.position[0];
        points[1][1] += widget.position[1];
        // Have to add a z coordinate for the scheme
        // Hacky way to save visibility state.
        points[0][2] = points[1][2] = widget.visibility;
        element = {
          'type': 'arrow',
          'lineWidth': 10,
          'fillColor': SAM.ConvertColorToHex(widget.color),
          'points': points};
        element.label = {
          'value': widget.string,
          'fontSize': widget.size,
          'color': SAM.ConvertColorToHex(widget.color)};
      }
      if (widget.type === 'arrow') {
        // Will not keep scale feature..
        var pt1 = [widget.origin[0], widget.origin[1], 0];
        var pt2 = [widget.origin[0], widget.origin[1], 0];
        var theta = -widget.orientation * Math.PI / 180.0;
        pt2[0] += widget.length * Math.cos(theta);
        pt2[1] += widget.length * Math.sin(theta);
        points = [pt1, pt2];
        element = {
          'type': 'arrow',
          // 'lineWidth': widget.lineWidth,
          'lineColor': widget.lineColor,
          'fillColor': widget.fillColor,
          'points': points};
      }
      if (widget.type === 'grid') {
        element = {
          'type': 'rectanglegrid',
          'center': widget.origin,
          'width': widget.bin_width * widget.dimensions[0],
          'height': widget.bin_height * widget.dimensions[1],
          'rotation': widget.orientation,
          'normal': [0, 0, 1.0],
          'widthSubdivisions': widget.dimensions[0],
          'heightSubdivisions': widget.dimensions[1],
          'lineWidth': widget.lineWidth,
          'lineColor': widget.lineColor};
      }
      if (widget.type === 'rect_set') {
        var num = widget.widths.length;
        for (j = 0; j < num; ++j) {
          element = {
            'type': 'rectangle',
            'label': {'value': widget.labels[j]},
            'center': [widget.centers[2 * j], widget.centers[2 * j + 1], 0],
            'height': widget.heights[j],
            'width': widget.widths[j],
            'rotation': 0,
            'scalar': widget.confidences[j]};
          returnElements.push(element);
        }
        element = undefined;
      }
      if (widget.type === 'polyline') {
        element = {
          'type': 'polyline',
          'closed': widget.closedloop,
          'lineWidth': widget.lineWidth,
          'lineColor': widget.lineColor,
          'points': widget.points};
      }
      if (widget.type === 'lasso') {
        element = {
          'type': 'polyline',
          'closed': true,
          'lineWidth': widget.lineWidth,
          'lineColor': widget.lineColor,
          'points': widget.points};
      }
      // Pencil scheme not exact match.  Need to split up polylines.
      if (widget.type === 'pencil') {
        for (k = 0; k < widget.shapes.length; ++k) {
          points = widget.shapes[k];
          element = {
            'type': 'polyline',
            'closed': widget.closedFlags[k],
            'points': points};
          // Hackish way to deal with multiple lines.
          if (widget.lineColor !== undefined) {
            element.lineColor = widget.lineColor;
          }
          if (widget.lineWidth !== undefined) {
            element.lineWidth = Math.round(widget.lineWidth);
          }
          returnElements.push(element);
          element = undefined;
        }
      } else if (element) {
        returnElements.push(element);
        element = undefined;
      }
    }
    return returnElements;
  };

  AnnotationLayerGui.prototype.UpdateToolVisibility = function () {
    if (this.ToolPanel) {
      this.ToolPanel.UpdateToolVisibility();
    }
  };

  // Rectangle select is only active on the editing layer.
  // Only widgets from one layer can be selected.
  // Called by the SelectedDeleteButton click event (or delete key).
  // Returns true if a widget was deleted.
  AnnotationLayerGui.prototype.DeleteSelected = function () {
    if (this.Layer.IsEmpty()) {
      this.Delete();
      return;
    }
    if (this.Layer.DeleteSelected()) {
      this.AnnotationModified();
      if (this.Layer.IsEmpty()) {
        this.Delete();
        return;
      }
    }
    this.SelectedWidgets = [];
    // TODO: Clean this up.
    var toolPanel = this.GetToolPanel();
    toolPanel.ToolRadioButtonCallback(toolPanel.CursorButton);
    this.UpdateToolVisibility();
    this.Layer.EventuallyDraw();
  };

  // If only one widget is selected, we make it active (and show the properties button.
  // You can call this with selectedWidget = undefined to unset it.
  // "selectedLayerGui" is the one that contains the widget.
  AnnotationLayerGui.prototype.SetSelectedWidgets = function (selectedWidgets) {
    // Unselect previous selected widgets.
    // I do not think this is necessary.  The picking process should do this.
    // for (var i = 0; i < this.SelectedWidgets.length; ++i) {
    //   var widget = this.SelectedWidgets[i];
    //   widget.SetActive(false);
    // }
    this.SelectedWidgets = [];

    var tools;
    // No widget: Go back to the cursor mode.
    if (!selectedWidgets || selectedWidgets.length === 0) {
      // Nothing was selected.
      // Change the state back to cursor.
      // TODO: Clean this API up.
      tools = this.GetToolPanel();
      tools.HighlightRadioToolButton(tools.CursorButton);
      // See if we can move this to CursorOn
      this.Viewer.EventuallyRender();
      tools.UpdateToolVisibility();
      return true;
    }

    this.EditOn();
    // Hack so I do not need to deal with multiple selection right now.
    var selectedWidget = selectedWidgets[0];

    // TODO: Try to get rid of this case statement.
    // TODO: Move this into ToolPanel
    // Change the tool radio to reflect the widget choosen.
    tools = this.GetToolPanel();
    if (selectedWidget.Type === 'pencil') {
      // Make the open-closed toggle button match the state of the selected widget.
      // I could not (easily) put this in UpdateToolVisibility because the widget
      // was changed to match the button before this code executed.
      if (selectedWidget.IsModeClosed()) {
        tools.SetPencilModeToClosed();
      } else {
        tools.SetPencilModeToOpen();
      }
      // Turn on the pencil tool
      // I am trying to avoid triggering the button. It has caused headaches in the past.
      // This might miss setting up a callback on the widget.
      tools.HighlightRadioToolButton(tools.PencilButton);
      // Should we change this to SetActive(true)?
      selectedWidget.SetStateToDrawing(this.Layer);
    }
    if (selectedWidget.Type === 'text') {
      selectedWidget.SetActive(true);
      tools.HighlightRadioToolButton(tools.TextButton);
    }
    if (selectedWidget.Type === 'arrow') {
      tools.HighlightRadioToolButton(tools.ArrowButton);
      selectedWidget.SetActive(true);
    }
    if (selectedWidget.Type === 'circle') {
      tools.HighlightRadioToolButton(tools.CircleButton);
      selectedWidget.SetActive(true);
    }
    if (selectedWidget.Type === 'rect') {
      tools.HighlightRadioToolButton(tools.RectangleButton);
      selectedWidget.SetActive(true);
    }

    // TODO: This ivar is only really needed for the properties dialog.
    // We could just find the first selected widget ....
    this.SelectedWidgets = selectedWidgets;
    tools.UpdateToolVisibility();
  };

  SAM.AnnotationLayerGui = AnnotationLayerGui;
})();

// Split off from girderAnnotationPannel.js
// NOTE: These two classes have not been untangled completely.
// Try to get rid of "LayerPanel" ivar wherever it is used.

// This creates and manages the set of radio buttons for annotating.
// I tis a bit complex with the states.

// Get iPad pencil automatically triggering pecil tool (transiently)

// Get an eraser pencil option working.

// Text widget does not change background rect size when new lines are added.
// Fix potential infinte loop in pencil widget combine strokes.

// Delete stroke should select the last stroke in the widget. If the widget
// is empty, the widget should be removed and the tool state should go to cursor.

// Pencil should work on the overview.
// Copy?
// Higher opacity on ipad.
// ? button for instructions
// Eraser button.
// Double click a stroke brings up delete.
// Separate out the pencil dialog from the pencil widget.  make it apply to individual strokes.
// pop up dialog on doulbe click.

// Text background flag does not toggle.

// 1: fix delay before pencil starts drawing (gap in line).
//  9: Make the panel collapse to a single button.
// 11: make sure it works on an ipad / surface.

// 3: undo.

// Notes:  It was tricky getting two modes of activating tools:  1 radio button, 2 click to select widget.
// Here is what happens for the two paths:
// Click Tool button
//   0: Update the radio GUI.
//   2: Inactivate previous widget.
//   1: Layer editon (good)
//   3: Activate a new widget active
// Click widget (single select)
//   0: Inactivate Previous widget.
//   1: Widget state to Editing (Widget handles this)
//   2: Layer editon (good)
//   3: Changes tool button GUI.

// TODO: Clean up the access to "AnnotationLayerGui::SelectedWidgets"

(function () {
  'use strict';

  // PencilToggle.
  var OPEN = 0;
  var CLOSED = 1;

  // Parent is the viewer.Div
  // TODO: Simplify the args.
  function AnnotationToolPanel (layerPanel) {
    this.LayerPanel = layerPanel;
    // Any new layers created have to know the viewer.
    this.Viewer = layerPanel.Viewer;

    this.Parent = this.Viewer.GetDiv();

    // -----------------------------------------------------

    // CSS maybe?
    this.Margin = layerPanel.Margin;
    this.ToolDivHeight = layerPanel.ToolDivHeight;

    // If we have write access, this creates markup tools.
    this.ToolPanel = $('<div>')
      .appendTo(this.Parent.parent())
      .hover(function () { $(this).css({'opacity': '1'}); },
             function () { $(this).css({'opacity': '0.6'}); })
      .css({
        'position': 'absolute',
        'background-color': '#fff',
        'border': '1px solid #666666',
        'left': '3px',
        'top': (5 * this.Margin) + 'px',
        // 'height': this.ToolDivHeight.toString() + 'px',
        'opacity': '0.6',
        'z-index': '300'})
      .draggable()
      .hide();

    this.ToolDiv = $('<div>')
      .appendTo(this.ToolPanel);

    this.OptionsDiv = $('<div>')
      .appendTo(this.ToolPanel)
      .attr('id', 'saAnnotationTools');

    this.InitializeTools();
  }

  AnnotationToolPanel.prototype.SetLayerGui = function (layerGui) {
    this.LayerGui = layerGui;
  };

  AnnotationToolPanel.prototype.GetLayerGui = function () {
    if (!this.LayerGui) {
      this.LayerGui = this.LayerPanel.GetDefaultLayerGui();
      // The layer panel aleady sets this,
      // but it cannot hurt to do this for saftey.
      // It is a hack.  No API.
      // this.LayerGui.ToolPanel = this;
    }
    return this.LayerGui;
  };

  AnnotationToolPanel.prototype.Hide = function () {
    this.ToolPanel.hide();
  };

  AnnotationToolPanel.prototype.Show = function () {
    this.ToolPanel.show();
  };

  AnnotationToolPanel.prototype.InitializeTools = function () {
    var self = this;

    // Radio buttons for tools. (One active at a time).
    this.CursorButton = this.AddToolRadioButton('cursor_arrow.png', 'CursorOn');
    this.TextButton = this.AddToolRadioButton('Text.png', 'TextButtonOn');
    this.ArrowButton = this.AddToolRadioButton('Arrow.png', 'ArrowButtonOn');
    this.CircleButton = this.AddToolRadioButton('Circle.png', 'CircleButtonOn');
    this.RectangleButton = this.AddToolRadioButton('rectangle.gif', 'RectangleButtonOn');
    this.PencilButton = this.AddToolRadioButton('Pencil-icon.png', 'PencilButtonOn');
    this.RectSelectButton = this.AddToolRadioButton('rect_select.png', 'RectSelectOn');

    // This is visibile, only when a annotation is being edited.
    this.RectSelectButton.hide();
    this.CursorButton.css({
      'border': '2px solid #333',
      'background-color': '#bcf'});

    // Default just lets the viewer handle the events.
    this.ActiveToolButton = this.CursorButton;

    // Not part of the radio group.  This is a sub option for pencils.
    this.PencilOpenClosedState = OPEN;
    this.PencilOpenClosedToggle = $('<img>')
      .appendTo(this.OptionsDiv)
      .addClass('sa-view-annotation-button sa-flat-button-active')
      .addClass('sa-active')
      .css({
        'border': '1px solid #333',
        'width': '28px',
        'height': '28px',
        'background-color': '#fff'})
      .attr('type', 'image')
      .prop('title', 'open/closed')
      .attr('src', SA.ImagePathUrl + 'open_lasso.png')
      .on('click touchstart',
          function () {
            self.TogglePencilOpenClosed();
            return false;
          })
      .hide();
    this.PencilOpenClosedToggle.on('mousedown mousemove mouseup touchmove touchend',
                                   function () { return false; });

    // Not part of the radio group.  This is a sub option for pencils.
    this.PencilOpenClosedState = OPEN;
    this.PencilOpenClosedToggle = $('<img>')
      .appendTo(this.OptionsDiv)
      .addClass('sa-view-annotation-button sa-flat-button-active')
      .addClass('sa-active')
      .css({
        'border': '1px solid #333',
        'background-color': '#fff'})
      .attr('type', 'image')
      .prop('title', 'open/closed')
      .attr('src', SA.ImagePathUrl + 'open_lasso.png')
      .on('click touchstart',
          function () {
            self.TogglePencilOpenClosed();
            return false;
          })
      .hide();
    this.PencilOpenClosedToggle.on('mousedown mousemove mouseup touchmove touchend',
                                   function () { return false; });

    // A menu button that pops up when a markup is selected.
    // Not part of the radio group.  This is a sub option for widgets.
    this.PropertiesDialogButton = $('<img>')
      .appendTo(this.OptionsDiv)
      .addClass('sa-view-annotation-button sa-flat-button-active')
      .addClass('sa-active')
      .css({
        'border': '1px solid #333',
        'width': '28px',
        'height': '28px',
        'background-color': '#fff'})
      .attr('type', 'image')
      .prop('title', 'properties')
      .attr('src', SA.ImagePathUrl + 'Menu.jpg')
      .on('click touchstart',
          function () {
            self.ShowSelectedWidgetMenu();
            return false;
          })
      .hide()
      .on('mousedown mousemove mouseup touchmove touchend',
          function () { return false; });

    this.LoadDefaults();
  };

  AnnotationToolPanel.prototype.AddToolRadioButton = function (imageFile, onCallbackName) {
    var self = this;
    var button = $('<img>')
        .appendTo(this.ToolDiv)
        .css({
          'border': '2px solid #ccc',
          'margin': '1px',
          'background-color': '#fff',
          'width': '28px',
          'height': '28px'
        })
        .attr('type', 'image')
        .attr('src', SA.ImagePathUrl + imageFile)
      .on('click touchstart',
          function () {
            self.ToolRadioButtonCallback(button);
            return false;
          })
      // To block the viewer moving.
      .on('mousedown mousemove mouseup touchmove touchend',
          function () { return false; });
      // On off functionality
    if (onCallbackName) {
      button.on(
        'radio-on',
        function () {
          self.LayerPanel.WithEditingLayerCall(
            function (layerGui) {
              self.Viewer.InteractionOn();
              (self[onCallbackName])(layerGui);
            });
        });
    }
    return button;
  };

  // Change the state of the Radio GUI, but do not trigger side effects (PencidOn ...)
  AnnotationToolPanel.prototype.HighlightRadioToolButton = function (pressedButton) {
    if (pressedButton === this.ActiveToolButton) {
      return false;
    }
    // Turn off the old one. We have to do this by turning on the cursor.
    this.ActiveToolButton
      .css({
        'border': '2px solid #ccc',
        'background-color': '#fff'});
    // Turn on the new one.
    pressedButton.css({
      'border': '2px solid #222',
      'background-color': '#cdf'});
    this.ActiveToolButton = pressedButton;
  };

  // General for the radio
  // This assumes button is in the ToolRadioButtons list.
  AnnotationToolPanel.prototype.ToolRadioButtonCallback = function (pressedButton) {
    if (pressedButton === this.ActiveToolButton) {
      return false;
    }
    // GUI only change/
    this.HighlightRadioToolButton(pressedButton);

    // Turn off previous tool widgets. (deactivate)
    if (this.LayerPanel.EditingLayerGui) {
      var layer = this.LayerPanel.EditingLayerGui.Layer;
      layer.InactivateAll();
    }

    // Turn on the new one.
    // Note: This ensures a layer is highlighted.
    pressedButton.trigger('radio-on');

    // Show the open closed toggle and other options.
    this.UpdateToolVisibility();
  };

  // Called by the PropertiesDialogButton click event.
  AnnotationToolPanel.prototype.ShowSelectedWidgetMenu = function () {
    var layerGui = this.GetLayerGui();
    if (!layerGui.SelectedWidgets.length === 1) {
      return;
    }

    var widget = layerGui.SelectedWidgets[0];
    if (widget.SetStateToDialog) {
      widget.SetStateToDialog();
    } else {
      widget.ShowPropertiesDialog();
    }
  };

  // When tools have nothing to modify, they disappear.
  // TODO: Help tool. to explain why a tool is not available.
  AnnotationToolPanel.prototype.UpdateToolVisibility = function () {
    if (this.GetLayerGui().SelectedWidgets.length === 1) {
      this.PropertiesDialogButton.show();
    } else {
      this.PropertiesDialogButton.hide();
    }

    // Pencil is always visible. If a layer is not being edited, one is created and set to editon.

    // RectangleSelect is only active when a layer is being edited and it has marks.
    //     An alternitive single select with mouseclick can always select and mark.
    // It does not make sense to create an annotation if one is not editing.
    // any created annotation will have no marks to select. Instead I will disable
    // the button until one is selected.
    // Just show and hid it for now.  I would really like to gray it out and put a hint
    // why it is grayed out.
    if (this.LayerPanel.EditingLayer && !this.LayerPanel.EditingLayer.Layer.IsEmpty()) {
      this.RectSelectButton.show();
    } else {
      this.RectSelectButton.hide();
    }

    // Open closed button is visible when any polylines are selected.
    // or the drawing pencil is active.
    var lineSelected = false;
    if (this.LayerPanel.EditingLayer) {
      var layer = this.LayerPanel.EditingLayer.Layer;
      for (var idx = 0; idx < layer.GetNumberOfWidgets(); ++idx) {
        var widget = layer.GetWidget(idx);
        if (widget.Type === 'pencil' && widget.IsSelected && widget.IsSelected()) {
          lineSelected = true;
          break;
        }
      }
    }
    // Some layer has to be being edited.
    if (this.LayerPanel.EditingLayer) {
      if (this.ActiveToolButton === this.PencilButton || lineSelected) {
        this.PencilOpenClosedToggle.show();
      } else {
        this.PencilOpenClosedToggle.hide();
      }
    }
  };

  AnnotationToolPanel.prototype.LoadDefaults = function () {
    if (localStorage.SaAnnotationPanelDefaults) {
      var defaults = JSON.parse(localStorage.SaAnnotationPanelDefaults);
      if (defaults.PencilMode === 'closed') {
        this.SetPencilModeToClosed();
      }
    }
  };

  AnnotationToolPanel.prototype.SaveDefaults = function () {
    var defaults = {'PencilMode': 'open'};
    if (this.PencilOpenClosedState === CLOSED) {
      defaults.PencilMode = 'closed';
    }
    localStorage.SaAnnotationPanelDefaults = JSON.stringify(defaults);
  };

  AnnotationToolPanel.prototype.TogglePencilOpenClosed = function () {
    if (this.PencilOpenClosedState === CLOSED) {
      this.SetPencilModeToOpen();
    } else {
      this.SetPencilModeToClosed();
    }
    if (this.LayerPanel.EditingLayer) {
      var layer = this.LayerPanel.EditingLayer.Layer;
      layer.EventuallyDraw();
    }
  };

  AnnotationToolPanel.prototype.SetPencilModeToOpen = function () {
    if (this.PencilOpenClosedState === OPEN) {
      return;
    }
    this.PencilOpenClosedState = OPEN;
    this.PencilOpenClosedToggle
        .attr('src', SA.ImagePathUrl + 'open_lasso.png');

    if (this.LayerGui) {
      var layerGui = this.LayerGui;
      for (var i = 0; i < layerGui.SelectedWidgets.length; ++i) {
        var widget = layerGui.SelectedWidgets[i];
        if (widget.SetModeToOpen) {
          widget.SetModeToOpen();
        }
        if (this.LayerPanel.EditingLayer) {
          this.LayerPanel.EditingLayer.Layer.EventuallyDraw();
        }
      }
    }
    this.SaveDefaults();
  };

  AnnotationToolPanel.prototype.SetPencilModeToClosed = function () {
    if (this.PencilOpenClosedState === CLOSED) {
      return;
    }
    this.PencilOpenClosedState = CLOSED;
    this.PencilOpenClosedToggle
        .attr('src', SA.ImagePathUrl + 'select_lasso.png');

    if (this.LayerGui) {
      var layerGui = this.LayerGui;
      for (var i = 0; i < layerGui.SelectedWidgets.length; ++i) {
        var widget = layerGui.SelectedWidgets[i];
        if (widget.SetModeToClosed) {
          widget.SetModeToClosed();
        }
        if (this.LayerPanel.EditingLayer) {
          this.LayerPanel.EditingLayer.Layer.EventuallyDraw();
        }
      }
    }
    this.SaveDefaults();
  };

  // ============================================================================
  // new (used) stuff.

  AnnotationToolPanel.prototype.CursorOn = function () {
    if (this.LayerPanel.EditingLayer && this.LayerPanel.EditingLayer.Layer) {
      this.LayerPanel.EditingLayer.Layer.SetSelected(false);
      this.LayerPanel.EditingLayer.Layer.EventuallyDraw();
    }
    this.Viewer.GetParentDiv().css({'cursor': ''});
    this.ActiveToolButton = this.CursorButton;
    // Is this thie correct behavior?
    if (this.LayerGui) {
      this.LayerGui.SelectedWidgets = [];
    }
  };

  // An annotation has to be selected for editing before this is called.
  // It starts a rectSelectWidget for the user.
  AnnotationToolPanel.prototype.RectSelectOn = function () {
    var self = this;
    var layerGui = this.LayerPanel.EditingLayer;
    // Anything being edited has to be loaded too.
    var layer = layerGui.Layer;
    layer.SetSelected(false);
    var rectSelectWidget = new SAM.RectSelectWidget(layer);
    rectSelectWidget.SetFinishCallback(function (w) { self.RectSelectOff(rectSelectWidget); });
    layer.AddWidget(rectSelectWidget);
    // Start receiving events.
    // Normally this happens as a call back when state changes to drawing.
    layer.ActivateWidget(rectSelectWidget);
    rectSelectWidget.SetStateToDrawing(layer);
  };
  // This is called when the selection has been made by the user.
  AnnotationToolPanel.prototype.RectSelectOff = function (selector) {
    var layerGui = this.LayerPanel.EditingLayer;
    var selectedWidgets = [];
    var layer = layerGui.Layer;
    for (var idx = 0; idx < layer.GetNumberOfWidgets(); ++idx) {
      var w = layer.GetWidget(idx);
      if (w.ApplySelect && w.ApplySelect(selector)) {
        selectedWidgets.push(w);
      }
    }
    layer.RemoveWidget(selector);
    layer.EventuallyDraw();

    layerGui = this.GetLayerGui();
    if (selectedWidgets.length === 1) {
      layerGui.SetSelectedWidget(selectedWidgets[0]);
    } else {
      // See if we can move this to CursorOn
      layerGui.SelectedWidgets = selectedWidgets;
      this.HighlightRadioToolButton(this.CursorButton);
    }
    this.UpdateToolVisibility();
  };

  // TextButton is really a toggle (part of a radio group).
  // Text buttonOn <=> dialog showing.
  // Selecting a text automatically turns text button on and shows dialog.
  // I do not know if any call actually passes a wiodget.
  // Widget is an optional arguement. May not ever be called with a widget.
  AnnotationToolPanel.prototype.TextButtonOn = function (layerGui) {
    // The layer has to be in editing mode.
    layerGui.EditOn();

    var widget;
    // Get a text widget.
    // Look for a selected widget to reuse.
    var layer = layerGui.Layer;
    if (!widget) {
      widget = layer.GetASelectedWidget('text');
    }
    if (!widget) {
      // A selected textWidget was not found. Make a new text widget.
      widget = new SAM.TextWidget(layer);
      // widget.State = 3; // hack hack TODO: fix (text chowing up before dialog closes.
      // Dialog needs tu turn off and on bindings.
      // TODO: REmove dialogs from widget and manage them here.
      // Widgets can share a dialog.
      layer.AddWidget(widget);
      // widget.SetCreationCamera(layer.GetCamera());
      widget.SetStateToDialog();
    }

    // Activate the widget to start drawing.
    // TODO: Fix the Text dialog creation process.  THis is not right but necvessary it seems.
    // widget.SetActive(true);

    // If the text is deactivated by closing the dialog, this will turn off the
    // text button.
    var self = this;
    widget.SetStateChangeCallback(function () {
      if (!widget.Layer) {
        // string was empty.  TODO: find a better way to handle widget initiated delete.
        self.GetLayerGui().SelectedWidgets = [];
        self.ToolRadioButtonCallback(self.CursorButton);
        self.UpdateToolVisibility();
      } else if (!widget.GetActive()) {
        self.ToolRadioButtonCallback(self.CursorButton);
      }
    });

    this.GetLayerGui().SelectedWidgets = [widget];
  };

  // Widget is an optional arguement.
  AnnotationToolPanel.prototype.ArrowButtonOn = function (layerGui) {
    // The layer has to be in editing mode.
    layerGui.EditOn();

    var widget;
    // Get an arrow widget.
    // Look for a selected widget to reuse.
    var layer = layerGui.Layer;
    if (!widget) {
      widget = layer.GetASelectedWidget('arrow');
    }
    if (!widget) {
      // A selected arrowWidget was not found. Make a new arrow widget.
      widget = new SAM.ArrowWidget(layer);
      // Dialog needs tu turn off and on bindings.
      // TODO: REmove dialogs from widget and manage them here.
      // Widgets can share a dialog.
      layer.AddWidget(widget);
      // widget.SetCreationCamera(layer.GetCamera());
    }

    // Activate the widget to start drawing.
    widget.SetStateToDrawing(layer);

    // If the arrow is deactivated with a key stroke, this will turn off the
    // arrow button when the widget deactivates itself.
    var self = this;
    widget.SetStateChangeCallback(function () {
      if (!widget.GetActive()) {
        self.ToolRadioButtonCallback(self.CursorButton);
      }
    });

    this.GetLayerGui().SelectedWidgets = [widget];
  };

  AnnotationToolPanel.prototype.CircleButtonOn = function (layerGui) {
    // The layer has to be in editing mode.
    layerGui.EditOn();

    var widget;
    // Get an arrow widget.
    // Look for a selected widget to reuse.
    var layer = layerGui.Layer;
    if (!widget) {
      widget = layer.GetASelectedWidget('circle');
    }
    if (!widget) {
      // A selected arrowWidget was not found. Make a new arrow widget.
      widget = new SAM.CircleWidget(layer);
      // Dialog needs tu turn off and on bindings.
      // TODO: REmove dialogs from widget and manage them here.
      // Widgets can share a dialog.
      layer.AddWidget(widget);
      // widget.SetCreationCamera(layer.GetCamera());
    }

    // Activate the widget to start drawing.
    widget.SetStateToDrawing(layer);

    // If the arrow is deactivated with a key stroke, this will turn off the
    // arrow button when the widget deactivates itself.
    var self = this;
    widget.SetStateChangeCallback(function () {
      if (!widget.GetActive()) {
        self.ToolRadioButtonCallback(self.CursorButton);
      }
    });

    this.GetLayerGui().SelectedWidgets = [widget];
  };

  AnnotationToolPanel.prototype.RectangleButtonOn = function (layerGui) {
    // The layer has to be in editing mode.
    layerGui.EditOn();

    var widget;
    // Get an arrow widget.
    // Look for a selected widget to reuse.
    var layer = layerGui.Layer;
    if (!widget) {
      widget = layer.GetASelectedWidget('rect');
    }
    if (!widget) {
      // A selected arrowWidget was not found. Make a new arrow widget.
      widget = new SAM.RectWidget(layer);
      // Dialog needs to turn off and on bindings.
      // TODO: REmove dialogs from widget and manage them here.
      // Widgets can share a dialog.
      layer.AddWidget(widget);
      // widget.SetCreationCamera(layer.GetCamera());
    }

    // Activate the widget to start drawing.
    widget.SetStateToDrawing(layer);

    // If the rectangle is deactivated with a key stroke, this will turn off the
    // rectangle button when the widget deactivates itself.
    var self = this;
    widget.SetStateChangeCallback(function () {
      if (!widget.GetActive()) {
        self.ToolRadioButtonCallback(self.CursorButton);
      }
    });

    this.GetLayerGui().SelectedWidgets = [widget];
  };

  // Widget is an optional arguement.
  AnnotationToolPanel.prototype.PencilButtonOn = function (layerGui) {
    // The layer has to be in editing mode.
    layerGui.EditOn();

    var widget;
    // Get a pencil widget.
    // Look for a selected widget to reuse.
    var layer = layerGui.Layer;
    if (!widget) {
      widget = layer.GetASelectedWidget('pencil');
    }
    if (!widget) {
      // A selected pencilWidget was not found. Make a new pencil widget.
      widget = new SAM.PencilWidget(layer);
      // Dialog needs tu turn off and on bindings.
      // TODO: REmove dialogs from widget and manage them here.
      // Widgets can share a dialog.
      layer.AddWidget(widget);
      // widget.SetCreationCamera(layer.GetCamera());
    }

    // Activate the widget to start drawing.
    widget.SetStateToDrawing(layer);

    // If the pencil is deactivated with a key stroke, this will turn off the
    // pencil button when the widget deactivates itself.
    var self = this;
    widget.SetStateChangeCallback(function () {
      if (!widget.GetActive()) {
        self.ToolRadioButtonCallback(self.CursorButton);
      }
    });

    // Will it use open or closed strokes?
    if (this.PencilOpenClosedState === OPEN) {
      widget.SetModeToOpen(layer);
    } else {
      widget.SetModeToClosed(layer);
    }

    this.GetLayerGui().SelectedWidgets = [widget];
  };

  AnnotationToolPanel.prototype.SetTime = function (time) {
    for (var i = 0; i < this.AnnotationObjects.length; ++i) {
      var layerGui = this.AnnotationObjects[i];
      var layer = layerGui.Layer;
      if (layer) {
        layer.ZTime = time;
      }
    }
  };

  SAM.AnnotationToolPanel = AnnotationToolPanel;
})();

// Split off from annotationToolPanel.js
// This is for mask tools: draw and erase.

(function () {
  'use strict';

  // Parent is the viewer.Div
  // TODO: Simplify the args.
  function MaskToolPanel (layerPanel) {
    this.LayerPanel = layerPanel;
    // Any new layers created have to know the viewer.
    this.Viewer = layerPanel.Viewer;

    this.Parent = this.Viewer.GetDiv();

    // -----------------------------------------------------

    // CSS maybe?
    this.Margin = layerPanel.Margin;
    this.ToolDivHeight = layerPanel.ToolDivHeight;

    // If we have write access, this creates markup tools.
    this.ToolPanel = $('<div>')
      .appendTo(this.Parent.parent())
      .hover(function () { $(this).css({'opacity': '1'}); },
             function () { $(this).css({'opacity': '0.6'}); })
      .css({
        'position': 'absolute',
        'background-color': '#fff',
        'border': '1px solid #666666',
        'left': '3px',
        'top': (5 * this.Margin) + 'px',
        'opacity': '0.6',
        'z-index': '300'})
      .draggable()
      .hide();

    this.ToolDiv = $('<div>')
      .appendTo(this.ToolPanel);

    this.OptionsDiv = $('<div>')
      .appendTo(this.ToolPanel)
      .attr('id', 'saAnnotationTools');

    this.InitializeTools();
  }

  MaskToolPanel.prototype.SetLayerGui = function (layerGui) {
    this.LayerGui = layerGui;
  };

  MaskToolPanel.prototype.Hide = function () {
    this.ToolPanel.hide();
  };

  MaskToolPanel.prototype.Show = function () {
    this.ToolPanel.show();
  };

  MaskToolPanel.prototype.InitializeTools = function () {
    // Radio buttons for tools. (One active at a time).
    this.CursorButton = this.AddToolRadioButton('cursor_arrow.png', 'CursorOn');
    this.PaintButton = this.AddToolRadioButton('paint64.png', 'PaintButtonOn');
    this.EraseButton = this.AddToolRadioButton('eraser64.png', 'EraseButtonOn');

    this.CursorButton.css({
      'border': '2px solid #333',
      'background-color': '#bcf'});

    // Default just lets the viewer handle the events.
    this.ActiveToolButton = this.CursorButton;
  };

  MaskToolPanel.prototype.AddToolRadioButton = function (imageFile, onCallbackName) {
    var self = this;
    var button = $('<img>')
        .appendTo(this.ToolDiv)
        .css({
          'border': '2px solid #ccc',
          'margin': '1px',
          'background-color': '#fff',
          'width': '28px',
          'height': '28px'
        })
        .attr('type', 'image')
        .attr('src', SA.ImagePathUrl + imageFile)
      .on('click touchstart',
          function () {
            self.ToolRadioButtonCallback(button);
            return false;
          })
      // To block the viewer moving.
      .on('mousedown mousemove mouseup touchmove touchend',
          function () { return false; });
      // On off functionality
    if (onCallbackName) {
      button.on(
        'radio-on',
        function () {
          self.LayerPanel.WithEditingLayerCall(
            function (annotObj) {
              (self[onCallbackName])(annotObj);
            });
        });
    }
    return button;
  };

  // Change the state of the Radio GUI, but do not trigger side effects (PencidOn ...)
  MaskToolPanel.prototype.HighlightRadioToolButton = function (pressedButton) {
    if (pressedButton === this.ActiveToolButton) {
      return false;
    }
    // Turn off the old one. We have to do this by turning on the cursor.
    this.ActiveToolButton
      .css({
        'border': '2px solid #ccc',
        'background-color': '#fff'});
    // Turn on the new one.
    pressedButton.css({
      'border': '2px solid #222',
      'background-color': '#cdf'});
    this.ActiveToolButton = pressedButton;
  };

  // General for the radio
  // This assumes button is in the ToolRadioButtons list.
  MaskToolPanel.prototype.ToolRadioButtonCallback = function (pressedButton) {
    if (pressedButton === this.ActiveToolButton) {
      return false;
    }
    // GUI only change/
    this.HighlightRadioToolButton(pressedButton);

    // Turn off previous tool widgets. (deactivate)
    if (this.LayerPanel.EditingLayer) {
      var layer = this.LayerPanel.EditingLayer.Layer;
      layer.InactivateAll();
    }

    // Turn on the new one.
    // Note: This ensures a layer is highlighted.
    pressedButton.trigger('radio-on');

    // Show the open closed toggle and other options.
    this.UpdateToolVisibility();
  };

  MaskToolPanel.prototype.UpdateToolVisibility = function () {
    console.log('UpdateToolVisibility not needed here.  Does it have to be called?');
  };

  MaskToolPanel.prototype.CursorOn = function () {
    if (this.LayerPanel.EditingLayer && this.LayerPanel.EditingLayer.Layer) {
      this.LayerPanel.EditingLayer.Layer.SetSelected(false);
      this.LayerPanel.EditingLayer.Layer.EventuallyDraw();
    }
    this.Viewer.GetParentDiv().css({'cursor': ''});
    this.ActiveToolButton = this.CursorButton;
    // Is this thie correct behavior?
    this.LayerGui.SelectedWidgets = [];
  };

  MaskToolPanel.prototype.PaintButtonOn = function (annotObj) {
    // The layer has to be in editing mode.
    annotObj.EditOn();

    var widget;
    // Get a paint widget.
    // Look for a selected widget to reuse.
    var layer = annotObj.Layer;
    // ??????
    if (!widget) {
      widget = layer.GetASelectedWidget('paint');
    }
    if (!widget) {
      // A selected arrowWidget was not found. Make a new arrow widget.
      widget = new SAM.PaintWidget(layer);
      layer.AddWidget(widget);
      widget.SetCreationCamera(layer.GetCamera());
    }

    // Activate the widget to start drawing.
    widget.SetStateToDrawing(layer);

    // If the widget is deactivated with a key stroke, this will turn off the
    // widget button when the widget deactivates itself.
    var self = this;
    widget.SetStateChangeCallback(function () {
      if (!widget.GetActive()) {
        self.ToolRadioButtonCallback(self.CursorButton);
      }
    });

    this.LayerGui.SelectedWidgets = [widget];
  };

  MaskToolPanel.prototype.EraseButtonOn = function (annotObj) {
    // The layer has to be in editing mode.
    annotObj.EditOn();

    var widget;
    // Get an erase widget.
    // Look for a selected widget to reuse.
    var layer = annotObj.Layer;
    // ??????
    if (!widget) {
      widget = layer.GetASelectedWidget('erase');
    }
    if (!widget) {
      // A selected arrowWidget was not found. Make a new arrow widget.
      widget = new SAM.EraseWidget(layer);
      layer.AddWidget(widget);
      widget.SetCreationCamera(layer.GetCamera());
    }

    // Activate the widget to start drawing.
    widget.SetStateToDrawing(layer);

    // If the widget is deactivated with a key stroke, this will turn off the
    // widget button when the widget deactivates itself.
    var self = this;
    widget.SetStateChangeCallback(function () {
      if (!widget.GetActive()) {
        self.ToolRadioButtonCallback(self.CursorButton);
      }
    });

    this.LayerGui.SelectedWidgets = [widget];
  };

  MaskToolPanel.prototype.SetTime = function (time) {
    for (var i = 0; i < this.AnnotationObjects.length; ++i) {
      var annotObj = this.AnnotationObjects[i];
      var layer = annotObj.Layer;
      if (layer) {
        layer.ZTime = time;
      }
    }
  };

  SAM.MaskToolPanel = MaskToolPanel;
})();

// It seems I cannot control the order these files are loaded.
window.SA = window.SA || {};

// Utilities to manage cookies

(function () {
  'use strict';

  SA.setCookie = function (cName, value, exdays) {
    var exdate = new Date();
    exdate.setDate(exdate.getDate() + exdays);
    var cValue = escape(value) + ((exdays === null) ? '' : '; expires=' + exdate.toUTCString());
    document.cookie = cName + '=' + cValue;
  };

  SA.getCookie = function (cName) {
    var i, x, y;
    var ARRcookies = document.cookie.split(';');
    for (i = 0; i < ARRcookies.length; i++) {
      x = ARRcookies[i].substr(0, ARRcookies[i].indexOf('='));
      y = ARRcookies[i].substr(ARRcookies[i].indexOf('=') + 1);
      x = x.replace(/^\s+|\s+$/g, '');
      if (x === cName) {
        return unescape(y);
      }
    }
  };
})();

// To be put in the girder annotation panel.
// Fast forward skips ahead/back 1/10 of folder.
// However, I want to use callbacks to make this more general.

(function () {
  'use strict';

  function GirderNavigationWidget (parent, itemId) {
    this.InitializeItemId(itemId);
    this.ChangeItemCallback = undefined;
    this.ItemIndex = -1;
    this.FolderItemIds = undefined;

    var self = this;
    var size = '40px';
    if (SAM.detectMobile()) {
      // fake a tab
      this.Tab = {};
      this.Tab.Panel = $('<div>')
            .appendTo(parent)
            .hide()
            // .addClass("sa-view-navigation-div ui-responsive");
            .addClass('ui-responsive')
            .css({'position': 'absolute',
              'right': '150px',
              'bottom': '20px',
              'z-index': '5'});
      var panel = this.Tab.Panel;
      this.Tab.show = function () { panel.show(); };
      this.Tab.hide = function () {
        panel.hide();
      };
      // SA.OnStartInteraction( function () { panel.hide();} );
    } else {
      this.Tab = new SA.Tab(parent, SA.ImagePathUrl + 'nav.png', 'navigationTab');
      // this.Tab.Div.prop('title', 'Navigation');
      this.Tab.Div
        // .addClass('sa-view-navigation-div')
        .css({
          'box-sizing': 'border-box',
          '`position': 'absolute',
          'bottom': '0px',
          'right': '150px',
          'z-index': '200'});
      this.Tab.Panel
        .addClass('sa-view-navigation-panel')
        .css({'overflow': 'hidden'});

      // Put the stack display in the navigation button
      this.NoteDisplay = $('<div>')
            .appendTo(this.Tab.Div)
            .addClass('sa-view-note')
            .html('');
    }

    this.PreviousSlideButton =
        $('<img>').appendTo(this.Tab.Panel)
        .addClass('sa-view-navigation-button')
        .attr('src', SA.ImagePathUrl + 'previousSlide.png')
        // .prop('title', 'Previous Slide. (page-up)')
        .click(function () { self.PreviousSlide(); });

    this.PreviousNoteButton =
        $('<img>').appendTo(this.Tab.Panel)
        .addClass('sa-view-navigation-button')
        .attr('src', SA.ImagePathUrl + 'previousNote.png')
        // .prop('title', 'Previous Note. (p)')
        .click(function () { self.PreviousNote(); });

    this.NextNoteButton =
        $('<img>').appendTo(this.Tab.Panel)
        .addClass('sa-view-navigation-button')
        .attr('src', SA.ImagePathUrl + 'nextNote.png')
        // .prop('title', 'Next Note, (n, space)')
        .click(function () { self.NextNote(); });

    this.NextSlideButton =
        $('<img>').appendTo(this.Tab.Panel)
        .addClass('sa-view-navigation-button')
        .attr('src', SA.ImagePathUrl + 'nextSlide.png')
        // .prop('title', 'Next Slide. (page-down)')
        .css({'z-index': '100'})
        .click(function () { self.NextSlide(); });
    this.NextSlideButton
        .on('touchend', function (event) {
          self.NextSlide();
          return false;
        });

    this.NameLabel = $('<div>')
      .appendTo(this.Tab.Panel)
      .css({
        'font-size': '10px',
        'position': 'relative',
        'top': '-3px'});

    // TODO: Fix the main css file for mobile.  Hack this until fixed.
    if (SAM.MOBILE_DEVICE) {
      size = '80px';
      if (SAM.MOBILE_DEVICE === 'iPhone') {
        size = '100px';
      }
      this.PreviousSlideButton
            .css({'height': size,
              'width': size,
              'opacity': '0.8'})
            .on('touchend', function () { self.PreviousSlide(); });
      this.PreviousNoteButton
            .css({'height': size,
              'width': size,
              'opacity': '0.8'})
            .on('touchend', function () { self.PreviousNote(); });
      this.NextNoteButton
            .css({'height': size,
              'width': size,
              'opacity': '0.8'})
            .on('touchend', function () { self.NextNote(); });
      this.NextSlideButton
            .css({'height': size,
              'width': size,
              'opacity': '0.8'});
    }

    // this.CopyrightWrapper =
    //    $('<div>').appendTo(parent)
    //    .css({
    //      'width': '100%',
    //      'text-align': 'center'
    //    }).html();
  }

  GirderNavigationWidget.prototype.SetChangeItemCallback = function (callback) {
    this.ChangeItemCallback = callback;
  };

  GirderNavigationWidget.prototype.ChangeItem = function () {
    window.history.pushState(this.ItemId, 'SlideAtlas viewer ' + this.ItemId,
                             '/#item/' + this.ItemId);

    if (this.ChangeItemCallback) {
      (this.ChangeItemCallback)(this.ItemId);
    }
  };

  GirderNavigationWidget.prototype.InitializeItemId = function (itemId) {
    // Get the item object so we can find the folder id.
    this.ItemId = itemId;
    var self = this;
    girder.rest.restRequest({
      url: 'item/' + itemId,
      method: 'GET'
    }).done(function (data) {
      if (data && data.folderId) {
        self.InitializeFolderId(data.folderId);
      } else {
        console.log('Could not find item ' + itemId);
      }
    });
  };

  GirderNavigationWidget.prototype.InitializeFolderId = function (folderId) {
    // Load the folder so we can create a list to iterate over.
    var self = this;
    girder.rest.restRequest({
      url: 'item?folderId=' + folderId + '&limit=5000&sort=lowerName&sortdir=1',
      method: 'GET'
    }).done(function (data) {
      self.LoadFolderItems(data);
    });
  };

  GirderNavigationWidget.prototype.LoadFolderItems = function (data) {
    this.ItemIndex = -1;
    this.FolderItemIds = [];
    this.FolderItemNames = [];
    for (var i = 0; i < data.length; ++i) {
      var itemId = data[i]._id;
      if (itemId === this.ItemId) {
        this.ItemIndex = i;
      }
      this.FolderItemIds.push(itemId);
      this.FolderItemNames.push(data[i].name);
    }
    this.Update();
  };

  GirderNavigationWidget.prototype.SetInteractionEnabled = function (flag) {
    var self = this;
    if (flag) {
      this.Display.Parent.on(
            'keydown.navigation',
            function (event) {
              return self.HandleKeyDown(event);
            });
    } else {
      this.Display.Parent.off('keydown.navigation');
    }
  };

  GirderNavigationWidget.prototype.HandleKeyDown = function (event) {
    var keyCode = event.keyCode;
    // 34=page down, 78=n, 32=space
    if (keyCode === 34) {
      this.NextSlide();
      return false;
    }
    if (keyCode === 78 || keyCode === 32) {
      this.NextNote();
      return false;
    }
    // 33=page up, 80=p
    if (keyCode === 33) {
      this.PreviousSlide();
      return false;
    }
    if (keyCode === 80) {
      this.PreviousNote();
      return false;
    }

    return true;
  };

  GirderNavigationWidget.prototype.ToggleVisibility = function () {
    this.SetVisibility(!this.Visibility);
  };

  // Used on mobile.
  GirderNavigationWidget.prototype.SetVisibility = function (v) {
    this.Visibility = v;
    if (v) {
      this.Tab.show();
    } else {
      this.Tab.hide();
    }
  };

  // Change which buttons are active based on the current index.
  GirderNavigationWidget.prototype.Update = function () {
    this.ItemName = this.FolderItemNames[this.ItemIndex];
    this.NameLabel.text(this.ItemIndex.toString() + ':' + this.ItemName);

    // Disable and enable prev/next slide buttons so we cannot go past the end.
    if (!this.FolderItemIds || this.ItemIndex <= 0) {
      this.PreviousNoteButton.removeClass('sa-active');
      this.PreviousSlideButton.removeClass('sa-active');
    } else {
      this.PreviousNoteButton.addClass('sa-active');
      this.PreviousSlideButton.addClass('sa-active');
    }
    if (!this.FolderItemIds || this.ItemIndex >= this.FolderItemIds.length - 1) {
      this.NextNoteButton.removeClass('sa-active');
      this.NextSlideButton.removeClass('sa-active');
    } else {
      this.NextNoteButton.addClass('sa-active');
      this.NextSlideButton.addClass('sa-active');
    }
  };

  GirderNavigationWidget.prototype.PreviousNote = function () {
    if (!this.FolderItemIds) { return; }
    // Make sure user notw changes are not pending to be saved.
    // if (SA.notesWidget) { SA.notesWidget.Flush(); }
    if (this.ItemIndex <= 0) {
      return;
    }
    this.ItemIndex -= 1;
    this.ItemId = this.FolderItemIds[this.ItemIndex];
    this.ChangeItem();
    this.Update();
  };

  GirderNavigationWidget.prototype.NextNote = function () {
    if (!this.FolderItemIds) { return; }
    // Make sure user not changes are not pending to be saved.
    // if (SA.notesWidget) { SA.notesWidget.Flush(); }
    if (this.ItemIndex >= this.FolderItemIds.length) {
      return;
    }

    this.ItemIndex += 1;
    this.ItemId = this.FolderItemIds[this.ItemIndex];
    this.ChangeItem();
    this.Update();
  };

  GirderNavigationWidget.prototype.GetFastIncrement = function () {
    var inc = this.FolderItemIds.length / 20;
    if (inc < 5) {
      return 5;
    }
    var tmp;
    for (tmp = 10; tmp <= 50; tmp += 10) {
      if (inc < tmp) {
        return tmp;
      }
    }
    for (tmp = 100; tmp <= 500; tmp += 100) {
      if (inc < tmp) {
        return tmp;
      }
    }
    return 1000;
  };

  GirderNavigationWidget.prototype.PreviousSlide = function () {
    if (!this.FolderItemIds) { return; }
    // Make sure user notw changes are not pending to be saved.
    // if (SA.notesWidget) { SA.notesWidget.Flush(); }

    if (this.ItemIndex <= 0) {
      return;
    }
    var inc = this.GetFastIncrement();

    this.ItemIndex -= inc;
    if (this.ItemIndex < 0) {
      this.ItemIndex = 0;
    }
    this.ItemId = this.FolderItemIds[this.ItemIndex];
    this.ChangeItem();
    this.Update();
  };

  GirderNavigationWidget.prototype.NextSlide = function () {
    if (!this.FolderItemIds) { return; }
    // Make sure user notw changes are not pending to be saved.
    // if (SA.notesWidget) { SA.notesWidget.Flush(); }

    if (this.ItemIndex >= this.FolderItemIds.length) {
      return;
    }
    var inc = this.GetFastIncrement();

    this.ItemIndex += inc;
    if (this.ItemIndex >= this.FolderItemIds.length) {
      this.ItemIndex = this.FolderItemIds.length - 1;
    }
    this.ItemId = this.FolderItemIds[this.ItemIndex];
    this.ChangeItem();
    this.Update();
  };

  SA.GirderNavigationWidget = GirderNavigationWidget;
})();

window.SA = window.SA || {};

(function () {
  'use strict';

  window.requestAnimationFrame =
        window.requestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.msRequestAnimationFrame;

  // TODO: Merge this with cache.SetTileSource.
  SA.TileSourceToCache = function (tileSource) {
    var w = tileSource.width;
    var h = tileSource.height;
    if (!tileSource.bounds) {
      tileSource.bounds = [0, w - 1, 0, h - 1];
    }
    var cache = new SA.Cache();
    cache.TileSource = tileSource;
    // Make an id for the image so it can be reused.
    var image = {levels: tileSource.maxLevel + 1,
      dimensions: [w, h],
      bounds: tileSource.bounds,
      units: tileSource.units,
      spacing: tileSource.spacing,
      _id: new ObjectId().toString()};

    if (tileSource.tileHeight) {
      image.TileHeight = tileSource.tileHeight;
    }

    if (tileSource.tileWidth) {
      image.TileWidth = tileSource.tileWidth;
    }

    if (tileSource.filename) {
      image.filename = tileSource.filename;
      image.label = tileSource.filename;
    } else {
      image.label = image._id;
    }
    cache.SetImageData(image);
    return cache;
  };

  // TODO: Clean up dependency on notes.
  // Girder make a viewer record from a tile source so the rest of slide
  // atlas works.
  SA.TileSourceToViewerRecord = function (tileSource) {
    var w = tileSource.width;
    var h = tileSource.height;
    if (!tileSource.bounds) {
      tileSource.bounds = [0, w - 1, 0, h - 1];
    }
    var cache = SA.TileSourceToCache(tileSource);
    // Make an id for the image so it can be reused.
    var image = cache.Image;
    var record = new SA.ViewerRecord();
    record.Image = image;
    record.OverViewBounds = tileSource.bounds;
    var bds = tileSource.bounds;
    record.Camera = {
      FocalPoint: [(bds[0] + bds[1]) / 2, (bds[2] + bds[3]) / 2],
      Roll: 0,
      Height: bds[3] - bds[2]};
    return record;
  };

  // Girder make a dummy note from a tile source so the rest of slide
  // atlas works.
  SA.TileSourceToNote = function (tileSource) {
    var note = new SA.Note();
    var record = SA.TileSourceToViewerRecord(tileSource);
    note.ViewerRecords.push(record);
    return note;
  };

    // Put the user note text and annotions it the viewer without changing
    // the camera.  THis has the side effect of reloading the primary note
    // annotations, so the caller should record any new annotations in the
    // viewer before calling this.
  SA.UpdateUserNotes = function () {
    if (SA.notesWidget) {
      SA.notesWidget.UpdateUserNotes();
    }
    if (SA.display) {
      SA.display.UpdateUserNotes();
    }
  };

    // So many optional items have a SetNote(note) method, I decided to
    // have a global method to check each.
  SA.SetNote = function (note) {
    if (SA.notesWidget) {
      SA.notesWidget.SetNote(note);
    }
    if (SA.navigationWidget) {
      SA.navigationWidget.SetNote(note);
    }
    if (SA.display) {
      SA.display.SetNote(note);
    }
  };

  SA.SetNoteFromId = function (noteId) {
    var note = SA.GetNoteFromId(noteId);
    if (!note) {
      note = new SA.Note();
      note.LoadViewId(
                noteId,
                function () {
                  SA.SetNote(note);
                });
      return note;
    }
    SA.SetNote(note);
    return note;
  };

  // Firefox does not set which for mouse move events.
  SA.FirefoxWhich = function (event) {
    if (event.which !== undefined) {
      return;
    }
    event.which = event.buttons;
    if (event.which === 2) {
      event.which = 3;
    } else if (event.which === 3) {
      event.which = 2;
    }
    console.log('firefox which = ' + event.which);
  };

  SA.Debug = function (msg) {
    console.log(msg);
  };

  SA.ZERO_PAD = function (i, n) {
    var s = '0000000000' + i.toFixed();
    return s.slice(-n);
  };

  // This file contains some global variables and misc procedures to
  // initials shaders and some buffers we need and to render.
  // Main function called by the default view.html template
  // SA global will be set to this object.

  // For managing progress with multiple ajax calls.
  SA.ProgressCount = 0;

  // How can we distribute the initialization of these?
  // TODO: Many of these are not used anymore. Clean them up.

  SA.Caches = [];

  SA.StartInteractionListeners = [];

  SA.PushProgress = function () {
    $('body').css({'cursor': 'progress'});
    SA.ProgressCount += 1;
  };

  SA.PopProgress = function () {
    SA.ProgressCount -= 1;
    if (SA.ProgressCount <= 0) {
      $('body').css({'cursor': 'default'});
    }
  };

  // Main function called by the default view.html template
  // SA global will be set to this object.
  SA.Run = function () {
    var self = SA;
    if (SA.SessionId) {
      $.ajax({
        type: 'get',
        url: SA.SessionUrl + '?json=true&sessid=' + SA.SessionId,
        success: function (data, status) {
          self.Session = data;
          self.HideAnnotations = data.hide;
          // TODO: fix this serialization.
          self.Run2();
        },
        error: function () {
          SA.Debug('AJAX - error() : session');
          self.Run2();
        }
      });
    } else {
      SA.Run2();
    }
  };

    // Now we have the session (if the id was passed in).
  SA.Run2 = function () {
    // Get the root note.
    if (SA.ViewId === '' || SA.ViewId === 'None') {
      delete SA.ViewId;
    }
    if (SA.SessionId === '' || SA.SessionId === 'None') {
      delete SA.SessionId;
    }

    // We need to get the view so we know how to initialize the app.
    var rootNote = new SA.Note();

    // Hack to create a new presenation.
    if (SA.ViewId === 'presentation') {
      var title = window.prompt('Please enter the presentation title.',
                                      'SlideShow');
      if (title === null) {
                // Go back in browser?
        return;
      }
      rootNote.Title = title;
      rootNote.HiddenTitle = title;
      rootNote.Text = '';
      rootNote.Type = 'HTML';

      Main(rootNote);
    } else {
      if (SA.ViewId === '') {
        SA.Debug('Missing view id');
        return;
      }
      // Sort of a hack that we rely on main getting called after SA
      // method returns and other variables of SA are initialize.
      rootNote.LoadViewId(SA.ViewId,
                            function () { Main(rootNote); });
    }
  };

  // Stack editing stuff (should not be in the global class).
  // It used to be in the event manager.  Skipping the focus stuff.
  // TODO:
  // Modifier could be handled better with keypress events.
  SA.HandleKeyDownStack = function (event) {
    if (SA.ContentEditableHasFocus) { return true; }

    if (event.keyCode === 16) {
      // Do not forward modifier keys events to objects that consume keypresses.
      return true;
    }
    if (event.keyCode === 17) {
      // Control key modifier.
      SA.ControlKeyPressed = true;
      return true;
    }

    // Handle undo and redo (cntrl-z, cntrl-y)
    if (SA.ControlKeyPressed && event.keyCode === 90) {
      // Function in recordWidget.
      SA.recorderWidget.UndoState();
      return false;
    } else if (SA.ControlKeyPressed && event.keyCode === 89) {
      // Function in recordWidget.
      SA.recorderWidget.RedoState();
      return false;
    }

    if (SA.presentation) {
      SA.presentation.HandleKeyDown(event);
      return true;
    }

    return true;
  };

  SA.HandleKeyUpStack = function (event) {
    if (SA.ContentEditableHasFocus) { return true; }

    // For debugging deformable alignment in stacks.
    if (event.keyCode === 90) { // z = 90
      if (event.shiftKey) {
        SA.DeformableAlignViewers(false);
        return true;
      }
    }
    if (event.keyCode === 89) { // y = 89
      if (event.shiftKey) {
        SA.DeformableAlignViewers(true);
        return true;
      }
    }

        // It is sort of a hack to check for the cursor mode here, but it
        // affects both viewers.
    if (event.keyCode === 88) { // x = 88
            // I am using the 'x' key to display to focal point cursor
            // SA.StackCursorFlag = false;
            // what a pain.  Holding x down sometimes blocks mouse events.
            // Have to change to toggle.
      SA.StackCursorFlag = !SA.StackCursorFlag;
      if (event.shiftKey && SA.StackCursorFlag) {
        SA.testAlignTranslation();
        var self = SA;
        window.setTimeout(function () { self.StackCursorFlag = false; }, 1000);
      }

      SA.display.EventuallyRender();
      return false;
    }

    if (event.keyCode === 16) {
      // Shift key modifier.
      // SA.StackCursorFlag = false;
    } else if (event.keyCode === 17) {
      // Control key modifier.
      SA.ControlKeyPressed = false;
    }

        // Is SA really necessary?
        // TODO: Try to remove SA and test presentation stuff.
    if (SA.presentation) {
      SA.presentation.HandleKeyUp(event);
      return true;
    }

    return true;
  };

    // TODO: SA should be in viewer.
  SA.OnStartInteraction = function (callback) {
    SA.StartInteractionListeners.push(callback);
  };

  SA.TriggerStartInteraction = function () {
    if (!SA.StartInteractionListeners) { return; }
    for (var i = 0; i < SA.StartInteractionListeners.length; ++i) {
      var callback = SA.StartInteractionListeners[i];
      callback();
    }
  };

    // TODO: These should be moved to viewer-utils so they can be used
    // separately from SlideAtlas.
    // Helper function: Looks for a key phase in the text.
    // first === true: Look only at the start. Returns true if found.
    // first === false: return index of tag or -1;
  SA.TagCompare = function (tag, text, first) {
    if (first) {
      return (tag.toUpperCase() ===
                    text.substring(0, tag.length).toUpperCase());
    }
    return text.toUpperCase().search(tag.toUpperCase());
  };

    // Process HTML to add standard tags.
    // Returns the altered html.
    // I am writting SA to be safe to call multiple times.
    // Depth first traversal of tree.
  SA.AddHtmlTags = function (item) {
    var container;
    var tags = [{string: 'History:', class: 'sa-history'},
                    {string: 'Diagnosis:', class: 'sa-diagnosis'},
                    {string: 'Differential Diagnosis:', class: 'sa-differential-diagnosis'},
                    {string: 'Teaching Points:', class: 'sa-teaching-points'},
                    {string: 'Compare with:', class: 'sa-compare'},
                    {string: 'Notes:', class: 'sa-notes'}];

        // Since text concatinates children,
        // containers only have to consume siblings.
    var children = item.children();
    var i;
    var j;
    var tag;
    var foundTag;
    var grandChildren;
    for (i = 0; i < children.length; ++i) {
      var child = $(children[i]);

      // Look for an existing class from our set.
      // If we find one, terminate processing for the item and ites children.
      // Terminate the container collecting items.
      for (j = 0; j < tags.length; ++j) {
        if (child.hasClass(tags[j].class)) {
          foundTag = tags[j];
        }
      }
      if (foundTag) {
        container = undefined;
        continue;
      }

      // special (one line tag)
      if (child.hasClass('sa-ssc-title')) {
        container = undefined;
        continue;
      }

      // Look for a tag string inthe text
      var text = child.text();
      // Special case: treat the title as a single line.
      if (SA.TagCompare('SSC', text, true) && !child.hasClass('sa-ssc-title')) {
        child.addClass('sa-ssc-title');
      }

      // Make sure tags are not grouped.
      // SA is a bit of a hack.  THere are too many ways html can be formatted.
      if (child.children().length > 1) {
        for (j = 0; j < tags.length; ++j) {
          tag = tags[j];
          if (SA.TagCompare(tag.string, text, false) > 0) {
            grandChildren = child.children();
            grandChildren.remove();
            grandChildren.insertAfter(child);
            children = item.children();
            text = child.text();
            break;
          }
        }
      }

      // These tags consume children followint the tag.
      foundTag = false;
      for (j = 0; j < tags.length; ++j) {
        tag = tags[j];
        if (SA.TagCompare(tag.string, text, true)) {
          foundTag = tag;
          break;
        }
      }

      if (foundTag) {
        // If the outer is a div,  reuse it for the container.
        // There was a bug with diagnosis in the history container.
        // This will ungroup multiple tags. However recursion may be
        // needed.
        if (child[0].tagName === 'DIV') {
          grandChildren = child.children();

          // child.empty() // looses text that is not a child.
          // child.contents()[0] gets it. Maybe make a span and
          // put it after 'child'.
          child.children().remove();

          grandChildren.insertAfter(child);
          children = item.children();
          container = child;
          ++i;
          child = $(children[i]);
        } else {
          // Start a new container.
          container = $('<div>')
                        .insertBefore(child);
          children = item.children();
          // Manipulating a list we are traversing is a pain.
          ++i;
        }
        container.addClass(foundTag.class);
      }

            // If we have a container, it consumes all items after it.
      if (container) {
                // Remove the item and add it to the container.
        child.remove();
        child.appendTo(container);
        children = item.children();
                // Manipulating a list we are traversing is a pain.
        --i;
      }
    }
  };

    // Useful utility to get selected text / the position of the cursor.
    // Get the selection in div.  Returns a range.
    // If not, the range is collapsed at the
    // end of the text and a new line is added.
    // div is a jquery parent.
  SA.GetSelectionRange = function (div) {
    var sel = window.getSelection();
    var range;
    var parent = null;

        // Two conditions when we have to create a selection:
        // nothing selected, and something selected in wrong parent.
        // use parent as a flag.
    if (sel.rangeCount > 0) {
            // Something is selected
      range = sel.getRangeAt(0);
      range.noCursor = false;
            // Make sure the selection / cursor is in this editor.
      parent = range.commonAncestorContainer;
            // I could use jquery .parents(), but I bet this is more efficient.
      while (parent && parent !== div[0]) {
                // if ( ! parent) {
                // I believe this happens when outside text is selected.
                // We should we treat this case like nothing is selected.
                // console.log("Wrong parent");
                // return;
                // }
        if (parent) {
          parent = parent.parentNode;
        }
      }
    }
    if (!parent) {
      return null;
            // returnSA.MakeSelectionRange(div);
    }

    return range;
  };

    // When we are inserting at the end and nothing is selected, we need to
    // add a div with a break at the end and select the break. This keeps the
    // cursor after the inserted item. This returns the range.
  SA.MakeSelectionRange = function (div) {
        // When nothing is select, I am trying to make the cursor stay
        // after the question inserted with the range we return.
        // TODO: change this so that the div is added after the dialog
        // apply. Cancel should leave div unchanged.(AddQuestion)
    var sel = window.getSelection();

    div[0].focus();
    var br = $('<br>').appendTo(div);
    var range = document.createRange();
    range.selectNode(br[0]);
    sel.removeAllRanges();
    sel.addRange(range);
    return range;
  };

  SA.GetUser = function () {
    if (typeof (SA.User) !== 'undefined') {
      return SA.User;
    }
        // Happens with girder plugin.
        // SA.Debug("Could not find user");
    return '';
  };

  SA.initWebGL = function (view) {
    // if (view.imageProgram) { return; }
    // Defined in HTML
    // initShaderPrograms(view.gl);
    // initOutlineBuffers(view.gl);
    initImageTileBuffers(view);
  };

  function getShader (gl, type, str) {
    var shader;
    shader = gl.createShader(type);
    gl.shaderSource(shader, str);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      SA.Debug(gl.getShaderInfoLog(shader));
      return null;
    }

    return shader;
  }

// Not used because annotations are all canvas.
// Might be useful in the future.
/*
<script id="shader-poly-fs" type="x-shader/x-fragment">
  precision mediump float;
  uniform vec3 uColor;
  void main(void) {
   gl_FragColor = vec4(uColor, 1.0);
   //gl_FragColor = vec4(0.5, 0.0, 0.0, 1.0);
  }
</script>
<script id="shader-poly-vs" type="x-shader/x-vertex">
  attribute vec3 aVertexPosition;
  uniform mat4 uMVMatrix;
  uniform mat4 uPMatrix;
  void main(void) {
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
  }
</script>

<script id="shader-text-fs" type="x-shader/x-fragment">
  precision mediump float;

  varying vec2 vTextureCoord;
  uniform sampler2D uSampler;
  uniform vec3 uColor;

  void main(void) {
    vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
    // Use the image pixel value as transparency.
    gl_FragColor = vec4(uColor, textureColor.rgb[0]);
  }
</script>
<script id="shader-text-vs" type="x-shader/x-vertex">
  attribute vec3 aVertexPosition;
  attribute vec2 aTextureCoord;

  uniform mat4 uMVMatrix;
  uniform mat4 uPMatrix;

  varying vec2 vTextureCoord;
  void main(void) {
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    vTextureCoord = aTextureCoord;
  }

  function initShaderPrograms (view, gl) {
    // Test threshold value for alpha.
    var heatMapTestFragmentShaderString =
            'precision highp float;' +
            'uniform sampler2D uSampler;' +
            'varying vec2 vTextureCoord;' +
            'void main(void) {' +
            '   vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));' +
            '   highp float value = textureColor.rgb[1] + textureColor.rgb[1] +textureColor.rgb[2];' +
            '   if (value < 0.3 || value > 2.5) {' +
            '     textureColor[0] = textureColor[1] = textureColor[2] = textureColor[3] = 0.0;' +
            '   }' +
            '   gl_FragColor = textureColor;' +
            ' }';
    // Test red->alpha, greed->hue
    var heatMapHueFragmentShaderString =
            'precision highp float;' +
            'uniform sampler2D uSampler;' +
            'varying vec2 vTextureCoord;' +
            'void main(void) {' +
            '  vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));' +
            '  textureColor[3] = textureColor[0];' +
            '  highp float h = textureColor[1] * 6.0;' +
            '  if (h < 1.0) {' +
            '    textureColor[0] = 1.0;' +
            '    textureColor[1] = h;' +
            '    textureColor[3] = 0.0;' +
            '  } else if (h < 2.0) {' +
            '    textureColor[0] = 2.0-h;' +
            '    textureColor[1] = 1.0;' +
            '    textureColor[3] = 0.0;' +
            '  } else if (h < 3.0) {' +
            '    textureColor[0] = 0.0;' +
            '    textureColor[1] = 1.0;' +
            '    textureColor[3] = h-2.0;' +
            '  } else if (h < 4.0) {' +
            '    textureColor[0] = 0.0;' +
            '    textureColor[1] = 4.0-h;' +
            '    textureColor[3] = 1.0;' +
            '  } else if (h < 5.0) {' +
            '    textureColor[0] = h-4.0;' +
            '    textureColor[1] = 0.0;' +
            '    textureColor[3] = 1.0;' +
            '  } else if (h < 6.0) {' +
            '    textureColor[0] = 1.0;' +
            '    textureColor[1] = 0.0;' +
            '    textureColor[3] = 6.0-h;' +
            '  }' +
            '  gl_FragColor = textureColor;' +
            '}';
    // Test red->alpha, constant color set externally
    var heatMapFragmentShaderString =
            'precision highp float;' +
            'uniform sampler2D uSampler;' +
            'uniform vec3 uColor;' +
            'varying vec2 vTextureCoord;' +
            'void main(void) {' +
            '  vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t)).rgba;' +
            '  textureColor = vec4(uColor, textureColor[0]);' +
            '  gl_FragColor = textureColor;' +
            '}';
    var fragmentShaderString =
            'precision highp float;' +
            'uniform sampler2D uSampler;' +
            'varying vec2 vTextureCoord;' +
            'void main(void) {' +
            '   vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));' +
            '   gl_FragColor = textureColor;' +
            ' }';
    var vertexShaderString =
            'attribute vec3 aVertexPosition;' +
            'attribute vec2 aTextureCoord;' +
            'uniform mat4 uMVMatrix;' +
            'uniform mat4 uPMatrix;' +
            'uniform mat3 uNMatrix;' +
            'varying vec2 vTextureCoord;' +
            'void main(void) {' +
            '  gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition,1.0);' +
            '  vTextureCoord = aTextureCoord;' +
            '}';

    // SA.imageProgram = SA.createWebGlProgram(fragmentShaderString, vertexShaderString, gl);
    view.imageProgram = SA.createWebGlProgram(heatMapFragmentShaderString, vertexShaderString, gl);
    // Texture coordinate attribute and texture image uniform
    view.imageProgram.textureCoordAttribute =
        gl.getAttribLocation(view.imageProgram, 'aTextureCoord');
    gl.enableVertexAttribArray(view.imageProgram.textureCoordAttribute);
    view.imageProgram.samplerUniform = gl.getUniformLocation(view.imageProgram, 'uSampler');
    view.imageProgram.colorUniform = gl.getUniformLocation(view.imageProgram, 'uColor');

    // polyProgram = SA.createWebGlProgram("shader-poly-fs", "shader-poly-vs", gl);
    // polyProgram.colorUniform = gl.getUniformLocation(polyProgram, "uColor");

    // textProgram = SA.createWebGlProgram("shader-text-fs", "shader-text-vs", gl);
    // textProgram.textureCoordAttribute
    //    = gl.getAttribLocation(textProgram, "aTextureCoord");
    // gl.enableVertexAttribArray(textProgram.textureCoordAttribute);
    // textProgram.samplerUniform
    //    = gl.getUniformLocation(textProgram, "uSampler");
    // textProgram.colorUniform = gl.getUniformLocation(textProgram, "uColor");
  }
*/

  SA.createWebGlProgram = function (fragmentShaderString, vertexShaderString, gl) {
    var fragmentShader = getShader(gl, gl.FRAGMENT_SHADER, fragmentShaderString);
    var vertexShader = getShader(gl, gl.VERTEX_SHADER, vertexShaderString);

    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      SA.Debug('Could not initialise shaders');
    }

    program.vertexPositionAttribute = gl.getAttribLocation(program, 'aVertexPosition');
    gl.enableVertexAttribArray(program.vertexPositionAttribute);

        // Camera matrix
    program.pMatrixUniform = gl.getUniformLocation(program, 'uPMatrix');
        // Model matrix
    program.mvMatrixUniform = gl.getUniformLocation(program, 'uMVMatrix');

    return program;
  };
  /*
  function initOutlineBuffers (gl) {
    // Outline Square
    var vertices = [
      0.0, 0.0, 0.0,
      0.0, 1.0, 0.0,
      1.0, 1.0, 0.0,
      1.0, 0.0, 0.0,
      0.0, 0.0, 0.0];
    SA.squareOutlinePositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, SA.squareOutlinePositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    SA.squareOutlinePositionBuffer.itemSize = 3;
    SA.squareOutlinePositionBuffer.numItems = 5;

    // Filled square
    SA.squarePositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, SA.squarePositionBuffer);
    vertices = [
      1.0, 1.0, 0.0,
      0.0, 1.0, 0.0,
      1.0, 0.0, 0.0,
      0.0, 0.0, 0.0
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    SA.squarePositionBuffer.itemSize = 3;
    SA.squarePositionBuffer.numItems = 4;
  }
  */
  // ==============================================================================

  function initImageTileBuffers (view) {
    if (view.tileVertexTextureCoordinateBuffer) { return; }

    var gl = view.gl;
    var vertexPositionData = [];
    var textureCoordData = [];

    // Make 4 points
    textureCoordData.push(0.0);
    textureCoordData.push(0.0);
    vertexPositionData.push(0.0);
    vertexPositionData.push(0.0);
    vertexPositionData.push(0.0);

    textureCoordData.push(1.0);
    textureCoordData.push(0.0);
    vertexPositionData.push(1.0);
    vertexPositionData.push(0.0);
    vertexPositionData.push(0.0);

    textureCoordData.push(0.0);
    textureCoordData.push(1.0);
    vertexPositionData.push(0.0);
    vertexPositionData.push(1.0);
    vertexPositionData.push(0.0);

    textureCoordData.push(1.0);
    textureCoordData.push(1.0);
    vertexPositionData.push(1.0);
    vertexPositionData.push(1.0);
    vertexPositionData.push(0.0);

        // Now create the cell.
    var cellData = [];
    cellData.push(0);
    cellData.push(1);
    cellData.push(2);

    cellData.push(2);
    cellData.push(1);
    cellData.push(3);

    view.tileVertexTextureCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, view.tileVertexTextureCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordData), gl.STATIC_DRAW);
    view.tileVertexTextureCoordBuffer.itemSize = 2;
    view.tileVertexTextureCoordBuffer.numItems = textureCoordData.length / 2;

    view.tileVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, view.tileVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), gl.STATIC_DRAW);
    view.tileVertexPositionBuffer.itemSize = 3;
    view.tileVertexPositionBuffer.numItems = vertexPositionData.length / 3;

    view.tileCellBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, view.tileCellBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cellData), gl.STATIC_DRAW);
    view.tileCellBuffer.itemSize = 1;
    view.tileCellBuffer.numItems = cellData.length;
  }

    // TODO: Get rid of this as legacy.
    // I put an eveutallyRender method in the viewer, but have not completely
    // converted code yet.
    // Stuff for drawing
    // var RENDER_PENDING = false;
    // function eventuallyRender() {
    //    if (! RENDER_PENDING) {
    //      RENDER_PENDING = true;
    //      requestAnimFrame(tick);
    //    }
    // }

    // function tick() {
    //    //console.timeEnd("system");
    //    RENDER_PENDING = false;
    //    draw();
    //    //console.time("system");
    // }

    // ==============================================================================
    // Alternative to webgl, HTML5 2d canvas

  function initGC () {
    SAM.detectMobile();
  }

  // ----------------------------------------------------------
  // Log to track down iPad bug.  Console does not log until
  // debugger is running.  Bug does not occur when debugger
  // is running.

  var LOGGING = false;
  var DEBUG_LOG = [];

  function StartLogging (message) { // eslint-disable-line no-unused-vars
    if (LOGGING) {
      return;
    }
    LOGGING = true;
    // alert("Error: Check log");
  }

  function LogMessage (message) { // eslint-disable-line no-unused-vars
    if (LOGGING) {
      DEBUG_LOG.push(message);
    }
  }

  // ----------------------------------------------------------
  // In an attempt to simplify the view.html template file, I am putting
  // as much of the javascript from that file into this file as I can.
  // As I abstract viewer features, these variables and functions
  // should migrate into objects and other files.

  // ==============================================================================

  // TODO:  Get rid of this function.
  function handleResize () {
    $('window').trigger('resize');
  }

  // TODO: Move these out of the global SLideAtlas object.
  function handleKeyDown (event) {
    return SA.HandleKeyDownStack(event);
  }
  function handleKeyUp (event) {
    return SA.HandleKeyUpStack(event);
  }

  SA.cancelContextMenu = function (e) {
    // alert("Try to cancel context menu");
    if (e && e.stopPropagation) {
      e.stopPropagation();
    }
    return false;
  };

  // Call back from NotesWidget.
  function NotesModified () {
    if (SA.Edit && SA.SaveButton) {
      SA.SaveButton.attr('src', SA.ImagePathUrl + 'save.png');
    }
  }

  function NotesNotModified () {
    if (SA.Edit && SA.SaveButton) {
      SA.SaveButton.attr('src', SA.ImagePathUrl + 'save22.png');
    }
  }

  // This function gets called when the save button is pressed.
  function SaveCallback () {
    // TODO: This is no longer called by a button, so change its name.
    SA.notesWidget.SaveCallback(
            function () {
              // finished
              SA.SaveButton.attr('src', SA.ImagePathUrl + 'save22.png');
            });
  }

  // This serializes loading a bit, but we need to know what type the note is
  // so we can coustomize the webApp.  The server could pass the type to us.
  // It might speed up loading.
  // Note is the same as a view.
  function Main (rootNote) {
    SA.RootNote = rootNote;

    if (rootNote.Type === 'Presentation' ||
            rootNote.Type === 'HTML') {
      SA.presentation = new SA.Presentation(rootNote, SA.Edit);
      return;
    }

    SAM.detectMobile();
    $('body').addClass('sa-view-body');
    // Just to see if webgl is supported:
    // var testCanvas = document.getElementById("gltest");

    // I think the webgl viewer crashes.
    // Maybe it is the texture leak I have seen in connectome.
    // Just use the canvas for now.
    // I have been getting crashes I attribute to not freeing texture
    // memory properly.
    // NOTE: I am getting similar crashes with the canvas too.
    // Stack is running out of some resource.
    // initGL(); Sets CANVAS and GL global variables
    initGC();

    if (SAM.detectMobile() && SA.MOBILE_ANNOTATION_WIDGET) {
      SA.MOBILE_ANNOTATION_WIDGET = new SA.MobileAnnotationWidget();
    }

    SA.MainDiv = $('<div>')
            .appendTo('body')
            .css({
              'position': 'fixed',
              'left': '0px',
              'width': '100%'})
            .saFullHeight();
        // .addClass("sa-view-canvas-panel")

        // Left panel for notes.
    SA.resizePanel = new SA.ResizePanel(SA.MainDiv);
    SA.display = new SA.DualViewWidget(SA.resizePanel.MainDiv);
    SA.notesWidget = new SA.NotesWidget(SA.resizePanel.PanelDiv,
                                            SA.display);

    if (rootNote.Type === 'Stack') {
      SA.display.SetNumberOfViewers(2);
    }

    SA.notesWidget.SetModifiedCallback(NotesModified);
    SA.notesWidget.SetModifiedClearCallback(NotesNotModified);
        // Navigation widget keeps track of which note is current.
        // Notes widget needs to access and change this.
    SA.notesWidget.SetNavigationWidget(SA.display.NavigationWidget);
    if (SA.display.NavigationWidget) {
      SA.display.NavigationWidget.SetInteractionEnabled(true);
    }

    SA.recorderWidget = new SA.RecorderWidget(SA.display);

        // Do not let guests create favorites.
        // TODO: Rework how favorites behave on mobile devices.
    if (SA.User !== '' && !SAM.detectMobile()) {
      if (SA.Edit) {
                // Put a save button here when editing.
        SA.SaveButton = $('<img>')
                    .appendTo(SA.resizePanel.MainDiv)
                    .css({'position': 'absolute',
                      'bottom': '4px',
                      'left': '10px',
                      'height': '28px',
                      'z-index': '5'})
                    .prop('title', 'save to databse')
                    .addClass('editButton')
                    .attr('src', SA.ImagePathUrl + 'save22.png')
                    .click(SaveCallback);
                // for (var i = 0; i < SA.display.Viewers.length; ++i) {
                // SA.display.Viewers[i].OnInteraction(function () {});
                // }
      } else {
                // Favorites when not editing.
        SA.FAVORITES_WIDGET = new SA.FavoritesWidget(SA.MainDiv, SA.display);
                // SA.FAVORITES_WIDGET.HandleResize(CANVAS.innerWidth());
      }
    }

    if (SAM.MOBILE_DEVICE && SA.DualDisplay &&
            SA.DualDisplay.NavigationWidget) {
      SA.DualDisplay.NavigationWidget.SetVisibility(false);
    }
    if (SAM.MOBILE_DEVICE && SA.MOBILE_ANNOTATION_WIDGET) {
      SA.MOBILE_ANNOTATION_WIDGET.SetVisibility(false);
    }

        // CONFERENCE_WIDGET = new SA.ConferenceWidget();

        // The event manager still handles stack alignment.
        // This should be moved to a stack helper class.
        // Undo and redo too.
    document.onkeydown = handleKeyDown;
    document.onkeyup = handleKeyUp;

        // Keep the browser from showing the left click menu.
    document.oncontextmenu = SA.cancelContextMenu;

    if (!SAM.MOBILE_DEVICE) {
            // Hack for all viewer edit menus to share browser.
      SA.VIEW_BROWSER = new SA.ViewBrowser($('body'));

            // TODO: See if we can get rid of this, or combine it with
            // the view browser.
      SA.InitSlideSelector(SA.MainDiv); // What is this?
      SA.viewMenu1 = new SA.ViewEditMenu(SA.display.Viewers[0],
                                         SA.display.Viewers[1]);
      SA.viewMenu2 = new SA.ViewEditMenu(SA.display.Viewers[1],
                                         SA.display.Viewers[0]);
      SA.display.UpdateGui();

            // ==============================
            // Experiment wit combining transparent webgl ontop of canvas.
            /*
            var imageObj = {prefix:"/tile?img=560b4011a7a1412197c0cc76&db=5460e35a4a737abc47a0f5e3&name=",
                            levels:     12,
                            dimensions: [419168, 290400, 1],
                            bounds: [0,419167, 0, 290399, 0,0],
                            spacing: [0.1,0.1,1.0],
                            origin : [100, 10000]};
            var heatMapSource = new SA.SlideAtlasSource();
            heatMapSource.Prefix = imageObj.prefix;
            var heatMapCache = new SA.Cache();
            heatMapCache.TileSource = heatMapSource;
            heatMapCache.SetImageData(imageObj);

            SA.heatMap1 = new SA.HeatMap(viewer1.Div);
            SA.heatMap1.SetCache(heatMapCache);
            viewer1.AddLayer(SA.heatMap1);
            */
            /*
            SA.heatMap1.SetImageData(
                {prefix:"/tile?img=560b4011a7a1412197c0cc76&db=5460e35a4a737abc47a0f5e3&name=",
                 levels:     12,
                 dimensions: [419168, 290400, 1],
                 bounds: [0,419167, 0, 290399, 0,0],
                 spacing: [0.1,0.1,1.0],
                 origin : [100, 10000]});
            viewer1.AddLayer(SA.heatMap1);
            */
            /*

            SA.heatMap2 = new SA.HeatMap(viewer1.Div);
            SA.heatMap2.Color = [0.0, 0.0, 0.7];
            SA.heatMap2.SetImageData(
                {prefix:"/tile?img=560b4011a7a1412197c0cc76&db=5460e35a4a737abc47a0f5e3&name=",
                 levels:     12,
                 dimensions: [419168, 290400, 1],
                 bounds: [0,419167, 0, 290399, 0,0],
                 spacing: [0.15,0.15,1.0],
                 origin : [20000, 20000]});
            viewer1.AddLayer(SA.heatMap2);

            SA.heatMap3 = new SA.HeatMap(viewer2.Div);
            SA.heatMap3.Color = [0.0, 0.0, 0.7];
            SA.heatMap3.Window = -1.0;
            SA.heatMap3.Gama = 0.2;
            SA.heatMap3.SetImageData(
                {prefix:"/tile?img=560b4011a7a1412197c0cc76&db=5460e35a4a737abc47a0f5e3&name=",
                 levels:     12,
                 dimensions: [419168, 290400, 1],
                 bounds: [0,419167, 0, 290399, 0,0],
                 spacing: [0.15,0.15,1.0],
                 origin : [2000, 10000]});
            viewer2.AddLayer(SA.heatMap3);
            */
    }

    SA.SetNote(rootNote);

    $(window).bind('orientationchange', function (event) {
      handleResize();
    });

    $(window).resize(function () {
      handleResize();
    }).trigger('resize');

    if (SA.display) {
      SA.display.Draw();
    }
  }
})();

// It seems I cannot control the order these files are loaded.
window.SA = window.SA || {};

// TODO:
//  ShowViewBrowser();});
// get rid of these.

// function ComparisonSaveAnnotations() {} (used wrongly in text widget.)
// function ShowViewerEditMenu(viewer) {

// Empty
// ViewEditMenu.prototype.SessionAdvanceAjax = function() {

(function () {
  'use strict';

// Other viewer is a hack for copy camera.
// parent is for the view browser.
  function ViewEditMenu (viewer, otherViewer) {
    var self = this; // trick to set methods in callbacks.
    this.Viewer = viewer;
    // Other viewer is a hack for copy camera.
    this.OtherViewer = otherViewer;
    this.Tab = new SA.Tab(viewer.GetDiv(), SA.ImagePathUrl + 'Menu.jpg', 'editTab');
    this.Tab.Div
        .css({'position': 'absolute',
          'right': '47px',
          'bottom': '0px',
          'z-index': '200'})
        .prop('title', 'View Menu');

    this.Tab.Panel.addClass('sa-view-edit-panel');

    if (SA.VIEW_BROWSER) {
      $('<button>')
            .appendTo(this.Tab.Panel)
            .text('Load Slide')
            .addClass('sa-view-edit-button')
            .click(
                function () {
                  self.Tab.PanelOff();
                  SA.VIEW_BROWSER.Open(self.Viewer);
                });
    }
    if (SA.Edit) {
      $('<button>')
            .appendTo(this.Tab.Panel)
            .text('Save View')
            .addClass('sa-view-edit-button')
            .click(function () { self.SaveView(); });
    }
    if (SA.notesWidget) {
      $('<button>')
            .appendTo(this.Tab.Panel)
            .text('Download Image')
            .addClass('sa-view-edit-button')
            .click(function () {
              self.Tab.PanelOff();
              DownloadImage(self.Viewer);
            });

      $('<button>')
            .appendTo(this.Tab.Panel)
            .text('Slide Info')
            .addClass('sa-view-edit-button')
            .click(function () { self.ShowSlideInformation(); });

      if (SA.recorderWidget.TimeLine) {
            // Test for showing coverage of view histor.
        this.HistoryMenuItem = $('<button>')
                .appendTo(this.Tab.Panel)
                .text('History On')
                .addClass('sa-view-edit-button')
                .click(function () { self.ToggleHistory(); });
      }
        // Hack until we have some sort of scale.
      if (this.OtherViewer) {
        this.CopyZoomMenuItem = $('<button>')
                .appendTo(this.Tab.Panel)
                .text('Copy Zoom')
                .hide()
                .addClass('sa-view-edit-button')
                .click(function () { self.CopyZoom(); });
      }

      $('<button>').appendTo(this.Tab.Panel)
            .text('Flip Horizontal')
            .addClass('sa-view-edit-button')
            .click(function () { self.FlipHorizontal(); });
        /* cutout widget dialog is broken.
        $('<button>').appendTo(this.Tab.Panel)
            .text("Download image from server")
            .addClass("sa-view-edit-button")
            .click(function(){
                self.Tab.PanelOff();
                // When the circle button is pressed, create the widget.
                if ( ! self.Viewer) { return; }
                new SA.CutoutWidget(parent, self.Viewer);
            });
        // color threshold is also broken
        for(var plugin in window.PLUGINS) {
            var that = this;
            if(window.PLUGINS[plugin].button_text) {
                (function (plugin) {
                    // console.log("Adding menu for " + plugin);
                    $('<button>').appendTo(that.Tab.Panel)
                        .text(window.PLUGINS[plugin].button_text)
                        .addClass("sa-view-edit-button")
                        .click(function () {
                            window.PLUGINS[plugin].Init();
                        });
                })(plugin);
            }
        }
        */

        // I need some indication that the behavior id different in edit mode.
        // If the user is authorized, the new bounds are automatically saved.
      if (SA.Edit) {
        $('<button>').appendTo(this.Tab.Panel)
                .text('Save OverView Bounds')
                .addClass('sa-view-edit-button')
                .click(function () { self.SetViewBounds(); });
      } else {
        $('<button>').appendTo(this.Tab.Panel)
                .text('Set OverView Bounds')
                .addClass('sa-view-edit-button')
                .click(function () { self.SetViewBounds(); });
      }
    }
  }

  ViewEditMenu.prototype.SetVisibility = function (flag) {
    if (flag) {
      this.Tab.show();
    } else {
      this.Tab.hide();
    }
  };

  ViewEditMenu.prototype.ToggleHistory = function () {
    this.Tab.PanelOff();

    this.Viewer.HistoryFlag = !this.Viewer.HitoryFlag;
    if (this.Viewer.HistoryFlag) {
      this.HistoryMenuItem.text('History Off');
    } else {
      this.HistoryMenuItem.text('History On');
    }
    SA.display.EventuallyRender();
  };

// Record the viewer into the current note and save into the database.
  ViewEditMenu.prototype.SaveView = function () {
    this.Tab.PanelOff();
    if (SA.notesWidget) {
      SA.notesWidget.SaveCallback();
    }
  };

  ViewEditMenu.prototype.GetViewerBounds = function (viewer) {
    var cam = viewer.GetCamera();
    var fp = cam.GetWorldFocalPoint();
    var halfWidth = cam.GetWidth() / 2;
    var halfHeight = cam.GetHeight() / 2;
    return [fp[0] - halfWidth, fp[0] + halfWidth, fp[1] - halfHeight, fp[1] + halfHeight];
  };

// Add bounds to view to overide image bounds.
  ViewEditMenu.prototype.SetViewBounds = function () {
    this.Tab.PanelOff();
    var bounds = this.GetViewerBounds(this.Viewer);
    var note = SA.display.GetNote();
    // Which view record?
    var viewerRecord = note.ViewerRecords[this.Viewer.RecordIndex];

    viewerRecord.OverViewBounds = bounds;
    // Set the image bounds so the new bounds are used immediately.
    viewerRecord.Image.bounds = viewerRecord.OverViewBounds;
    this.Viewer.OverView.Camera.SetWorldFocalPoint([(bounds[0] + bounds[1]) / 2,
      (bounds[2] + bounds[3]) / 2]);
    this.Viewer.OverView.Camera.SetHeight(bounds[3] - bounds[2]);
    this.Viewer.OverView.Camera.ComputeMatrix();
    this.Viewer.eventuallyRender();

    // Save automatically if user has permission.
    var self = this;
    if (SA.Edit) {
        // I cannot do this because it first sets the viewer record and bounds are lost.
        // SA.notesWidget.SaveCallback();
        // Lets try just setting this one note.
      var noteObj = JSON.stringify(note.Serialize(true));
      var d = new Date();
      $.ajax({
        type: 'post',
        url: 'webgl-viewer/saveviewnotes',
        data: {'note': noteObj,
          'date': d.getTime()},
        success: function (data, status) {
          self.Viewer.EventuallyRender();
        },
        error: function () { SA.Debug('AJAX - error() : saveviewnotes (bounds)'); }
      });
    }
  };

// Add bounds to view to overide image bounds.
  ViewEditMenu.prototype.SetImageBounds = function () {
    this.Tab.PanelOff();

    var viewer = this.Viewer;
    var imageDb = viewer.GetCache().Image.database;
    var imageId = viewer.GetCache().Image._id;
    var bounds = this.GetViewerBounds(viewer);

    // Set the image bounds so the new bounds are used immediately.
    viewer.GetCache().Image.bounds = bounds;
    viewer.OverView.Camera.SetWorldFocalPoint([(bounds[0] + bounds[1]) / 2,
      (bounds[2] + bounds[3]) / 2]);
    viewer.OverView.Camera.SetHeight(bounds[3] - bounds[2]);
    viewer.OverView.Camera.ComputeMatrix();
    viewer.EventuallyRender();

    $.ajax({
      type: 'post',
      url: 'webgl-viewer/set-image-bounds',
      data: {'img': imageId,
        'imgdb': imageDb,
        'bds': JSON.stringify(bounds)},
      success: function (data, status) {},
      error: function () {
        SA.Debug('AJAX - error() : saveusernote 1');
      }
    });
  };

// ==============================================================================
// Create and manage the menu to edit dual views.

// hack: Find the other viewer to copy.
  ViewEditMenu.prototype.CopyZoom = function () {
    this.Tab.PanelOff();

    var cam = this.Viewer.GetCamera();
    var copyCam = this.OtherViewer.GetCamera();

    this.Viewer.AnimateCamera(cam.GetWorldFocalPoint(),
                              cam.GetWorldRoll(), copyCam.Height);
  };

  ViewEditMenu.prototype.ShowSlideInformation = function () {
    this.Tab.PanelOff();
    var imageObj = this.Viewer.MainView.Section.Caches[0].Image;
    SA.SlideInformation.Open(imageObj, this.Viewer);
  };

// Mirror image
  ViewEditMenu.prototype.FlipHorizontal = function () {
    this.Tab.PanelOff();
    // When the circle button is pressed, create the widget.
    if (!this.Viewer) { return; }

    var cam = this.Viewer.GetCamera();
    this.Viewer.ToggleMirror();
    this.Viewer.SetCamera(cam.GetWorldFocalPoint(),
                          cam.GetRotation() + 180.0, cam.Height);
    SA.RecordState();
  };

// Stuff that should be moved to some other file.

// Make the download dialog / function a module.
  var DownloadImage = (function () {
    // Dialogs require an object when accept is pressed.
    var DOWNLOAD_WIDGET;

    function DownloadImage (viewer) {
        // Use a global so apply callback can get the viewer.
      SA.VIEWER = viewer;

      if (!DOWNLOAD_WIDGET) {
        InitializeDialogs();
      }

        // Setup default dimensions.
      var viewport = viewer.GetViewport();
      var d = DOWNLOAD_WIDGET.DimensionDialog;
      d.PxWidthInput.val(viewport[2]);
      d.PxHeightInput.val(viewport[3]);
      var pixelsPerInch = parseInt(d.SizeResInput.val());
      d.SizeWidthInput.val((viewport[2] / pixelsPerInch).toFixed(2));
      d.SizeHeightInput.val((viewport[3] / pixelsPerInch).toFixed(2));
      d.AspectRatio = viewport[2] / viewport[3];

        // Hide or show the stack option.
      if (SA.display.GetNote().Type === 'Stack') {
        DOWNLOAD_WIDGET.DimensionDialog.StackDiv.show();
      } else {
        DOWNLOAD_WIDGET.DimensionDialog.StackDiv.hide();
      }

      DOWNLOAD_WIDGET.DimensionDialog.Show(1);
    }

    function InitializeDialogs () {
      DOWNLOAD_WIDGET = {};

        // Two dialogs.
        // Dialog to choose dimensions and initiate download.
        // A dialog to cancel the download while waiting for tiles.
      var CancelDownloadCallback = function () {
        if (DOWNLOAD_WIDGET.Viewer) {
                // We are in the middle of rendering.
                // This method was called by the cancel dialog.
          DOWNLOAD_WIDGET.Viewer.CancelLargeImage();
          DOWNLOAD_WIDGET.Viewer = undefined;
                // The dialog hides itself.
        }
      };
      var StartDownloadCallback = function () {
            // Trigger the process to start rendering the image.
        DOWNLOAD_WIDGET.Viewer = SA.VIEWER;
        var width = parseInt(DOWNLOAD_WIDGET.DimensionDialog.PxWidthInput.val());
        var height = parseInt(DOWNLOAD_WIDGET.DimensionDialog.PxHeightInput.val());
        var stack = DOWNLOAD_WIDGET.DimensionDialog.StackCheckbox.prop('checked');

            // Show the dialog that empowers the user to cancel while rendering.
        DOWNLOAD_WIDGET.CancelDialog.Show(1);
            // We need a finished callback to hide the cancel dialog.
        if (stack) {
          DOWNLOAD_WIDGET.CancelDialog.StackMessage.show();
        } else {
          DOWNLOAD_WIDGET.CancelDialog.StackMessage.hide();
        }
        SA.VIEWER.SaveLargeImage('slide-atlas.png', width, height, stack,
                                  function () {
                                      // Rendering has finished.
                                      // The user can no longer cancel.
                                    DOWNLOAD_WIDGET.Viewer = undefined;
                                    DOWNLOAD_WIDGET.CancelDialog.Hide();
                                  });
      };

      var d = new SAM.Dialog(StartDownloadCallback);
      d.Body.css({'margin': '1em 2em',
                    // Hack no time to figure out layout with border box option.
        'padding-bottom': '2em',
        'padding-right': '3em'});
      DOWNLOAD_WIDGET.DimensionDialog = d;
      d.Title.text('Download Image');

        // Pixel Dimensions
      d.PxDiv = $('<div>')
            .appendTo(d.Body)
            .css({'border': '1px solid #555',
              'margin': '15px',
              'padding-left': '5px'});
      d.PxLabel =
            $('<div>')
            .appendTo(d.PxDiv)
            .text('Dimensions:')
            .css({'position': 'relative',
              'top': '-9px',
              'display': 'inline-block',
              'background-color': 'white'});

      d.PxWidthDiv =
            $('<div>')
            .appendTo(d.PxDiv)
            .css({'display': 'table-row'});

      d.PxWidthLabel =
            $('<div>')
            .appendTo(d.PxWidthDiv)
            .text('Width:')
            .css({'display': 'table-cell',
              'text-align': 'right',
              'width': '6em'});
      d.PxWidthInput =
            $('<input type="number">')
            .appendTo(d.PxWidthDiv)
            .val('1900')
            .css({'display': 'table-cell',
              'width': '100px',
              'margin': '5px'})
            .change(function () { PxWidthChanged(); });
      d.PxWidthUnits =
            $('<div>')
            .appendTo(d.PxWidthDiv)
            .text('Pixels')
            .css({'display': 'table-cell',
              'text-align': 'left'});

      d.PxHeightDiv =
            $('<div>')
            .appendTo(d.PxDiv)
            .css({'display': 'table-row',
              'margin': '5px'});
      d.PxHeightLabel =
            $('<div>')
            .appendTo(d.PxHeightDiv)
            .text('Height:')
            .css({'display': 'table-cell',
              'text-align': 'right'});
      d.PxHeightInput =
            $('<input type="number">')
            .appendTo(d.PxHeightDiv)
            .val('1080')
            .css({'display': 'table-cell',
              'width': '100px',
              'margin': '5px'})
            .change(function () { PxHeightChanged(); });

      d.PxHeightUnits =
            $('<div>')
            .appendTo(d.PxHeightDiv)
            .text('Pixels')
            .css({'display': 'table-cell',
              'text-align': 'left'});

        // Document Size
      d.SizeDiv = $('<div>')
            .appendTo(d.Body)
            .css({'border': '1px solid #555',
              'margin': '15px',
              'padding-left': '5px'});
      d.SizeLabel =
            $('<div>')
            .appendTo(d.SizeDiv)
            .text('Document Size:')
            .css({'position': 'relative',
              'top': '-9px',
              'display': 'inline-block',
              'background-color': 'white'});

      d.SizeWidthDiv =
            $('<div>')
            .appendTo(d.SizeDiv)
            .css({'display': 'table-row',
              'margin': '5px'});
      d.SizeWidthLabel =
            $('<div>')
            .appendTo(d.SizeWidthDiv)
            .text('Width:')
            .css({'display': 'table-cell',
              'text-align': 'right',
              'width': '6em'});
      d.SizeWidthInput =
            $('<input type="number">')
            .appendTo(d.SizeWidthDiv)
            .val('1900')
            .css({'display': 'table-cell',
              'width': '100px',
              'margin': '5px'})
            .change(function () { SizeWidthChanged(); });

      d.SizeWidthUnits =
            $('<div>')
            .appendTo(d.SizeWidthDiv)
            .text('Inches')
            .css({'display': 'table-cell',
              'text-align': 'left'});

      d.SizeHeightDiv =
            $('<div>')
            .appendTo(d.SizeDiv)
            .css({'display': 'table-row',
              'margin': '5px'});
      d.SizeHeightLabel =
            $('<div>')
            .appendTo(d.SizeHeightDiv)
            .text('Height:')
            .css({'display': 'table-cell',
              'text-align': 'right'});
      d.SizeHeightInput =
            $('<input type="number">')
            .appendTo(d.SizeHeightDiv)
            .val('1900')
            .css({'display': 'table-cell',
              'width': '100px',
              'margin': '5px'})
            .change(function () { SizeHeightChanged(); });

      d.SizeHeightUnits =
            $('<div>')
            .appendTo(d.SizeHeightDiv)
            .text('Inches')
            .css({'display': 'table-cell',
              'text-align': 'left'});

      d.SizeResDiv =
            $('<div>')
            .appendTo(d.SizeDiv)
            .css({'display': 'table-row',
              'margin': '5px'});
      d.SizeResLabel =
            $('<div>')
            .appendTo(d.SizeResDiv)
            .text('Resolution:')
            .css({'display': 'table-cell',
              'text-align': 'right'});
      d.SizeResInput =
            $('<input type="number">')
            .appendTo(d.SizeResDiv)
            .val('72')
            .css({'display': 'table-cell',
              'width': '100px',
              'margin': '5px'})
            .change(function () { ResChanged(); });

      d.SizeResUnits =
            $('<div>')
            .appendTo(d.SizeResDiv)
            .text('Pixels/Inch')
            .css({'display': 'table-cell',
              'text-align': 'left'});

      d.ProportionsDiv =
            $('<div>')
            .appendTo(d.Body)
            .css({'margin': '15px',
              'padding-left': '5px'});
      d.ProportionsLabel =
            $('<div>')
            .appendTo(d.ProportionsDiv)
            .text('Constrain Proportions:')
            .css({'display': 'inline'});
      d.ProportionsCheckbox =
            $('<input type="checkbox">')
            .appendTo(d.ProportionsDiv)
            .css({'display': 'inline'})
            .prop('checked', true);

      d.StackDiv =
            $('<div>')
            .appendTo(d.Body)
            .css({'margin': '15px',
              'padding-left': '5px'})
            .hide();
      d.StackLabel =
            $('<div>')
            .appendTo(d.StackDiv)
            .text('All stack sections:')
            .css({'display': 'inline'});
      d.StackCheckbox =
            $('<input type="checkbox">')
            .appendTo(d.StackDiv)
            .css({'display': 'inline'})
            .prop('checked', false);

      d.AspectRatio = 1.0;

        // A dialog to cancel the download before we get all the tiles
        // needed to render thie image.
      d = new SAM.Dialog(CancelDownloadCallback);
      DOWNLOAD_WIDGET.CancelDialog = d;
      d.Title.text('Processing');

      d.WaitingImage = $('<img>')
            .appendTo(d.Body)
            .attr('src', SA.ImagePathUrl + 'circular.gif')
            .attr('alt', 'waiting...')
            .css({'width': '40px'});

      d.StackMessage = $('<div>')
            .appendTo(d.Body)
            .text("Downloading multiple images.  Turn off browser's prompt-on-download option.")
            .hide();

      d.ApplyButton.text('Cancel');
    }

    function PxWidthChanged () {
      var d = DOWNLOAD_WIDGET.DimensionDialog;
      var pixelsPerInch = parseInt(d.SizeResInput.val());
      var width = parseInt(d.PxWidthInput.val());
      d.SizeWidthInput.val((width / pixelsPerInch).toFixed(2));
      var height;
      if (d.ProportionsCheckbox.prop('checked')) {
        height = width / d.AspectRatio;
        d.PxHeightInput.val(height.toFixed());
        d.SizeHeightInput.val((height / pixelsPerInch).toFixed(2));
      } else {
        height = parseInt(d.PxHeightInput.val());
        d.AspectRatio = width / height;
      }
    }

    function PxHeightChanged () {
      var d = DOWNLOAD_WIDGET.DimensionDialog;
      var pixelsPerInch = parseInt(d.SizeResInput.val());
      var height = parseInt(d.PxHeightInput.val());
      d.SizeHeightInput.val((height / pixelsPerInch).toFixed(2));
      var width;
      if (d.ProportionsCheckbox.prop('checked')) {
        width = height * d.AspectRatio;
        d.PxWidthInput.val(width.toFixed());
        d.SizeWidthInput.val((width / pixelsPerInch).toFixed(2));
      } else {
        width = parseInt(d.PxWidthInput.val());
        d.AspectRatio = width / height;
      }
    }

    function SizeWidthChanged () {
      var d = DOWNLOAD_WIDGET.DimensionDialog;
      var pixelsPerInch = parseInt(d.SizeResInput.val());
      var width = parseInt(d.SizeWidthInput.val());
      d.PxWidthInput.val((width * pixelsPerInch).toFixed());
      var height;
      if (d.ProportionsCheckbox.prop('checked')) {
        height = width / d.AspectRatio;
        d.SizeHeightInput.val(height.toFixed(2));
        d.PxHeightInput.val((height * pixelsPerInch).toFixed());
      } else {
        height = parseInt(d.SizeHeightInput.val());
        d.AspectRatio = width / height;
      }
    }

    function SizeHeightChanged () {
      var d = DOWNLOAD_WIDGET.DimensionDialog;
      var pixelsPerInch = parseInt(d.SizeResInput.val());
      var height = parseInt(d.SizeHeightInput.val());
      d.PxHeightInput.val((height * pixelsPerInch).toFixed());
      var width;
      if (d.ProportionsCheckbox.prop('checked')) {
        width = height * d.AspectRatio;
        d.SizeWidthInput.val(width.toFixed(2));
        d.PxWidthInput.val((width * pixelsPerInch).toFixed());
      } else {
        width = parseInt(d.SizeWidthInput.val());
        d.AspectRatio = width / height;
      }
    }

    function ResChanged () {
      var d = DOWNLOAD_WIDGET.DimensionDialog;
      var pixelsPerInch = parseInt(d.SizeResInput.val());
      var height = parseInt(d.SizeHeightInput.val());
      var width = parseInt(d.SizeWidthInput.val());
      d.PxHeightInput.val((height * pixelsPerInch).toFixed());
      d.PxWidthInput.val((width * pixelsPerInch).toFixed());
    }

    return DownloadImage;
  })();

// Create a selection list of sessions.
// This does not belong here.
  SA.InitSlideSelector = function (parent) {
    $('<div>')
        .appendTo(parent)
        .css({
          'background-color': 'white',
          'border-style': 'solid',
          'border-width': '1px',
          'border-radius': '5px',
          'position': 'absolute',
          'top': '35px',
          'left': '35px',
          'width': '500px',
          'height': '700px',
          'overflow': 'auto',
          'z-index': '4',
          'color': '#303030',
          'font-size': '20px' })
        .attr('id', 'sessionMenu').hide()
        .mouseleave(function () { $(this).fadeOut(); });
    $('<ul>').appendTo('#sessionMenu').attr('id', 'sessionMenuSelector');

    // Create a selector for views.
    $('<div>')
        .appendTo(parent)
        .css({
          'background-color': 'white',
          'border-style': 'solid',
          'border-width': '1px',
          'border-radius': '5px',
          'position': 'absolute',
          'top': '135px',
          'left': '135px',
          'width': '500px',
          'height': '700px',
          'overflow': 'auto',
          'z-index': '4',
          'color': '#303030',
          'font-size': '20px' })
        .attr('id', 'viewMenu').hide()
        .mouseleave(function () { $(this).fadeOut(); });
    $('<ul>').appendTo('#viewMenu').attr('id', 'viewMenuSelector'); // <select> for drop down

    SA.SlideInformation = new ImageInformationDialog(parent, SA.Edit);
  };

  function ImageInformationDialog (parent, editable) {
    var self = this;

    this.Editable = editable;

    this.Body = $('<div>')
        .appendTo(parent)
        .css({
          'background-color': 'white',
          'border-style': 'solid',
          'border-width': '1px',
          'border-radius': '5px',
          'position': 'absolute',
          'top': '30%',
          'left': '30%',
          'width': '40%',
          'height': '40%',
          'overflow': 'auto',
          'padding': '10px',
          'z-index': '4',
          'color': '#303030',
          'font-size': '20px'})
        .hide()
        .mouseleave(function () { self.Close(); });

    this.TitleInput =
        $('<div>')
        .css({'width': '100%',
          'cursor': 'text',
          'white-space': 'nowrap',
          'margin-bottom': '5px'})
        .appendTo(this.Body)
        .keypress(function (event) { return event.keyCode !== 13; });
    if (editable) {
      this.TitleInput
            .attr('contenteditable', 'true')
            .css({'background': '#f0f0ff'});
    }

    this.CopyrightDiv =
        $('<div>')
        .css({'width': '100%',
          'display': 'inline-block'})
        .appendTo(this.Body)
        .addClass('sa-view-annotation-modal-div');
    this.CopyrightLabel =
        $('<div>')
        .appendTo(this.CopyrightDiv)
        .text('Copyright:');
    this.CopyrightInput =
        $('<div>')
        .css({'width': '300px',
          'cursor': 'text'})
        .appendTo(this.CopyrightDiv)
        .keypress(function (event) { return event.keyCode !== 13; });
    if (editable) {
      this.CopyrightInput
            .attr('contenteditable', 'true')
            .css({'background': '#f0f0ff'});
    }

    this.ResolutionDiv =
        $('<div>')
        .appendTo(this.Body)
        .addClass('sa-view-annotation-modal-div');
    this.ResolutionLabel =
        $('<div>')
        .appendTo(this.ResolutionDiv)
        .text('Resolution:')
        .addClass('sa-view-annotation-modal-input-label');
    this.ResolutionInput =
        $('<div>')
        .appendTo(this.ResolutionDiv);
    this.ResolutionUnitsInput =
        $('<div>')
        .appendTo(this.ResolutionDiv);
    if (editable) {
      this.ResolutionInput
            .attr('contenteditable', 'true')
            .css({'background': '#f0f0ff',
              'cursor': 'text'})
            .keypress(function (event) { return event.keyCode !== 13; });
      this.ResolutionUnitsInput
            .attr('contenteditable', 'true')
            .css({'background': '#f0f0ff',
              'cursor': 'text'})
            .attr('contenteditable', 'true')
            .keypress(function (event) { return event.keyCode !== 13; });
    }

    // Non editable strings.
    this.FileNameDiv =
        $('<div>')
        .appendTo(this.Body)
        .addClass('sa-view-annotation-modal-div');
    this.CreatedDiv =
        $('<div>')
        .appendTo(this.Body)
        .addClass('sa-view-annotation-modal-div');
    this.DimensionsDiv =
        $('<div>')
        .appendTo(this.Body)
        .addClass('sa-view-annotation-modal-div');
    this.LevelsDiv =
        $('<div>')
        .appendTo(this.Body)
        .addClass('sa-view-annotation-modal-div');
  }

  ImageInformationDialog.prototype.Open = function (imageObj, viewer) {
    this.Viewer = viewer;

    // Save so we can modify it on close.
    this.ImageObj = imageObj;
    this.TitleInput.text(imageObj.label);
    this.FileNameDiv.text('File Name: ' + imageObj.filename);
    this.CreatedDiv.text('Created: ' + imageObj.uploaded_at);
    this.DimensionsDiv.text('Dimensions: ' +
                            imageObj.dimensions[0] + ', ' +
                            imageObj.dimensions[1]);
    this.LevelsDiv.text('Levels: ' + imageObj.levels);
    this.CopyrightInput.text(imageObj.copyright);

    var spacing;
    if (imageObj.units) {
      spacing = {value: imageObj.spacing[0],
        units: imageObj.units};
    } else {
      spacing = {value: 0.25,
        units: '\xB5m'}; // um / micro meters
    }

    SAM.ConvertForGui(spacing);
    this.ResolutionInput.text(spacing.value.toString());
    this.ResolutionUnitsInput.text(spacing.units.toString());

    this.Body.show();
  };

  ImageInformationDialog.prototype.Close = function () {
    if (this.Editable) {
      this.ImageObj.label = this.TitleInput.text();
      this.ImageObj.copyright = this.CopyrightInput.text();
      var spacing = {value: parseFloat(this.ResolutionInput.text()),
        units: this.ResolutionUnitsInput.text()};
      SAM.ConvertToMeters(spacing);
      this.ImageObj.spacing[0] = this.ImageObj.spacing[1] = spacing.value;
      this.ImageObj.units = spacing.units;
    }

    this.Body.fadeOut();

    if (!this.Editable) {
      return;
    }

    if (this.ImageObj.dimensions.length < 3) {
      this.ImageObj.dimensions.push(1);
    }

    var imageObj = {
      _id: this.ImageObj._id,
      database: this.ImageObj.database,
      label: this.ImageObj.label,
      copyright: this.ImageObj.copyright,
      spacing: this.ImageObj.spacing,
      units: this.ImageObj.units};

    // Save the image meta data.
    var self = this;
    $.ajax({
      type: 'post',
      url: 'webgl-viewer/saveimagedata',
      data: {'metadata': JSON.stringify(imageObj)},
      success: function (data, status) {
        if (self.Viewer) { self.Viewer.EventuallyRender(); }
      },
      error: function () { SA.Debug('AJAX - error() : saveimagedata'); }
    });
  };

  SA.ViewEditMenu = ViewEditMenu;
})();

// It seems I cannot control the order these files are loaded.
window.SA = window.SA || {};

// ==============================================================================
// Create and manage the menu to browse and select views.
// I am changing this to be more about selecting an image.
// I am also making this into a dialog object. (not based on the dialog class).

// It may be better to undock and redock

(function () {
  'use strict';

  function ViewBrowser (parent) {
    var self = this;
    // A view browser (short cut menu) for the text input.
    this.Div = $('<div>')
        .appendTo(parent)
        .hide().css({
          'position': 'absolute',
          'top': '5%',
          'height': '80%',
          'left': '10%',
          'width': '70%',
          'padding': '5%',
          'z-index': '1007',
          'text-align': 'left',
          'color': '#303030'})
        .mouseleave(function () { self.Div.fadeOut(); });

    this.TabbedDiv = new SA.TabbedDiv(this.Div);
    this.BrowserDiv = this.TabbedDiv.NewTabDiv('Browser');
    this.BrowserDiv.css({'overflow-y': 'auto'});
    this.SearchDiv = this.TabbedDiv.NewTabDiv('Search');
    this.ClipboardDiv = this.TabbedDiv.NewTabDiv('Clipboard');

    this.BrowserPanel = new BrowserPanel(
        this.BrowserDiv,
        function (viewObj) {
          self.SelectView(viewObj);
        });

    this.SearchPanel = new SA.SearchPanel(
        this.SearchDiv,
        function (imageObj) {
          self.SelectImage(imageObj);
        });

    this.ClipboardPanel = new SA.ClipboardPanel(
        this.ClipboardDiv,
        function (viewObj) {
          self.SelectView(viewObj);
        });

    this.Viewer = null;
  }

  ViewBrowser.prototype.SelectView = function (viewObj) {
    if (viewObj === null) {
      this.Viewer.SetCache(null);
      this.Viewer.eventuallyRender();
    }

    // This will get the camera and the annotations too.
    var record = new SA.ViewerRecord();
    record.Load(viewObj.ViewerRecords[0]);
    this.Viewer.SetViewerRecord(record);
    // this.SelectImage(viewObj.ViewerRecords[0].Image);
  };

  ViewBrowser.prototype.SelectImage = function (imgobj) {
    this.Div.fadeOut();
    var source = SA.FindCache(imgobj);

    // We have to get rid of annotation which does not apply to the new image.
    this.Viewer.Reset();
    this.Viewer.SetCache(source);

    SA.RecordState();

    this.Viewer.eventuallyRender();
  };

// Open the dialog. (ShowViewBrowser).
  ViewBrowser.prototype.Open = function (viewer) {
    this.Viewer = viewer;
    if (!viewer) { return; }

    this.Div.show();
  };

// ==============================================================================
// Open close item
  function BrowserFolder (parent, label, data, initCallback) {
    var self = this;
    this.Data = data;
    this.InitializeCallback = initCallback;
    // Bad name for this div because it contains the bullet too.
    // TODO: Change the name.
    this.TitleDiv = $('<div>')
        .css({'position': 'relative'})
        .appendTo(parent);
    this.Bullet = $('<span>')
        .appendTo(this.TitleDiv)
        .css({'position': 'absolute',
          'left': '0px',
          'top': '1px',
          'opacity': '0.75'})
        .addClass('ui-icon ui-icon-plus')
        .on('click.open',
            function () {
              self.OpenCallback();
            })
        .addClass('saButton'); // for hover highlighting

    this.Title = $('<div>')
        .appendTo(this.TitleDiv)
        .css({'margin-left': '20px'});
    this.Label = $('<div>')
        .appendTo(this.Title)
        .css({'display': 'block'})
        .text(label);
    this.List = $('<ul>')
        .appendTo(parent)
        .addClass('sa-ul')
        .hide();
  }

  BrowserFolder.prototype.OpenCallback = function () {
    var self = this;
    if (this.InitializeCallback) {
      (this.InitializeCallback)(this);
      delete this.InitializeCallback;
    }
    // Remove the binding.
    // Setup next click to close.
    this.Bullet.off('click.open')
        .removeClass('ui-icon-plus')
        .addClass('ui-icon-minus')
        .on(
            'click.close',
            function () {
              self.CloseCallback();
            });
    this.List.show();
  };

  BrowserFolder.prototype.CloseCallback = function () {
    var self = this;
    // Setup next click to open.
    this.Bullet.off('click.close')
        .removeClass('ui-icon-minus')
        .addClass('ui-icon-plus')
        .on(
            'click.open',
            function () {
              self.OpenCallback();
            });
    this.List.hide();
  };

// ==============================================================================

  function BrowserPanel (browserDiv, callback) {
    this.BrowserDiv = browserDiv;
    this.SelectView = callback;

    this.BrowserInfo = null;
    this.ReloadViewBrowserInfo();
    this.ProgressCount = 0;
  }

// I have the same functionality in the SlideAtlas object.
// I am leaving this because this only displays progress in the browser.
  BrowserPanel.prototype.PushProgress = function () {
    this.BrowserDiv.css({'cursor': 'progress'});
    this.ProgressCount += 1;
  };

  BrowserPanel.prototype.PopProgress = function () {
    this.ProgressCount -= 1;
    if (this.ProgressCount <= 0) {
      this.BrowserDiv.css({'cursor': 'default'});
    }
  };

  BrowserPanel.prototype.LoadGUI = function () {
    var self = this;
    var data = this.BrowserInfo;
    this.BrowserDiv.empty();
    var groupList = $('<ul>')
        .addClass('sa-ul')
        .appendTo(this.BrowserDiv);

    for (var i = 0; i < data.sessions.length; ++i) {
      var groupItem = $('<li>')
            .appendTo(groupList);
      var group = data.sessions[i];
      var groupFolder = new BrowserFolder(groupItem, group.rule);
        // Initialize immediately.
      var sessionList = groupFolder.List;
      for (var j = 0; j < group.sessions.length; ++j) {
        var session = group.sessions[j];
        var sessionData = {'db': session.sessdb, 'sessid': session.sessid};
        var sessionItem = $('<li>')
                .appendTo(sessionList);

        new BrowserFolder( // eslint-disable-line no-new
                sessionItem, session.label, sessionData,
                function (folder) {
                  self.RequestSessionViews(folder);
                });
      }
    }
  };

  BrowserPanel.prototype.ReloadViewBrowserInfo = function () {
    var self = this;
    // Get the sessions this user has access to.

    this.PushProgress();
    $.get('/sessions?json=true',
          function (data, status) {
            self.PopProgress();
            if (status === 'success') {
              self.BrowserInfo = data;
                  // I might want to open a session to avoid an extra click.
                  // I might want to sort the sessions to put the recent at the top.
              self.LoadGUI(data);
            } else {
              SA.Debug('ajax failed.');
            }
          });
  };

  BrowserPanel.prototype.RequestSessionViews = function (sessionFolder) {
    var self = this;
    this.PushProgress();
    var sessId = sessionFolder.Data.sessid;
    $.get('/sessions?json=true' + '&sessid=' + sessId,
          function (data, status) {
            self.PopProgress();
            if (status === 'success') {
              self.AddSessionViews(sessionFolder, data);
            } else { SA.Debug('ajax failed.'); }
          });
  };

  BrowserPanel.prototype.AddSessionViews = function (sessionFolder, sessionData) {
    var self = this;
    var viewList = sessionFolder.List;
    for (var i = 0; i < sessionData.images.length; ++i) {
      var image = sessionData.images[i];
      var viewFolder = self.AddViewFolder(viewList, image.label, image.view);
      this.RequestViewChildren(viewFolder);
    }
  };

// NOTE: It would be cleaner to wait for the view data before creating the folder.
// However, we might loose the order of the views in a session.
  BrowserPanel.prototype.AddViewFolder = function (viewList, label, viewId) {
    var self = this;
    var item = $('<li>')
        .appendTo(viewList);
    // We do not know if views have subviews until we get the viewObj.
    // Just make them all folders for now.
    var viewData = {viewid: viewId};
    var viewFolder = new BrowserFolder(item, label, viewData);
    viewFolder.Bullet.hide();
    viewFolder.Title
        .click(function () { self.ViewClickCallback(viewFolder); })
        .addClass('saButton'); // for hover highlighting

    return viewFolder;
  };

  BrowserPanel.prototype.RequestViewChildren = function (viewFolder) {
    var self = this;
    this.PushProgress();
    var viewId = viewFolder.Data.viewid;
    $.ajax({
      type: 'get',
      url: '/webgl-viewer/getview',
      data: {'viewid': viewId},
      success: function (data, status) {
        self.PopProgress();
        self.LoadViewChildren(viewFolder, data);
      },
      error: function () {
        SA.Debug('AJAX - error() : getview');
        self.PopProgress();
      }
    });
  };

  BrowserPanel.prototype.LoadViewChildren = function (viewFolder, data) {
    // Replace image with thumb?
    if (data.Type === 'HTML') {
        // Add a small slide html page.
      var div1 = $('<div>')
            .appendTo(viewFolder.Title)
            .css({'position': 'relative',
              'height': '100px',
              'width': '134px',
              'margin-bottom': '2px',
              'overflow': 'hidden',
              'border': '1px solid #AAA'});
      var div = $('<div>')
            .appendTo(div1)
            .saPresentation({aspectRatio: 1.3333});
      div.saHtml(data.Text);
      div.trigger('resize');
      div.find('.sa-element').saElement({editable: false, interactive: false});
        // hack,  This should be off by default.
      div.find('.sa-viewer').saElement({hideCopyright: true});
        // Look for an alternative label.
      if (!data.Title || data.Title === '') {
        var titleDiv = div.find('.sa-presentation-title');
        if (titleDiv.length > 0) {
          viewFolder.Label.text(titleDiv.text());
        }
      }
    } else if (data.ViewerRecords && data.ViewerRecords.length > 0) {
        // Add the image to the label.
      var image = data.ViewerRecords[0].Image;
      $('<img>')
            .appendTo(viewFolder.Title)
            .attr('src', '/thumb?db=' + image.database + '&img=' + image._id)
            .css({'height': '50px',
              'display': 'block'});
    }

    if (!data.Children || data.Children.length < 1) { return; }
    viewFolder.Bullet.show();
    for (var i = 0; i < data.Children.length; ++i) {
      var child = data.Children[i];
      var childFolder = this.AddViewFolder(viewFolder.List, child.Title,
                                             child._id);

      this.LoadViewChildren(childFolder, child);
    }
  };

  BrowserPanel.prototype.ViewClickCallback = function (viewFolder) {
    var self = this;

    // null implies the user wants an empty view. ?????????????????
    // if (obj === null) {
    //    this.SelectView(null);
    //    return;
    // }

    // TODO: Get rid of this arg.
    var viewid = viewFolder.Data.viewid;

    // "sessid": $(obj).attr('sessid'),
    // Ok, so we only have the viewId at this point.
    // We need to get the view object to get the image id.
    this.PushProgress();
    $.ajax({
      type: 'get',
      url: '/webgl-viewer/getview',
      data: {'viewid': viewid},
      success: function (data, status) {
        self.PopProgress();
        self.SelectView(data);
      },
      error: function () {
        self.PopProgress();
        SA.Debug('AJAX - error() : getview (browser)');
      }
    });
  };

  SA.BrowserPanel = BrowserPanel;
  SA.ViewBrowser = ViewBrowser;
})();

// It seems I cannot control the order these files are loaded.
window.SA = window.SA || {};

// Interface for ViewerSet
// GetNumberOfViewers();

// Does not have to abide.
// SetNumberOfViewers(n);

// GetViewer(idx);

// Create and respond to the dual / single view toggle button.
// How the window is derived between viewer1 and viewer1.
// Default: viewer1 uses all available space.

(function () {
  'use strict';

  // TODO: Get rid of these global variable.
  SA.VIEWERS = [];

  function DualViewWidget (parent) {
    var self = this;
    this.Viewers = []; // It would be nice to get rid of this.
    this.ViewerDivs = [];

    // Rather than getting the current note from the NotesWidget, keep a
    // reference here.  SlideShow can have multiple "displays".
    // We might consider keep a reference in the dua
    this.saNote = null;
    this.saNoteStartIndex = 0;

    this.Parent = parent;
    parent.addClass('sa-dual-viewer');
    // I need relative position but should not modify parent.
    this.TopDiv = $('<div>')
      .appendTo(parent)
      .css({'position': 'relative',
        'width': '100%',
        'height': '100%'});

    for (var i = 0; i < 2; ++i) {
      var viewerDiv = $('<div>')
        .appendTo(this.TopDiv)
        .css({'position': 'absolulute',
          'top': '0px'})
        .saViewer({overview: true, zoomWidget: true})
        .addClass('sa-view-canvas-div');

      this.ViewerDivs[i] = viewerDiv;
      this.Viewers[i] = viewerDiv[0].saViewer;
      // TODO: Get rid of this.
      // I believe the note should sets this, and we do not need to do it
      // here..
      this.Viewers[i].RecordIndex = i;
    }

        // TODO: Get rid of these.
    SA.VIEWERS = this.Viewers;
    SA.VIEWER1 = this.Viewers[0];
    SA.VIEWER2 = this.Viewers[1];

    this.DualView = false;
    this.Viewer1Fraction = 1.0;
    // It would be nice to integrate all animation in a flexible utility.
    this.AnimationLastTime = 0;
    this.AnimationDuration = 0;
    this.AnimationTarget = 0;

    // DualViewer is the navigation widgets temporary home.
    // SlideShow can have multiple navigation widgets so it is no
    // longer a singleton.
    // This is for moving through notes, session views and stacks.
    // It is not exactly related to dual viewer. It is sort of a child
    // of the dual viewer.
    this.NavigationWidget = new SA.NavigationWidget(this.TopDiv, this);

    if (!SAM.MOBILE_DEVICE) { // || SAM.MOBILE_DEVICE === 'iPad') {
            // Todo: Make the button become more opaque when pressed.
      $('<img>')
        .appendTo(this.ViewerDivs[0])
        .css({'position': 'absolute',
          'right': '0px',
          'top': '0px'})
        .addClass('sa-view-dualview-div')
        .attr('id', 'dualWidgetLeft')
        .attr('src', SA.ImagePathUrl + 'dualArrowLeft2.png')
        .click(function () { self.ToggleDualView(); })
        .attr('draggable', 'false')
        .on('dragstart', function () {
          return false;
        });

      $('<img>')
        .appendTo(this.TopDiv)
        .appendTo(this.ViewerDivs[1])
        .css({'position': 'absolute',
          'left': '0px',
          'top': '0px'})
        .hide()
        .addClass('sa-view-dualview-img')
        .attr('id', 'dualWidgetRight')
        .attr('src', SA.ImagePathUrl + 'dualArrowRight2.png')
        .click(function () { self.ToggleDualView(); })
        .attr('draggable', 'false')
        .on('dragstart', function () {
          return false;
        });
    } else {
      this.NavigationWidget.SetVisibility(false);
    }
  }

  DualViewWidget.prototype.EventuallyRender = function () {
    for (var i = 0; i < this.Viewers.length; ++i) {
      this.GetViewer(i).EventuallyRender(false);
    }
  };

  // Abstracting saViewer  for viewer and dualViewWidget.
  // Save viewer state in a note.
  DualViewWidget.prototype.Record = function (note, startViewIdx) {
    if (startViewIdx) {
      note.StartIndex = startViewIdx;
    }
    startViewIdx = startViewIdx || 0;
    // TODO: Deal with multiple  windows consistently.
    // Now num viewRecords indicates the number of views in the display,
    // but not for stacks.  We have this start index which implies stack behavior.
    if (note.Type !== 'Stack') {
      if (!this.DualView && note.ViewerRecords.length > 1) {
        note.ViewerRecords = [note.ViewerRecords[0]];
      }
      if (this.DualView && note.ViewerRecords.length < 2) {
        while (note.ViewerRecords.length < 2) {
          note.ViewerRecords.push(new SA.ViewerRecord());
        }
      }
    }

    for (var i = 0; i < this.GetNumberOfViewers(); ++i) {
      if (i + startViewIdx < note.ViewerRecords.length) {
        this.GetViewer(i).Record(note, i + startViewIdx);
      }
    }
  };

  // Abstracting the saViewer class to support dual viewers and stacks.
  DualViewWidget.prototype.ProcessArguments = function (args) {
    if (args.note) {
      // TODO: DO we need both?
      this.SetNote(args.note, args.viewIndex);
      // NOTE: TempId is legacy
      this.Parent.attr('sa-note-id', args.note.Id || args.note.TempId);
    }

    if (args.tileSource) {
      var w = args.tileSource.width;
      var h = args.tileSource.height;
      var cache = new SA.Cache();
      cache.TileSource = args.tileSource;
      // Use the note tmp id as an image id so the viewer can index the
      // cache.
      var note = new SA.Note();
      var image = {levels: args.maxLevel + 1,
        dimensions: [w, h],
        bounds: [0, w - 1, 0, h - 1],
        _id: note.TempId};
      var record = new SA.ViewerRecord();
      record.Image = image;
      record.OverViewBounds = [0, w - 1, 0, h - 1];
      record.Camera = {FocalPoint: [w / 2, h / 2],
        Roll: 0,
        Height: h};
      note.ViewerRecords.push(record);
      cache.SetImageData(image);
      this.SetNote(args.note, args.viewIndex);
    }

    for (var i = 0; i < this.Viewers.length; ++i) {
      var viewer = this.Viewers[i];

      if (args.hideCopyright !== undefined) {
        viewer.SetCopyrightVisibility(!args.hideCopyright);
      }
      if (args.overview !== undefined) {
        viewer.SetOverViewVisibility(args.overview);
      }
      if (args.navigation !== undefined) {
        this.NavigationWidget.SetVisibility(args.navigation);
      }
      if (args.dualWidget !== undefined) {
        this.HideHandles = !args.dualWidget;
        this.UpdateGui();
      }
      if (args.zoomWidget !== undefined) {
        viewer.SetZoomWidgetVisibility(args.zoomWidget);
      }
      if (args.drawWidget !== undefined) {
        viewer.SetAnnotationWidgetVisibility(args.drawWidget);
      }
      if (args.rotatable !== undefined) {
        viewer.SetRotatable(args.rotatable);
      }
      // The way I handle the viewer edit menu is messy.
      // TODO: Find a more elegant way to add tabs.
      // Maybe the way we handle the anntation tab shouodl be our pattern.
      if (args.menu !== undefined) {
        if (!viewer.Menu) {
          viewer.Menu = new SA.ViewEditMenu(viewer, null);
        }
        viewer.Menu.SetVisibility(args.menu);
      }

      if (args.interaction !== undefined) {
        viewer.SetInteractionEnabled(args.interaction);
        if (this.NavigationWidget) {
          this.NavigationWidget.SetInteractionEnabled(args.interaction);
        }
      }
    }
  };

  DualViewWidget.prototype.RecordAnnotations = function () {
    // Aggressively record annotations.  User still needs to hit the
    // save button.
    if (SA.Edit && this.saNote) {
      this.saNote.RecordAnnotations(this);
    }
  };

  DualViewWidget.prototype.SetNote = function (note) {
    // NOTE: Even when this.saNote === note, we still need to set the
    // camera and annotations because the user might have changed these.

    // If the note is not loaded, request the note, and call this method
    // when the note is finally loaded.
    var self = this;
    if (note && note.LoadState !== 2) {
      note.LoadViewId(
                note.Id,
                function () {
                  self.SetNote(note);
                });
      return;
    }

    this.saNote = note;
    this.saNoteStartIndex = note.StartIndex;
    var viewIdx = note.StartIndex || 0;

    if (!note || viewIdx < 0 || viewIdx >= note.ViewerRecords.length) {
      console.log('Cannot set viewer record of note');
      return;
    }
    this.saViewerIndex = viewIdx;
    if (this.NavigationWidget) {
      this.NavigationWidget.SetNote(note);
      // this.NavigationWidget.Update(); // not sure if this is necessary
    }
    this.DisplayNote(note);
    if (note.Type === 'Stack') {
      // TODO: Can I move this logic into the display? SetNote maybe?
      // Possibly nagivationWidget (we need to know which viewer is referecne.
      // Select only gets called when the stack is first loaded.
      this.GetViewer(0).OnInteraction(function () {
        self.SynchronizeViews(0, note);
      });
      this.GetViewer(1).OnInteraction(function () {
        self.SynchronizeViews(1, note);
      });
      note.DisplayStack(this);
      // First view is set by viewer record camera.
      // Second is set relative to the first.
      this.SynchronizeViews(0, note);
    }
  };

  DualViewWidget.prototype.MatrixMultiply = function (M, p) {
    var x = p[0] * M[0] + p[1] * M[1] + M[2];
    var y = p[0] * M[3] + p[1] * M[4] + M[5];
    var k = p[0] * M[6] + p[1] * M[7] + M[8];
    p[0] = x / k;
    p[1] = y / k;
  };

  DualViewWidget.prototype.InitializeSynchronousViewsWithPoints = function (p1a, p2a, p1b, p2b, p1c, p2c) {
        // Just fashoin a not for now.
    var note = new SA.Note();
    var viewerRecord1 = new SA.ViewerRecord();
    viewerRecord1.Transform = new SA.PairTransformation(); // not necessary
    var viewerRecord2 = new SA.ViewerRecord();
    viewerRecord2.Transform = new SAM.MatrixTransformation();
    viewerRecord2.Transform.InitializeWithPoints(p1a, p2a, p1b, p2b, p1c, p2c);

    var pt;
    var p1 = p1a;
    var p2 = p2a;
    pt = viewerRecord2.Transform.ForwardTransformPoint(p1);
    console.log(p2[0] + ',' + p2[1] + ':' + pt[0] + ',' + pt[1]);
    p1 = p1b;
    p2 = p2b;
    pt = viewerRecord2.Transform.ForwardTransformPoint(p1);
    console.log(p2[0] + ',' + p2[1] + ':' + pt[0] + ',' + pt[1]);
    p1 = p1c;
    p2 = p2c;
    pt = viewerRecord2.Transform.ForwardTransformPoint(p1);
    console.log(p2[0] + ',' + p2[1] + ':' + pt[0] + ',' + pt[1]);

    note.ViewerRecords = [viewerRecord1, viewerRecord2];
    note.StartIndex = 0;
    note.Type = 'Stack';

    this.saNote = note;
    this.saNoteStartIndex = note.StartIndex;
    this.saViewerIndex = 0;

    var self = this;
    this.GetViewer(0).OnInteraction(function () {
      self.SynchronizeViews(0, note);
    });
    this.GetViewer(1).OnInteraction(function () {
      self.SynchronizeViews(1, note);
    });

        // First view is set by viewer record camera.
        // Second is set relative to the first.
    this.SynchronizeViews(0, note);
  };
  DualViewWidget.prototype.InitializeSynchronousViews = function (camModel1, camModel2) {
        // Just fashoin a not for now.
    var note = new SA.Note();
    var viewerRecord1 = new SA.ViewerRecord();
    viewerRecord1.Transform = new SA.PairTransformation(); // not necessary
    var viewerRecord2 = new SA.ViewerRecord();
    viewerRecord2.Transform = new SAM.MatrixTransformation(camModel1, camModel2);

    var pt;
    pt = viewerRecord2.Transform.ForwardTransformPoint([259, 656]);
    console.log('(345,261):' + pt[0] + ',' + pt[1]);
    pt = viewerRecord2.Transform.ForwardTransformPoint([285, 8896]);
    console.log('(167,7265):' + pt[0] + ',' + pt[1]);
    pt = viewerRecord2.Transform.ForwardTransformPoint([9406, 16]);
    console.log('(7789,306):' + pt[0] + ',' + pt[1]);
    pt = viewerRecord2.Transform.ForwardTransformPoint([7977, 6215]);
    console.log('(6689,5510):' + pt[0] + ',' + pt[1]);

    note.ViewerRecords = [viewerRecord1, viewerRecord2];
    note.StartIndex = 0;
    note.Type = 'Stack';

    this.saNote = note;
    this.saNoteStartIndex = note.StartIndex;
    this.saViewerIndex = 0;

    var self = this;
    this.GetViewer(0).OnInteraction(function () {
      self.SynchronizeViews(0, note);
    });
    this.GetViewer(1).OnInteraction(function () {
      self.SynchronizeViews(1, note);
    });

    // First view is set by viewer record camera.
    // Second is set relative to the first.
    this.SynchronizeViews(0, note);
  };

  // Display Note
  // Set the state of the WebGL viewer from this notes ViewerRecords.
  // Lock camera is for when the user note updates and we only want to
  // update the annotations.
  DualViewWidget.prototype.DisplayNote = function (note, lockCamera) {
    var numViewers = this.GetNumberOfViewers();
    if (numViewers === 0) { return; }
    if (note.Type === 'Stack') {
      // Stack display needs to keep both viewers up to date.
      numViewers = 2;
    }

    // We could have more than two in the future.
    if (note.Type !== 'Stack') {
      // I want the single view (when set by the user) to persist for rthe stack.
      numViewers = note.ViewerRecords.length;
      this.SetNumberOfViewers(numViewers);
    }

    var idx = note.StartIndex;
    for (var i = 0; i < numViewers; ++i) {
      var viewer = this.GetViewer(i);

      if (i + idx < note.ViewerRecords.length) {
        viewer.SetViewerRecord(note.ViewerRecords[idx + i], lockCamera);
        // This is for synchronizing changes in the viewer back to the note.
        viewer.RecordIndex = i;
      }
    }
  };

  // User notes are load on demand and will show up after the root note.
  // When we add the user note annotations, We cannot reset the camera.
  DualViewWidget.prototype.UpdateUserNotes = function () {
    // Where do we record annotations before wiping the viewer
    // annotations out?
    var note = this.saNote;
    this.DisplayNote(note, true);
  };

  DualViewWidget.prototype.GetNote = function () {
    return this.saNote;
  };

  DualViewWidget.prototype.GetRootNote = function () {
    var note = this.saNote;
    while (note.Parent) {
      note = note.Parent;
    }
    return note;
  };

  DualViewWidget.prototype.SetNoteFromId = function (noteId) {
    var note = SA.GetNoteFromId(noteId);
    if (!note) {
      note = new SA.Note();
    }
    if (note.LoadState !== 2) {
      var self = this;
      note.LoadViewId(
                noteId,
                function () {
                  self.SetNote(note);
                });
      return note;
    }

    this.SetNote(note);
    return note;
  };

  // API for ViewerSet
  DualViewWidget.prototype.GetNumberOfViewers = function () {
    if (this.DualView) {
      return 2;
    }

    return 1;
  };

  // API for ViewerSet
  DualViewWidget.prototype.GetViewer = function (idx) {
    return this.Viewers[idx];
  };

  // Called programmatically. No animation.
  DualViewWidget.prototype.SetNumberOfViewers = function (numViews) {
    this.DualView = (numViews > 1);

    if (this.DualView) {
      this.Viewer1Fraction = 0.5;
    } else {
      this.Viewer1Fraction = 1.0;
    }

    this.UpdateSize();
    this.UpdateGui();
  };

  DualViewWidget.prototype.ToggleDualView = function () {
    this.DualView = !this.DualView;

    if (this.DualView) {
            // If there is no image in the second viewer, copy it from the first.
      if (!this.Viewers[1].GetCache()) {
        this.Viewers[1].SetCache(this.Viewers[0].GetCache());
        this.Viewers[1].GetCamera().DeepCopy(this.Viewers[0].GetCamera());
      }
      this.AnimationCurrent = 1.0;
      this.AnimationTarget = 0.5;
            // Edit menu option to copy camera zoom between views.
            // I do not call update gui here because I want
            // the buttons to appear at the end of the animation.
      $('#dualViewCopyZoom').show();
            // Animation takes care of switching the buttons
    } else {
      this.AnimationCurrent = 0.5;
      this.AnimationTarget = 1.0;
      this.UpdateGui();
    }

    SA.RecordState();

    this.AnimationLastTime = new Date().getTime();
    this.AnimationDuration = 1000.0;
    this.AnimateViewToggle();
  };

  DualViewWidget.prototype.UpdateGui = function () {
    if (this.HideHandles) {
      $('#dualWidgetLeft').hide();
      $('#dualWidgetRight').hide();
      return;
    }
        // Now swap the buttons.
    if (this.DualView) {
      $('#dualWidgetLeft').hide();
      $('#dualWidgetRight').show();
            // Edit menu option to copy camera zoom between views.
      $('#dualViewCopyZoom').show();
    } else {
      $('#dualWidgetRight').hide();
      $('#dualViewCopyZoom').hide();
      $('#dualWidgetLeft').show();
            // Edit menu option to copy camera zoom between views.
    }
  };

  DualViewWidget.prototype.AnimateViewToggle = function () {
    var timeStep = new Date().getTime() - this.AnimationLastTime;
    if (timeStep > this.AnimationDuration) {
            // end the animation.
      this.Viewer1Fraction = this.AnimationTarget;
      this.UpdateSize();
      this.UpdateGui();
      this.Draw();
      return;
    }

    var k = timeStep / this.AnimationDuration;

        // update
    this.AnimationDuration *= (1.0 - k);
    this.Viewer1Fraction += (this.AnimationTarget - this.Viewer1Fraction) * k;

    this.UpdateSize();
        // 2d canvas does not draw without this.
    this.Draw();
    var self = this;
    window.requestAnimationFrame(function () { self.AnimateViewToggle(); });
  };

  DualViewWidget.prototype.CreateThumbnailImage = function (height) {
    var canvas = document.createElement('canvas'); // create
    var ctx = canvas.getContext('2d');
    var img1 = this.Viewers[0].MainView.CaptureImage();
    var scale = height / img1.height;
    var width1 = Math.round(img1.width * scale);
    var height1 = Math.round(img1.height * scale);
    if (this.DualView) {
      var img2 = this.Viewers[2].MainView.CaptureImage();
      var width2 = Math.round(img2.width * scale);
      var height2 = Math.round(img2.height * scale);
      canvas.width = width1 + width2;
      canvas.height = Math.max(height1, height2);
      ctx.drawImage(img2, 0, 0, img2.width, img2.height,
                          width1, 0, width2, height2);
    } else {
      canvas.width = width1;
      canvas.height = height1;
    }
    ctx.drawImage(img1, 0, 0, img1.width, img1.height,
                      0, 0, width1, height1);

    var url = canvas.toDataURL('image/jpeg', 0.8);
    var thumb = document.createElement('img'); // create
    thumb.src = url;

    return thumb;
  };

  DualViewWidget.prototype.Draw = function (gl) {
    if (gl) {
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    }

    if (this.saNote && this.saNote.WaterMark) {
      SA.WaterMark = true;
    } else {
      SA.WaterMark = false;
    }

        // This just changes the camera based on the current time.
    if (this.Viewers[0]) {
      this.Viewers[0].Animate();
      if (this.DualView) { this.Viewers[1].Animate(); }
      this.Viewers[0].Draw();
    }
    if (this.Viewers[1] && this.DualView) { this.Viewers[1].Draw(); }
  };

  DualViewWidget.prototype.UpdateSize = function () {
    var percent = this.Viewer1Fraction * 100;
    if (this.ViewerDivs[0]) {
      this.ViewerDivs[0].css({'left': '0%',
        'width': percent + '%',
        'height': '100%'});
      this.Viewers[0].UpdateSize();
    }
    if (this.ViewerDivs[1]) {
      this.ViewerDivs[1].css({'left': percent + '%',
        'width': (100 - percent) + '%',
        'height': '100%'});
      this.Viewers[1].UpdateSize();
    }

    if (percent >= 90) {
      this.Viewers[1].Hide();
    } else {
      this.Viewers[1].Show();
    }

    // This looks problematic.
    // TODO: Try to get rid of it.
    // $(window).trigger('resize');
  };

  DualViewWidget.prototype.AnnotationWidgetOn = function () {
    for (var i = 0; i < this.Viewers.length; ++i) {
      this.Viewers.AnnotationWidgetOn();
    }
  };

  DualViewWidget.prototype.AnnotationWidgetOff = function () {
    for (var i = 0; i < this.Viewers.length; ++i) {
      this.Viewers.AnnotationWidgetOff();
    }
  };

  // refViewerIdx is the viewer that changed and other viewers need
  // to be updated to match that reference viewer.
  DualViewWidget.prototype.SynchronizeViews = function (refViewerIdx, note) {
    // We allow the viewer to go one past the end.
    if (refViewerIdx + note.StartIndex >= note.ViewerRecords.length) {
      return;
    }

    // Special case for when the shift key is pressed.
    // Translate only one camera and modify the tranform to match.
    if (SA.Edit && SA.StackCursorFlag) {
      var trans = note.ViewerRecords[note.StartIndex + 1].Transform;
      if (!note.ActiveCorrelation && trans.Correlations) {
        if (!trans) {
          alert('Missing transform');
          return;
        }
                // Remove all correlations visible in the window.
        var cam = this.GetViewer(0).GetCamera();
        var bds = cam.GetBounds();
        var idx = 0;
        while (idx < trans.Correlations.length) {
          var cor = trans.Correlations[idx];
          if (cor.point0[0] > bds[0] && cor.point0[0] < bds[1] &&
                        cor.point0[1] > bds[2] && cor.point0[1] < bds[3]) {
            trans.Correlations.splice(idx, 1);
          } else {
            ++idx;
          }
        }

        // Now make a new replacement correlation.
        note.ActiveCorrelation = new SA.PairCorrelation();
        trans.Correlations.push(note.ActiveCorrelation);
      }
      var cam0 = this.GetViewer(0).GetCamera();
      var cam1 = this.GetViewer(1).GetCamera();
      note.ActiveCorrelation.SetPoint0(cam0.GetWorldFocalPoint());
      note.ActiveCorrelation.SetPoint1(cam1.GetWorldFocalPoint());
      // I really do not want to set the roll unless the user specifically changed it.
      // It would be hard to correct if the wrong value got set early in the aligment.
      var deltaRoll = cam1.GetWorldRoll() - cam0.GetWorldRoll();
      if (trans.Correlations && trans.Correlations.length > 1) {
        deltaRoll = 0;
        // Let roll be set by multiple correlation points.
      }
      note.ActiveCorrelation.SetWorldRoll(deltaRoll);
      note.ActiveCorrelation.SetHeight(0.5 * (cam1.Height + cam0.Height));
      return;
    } else {
      // A round about way to set and unset the active correlation.
      // Note is OK, because if there is no interaction without the shift key
      // the active correlation will not change anyway.
      note.ActiveCorrelation = undefined;
    }

    // No shift modifier:
    // Synchronize all the cameras.
    // Hard coded for two viewers (recored 0 and 1 too).
    // First place all the cameras into an array for code simplicity.
    // Cameras used for preloading.
    if (!note.PreCamera) { note.PreCamera = new SAM.Camera(); }
    if (!note.PostCamera) { note.PostCamera = new SAM.Camera(); }
    var cameras = [note.PreCamera,
      this.GetViewer(0).GetCamera(),
      this.GetViewer(1).GetCamera(),
      note.PostCamera];
    var refCamIdx = refViewerIdx + 1; // An extra to account for PreCamera.
    // Start with the reference section and move forward.
    // With two sections, the second has the transform.

    var i;
    var transIdx;
    for (i = refCamIdx + 1; i < cameras.length; ++i) {
      transIdx = i - 1 + note.StartIndex;
      if (transIdx < note.ViewerRecords.length) {
        note.ViewerRecords[transIdx].Transform
                    .ForwardTransformCamera(cameras[i - 1], cameras[i]);
      } else {
        cameras[i] = undefined;
      }
    }

    // Start with the reference section and move backward.
    // With two sections, the second has the transform.
    for (i = refCamIdx; i > 0; --i) {
      transIdx = i + note.StartIndex - 1;
      if (transIdx > 0) { // First section does not have a transform
        note.ViewerRecords[transIdx].Transform
                    .ReverseTransformCamera(cameras[i], cameras[i - 1]);
      } else {
        cameras[i - 1] = undefined;
      }
    }

    // Preload the adjacent sections.
    var cache;
    var tiles;
    if (cameras[0]) {
      cache = SA.FindCache(note.ViewerRecords[note.StartIndex - 1].Image);
      cameras[0].SetViewport(this.GetViewer(0).GetViewport());
      tiles = cache.ChooseTiles(cameras[0], 0, []);
      for (i = 0; i < tiles.length; ++i) {
        tiles[i].LoadQueueAdd();
      }
      SA.LoadQueueUpdate();
    }
    if (cameras[3]) {
      cache = SA.FindCache(note.ViewerRecords[note.StartIndex + 2].Image);
      cameras[3].SetViewport(this.GetViewer(0).GetViewport());
      tiles = cache.ChooseTiles(cameras[3], 0, []);
      for (i = 0; i < tiles.length; ++i) {
        tiles[i].LoadQueueAdd();
      }
      SA.LoadQueueUpdate();
    }

    // OverView cameras need to be updated.
    if (refViewerIdx === 0) {
      this.GetViewer(1).UpdateCamera();
      this.GetViewer(1).EventuallyRender(false);
    } else {
      this.GetViewer(0).UpdateCamera();
      this.GetViewer(0).EventuallyRender(false);
    }

    // Synchronize annotation visibility.
    var refViewer = this.GetViewer(refViewerIdx);
    for (i = 0; i < 2; ++i) {
      if (i !== refViewerIdx) {
        var viewer = this.GetViewer(i);
        if (viewer.AnnotationWidget && refViewer.AnnotationWidget) {
          viewer.AnnotationWidget.SetVisibility(
                        refViewer.AnnotationWidget.GetVisibility());
        }
      }
    }
  };

  // Called from the console for renal stack.
  // For every polyline in the left viewer, try to find a corresponding
  // polyline in the right viewer. If found, change its color to match.
  DualViewWidget.prototype.MatchPolylines = function (color, tolerance) {
    tolerance = tolerance || 0.5;
    var widgets0 = this.Viewers[0].GetAnnotationLayer().GetWidgets();
    var widgets1 = this.Viewers[1].GetAnnotationLayer().GetWidgets();
    var note = this.saNote;

    var trans = note.ViewerRecords[note.StartIndex + 1].Transform;

    for (var i = 0; i < widgets0.length; ++i) {
      var w0 = widgets0[i];
      if (w0.Polyline) {
        var polyline0 = w0.Polyline;
        var r = Math.floor(polyline0.OutlineColor[0] * 255);
        var g = Math.floor(polyline0.OutlineColor[1] * 255);
        var b = Math.floor(polyline0.OutlineColor[2] * 255);
        if (r !== color[0] || g !== color[1] || b !== color[2]) {
          continue;
        }
        console.log('Matched color ' + i);

                // get the center and area.
        var center0 = [(polyline0.Bounds[0] + polyline0.Bounds[1]) * 0.5,
          (polyline0.Bounds[2] + polyline0.Bounds[3]) * 0.5];
        var size = Math.abs(polyline0.Bounds[1] - polyline0.Bounds[0]) +
                   Math.abs(polyline0.Bounds[3] - polyline0.Bounds[2]);

        var area0 = polyline0.ComputeArea();
        var bestMatch;
        var bestPolyline;
        var bestIdx = -1;
        for (var j = 0; j < widgets1.length; ++j) {
          var w1 = widgets1[j];
          if (w1.Polyline) {
            var polyline1 = w1.Polyline;
            // get the center and area.
            var center0b = trans.ForwardTransform(center0, size); // sigma);

            var center1 = [(polyline1.Bounds[0] + polyline1.Bounds[1]) * 0.5,
              (polyline1.Bounds[2] + polyline1.Bounds[3]) * 0.5];
            var area1 = polyline1.ComputeArea();
            var dx = center1[0] - center0b[0];
            var dy = center1[1] - center0b[1];
            var match = (dx * dx + dy * dy + Math.abs(area1 - area0)) / area0;
            if (bestIdx === -1 || match < bestMatch) {
              bestMatch = match;
              bestPolyline = w1;
              bestIdx = j;
            }
          }
        }

        if (bestIdx === -1) {
          // Should not happen
          console.log('+++ No candidates: Widget' + i);
        } else if (bestMatch < tolerance) {
          bestPolyline.Polyline.OutlineColor =
                        w0.Polyline.OutlineColor.slice(0);
          console.log('+++ Match: Widget ' + i + ' = ' + bestIdx + ', (' + bestMatch + ')');
        } else {
          console.log('--- No match: Widget ' + i + ', Closest ' + bestIdx + ', (' + bestMatch + ')');
        }
      }
    }

    this.EventuallyRender();
  };

  // For debugging called from console.
  // Resets the colors of the poly lines lin viewer 2 so we can see what
  // has changed when we run MatchPolylines
  // color is an array [1,1,1]
  DualViewWidget.prototype.SetPolylineColor = function (color) {
    var widgets1 = this.Viewers[1].GetAnnotationLayer().GetWidgets();

    for (var i = 0; i < widgets1.length; ++i) {
      var w1 = widgets1[i];
      if (w1.Polyline) {
        w1.Polyline.OutlineColor = color.slice(0);
      }
    }

    this.EventuallyRender();
  };

  SA.DualViewWidget = DualViewWidget;
})();

// ==============================================================================
// Is it time to switch to lowercase?  No.  I still like lower case for
// local variables. Upper case for instance variables

(function () {
  'use strict';

  function TabbedDiv (parent) {
    // Default css can be changed by the caller.
    this.Div = $('<div>')
        .appendTo(parent)
        .css({'position': 'relative',
          'width': '100%',
          'height': '100%'});
    // div for the tab buttons.
    this.TabDiv = $('<div>')
        .appendTo(this.Div)
        .css({'position': 'absolute',
          'width': '100%',
          'height': '30px'});
    // div for the tab bodies.
    this.BodyDiv = $('<div>')
        .appendTo(this.Div)
        .css({'position': 'absolute',
          'width': '100%',
          'top': '30px',
          'bottom': '0px'});

    this.TabPanels = [];
    this.CurrentTabPanel = null;
  }

// I want to hide the TabPanel object, so I return the div.
  TabbedDiv.prototype.NewTabDiv = function (label, helpString) {
    var tabPanel = new TabPanel(this, label);
    if (helpString) {
      tabPanel.Tab.prop('title', helpString);
    }
    this.TabPanels.push(tabPanel);
    // First panel added should be open by default.
    if (this.TabPanels.length === 1) {
      this.OpenTabPanel(tabPanel);
    }

    return tabPanel.Div;
  };

// Private
  TabbedDiv.prototype.OpenTabPanel = function (tabPanel) {
    if (!tabPanel) { return; }
    // close to previous tab
    // NOTE: If we only close the previous panel, tab buttons wrap to the next line
    for (var i = 0; i < this.TabPanels.length; ++i) {
      var panel = this.TabPanels[i];
      panel.Div.hide();
        // The z-index does not seem to be working.
        // When the panel is zoomed, Tab looks like it is on top.
      panel.Tab.css({'color': '#AAA',
        'z-index': '4',
        'border-color': '#BBB'});
    }
    // open the new tab.
    tabPanel.Div.show();
    tabPanel.Tab.css({'color': '#000',
      'z-index': '6',
      'border-color': '#BBB #BBB #FFF #BBB'});
    this.CurrentTabPanel = tabPanel;
    // The FillDiv callback does not work when the editor is hidden.
    // Trigger onResize after the text tab is made visible.
    $(window).trigger('resize');
  };

  TabbedDiv.prototype.GetCurrentDiv = function () {
    if (!this.CurrentTabPanel) {
      return undefined;
    }
    return this.CurrentTabPanel.Div;
  };

// Internal helper method
  TabbedDiv.prototype.GetTabPanelFromDiv = function (tabDiv) {
    for (var i = 0; i < this.TabPanels.length; ++i) {
      var tabPanel = this.TabPanels[i];
      if (tabPanel.Div === tabDiv) {
        return tabPanel;
      }
    }
    return null;
  };

// Internal helper method
  TabbedDiv.prototype.GetTabPanelFromIndex = function (index) {
    if (index < 0 || index >= this.TabPanels.length) {
      console.log('GetTabPanelFromIndex(' + index + '): error');
      return null;
    }
    return this.TabPanels[index];
  };

  TabbedDiv.prototype.ShowTabDiv = function (tabDiv) {
    this.OpenTabPanel(this.GetTabPanelFromDiv(tabDiv));
  };

  TabbedDiv.prototype.ShowTabIndex = function (index) {
    this.OpenTabPanel(this.GetTabPanelFromIndex(index));
  };

  TabbedDiv.prototype.EnableTabDiv = function (tabDiv) {
    var panel = this.GetTabPanelFromDiv(tabDiv);
    panel.Enabled = true;
    panel.Tab.show();
  };

  TabbedDiv.prototype.DisableTabDiv = function (tabDiv) {
    var panel = this.GetTabPanelFromDiv(tabDiv);
    if (!panel) { return; }

    panel.Enabled = false;
    if (panel === this.CurrentTabPanel) {
      this.CurrentTabPanel = null;
        // Find another panel to display.
      for (var i = 0; i < this.TabPanels.length; ++i) {
        if (this.TabPanels[i].Enabled) {
          this.OpenTabPanel(this.TabPanel[i]);
          break;
        }
      }
    }

    panel.Tab.css({'color': '#AAA',
      'z-index': '4',
      'border-color': '#BBB'});
    panel.Div.hide();
    panel.Tab.hide();
  };

// ==============================================================================

  function TabPanel (tabbedDiv, title) {
    var self = this;
    this.Enabled = true;
    this.Tab = $('<div>')
        .appendTo(tabbedDiv.TabDiv)
        .text(title)
        .css({'color': '#AAA',
          'border-color': '#BBB',
          'position': 'relative',
          'bottom': '-2px',
          'padding': '2px 7px 2px 7px',
          'margin': '5px 0px 0px 5px',
          'display': 'inline-block',
          'border-width': '1px',
          'border-style': 'solid',
          'border-radius': '5px 5px 0px 0px',
          'z-index': '6',
          'background': 'white'})
        .click(function () {
          tabbedDiv.OpenTabPanel(self);
        });
    this.Div = $('<div>')
        .hide()
        .appendTo(tabbedDiv.BodyDiv)
        .css({'position': 'absolute',
          'top': '0px',
          'bottom': '3px',
          'left': '3px',
          'right': '3px',
          'border-width': '1px',
          'border-style': 'solid',
          'border-color': '#BBB',
          'z-index': '5',
          'background': 'white'});
  }

// ==============================================================================

  SA.TabbedDiv = TabbedDiv;
  SA.TabPanel = TabPanel;
})();

// ------------------------------------------------------------------------------
// Note object (maybe will be used for views and sessions too).

// TODO: Remove GUI from this file.

(function () {
  'use strict';

  // Note load states.
  var INVALID = 0; // just an id
  var REQUESTED = 1;    // Load request and waiting for the callback
  var SYNCHRONIZED = 2; // Same as database

  // Globals
  // The client creates the real and permanent id, so this works even if
  // the note has not been added to the database.
  SA.GetNoteFromId = function (id) {
    for (var i = 0; i < SA.Notes.length; ++i) {
      var note = SA.Notes[i];
      if (note.Id && note.Id === id) {
        return note;
      }
    }
    return null;
  };
  SA.GetUserNoteFromImageId = function (id) {
    for (var i = 0; i < SA.Notes.length; ++i) {
      var note = SA.Notes[i];
      if (note.Type === 'UserNote' && note.Parent === id) {
        return note;
      }
    }
    return null;
  };
    // When a note fails to load, we need to remove it from the global list
    // of notes. We also delete recorder notes.  Once saved, we never user
    // them again.
  SA.DeleteNote = function (note) {
    var idx = SA.Notes.indexOf(note);
    if (idx !== -1) {
      SA.Notes.splice(idx, 1);
    }
  };

  function Note () {
    if (!SA.Notes) {
            // data is the object retrieved from mongo (with string ids)
            // Right now we expect bookmarks, but it will be generalized later.
      SA.Notes = [];
    }

        // A global list of notes so we can find a note by its id.
        // TODO: Legacy.  Get rid of TempId.
    this.Id = this.TempId = new ObjectId().toString();
    SA.Notes.push(this);

    var self = this;
        // 0: just an id
        // 1: requested
        // 2: received
    this.LoadState = INVALID;

    this.User = SA.GetUser(); // Reset by flask.
    var d = new Date();
    this.Date = d.getTime(); // Also reset later.
    this.Type = 'Note';
    this.Mode = '';

    this.Title = '';
    this.Text = '';
    this.Modified = false;

        // Upto two for dual view.
    this.ViewerRecords = [];

        // ParentNote (it would be nice to make the session a note too).
    this.Parent = null;

        // Sub notes
    this.Children = [];
    this.ChildrenVisibility = true;

        // GUI elements.
    this.Div = $('<li>')
            .attr({'class': 'note'});

    this.TitleDiv = $('<div>')
            .css({'position': 'relative'})
            .appendTo(this.Div);

    this.SortHandle = $('<span>')
            .appendTo(this.TitleDiv)
            .css({'position': 'absolute',
              'left': '0px',
              'top': '0px',
              'opacity': '0.5'})
            .addClass('ui-icon ui-icon-bullet');

    this.ButtonsDiv = $('<div>')
            .appendTo(this.TitleDiv)
            .css({'float': 'right'})
            .hide();
    this.TitleEntry = $('<div>')
            .css({'margin-left': '20px'})
            .appendTo(this.TitleDiv)
            .text(this.Title)
            .addClass('sa-title');
    if (this.Mode === 'answer-hide' || this.Mode === 'answer-interactive') {
      this.TitleEntry.text('-');
    }

    if (SA.Edit) {
      this.AddButton = $('<img>')
                .appendTo(this.ButtonsDiv)
                .attr('src', SA.ImagePathUrl + 'page_add.png')
                .addClass('editButton')
                .prop('title', 'add view')
                .css({
                  'width': '12px',
                  'height': '12px',
                  'opacity': '0.5'});
      this.LinkButton = $('<img>')
                .appendTo(this.ButtonsDiv)
                .attr('src', SA.ImagePathUrl + 'link.png')
                .prop('title', 'show url')
                .addClass('editButton')
                .css({
                  'width': '12px',
                  'height': '12px',
                  'opacity': '1.0'});
      this.RemoveButton = $('<img>')
                .appendTo(this.ButtonsDiv)
                .hide()
                .attr('src', SA.ImagePathUrl + 'remove.png')
                .prop('title', 'delete')
                .addClass('editButton')
                .css({
                  'width': '12px',
                  'height': '12px',
                  'opacity': '0.5'});
    }

    if (SA.HideAnnotations || this.Mode === 'answer-hide' ||
            this.Mode === 'answer-interactive') {
      this.TitleEntry.text('-');
    }

    if (SA.Edit) {
      this.Modified = false;
      if (this.Mode === 'answer-hide' && this.Mode !== 'answer-interactive') {
        this.TitleEntry
                    .attr('contenteditable', 'true');
      }
    }

        // The div should attached even if nothing is in it.
        // A child may appear and UpdateChildrenGui called.
        // If we could tell is was removed, UpdateChildGUI could append it.
    this.ChildrenDiv = $('<ul>')
            .addClass('sa-ul')
            .appendTo(this.Div);

    if (SA.Edit) {
      this.ChildrenDiv
                .sortable({update: function (event, ui) { self.SortCallback(); },
                  handle: '.ui-icon'});
    } else {
      this.ChildrenDiv
                .disableSelection();
    }

        // This is for stack notes (which could be a subclass).
        // It looks like the stack will start on this index when it first
        // is loaded.  This changes when navigating the stack.
    this.StartIndex = 0;
    this.ActiveCorrelation = undefined;
    this.StackDivs = [];
  }

    // For copy slide in presentations
  Note.prototype.DeepCopy = function (note) {
        // I tried serialize / load, but the image changed to a string id.
    this.Image = Note.Image; // not really deep.
    this.Children = [];
    for (var i = 0; i < note.Children.length; ++i) {
      var child = new SA.Note();
      child.DeepCopy(note.Children[i]);
      this.Children.push(child);
    }
    this.Parent = note.Parent;
    this.StartIndex = note.StartIndex;
        // Replace old note id with new in HTML.
    var oldId = note.Id;
    var newId = this.Id;
    this.Text = note.Text.replace(oldId, newId);
    this.Title = note.Title;
    this.Type = note.Type;
    this.User = note.User;
        // this.UserText = note.UserText;
    this.ViewerRecords = [];
    for (i = 0; i < note.ViewerRecords.length; ++i) {
      var record = new SA.ViewerRecord();
      record.DeepCopy(note.ViewerRecords[i]);
      this.ViewerRecords.push(record);
    }
  };

    // So this is a real pain.  I need to get the order of the notes from
    // the childrenDiv jquery element.
  Note.prototype.SortCallback = function () {
    var newChildren = [];
    var children = this.ChildrenDiv.children();
    for (var newIndex = 0; newIndex < children.length; ++newIndex) {
      var oldIndex = $(children[newIndex]).data('index');
      var note = this.Children[oldIndex];
      note.Div.data('index', newIndex);
      newChildren.push(note);
    }

    this.Children = newChildren;
    this.UpdateChildrenGUI();
    if (SA.notesWidget) {
      SA.notesWidget.MarkAsModified();
    }
  };

  // When the note is deleted, this clear associated text links.
  // However, it does not remove the span id.
  Note.prototype.ClearHyperlink = function () {
    if (this.Id) {
      // I think is will be best to seelct the element and then replace
      // it with text.
      this.SelectHyperlink();
      var sel = window.getSelection();
      document.execCommand('insertText', sel.toString());
    }
  };

  // Pragmatically select the hyper link (when the note is selected).
  Note.prototype.SelectHyperlink = function () {
    if (this.Id) {
      var el = document.getElementById(this.Id);
      if (el) {
        var range = document.createRange();
                // range.selectNodeContents(el);
        range.selectNode(el);
        var sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
      }
    }
  };

  // Pragmatically select the hyper link (when the note is selected).
  Note.prototype.UnselectHyperlink = function () {
    if (this.Id) {
      var el = document.getElementById(this.Id);
      if (el) {
        var range = document.createRange();
        range.collapse(true);
        var sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
      }
    }
  };

  Note.prototype.SetParent = function (parent) {
    this.Parent = parent;
    if (parent && SA.Edit) {
      this.RemoveButton.show();
    }
  };

  Note.prototype.TitleFocusInCallback = function () {
        // Keep the viewer from processing arrow keys.
    SA.ContentEditableHasFocus = true;
    SA.SetNote(this);
  };

  Note.prototype.TitleFocusOutCallback = function () {
    if (this.Modified) {
            // Move the Title from the GUI to the note.
      this.Modified = false;
      if (this.Mode !== 'answer-hide' && this.Mode !== 'answer-interactive') {
        this.Title = this.TitleEntry.text();
      }
      if (SA.notesWidget) {
        SA.notesWidget.MarkAsModified();
      }
    }
        // Allow the viewer to process arrow keys.
    SA.ContentEditableHasFocus = false;
    if (!this.Modified) { return; }
    this.Modified = false;
    if (this.Mode !== 'answer-hide' && this.Mode !== 'answer-interactive') {
      var text = this.TitleEntry.text();
      if (this.Title !== text && !SA.HideAnnotations) {
        this.Title = text;
        this.Save();
      }
    }
  };

  Note.prototype.LinkCallback = function () {
    if (!SA.LinkDiv) { return; }
    var text = 'slide-atlas.org/webgl-viewer?view=' + this.Id;
    SA.LinkDiv.html(text);
    SA.LinkDiv.show();
        // Select the text so it is easy to copy.
    var range = document.createRange();
    range.selectNodeContents(SA.LinkDiv[0]);
    var sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);

        // Try to copy to the clipboard.
    document.execCommand('copy', false, null);
  };

  Note.prototype.DeleteCallback = function () {
    if (this.Type === 'UserNote') {
            // User notes have a parent, but are also roots.
      return;
    }
    var parent = this.Parent;
    if (parent === null) {
      return;
    }

    this.ClearHyperlink();

    if (this.Type !== 'view') {
      if (SA.display && SA.display.NavigationWidget &&
                SA.display.NavigationWidget.GetNote() === this) {
                // Move the current note off this note.
                // There is always a previous.
        SA.display.NavigationWidget.PreviousNote();
      }
    }

        // Get rid of the note.
    var index = parent.Children.indexOf(this);
    parent.Children.splice(index, 1);
    this.Parent = null;

        // Redraw the GUI.
    parent.UpdateChildrenGUI();
    if (SA.notesWidget) {
      SA.notesWidget.MarkAsModified();
    }
  };

    // User notes are associated with images. They should be referenced by
    // the viewer record.  THis method is only used by presentations.
    // TODO: Fix this.
  Note.prototype.SetUserNote = function (userNote) {
    var parentNote = this;
    parentNote.UserNote = userNote;
    userNote.Parent = parentNote;
    userNote.Type = 'UserNote';
  };

  Note.prototype.UserCanEdit = function () {
    return SA.Edit;
  };

  Note.prototype.RecordView = function (display) {
        // TODO: Get rid of VIEWER globals.
    if (display.GetNumberOfViewers() === 0) { return; }

    if (this.Type === 'Stack') {
            // All we want to do is record the default
            // camera of the first section (if we at
            // the start of the stack).
      var viewer0 = display.GetViewer(0);
      if (this.StartIndex === 0) {
        this.ViewerRecords[0].CopyViewer(viewer0);
      }
      return;
    }
    this.ViewerRecords = [];
    for (var i = 0; i < display.GetNumberOfViewers(); ++i) {
      var viewerRecord = new SA.ViewerRecord();
      viewerRecord.CopyViewer(display.GetViewer(i));
      this.ViewerRecords.push(viewerRecord);
    }
  };

  Note.prototype.AddChild = function (childNote, first) {
        // Needed to get the order after a sort.
    childNote.Div.data('index', this.Children.length);

    if (first) {
      this.Children.splice(0, 0, childNote);
    } else {
      this.Children.push(childNote);
    }

    this.UpdateChildrenGUI();
  };

  // TODO: Get the GUI stuff out of note objects.
  Note.prototype.UpdateChildrenGUI = function () {
    // Callback trick
    var i;

    // Clear
    this.ChildrenDiv.empty();

    // Stacks
    if (this.Type === 'Stack') {
      // I want viewer records to look like children for stacks.
      this.StackDivs = [];
      for (i = 0; i < this.ViewerRecords.length; ++i) {
        var sectionDiv = $('<div>')
                    .addClass('note')
                    .appendTo(this.ChildrenDiv);
        if (SA.HideAnnotations) {
          sectionDiv.text(i.toString());
        } else {
          sectionDiv.text(this.ViewerRecords[i].Image.label);
        }
        this.StackDivs.push(sectionDiv);
        if (i === this.StartIndex) {
          sectionDiv.css({'background-color': '#BBB'});
        }
      }
      return;
    }

    // Notes
    if (this.Children.length === 0) {
      return;
    }

    // Move all the views to the end.  They do not take part in the notes
    // gui. They are for text links.  They may mess up drag ordering.
    var newChildren = [];
    for (i = 0; i < this.Children.length; ++i) {
      if (this.Children[i].Type === 'Note') {
        newChildren.push(this.Children[i]);
      }
    }
    for (i = 0; i < this.Children.length; ++i) {
      if (this.Children[i].Type !== 'Note') {
        newChildren.push(this.Children[i]);
      }
    }
    this.Children = newChildren;

    for (i = 0; i < this.Children.length; ++i) {
      if (this.Children[i].Type === 'Note') {
        this.Children[i].DisplayGUI(this.ChildrenDiv);
        // Indexes used for sorting.
        this.Children[i].Div.data('index', i);
        if (this.Children.length > 1) {
          this.Children[i].SortHandle.addClass('sa-sort-handle');
        } else {
          this.Children[i].SortHandle.removeClass('sa-sort-handle');
        }
      }
    }
  };

  Note.prototype.NewIterator = function () {
    return new SA.NoteIterator(this);
  };

  Note.prototype.Contains = function (decendent) {
    for (var i = 0; i < this.Children.length; ++i) {
      var child = this.Children[i];
      if (child === decendent) {
        return true;
      }
      if (child.Contains(decendent)) {
        return true;
      }
    }
    return false;
  };

    // Create a new note,  add it to the parent notes children at index "childIdx".
    // The new note is not automatically selected.
  Note.prototype.NewChild = function (childIdx, title) {
        // Create a new note.
    var childNote = new SA.Note();
    childNote.Title = title;
    var d = new Date();
    childNote.Date = d.getTime(); // Temporary. Set for real by server.

        // Now insert the child after the current note.
    this.Children.splice(childIdx, 0, childNote);
    childNote.SetParent(this);

    return childNote;
  };

    // Save the note in the database and set the note's id if it is new.
    // callback function can be set to execute an action with the new id.
  Note.prototype.Save = function (callback, excludeChildren) {
    console.log('Save note ' + this.Id + ' ' + this.Title);

    var self = this;
        // Save this users notes in the user specific collection.
    var noteObj = JSON.stringify(this.Serialize(excludeChildren));
    var d = new Date();
    SA.PushProgress();
    $.ajax({
      type: 'post',
      url: '/webgl-viewer/saveviewnotes',
      data: {'note': noteObj,
        'date': d.getTime()},
      success: function (data, status) {
        SA.PopProgress();
        if (callback) {
          (callback)(self);
        }
        self.LoadState = SYNCHRONIZED;
      },
      error: function () {
        SA.PopProgress();
        SA.Debug('AJAX - error() : saveviewnotes');
      }
    });
  };

  Note.prototype.HasAnnotations = function () {
    for (var i = 0; i < this.ViewerRecords.length; ++i) {
      if (this.ViewerRecords.Annotations.length > 0) {
        return true;
      }
    }
    return false;
  };

    // TODO: Method only used by presentations.  Move this to viewer
    // record.
    // This takes the state of the GUI and updates the notes to match
  Note.prototype.RecordAnnotations = function (display) {
        // This is ok, because user notes do not have user notes of their own.
    if (this.UserNote) {
            // UserNote annotations are kept separate from other annotations.
      this.UserNote.RecordAnnotations(display);
            // Save it to the database aggresively.
            // If the note has annotations, they might be new.
            // If it was loaded, the annotations might have been deleted.
      if (this.UserNote.HasAnnotations() ||
                this.UserNote.LoadState !== INVALID) {
        this.UserNote.Save();
      }
    }

        // A bit confusing.  This executes for both normal notes and user
        // notes. Each saves a different subset of the annotations.
    for (var i = 0; i < display.GetNumberOfViewers(); ++i) {
      if (this.ViewerRecords.length > this.StartIndex + i) {
        var viewerRecord = this.ViewerRecords[this.StartIndex + i];
        viewerRecord.CopyAnnotations(
                    display.GetViewer(i), (this.Type === 'UserNote'));
      }
    }
  };

    // No clearing.  Just draw this notes GUI in a div.
  Note.prototype.DisplayGUI = function (div) {
    var self = this;
    this.Div.appendTo(div);

    if (this.Mode !== 'answer-hide' && this.Mode !== 'answer-interactive') {
      this.TitleEntry
                .click(function () {
                  SA.SetNote(self);
                  self.ButtonsDiv.show();
                })
                .bind('input', function () {
                  self.Modified = true;
                })
                .focusin(function () { self.TitleFocusInCallback(); })
                .focusout(function () { self.TitleFocusOutCallback(); })
                .mouseleave(function () {
                  if (self.Modified) {
                    self.Modified = false;
                    self.Title = self.TitleEntry.text();
                    if (SA.notesWidget) { SA.notesWidget.MarkAsModified(); }
                  }
                });
      this.TitleDiv
                .hover(
                    function () {
                      self.TitleEntry.css({'color': '#33D'});
                      if (SA.notesWidget && SA.notesWidget.SelectedNote === self) {
                        self.ButtonsDiv.show();
                      }
                    },
                    function () {
                      self.TitleEntry.css({'color': '#3AF'});
                      self.ButtonsDiv.hide();
                    });
      this.TitleEntry.text(this.Title);
    } else {
      this.TitleEntry.text('-');
    }

        // Changing a div "parent/appendTo" removes all event bindings like click.
        // I would like to find a better solution to redraw.
    if (SA.Edit) {
            // Removing and adding removes the callbacks.
      this.AddButton
                .click(function () {
                  if (SA.notesWidget) { SA.notesWidget.NewCallback(); }
                });
      this.LinkButton
                .click(function () {
                  self.LinkCallback();
                });
      this.RemoveButton
                .click(function () {
                  self.DeleteCallback();
                });
    }

    this.UpdateChildrenGUI();
  };

  Note.prototype.Serialize = function (excludeChildren) {
    var obj = {};
    obj.SessionId = localStorage.sessionId;
    obj.Type = this.Type;
    obj.Mode = this.Mode;
    obj.User = this.User;
    obj.Date = this.Date;
    if (this.WaterMark) {
      obj.WaterMark = this.WaterMark;
    }

    // user data to customize note types
    // I needed this for background color and apsect ratio of presentations.
    if (this.TypeData) {
      obj.TypeData = this.TypeData;
    }

    if (this.NotesPanelOpen) {
      obj.NotesPanelOpen = true;
    }

    if (this.Id) {
      obj._id = this.Id;
      delete this._id;
    }
    // I would like to put the session as parent, but this would be an inclomplete reference.
    // A space is not a valid id. Niether is 'false'. Lets leave it blank.
    if (this.Parent) {
      if (typeof (this.Parent) === 'string') {
        // When the parent is an image.
        obj.ParentId = this.Parent;
      }
      if (typeof (this.Parent) === 'object' && this.Parent.Id) {
        // When the parent is a note.
        obj.ParentId = this.Parent.Id;
      }
      // These snuck into the database.
      delete this.ParentId;
    }
    obj.Title = this.Title;
    obj.HiddenTitle = this.HiddenTitle;

    obj.Text = this.Text;
    // The server handles copying views and the code is a pain.
    // I would rather have the client copy notes since is can now
    // save them one by one and get ids for new notes.
    // However,  until I make this change, I need a simple way of copying
    // a note and not messing up the references in the text.
    // Code the links in the html as indexes.
    // for (var i = 0; i < this.Children.length; ++i) {
    //    var Child
    // }

    // We should probably serialize the ViewerRecords too.
    obj.ViewerRecords = [];

    // The database wants an image id, not an embedded iamge object.
    //  The server should really take care of this since if
    for (var i = 0; i < this.ViewerRecords.length; ++i) {
      if (!this.ViewerRecords[i].Image) continue;
      var record = this.ViewerRecords[i].Serialize();
      obj.ViewerRecords.push(record);
    }

    // upper left pixel
    obj.CoordinateSystem = 'Pixel';

    // Will this erase children if includeChildren is off?
    if (!excludeChildren) {
      obj.Children = [];
      for (i = 0; i < this.Children.length; ++i) {
        obj.Children.push(this.Children[i].Serialize(excludeChildren));
      }
    }

    return obj;
  };

  // This method of loading is causing a pain.
  // Children are saved separately now, so the pain should be gone.
  Note.prototype.Load = function (obj) {
    // Received
    this.LoadState = SYNCHRONIZED;

    var ivar;
    for (ivar in obj) {
      this[ivar] = obj[ivar];
    }
    // I am not sure blindly copying all of the variables is a good idea.
    if (this._id) {
      this.Id = this._id;
      delete this._id;
    }

    // It would be better not to set the ParentId of user notes in the
    // first place. userNote.Parent is set to the id of the image.
    if (this.Type !== 'UserNote' && this.ParentId) {
      this.Parent = SA.GetNoteFromId(this.ParentId);
      delete this.ParentId;
    }

    if (SA.HideAnnotations || this.Mode === 'answer-hide' ||
            this.Model === 'answer-interactive') {
      this.TitleEntry.text('-');
    } else {
      this.TitleEntry.text(this.Title);
    }

    for (var i = 0; i < this.Children.length; ++i) {
      var child = this.Children[i];
      var childNote = new SA.Note();
      childNote.SetParent(this);
      if (typeof (child) === 'string') {
        // Asynchronous.  This may cause problems (race condition)
        // We should have a load state in note.
        // childNote.LoadViewId(child);
        childNote.Id = child;
      } else {
        childNote.Load(child);
      }
      this.Children[i] = childNote;
      childNote.Div.data('index', i);
    }

    // Only used by presentations.
    if (this.UserNote) {
      // Make the user not into a real object.
      obj = this.UserNote;
      this.UserNote = new SA.Note();
      this.UserNote.Load(obj);
    }

    for (i = 0; i < this.ViewerRecords.length; ++i) {
      if (this.ViewerRecords[i]) {
        obj = this.ViewerRecords[i];
        // It would be nice to have a constructor that took an object.
        this.ViewerRecords[i] = new SA.ViewerRecord();
        this.ViewerRecords[i].Load(obj);
        if (i < 3) {
          // Delay requesting the user notes for a long stack.
          this.ViewerRecords[i].RequestUserNote();
        }
      }
    }
  };

  // Making this handle callbacks added after original load call.
  // Will not reload. I am not really sure this feature is actually
  // needed. I will keep it to be safe.
  var HACK_LOAD_CALLBACKS = [];
  Note.prototype.LoadViewId = function (viewId, callback) {
    if (this.LoadState === SYNCHRONIZED) {
      // no realoading (could be done with an extra arg).
      (callback)();
      return;
    }
    if (this.LoadState === REQUESTED) {
      // Waiting for an ajax call to return.
      // Add the new callback to any already pending.
      // HACK + LOAD_CALLBACKS.push({note: this, callback: callback});
      return;
    }

    var self = this;
    this.LoadState = REQUESTED;

    SA.PushProgress();

    $.ajax({
      type: 'get',
      url: '/webgl-viewer/getview',
      data: {'viewid': viewId},
      success: function (data, status) {
        SA.PopProgress();
        self.Load(data);
        if (callback) {
          (callback)();
        }
        // Look for anycallbacks added after the ajax call.
        // This feature may nt be used, but it is safe.
        // I have been having problems with views note display in
        // presentations.
        var tmp = [];
        for (var i = 0; i < HACK_LOAD_CALLBACKS.length; ++i) {
          var tmp2 = HACK_LOAD_CALLBACKS[i];
          if (tmp2.note === self) {
            (tmp2.callback)();
          } else {
            tmp.push(tmp2);
          }
        }
        HACK_LOAD_CALLBACKS = tmp;
      },
      error: function () {
        SA.PopProgress();
        SA.Debug('AJAX - error() : getview');
      }
    });
  };

  Note.prototype.Collapse = function () {
    this.ChildrenVisibility = false;
    if (this.Contains(SA.notesWidget.SelectedNote)) {
      // Selected note should not be in collapsed branch.
      // Make the visible ancestor active.
      SA.SetNote(this);
    }
    this.UpdateChildrenGUI();
    SA.display.NavigationWidget.Update();
  };

  Note.prototype.Expand = function () {
    this.ChildrenVisibility = true;
    this.UpdateChildrenGUI();
    SA.display.NavigationWidget.Update();
  };

  // Extra stuff for stack.
  Note.prototype.DisplayStack = function (display) {
    // SA.SetNote(this);
    // For editing correlations
    if (SA.Edit && this.StartIndex + 1 < this.ViewerRecords.length) {
      var trans = this.ViewerRecords[this.StartIndex + 1].Transform;
      if (trans) {
        display.GetViewer(0).StackCorrelations = trans.Correlations;
        display.GetViewer(1).StackCorrelations = trans.Correlations;
      }
    }
    // Indicate which section is being displayed in viewer 1
    for (var i = 0; i < this.StackDivs.length; ++i) {
      if (i === this.StartIndex) {
        this.StackDivs[i].css({'background-color': '#BBB'});
      } else {
        this.StackDivs[i].css({'background-color': '#FFF'});
      }
    }
  };

  // Creates default transforms for Viewer Records 1-n
  // (if they do not exist already).  Uses cameras focal point.
  Note.prototype.InitializeStackTransforms = function () {
    for (var i = 1; i < this.ViewerRecords.length; ++i) {
      if (!this.ViewerRecords[i].Transform) {
        var cam0 = this.ViewerRecords[i - 1].Camera;
        var cam1 = this.ViewerRecords[i].Camera;
        var dRoll = cam1.GetWorldRoll() - cam0.GetWorldRoll();
        if (dRoll < 0.0) { dRoll += 2 * Math.PI; }
        var trans = new SA.PairTransformation();
        trans.AddCorrelation(cam0.GetWorldFocalPoint(), cam1.GetWorldFocalPoint(), dRoll,
                             0.5 * (cam0.Height + cam1.Height));
        this.ViewerRecords[i].Transform = trans;
      }
    }
  };

  SA.Note = Note;
})();

// A potential problem with user notes.  User note is created when a note
// is loaded.  It will not be possible to add user text right after a note
// is created.  I should disable usernote tab in this case. I do not think
// it is worthwile to create a user not earlier because I would have to
// merge user notes or indicate that a note is new and will never be loaded.
// that possibly share a superclass.

// Notes can be nested (tree structure) to allow for student questions, comments or discussion.
// Sessions could be notes.
// Notes within the same level are ordered.
// Question answers can be sub notes.

// Students can save comments that are not seen by other students.
// Student notes are stored as "favorites".
// Notes keep an ID of their parent in the database.
// The recording API is used to save the state of viewers (ViewerRecord)
// Notes just add a tree structure on top of these states (with GUI).

// Right now we are loading the view and bookmarks as notes.
// Bookmarks have two notes: Question and a child answer.
// I need to change this to be more like the origin open layers presentation.

// TODO:
// Highlight icon on hover.
// Drag notes to change the order.
// Show the user "favorite" notes.
// Allow user to delete the favorite note (even if edit is not on).

// HTML:
// Students like the HTML Text and would like to see hyperlinks to
// annotation and cameras.  The Scheme is not setup for this because
// children have their own text.  I am going to change the behavior so
// that children that do not have their own text, show the text of their
// parent.  I will probably hide children without text in the top display.
// TODO:
// Bug: Tabs do not look right (bottom should be white / z_index?)
// Bug: only the last child added can be selected by the title.
//      only the last child added shows the delete and camera buttons.
//      This only happens when editing.  Loading a saved view/note works
//      fine.
// Bug: Note title not being saved.
// Bug: Type "test" reload (not saved).

// Deleting a note should delete the usernote.
// Deleting a hyper link should delete its note. (test)

// Maybe have a "Add" at the bottom of the link list.
// Move deleted links to trash instead of deleting. (Undo delete)
// A way to get permalink to notes. (for Brown) (LinkCallback)
// Indicate the current note in the text.
// Save notes panel state (opened, closed, width) in mongo.
// ??? Link notes better in html ??? Saving edited html is the problem here.
// Make browser back arrow undo link (will this cause tiles to reload (note
//     panel to disapear?)

// NOTE:
// - !!!!!!!!!!!!!!!!!!!!!! Copy note needs to change ids in html !!!!!!!!!!!!!!!
// -I Could not highlight hyperlink when note is selected.
//     Text cannot be selected when hidden.  I would have to select the
//     text when Text tabe is clicked.....
// -Hyperlink selection background color (and color) should not be saved in
//     the note / database.

// ==============================================================================

(function () {
  'use strict';

    // TODO: put this class in its own file.
    // Links that open a separate window use this.
    // It has a gui to choose the window location and will reposition other
    // windows so they do not overlap.  Modeling after MS Windows snap
    // assist.

  function WindowManager () {
    var self = this;

    this.Windows = new Array(3);
    this.Windows[0] = new Array(3);
    this.Windows[1] = new Array(3);
    this.Windows[2] = new Array(3);

        // A model of the screen
    this.ScreenRectangle = $('<div>')
            .appendTo('body')
            .css({'position': 'absolute',
              'background': '#06F',
              'opacity': '0.5',
              'z-index': '100'})
            .hide();
        // hack to get dotted lines
    this.HorizontalLine = $('<div>')
            .appendTo(this.ScreenRectangle)
            .css({'position': 'absolute',
              'left': '0px',
              'width': '100%',
              'top': '50%',
              'height': '1px',
              'background': '#FFF',
              'opacity': '0.4'});
    this.VerticalLine = $('<div>')
            .appendTo(this.ScreenRectangle)
            .css({'position': 'absolute',
              'top': '0px',
              'height': '100%',
              'left': '50%',
              'width': '1px',
              'background': '#FFF',
              'opacity': '0.4'});
        // Feedback of where the window will be created
    this.WindowRectangle = $('<div>')
            .appendTo(this.ScreenRectangle)
            .css({'position': 'absolute',
              'box-sizing': 'border-box',
              'background': '#AAA',
              'border': '1px solid #FFF',
              'opacity': '0.7'});

        // Hiding does not get rid of the bound events.
    this.ScreenRectangle
            .bind('mousemove',
                  function (e) { self.HandleMouseMove(e); });
    this.ScreenRectangle
            .bind('mouseup',
                  function (e) { self.HandleMouseUp(e); });
    this.ScreenRectangle
            .bind('mouseleave',
                  function (e) { self.HandleMouseLeave(e); });

    $(window).bind('beforeunload', function () {
      for (var x = 0; x < 3; ++x) {
        for (var y = 0; y < 3; ++y) {
          var w = self.Windows[x][y];
          if (w && !w.closed) {
            w.close();
          }
        }
      }
    });
  }

    // mX,my is the mouse location.  The center of the GUI object will be
    // placed there.
  WindowManager.prototype.Show = function (mx, my, url, title) {
    this.Title = title || 'SlideAtlas';
    this.Url = url;

    this.AvailableLeft = screen.availLeft || 0;
    this.AvailableTop = screen.availTop || 0;
    this.AvailableWidth = screen.availWidth || screen.width || 1000;
    this.AvailableHeight = screen.availHeight || screen.height || 800;

    var w = this.AvailableWidth / 10;
    var h = this.AvailableHeight / 10;
    var x = mx - (w / 2);
    var y = my - (h / 2);
    if (x < 0) { x = 0; }
    if (y < 0) { y = 0; }

    this.Partition = [1, 1];
    this.WindowRectangle
            .css({'left': '3%',
              'top': '3%',
              'width': '94%',
              'height': '94%'});

    this.ScreenRectangle
            .css({'left': x + 'px',
              'top': y + 'px',
              'width': w + 'px',
              'height': h + 'px'})
            .show();
  };

  WindowManager.prototype.HandleMouseLeave = function (event) {
    this.ScreenRectangle.hide();
  };

  WindowManager.prototype.HandleMouseUp = function (event) {
    var xIdx = this.Partition[0];
    var yIdx = this.Partition[1];
    var w = this.Windows[xIdx][yIdx];
    if (w && !w.closed) {
      w.location.href = this.Url;
            // change the title
      w.document.title = this.Title;
      return;
    }

    var x = this.AvailableLeft;
    var y = this.AvailableTop;
    w = this.AvailableWidth;
    var h = this.AvailableHeight;

    if (xIdx !== 1) {
      w = w / 2;
    }
    if (yIdx !== 1) {
      h = h / 2;
    }
    if (xIdx === 2) {
      x = x + w;
    }
    if (yIdx === 2) {
      y = y + h;
    }
        // inner vs outer?
    w = w - 27;
    h = h - 100;
        // Two windows cannot have the same title.
    var title = this.Title + ' ' + xIdx + ' ' + yIdx;
    this.Windows[this.Partition[0]][this.Partition[1]] =
            window.open(this.Url, title,
                        'alwaysRaised=yes,titlebar=no,menubar=no,toolbar=no,dependent=yes,left=' + x + ',top=' + y + ',width=' + w + ',height=' + h);
    this.ScreenRectangle.hide();
  };

  WindowManager.prototype.HandleMouseMove = function (event) {
    var w = this.ScreenRectangle.width();
    var h = this.ScreenRectangle.height();
    var x = event.offsetX;
    var y = event.offsetY;

        // offsetX is relative to the source div which can be the
        // WindowRectangle. Change it to be relative to the
        // ScreenRectangle.
    var src = $(event.originalEvent.srcElement);
    while (src[0] !== this.ScreenRectangle[0]) {
      var pos = src.position();
      x += pos.left;
      y += pos.top;
      src = src.parent();
      if (!src) {
        return;
      }
    }

    if (x < w / 3) {
      this.Partition[0] = 0;
      this.WindowRectangle
                .css({'left': '3%',
                  'width': '44%'});
    } else if (x > 2 * w / 3) {
      this.Partition[0] = 2;
      this.WindowRectangle
                .css({'left': '53%',
                  'width': '44%'});
    } else {
      this.Partition[0] = 1;
      this.WindowRectangle
                .css({'left': '3%',
                  'width': '94%'});
    }
    if (y < h / 3) {
      this.Partition[1] = 0;
      this.WindowRectangle
                .css({'top': '3%',
                  'height': '44%'});
    } else if (y > 2 * h / 3) {
      this.Partition[1] = 2;
      this.WindowRectangle
                .css({'top': '53%',
                  'height': '44%'});
    } else {
      this.Partition[1] = 1;
      this.WindowRectangle
                .css({'top': '3%',
                  'height': '94%'});
    }
  };

  SA.WindowManager = WindowManager;
})();

(function () {
  'use strict';

    // TODO: Merge this with the text editor in viewer-utils.
    // Gray out buttons when no text is selected.
    // Remove options to insert link if no text is selected.

  function TextEditor (parent, display) {
    this.Header = $('<div>')
            .appendTo(parent)
            .css({'width': '100%'});

    this.Body = $('<div>')
            .appendTo(parent)
            .css({'width': '100%',
              'position': 'absolute',
              'top': '90px',
              'bottom': '0px'});

        // Add a call back to have the text editor fill available verticle space.
    var self = this;
    this.Header.saOnResize(
            function () {
              var top = self.Header.height();
              if (top === 0) {
                    // Hack because height not set yet.
                setTimeout(function () { self.Header[0].onresize(); }, 250);
                return;
              }
              self.Body.css({'top': top + 'px'});
            });

    this.Display = display;
    this.Parent = parent;
        // I do not want the text editable until the note is set.
    this.Editable = true;
    this.Edit = true;
        // The user can set this to save the note automatically.
    this.ChangeCallback = null;

    this.EditButtons = [];
    this.AddEditButton(SA.ImagePathUrl + 'camera.png', 'link view',
                           function () { self.InsertCameraLink(); });
    this.AddEditButton(SA.ImagePathUrl + 'link.png', 'link URL',
                           function () { self.InsertUrlLink(); });
    this.AddEditButton(SA.ImagePathUrl + 'font_bold.png', 'bold',
                           function () { document.execCommand('bold', false, null); });
    this.AddEditButton(SA.ImagePathUrl + 'text_italic.png', 'italic',
                           function () { document.execCommand('italic', false, null); });
    this.AddEditButton(SA.ImagePathUrl + 'edit_underline.png', 'underline',
                           function () { document.execCommand('underline', false, null); });
    this.AddEditButton(SA.ImagePathUrl + 'list_bullets.png', 'unorded list',
                           function () { document.execCommand('InsertUnorderedList', false, null); });
    this.AddEditButton(SA.ImagePathUrl + 'list_numbers.png', 'ordered list',
                           function () { document.execCommand('InsertOrderedList', false, null); });
    this.AddEditButton(SA.ImagePathUrl + 'indent_increase.png', 'indent',
                           function () { document.execCommand('indent', false, null); });
    this.AddEditButton(SA.ImagePathUrl + 'indent_decrease.png', 'outdent',
                           function () { document.execCommand('outdent', false, null); });
    this.AddEditButton(SA.ImagePathUrl + 'alignment_left.png', 'align left',
                           function () { document.execCommand('justifyLeft', false, null); });
    this.AddEditButton(SA.ImagePathUrl + 'alignment_center.png', 'align center',
                           function () { document.execCommand('justifyCenter', false, null); });
    this.AddEditButton(SA.ImagePathUrl + 'edit_superscript.png', 'superscript',
                           function () { document.execCommand('superscript', false, null); });
    this.AddEditButton(SA.ImagePathUrl + 'edit_subscript.png', 'subscript',
                           function () { document.execCommand('subscript', false, null); });
    this.AddEditButton(SA.ImagePathUrl + 'font_increase.png', 'large font',
                           function () {
                             document.execCommand('fontSize', false, '5');
                             self.ChangeBulletSize('1.5em');
                           });
    this.AddEditButton(SA.ImagePathUrl + 'font_decrease.png', 'small font',
                           function () {
                             document.execCommand('fontSize', false, '2');
                             self.ChangeBulletSize('0.9em');
                           });

    this.AddEditButton(SA.ImagePathUrl + 'question.png', 'add question',
                           function () {
                             self.AddQuestion();
                           });

    this.InitializeHomeButton(this.Header);

    this.TextEntry = $('<div>')
            .appendTo(this.Body)
            .attr('contenteditable', 'true')
            .removeAttr('readonly')
            .css({'box-sizing': 'border-box',
              'width': '100%',
              'height': '100%',
              'overflow': 'auto',
              'resize': 'none',
              'border-style': 'inset',
              'font-size': '10pt',
              'font-family': 'Century Gothic',
              'background': '#f5f8ff'})
            .bind('input', function () {
                // Leave events are not triggering.
              self.EventuallyUpdate();
            })
            .focusin(function () {
              SA.ContentEditableHasFocus = true;
            })
            .focusout(function () {
              SA.ContentEditableHasFocus = false;
              self.Update();
            })
        // Mouse leave events are not triggering.
            .mouseleave(function () { // back button does not cause loss of focus.
              self.Update();
            });

    this.UpdateTimer = null;
        // this.RecordViewTimer = null;

        // Do not enable editing until the Note is set.
    this.EditOff();
    this.Note = null;
  }

  TextEditor.prototype.HomeCallback = function () {
    if (!this.Note) {
      return;
    }
    SA.SetNote(this.Note);
  };

    // Home button is a link.  The link menu is used for other links too.
  TextEditor.prototype.InitializeHomeButton = function (parent) {
    var self = this;
    this.HomeButton = $('<div>')
            .appendTo(parent)
            .text('Home')
            .css({'text-align': 'center',
              'border': '1px solid #666666',
              'border-radius': '10px',
              'margin': '2px',
              'color': '#29C',
              'background': 'white'})
            .hover(function () { $(this).css('color', 'blue'); },
                   function () { $(this).css('color', '#29C'); });
    this.HomeButton.contextmenu(function () { return false; });
    this.HomeButton.mousedown(function (e) {
      if (e.button === 0) {
        self.HomeCallback();
        return false;
      }
      if (e.button === 2) {
        self.LinkMenuObject = {Link: self.HomeButton,
          Note: self.Note};
                // Position and show the properties menu.
        var pos = $(this).position();
                // Cannot delete the root note.
        self.DeleteLinkButton.hide();
        self.LinkMenu
                    .css({'left': (25 + pos.left) + 'px',
                      'top': (pos.top) + 'px'})
                    .show();
        return false;
      }
      return true;
    });

        // When a link is right clicked, the object {Link: ..., Note: ...} is set and the
        // menu is made visible.
    this.LinkMenuObject = undefined;
    this.LinkMenu = $('<div>')
            .appendTo(parent)
            .hide()
            .mouseleave(function () { $(this).hide(); })
            .css({'position': 'absolute',
              'background-color': '#FFFFFF',
              'border': '1px solid #666666',
              'box-sizing': 'border-box',
              'left': '-78px',
              'width': '100px',
              'padding': '0px 2px'});
    $('<button>')
            .appendTo(this.LinkMenu)
            .text('Save View')
            .css({'margin': '2px 0px',
              'width': '100%'})
            .prop('title', 'Replace Annotation')
            .click(
                function () {
                  self.SaveLink(self.LinkMenuObject.Link,
                                  self.LinkMenuObject.Note);
                  self.LinkMenu.hide();
                });
    this.DeleteLinkButton = $('<button>')
            .appendTo(this.LinkMenu)
            .text('Delete')
            .css({'margin': '2px 0px',
              'width': '100%'})
            .click(
                function () {
                  self.DeleteLink(self.LinkMenuObject.Link,
                                    self.LinkMenuObject.Note);
                  self.LinkMenu.hide();
                });
  };

  TextEditor.prototype.StartWindowManagerTimer = function (linkNote, x, y) {
        // I think motion is a better trigger for the window manager.
    this.WindowManagerX = x;
    this.WindowManagerY = y;
        // hint for mouse up (text editor handles the event).
    this.LinkWindowLocation = 0;
        // Start a timer.
    var self = this;
    this.WindowManagerTimer = setTimeout(function () {
      self.WindowManagerTimer = undefined;
      self.ShowWindowManager(linkNote, x, y);
    }, 1000);
  };

  TextEditor.prototype.ShowWindowManager = function (linkNote, x, y) {
    if (this.WindowMangerTimer) {
      clearTimeout(this.WindowManagerTimer);
      this.WindowManagerTimer = undefined;
    }
    if (!SA.windowManager) {
      SA.windowManager = new SA.WindowManager();
    }
    SA.windowManager.Show(x, y,
                              '/webgl-viewer?view=' + linkNote.Id,
                              linkNote.Title);
        // Hack to keep mouse up from loading the note.
    this.LinkWindowLocation = 1;
  };

    // Every time the "Text" is loaded, they hyper links have to be setup.
    // TODO: Do we need to turn off editable?
  TextEditor.prototype.FormatLink = function (linkNote) {
    var self = this;
    var link = document.getElementById(linkNote.Id);
    if (link) {
      $(link)
                .css({'color': '#29C',
                  'background': 'white'})
                .hover(function () { $(this).css('color', 'blue'); },
                       function () { $(this).css('color', '#29C'); })
                .attr('contenteditable', 'false');

      $(link).contextmenu(function () { return false; });
      $(link).mousedown(function (e) {
        if (e.button === 0) {
          self.StartWindowManagerTimer(linkNote, e.pageX, e.pageY);
          return false;
        }
        if (e.button === 2) {
          self.LinkMenuObject = {Link: $(link),
            Note: linkNote};
                    // Position and show the properties menu.
          var pos = $(this).position();
          self.DeleteLinkButton.show();
          self.LinkMenu
                        .css({'left': (25 + pos.left) + 'px',
                          'top': (pos.top) + 'px'})
                        .show();
          return false;
        }
        return true;
      });
      $(link).mousemove(function (e) {
        if (e.which === 1) {
          var dx = e.pageX - self.WindowManagerX;
          var dy = e.pageY - self.WindowManagerY;
          if (Math.abs(dx) + Math.abs(dy) > 5) {
            self.ShowWindowManager(linkNote, e.pageX, e.pageY);
          }
        }
      });

      $(link).mouseup(function (e) {
        if (e.button === 0) {
          if (self.WindowManagerTimer) {
            clearTimeout(self.WindowManagerTimer);
            self.WindowManagerTimer = undefined;
          }
          if (self.LinkWindowLocation === 0) {
            SA.SetNote(linkNote);
            return false;
          }
        }
        return true;
      });
    }
  };

  TextEditor.prototype.SaveLink = function (link, note) {
    note.RecordView(this.Display);
    note.Save();
  };

  TextEditor.prototype.DeleteLink = function (link, note) {
        // TODO: Keep the old text.
    var text = link.text();
    $(document.createTextNode(text)).insertAfter(link);
    link.remove();
    note.DeleteCallback();
    this.UpdateNote();
    this.Note.Save();
  };

  TextEditor.prototype.Change = function (callback) {
    this.ChangeCallback = callback;
  };

  TextEditor.prototype.EventuallyUpdate = function () {
    if (this.UpdateTimer) {
      clearTimeout(this.UpdateTimer);
      this.UpdateTimer = null;
    }
    var self = this;
    this.UpdateTimer = setTimeout(function () { self.UpdateNote(); }, 5000);
  };

  TextEditor.prototype.Update = function () {
    if (this.UpdateTimer) {
      clearTimeout(this.UpdateTimer);
      this.UpdateTimer = null;
    } else {
            // I am using the timer as a modified flag.
            // Call update note to force an update.
      return;
    }
    this.UpdateNote();
  };

  TextEditor.prototype.EditOff = function () {
    if (!this.Edit) { return; }
    this.Edit = false;

    for (var i = 0; i < this.EditButtons.length; ++i) {
      this.EditButtons[i].hide();
    }

    this.TextEntry
            .attr('contenteditable', 'false')
            .attr('spellcheck', 'false')
            .css({'border-style': 'outset',
              'background': '#ffffff'})
            .unbind('input')
            .unbind('focusin')
            .unbind('focusout')
            .unbind('mouseleave')
            .blur();
  };

  TextEditor.prototype.EditableOff = function () {
    this.EditOff();
    this.Editable = false;
  };

  TextEditor.prototype.EditOn = function () {
    var self = this;
    if (!this.Editable) { return; }
    if (this.Edit) { return; }
    this.Edit = true;

    for (var i = 0; i < this.EditButtons.length; ++i) {
      this.EditButtons[i].show();
    }

    this.TextEntry
            .attr('contenteditable', 'true')
            .removeAttr('readonly')
            .css({'border-style': 'inset',
              'background': '#f5f8ff'})
            .bind('input', function () {
              self.Modified = true;
              self.EventuallyUpdate();
            })
            .focusin(function () {
              SA.ContentEditableHasFocus = true;
            })
            .focusout(function () {
              SA.ContentEditableHasFocus = false;
              self.Update();
            })
            .mouseleave(function () { // back button does not cause loss of focus.
              self.Update();
            });
  };

  TextEditor.prototype.AddEditButton = function (src, tooltip, callback) {
    var button = $('<img>');
    if (tooltip) {
            // button = $('<img title="'+tooltip+'">')
      button.prop('title', tooltip);
    }
    button
      .appendTo(this.Header)
      .addClass('editButton')
      .attr('src', src)
      .click(callback);
    this.EditButtons.push(button);
  };

  TextEditor.prototype.AddQuestion = function () {
    var bar = $('<div>')
            .css({'position': 'relative',
              'margin': '3%',
              'width': '90%',
              'background': '#FFF',
              'border': '1px solid #AAA',
              'padding': '1% 1% 1% 1%'}) // top right bottom left
            .attr('contenteditable', 'false')
            .saQuestion({editable: SA.Edit,
              position: 'static'});

        // Need to get the range here because the dialog changes it.
    var self = this;
    var range = SA.GetSelectionRange(this.TextEntry);
        // Try to initialize the dialog with the contents of the range.
    if (!range.collapsed) {
      var clone = range.cloneContents();
      bar.saQuestion('SetQuestionText', clone.firstChild.textContent);
      if (clone.childElementCount > 1) {
                // var answers = clone.querySelectorAll('li');
        var answers = [];
        var first = 0;
        var li = clone.querySelector('li');
        if (li) {
                    // Answers are in a list.
          answers = li.parentElement;
        } else if (clone.childElementCount > 2) {
          answers = clone;
          first = 1;
        } else {
          answers = clone.children[1];
        }
        for (var i = first; i < answers.childElementCount; ++i) {
          var answer = answers.children[i];
          var bold = (answer.style.fontWeight === 'bold') ||
                        ($(answer).find('b').length > 0);
          bar.saQuestion('AddAnswerText',
                                   answer.textContent,
                                   bold);
        }
      }
    }

    bar.saQuestion('OpenDialog',
                       function () {
                         if (range) {
                           range.deleteContents();
                           range.insertNode(document.createElement('br'));
                         } else {
                           range = SA.MakeSelectionRange(self.TextEntry);
                         }
                         range.insertNode(bar[0]);
                           // Some gymnasitcs to keep the cursor after the question.
                         range.collapse(false);
                         var sel = window.getSelection();
                         sel.removeAllRanges();
                         sel.addRange(range);
                         self.TextEntry[0].focus();
                         self.UpdateNote();
                       });
  };

    // execCommand fontSize does change bullet size.
    // This is a work around.
  TextEditor.prototype.ChangeBulletSize = function (sizeString) {
    // This call will clear the selected text if it is not in this editor.
    var range = SA.GetSelectionRange(this.TextEntry);
    range = range || SA.MakeSelectionRange(this.TextEntry);
    var listItems = $('li');
    for (var i = 0; i < listItems.length; ++i) {
      var item = listItems[i];
      if (range.isPointInRange(item, 0) ||
                range.isPointInRange(item, 1)) {
        $(item).css({'font-size': sizeString});
      }
    }
  };

  TextEditor.prototype.InsertUrlLink = function () {
    var self = this;
    var sel = window.getSelection();
        // This call will clear the selected text if it is not in this editor.
    var range = SA.GetSelectionRange(this.TextEntry);
    var selectedText = sel.toString();

    if (!this.UrlDialog) {
      var dialog = new SAM.Dialog(function () {
        self.InsertUrlLinkAccept();
      });
      dialog.Body.css({'margin': '1em 2em'});
      this.UrlDialog = dialog;
      dialog.Dialog.css({'width': '40em'});
      dialog.Title.text('Paste URL link');
      dialog.TextDiv =
                $('<div>')
                .appendTo(dialog.Body)
                .css({'display': 'table-row',
                  'width': '100%'});
      dialog.TextLabel =
                $('<div>')
                .appendTo(dialog.TextDiv)
                .text('Text to display:')
                .css({'display': 'table-cell',
                  'height': '2em',
                  'text-align': 'left'});
      dialog.TextInput =
                $('<input>')
                .appendTo(dialog.TextDiv)
                .val('#30ff00')
                .css({'display': 'table-cell',
                  'width': '25em'});

      dialog.UrlDiv =
                $('<div>')
                .appendTo(dialog.Body)
                .css({'display': 'table-row'});
      dialog.UrlLabel =
                $('<div>')
                .appendTo(dialog.UrlDiv)
                .text('URL link:')
                .css({'display': 'table-cell',
                  'text-align': 'left'});
      dialog.UrlInput =
                $('<input>')
                .appendTo(dialog.UrlDiv)
                .val('#30ff00')
                .css({'display': 'table-cell',
                  'width': '25em'})
                .bind('input', function () {
                  var url = self.UrlDialog.UrlInput.val();
                  if (self.UrlDialog.LastUrl === self.UrlDialog.TextInput.val()) {
                        // The text is same as the URL. Keep them synchronized.
                    self.UrlDialog.TextInput.val(url);
                  }
                  self.UrlDialog.LastUrl = url;
                    // Deactivate the apply button if the url is blank.
                  if (url === '') {
                    self.UrlDialog.ApplyButton.attr('disabled', true);
                  } else {
                    self.UrlDialog.ApplyButton.attr('disabled', false);
                  }
                });
    }

        // We have to save the range/selection because user interaction with
        // the dialog clears the text entry selection.
    this.UrlDialog.SelectionRange = range;
    this.UrlDialog.TextInput.val(selectedText);
    this.UrlDialog.UrlInput.val('');
    this.UrlDialog.LastUrl = '';
    this.UrlDialog.ApplyButton.attr('disabled', true);
    this.UrlDialog.Show(true);
  };

  TextEditor.prototype.InsertUrlLinkAccept = function () {
    var sel = window.getSelection();
    var range = this.UrlDialog.SelectionRange;
    range = range || SA.MakeSelectionRange(this.TextEntry);

        // Simply put a span tag around the text with the id of the view.
        // It will be formated by the note hyperlink code.
    var link = document.createElement('a');
    link.href = this.UrlDialog.UrlInput.val();
    link.target = '_blank';

        // Replace or insert the text.
    if (!range.collapsed) {
            // Remove the seelcted text.
      range.extractContents(); // deleteContents(); // cloneContents
      range.collapse(true);
    }
    var linkText = this.UrlDialog.TextInput.val();
    if (linkText === '') {
      linkText = this.UrlDialog.UrlInput.val();
    }
    link.appendChild(document.createTextNode(linkText));

    range.insertNode(link);
    if (range.noCursor) {
      // Leave the selection the same as we found it.
      // Ready for the next link.
      sel.removeAllRanges();
    }
    this.UpdateNote();
  };

  // TODO: Untangle view links from the note.
  TextEditor.prototype.InsertCameraLink = function () {
        // Create a child note.
    var parentNote = this.Note;
    if (!parentNote) {
      parentNote = SA.display.GetRootNote();
    }

    // TODO: I think an icon as a default view link would look nicer.
    var text = '(view)';
    // Create a new note to hold the view.
    // Put the new note at the end of the list.
    var childIdx = parentNote.Children.length;
    // var childIdx = 0; // begining
    var childNote = parentNote.NewChild(childIdx, text);
    // Setup and save
    childNote.RecordView(this.Display);
    // Block subnotes and separate text.
    childNote.Type = 'View';

    var range = SA.GetSelectionRange(this.TextEntry);
    if (!range) {
      range = SA.MakeSelectionRange(this.TextEntry);
    } else if (!range.collapsed) {
      text = range.toString();
    }
    childNote.Title = text;
    range.deleteContents();

    // Simply put a span tag around the text with the id of the view.
    // It will be formated by the note hyperlink code.
    var span = document.createElement('span');
        // This id identifies the span as a hyperlink to this note.
        // The note will format the link and add callbacks later.
    span.id = childNote.Id;
    $(span).attr('contenteditable', 'false');
    span.appendChild(document.createTextNode(text));
    range.insertNode(span);
        // Let the note format it.
    this.FormatLink(childNote);

        // Some gymnasitcs to keep the cursor after the question.
    range.collapse(false);
    var sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
    this.TextEntry[0].focus();
        // NOTE: This may not be necesary no that text note "views" are
        // issolated from notes in views tab.
    this.UpdateNote();

    this.Note.Save();
        // Need this because the save button was overwriting the root note
        // view when a camera link was just inserted.
    SA.SetNote(childNote);
  };

  TextEditor.prototype.Resize = function (width, height) {
    var pos;
    pos = this.TextEntry.offset();
    this.TextEntry.height(height - pos.top - 5);
  };

    // No one seems to call this.
  TextEditor.prototype.SetHtml = function (html) {
    console.log("Something called 'TextEditor::SetHtml'");
    if (this.UpdateTimer) {
      clearTimeout(this.UpdateTimer);
      this.Update();
    }
    this.Note = null; // ??? Editing without a note
    this.EditOn();
    this.TextEntry.html(html);

    if (SA.Edit) {
      var items = this.TextEntry.find('.sa-question');
      items.saQuestion({editable: true,
        position: 'static'});
    }

        // Note needed here long term.
        // this looks for keywords in text and makes tags.
    SA.AddHtmlTags(this.TextEntry);
  };

  TextEditor.prototype.GetHtml = function () {
    return this.TextEntry.html();
  };

    // TODO: Editor should not become active until it has a note.
    // This probably belongs in a subclass.
    // Or in the note.
  TextEditor.prototype.LoadNote = function (note) {
    if (this.UpdateTimer) {
      clearTimeout(this.UpdateTimer);
      this.Update();
    }
    this.Note = note;

        // Make the home button highlight like the view links.
    this.HomeButton[0].id = note.Id;
        // .....$('#'+note.Id).css({'background':'#e0e0ff'});

    this.TextEntry.html(note.Text);
        // Note needed here long term.
        // this looks for keywords in text and makes tags.
    SA.AddHtmlTags(this.TextEntry);

    this.UpdateMode(note.Mode);

        // TODO: Hide this.  Maybe use saHtml.
    if (SA.Edit) {
      var items = this.TextEntry.find('.sa-question');
      items.saQuestion({editable: true,
        position: 'static'});
    }

        // TODO: Make the hyper link the same pattern as questions.
    for (var i = 0; i < note.Children.length; ++i) {
            // In the future we can only call this on type "View"
      this.FormatLink(note.Children[i]);
    }

    this.MakeLinksClickable();
    if (SA.Edit) {
      this.EditOn();
    }
        // Bug fix: Next slide button was not showing text because it's
        // the editor's height was 0.
    this.TextEntry.trigger('resize');
  };

    // This gets called when the note's mode changes.
  TextEditor.prototype.UpdateMode = function (mode) {
    if (mode === 'answer-show' && this.Note && this.Note.Title) {
      this.HomeButton.text(this.Note.Title);
    } else {
      this.HomeButton.text('Home');
    }

        // TODO: change this to apply only to the textEntry window.
    if (mode === 'answer-show') {
      $('.sa-note').show();
      $('.sa-notes').show();
      $('.sa-diagnosis').show();
      $('.sa-differential-diagnosis').show();
      $('.sa-teaching-points').show();
      $('.sa-compare').show();
      $('.sa-question').saQuestion('SetMode', mode);
    } else if (mode === 'answer-hide' || mode === 'answer-interactive') {
      $('.sa-note').hide();
      $('.sa-notes').hide();
      $('.sa-diagnosis').hide();
      $('.sa-differential-diagnosis').hide();
      $('.sa-teaching-points').hide();
      $('.sa-compare').hide();
      $('.sa-question').saQuestion('SetMode', mode);
    }
  };

    // Copy the text entry text back into the note
    // (when the textEntry changes).
    // It saves the note too.
  TextEditor.prototype.UpdateNote = function () {
    this.UpdateTimer = null;
    if (!this.Note) {
      return;
    }
    this.Note.Text = this.TextEntry.html();
    if (this.ChangeCallback) {
      (this.ChangeCallback)();
    }

    this.MakeLinksClickable();
  };

    // Link are not active in content editable divs.
    // Work around this.
  TextEditor.prototype.MakeLinksClickable = function () {
    if (SA.Edit) {
            // This is only necesary when div is editable.
            // Links work the same in both situations with this.
      var links = $('a');
      for (var i = 0; i < links.length; ++i) {
        var link = links[i];
        $(link)
                    .click(function () {
                      window.open(this.href, '_blank');
                    });
      }
    }
  };

  SA.TextEditor = TextEditor;
})();

    // ==============================================================================

(function () {
  'use strict';

  function NotesWidget (parent, display) {
    this.ModifiedCallback = null;
    // This is a hack.  I do not know when to save the camera.
    // The save button will save the camera for the last note displayed.
    // This may be different that the selected note because of camera links
    // in text that do not change the text.
    this.DisplayedNote = null;

    // Popup div to display permalink.
    SA.LinkDiv =
            $('<div>')
            .appendTo('body')
            .css({'top': '30px',
              'left': '10%',
              'position': 'absolute',
              'width': '80%',
              'height': '50px',
              'z-index': '3',
              'background-color': '#FFF',
              'border': '1px solid #777',
              'border-radius': '8px',
              'text-align': 'center',
              'padding-top': '26px'})
            .hide()
            .mouseleave(function () { SA.LinkDiv.fadeOut(); });

    // There is not option to show the link when SA.Edit is not on,
    // so this really does nothing.  Editable is probably necessary
    // for selection to copy.
    if (SA.Edit) {
      SA.LinkDiv.attr('contenteditable', 'true');
    }

    var self = this;
    this.Display = display;

    this.Modified = false;
    this.Window = $('<div>')
            .appendTo(parent)
            .css({
              'background-color': 'white',
              'position': 'absolute',
              'top': '0%',
              'left': '0%',
              'height': '100%',
              'width': '100%',
              'z-index': '2'})
            .attr('draggable', 'false')
            .on('dragstart', function () { return false; })
            .attr('id', 'NoteWindow');

    // --------------------------------------------------------------------------

    // GUI elements
    this.TabbedWindow = new SA.TabbedDiv(this.Window);
    this.TextDiv = this.TabbedWindow.NewTabDiv('Text');

    this.UserTextDiv = this.TabbedWindow.NewTabDiv('Notes', 'private notes');
    this.LinksDiv = this.TabbedWindow.NewTabDiv('Views');
    this.LinksRoot = $('<ul>')
            .addClass('sa-ul')
            .css({'padding-left': '0px'})
            .appendTo(this.LinksDiv);

    // for (var i = 0; i < this.Display.GetNumberOfViewers(); ++i) {
    //    this.Display.GetViewer(i).OnInteraction(function (){self.RecordView();});
    // }

    this.LinksDiv
            .css({'overflow': 'auto',
              'text-align': 'left',
              'color': '#303030',
              'font-size': '18px'})
            .attr('id', 'NoteTree');

    // no longer needed, but interesting: 'box-sizing': 'border-box'

    // This is the button for the links tab div.
    if (SA.Edit) {
      this.AddViewButton = $('<button>')
                .appendTo(this.LinksDiv)
                .css({'border-radius': '4px',
                  'margin': '1em'})
                .text('+ New View');
    }

    // Show hidden content to non administrator.
    // Do not show this unless not is interactive.
    this.QuizButton = $('<div>')
            .appendTo(this.TextDiv)
            .addClass('editButton')
            .css({'float': 'right',
              'font-size': 'small',
              'margin-top': '4px',
              'padding-left': '2px',
              'padding-right': '2px',
              'border': '1px solid #AAA',
              'border-radius': '2px'})
            .text('show')
            .hide();

    // Now for the text tab:
    if (SA.Edit) {
            // TODO: Encapsulate this menu (used more than once)
      this.QuizDiv = $('<div>')
                .appendTo(this.TextDiv);
      this.QuizMenu = $('<select name="quiz" id="quiz">')
                .appendTo(this.QuizDiv)
                .css({'float': 'right',
                  'margin': '3px'})
                .change(function () {
                  if (!self.RootNote) { return; }
                  if (this.value === 'review') {
                    self.RootNote.Mode = 'answer-show';
                  } else if (this.value === 'hidden') {
                    self.RootNote.Mode = 'answer-hide';
                  } else if (this.value === 'interactive') {
                    self.RootNote.Mode = 'answer-interactive';
                  }
                  self.UpdateQuestionMode();
                });
      this.QuizLabel = $('<div>')
                .appendTo(this.TextDiv)
                .css({'float': 'right',
                  'font-size': 'small',
                  'margin-top': '4px'})
                .text('quiz');
      $('<option>')
                .appendTo(this.QuizMenu)
                .text('review');
      $('<option>')
                .appendTo(this.QuizMenu)
                .text('hidden');
      $('<option>')
                .appendTo(this.QuizMenu)
                .text('interactive');
            // Set the question mode
      this.QuizMenu.val('review');
    }

    this.TextEditor = new SA.TextEditor(this.TextDiv, this.Display);

    if (!SA.Edit) {
      this.TextEditor.EditableOff();
    } else {
      this.TextEditor.Change(
                function () {
                  self.MarkAsModified();
                });
    }
        // Private notes.
    this.UserTextEditor = new SA.TextEditor(this.UserTextDiv, this.Display);

    this.UserTextEditor.Change(
            function () {
              self.UserTextEditor.Note.Save();
            });
  }

  // TODO: THese methods do not belong in this class.
  // Trying to save user notes quietly.
  // Sort of hackish.
  NotesWidget.prototype.EventuallySaveUserNote = function () {
    if (this.UserNoteTimerId) {
      clearTimeout(this.UserNoteTimerId);
    }
    var self = this;
    this.UserNoteTimerId = setTimeout(function () {
      self.SaveUserNote();
    }, 2000);
  };
  NotesWidget.prototype.Flush = function () {
    if (this.UserNoteTimerId) {
      clearTimeout(this.UserNoteTimerId);
      this.UserNoteTimerId = false;
      this.SaveUserNote();
    }
  };
  // Hackish.
  NotesWidget.prototype.SaveUserNote = function () {
    this.UserNoteTimerId = false;
    var note = SA.notesWidget.GetCurrentNote();
    if (!note || note.ViewerRecords.length === 0) {
      return;
    }
    var userNote = note.ViewerRecords[note.StartIndex].UserNote;

    // TODO: Fix this hack.
    // Make a method in display to record, the save them all.
    if (SA && SA.display) {
      // TODO: Fix: This will not work because previous widgets will
      // be in both widgets, but new widgets will only be in one.
      // I do not want to duplicate widgets in the note.
      // for (var i = 0; i < SA.display,GetNumberOfViewers(); ++i) {
      for (var i = 0; i < 1; ++i) {
        userNote.ViewerRecords[0].CopyAnnotations(SA.display.GetViewer(i), true);
      }
    }

    if (userNote.ViewerRecords[0].Annotations.length > 0 ||
            userNote.LoadState === 2) {
      userNote.Save();
    }
  };

  // Needed so administrators can create usernotes.
  NotesWidget.prototype.IsUserTextTabOpen = function () {
    if (this.TabbedWindow.GetCurrentDiv() === this.UserTextDiv) {
      return true;
    }
    return false;
  };

  NotesWidget.prototype.UpdateQuestionMode = function () {
    // Set the question mode
    if (!this.RootNote) {
      return;
    }

    if (!this.RootNote.Mode) {
      this.RootNote.Mode = 'answer-show';
    }

    if (this.QuizMenu) {
      if (this.RootNote.Mode === 'answer-hide') {
        this.QuizMenu.val('hidden');
      } else if (this.RootNote.Mode === 'answer-interactive') {
        this.QuizMenu.val('interactive');
      } else {
                // this.RootNote.Mode = 'answer-show';
        this.QuizMenu.val('review');
      }
    }
    if (this.RootNote.Mode === 'answer-interactive') {
      var self = this;
      this.QuizButton
                .show()
                .css('background-color', '')
                .click(function () {
                  self.SetAnswerVisibility('answer-show');
                  self.QuizButton.css({'background-color': '#AAAAAA'});
                });
    } else {
      this.QuizButton.hide();
    }

    this.SetAnswerVisibility(this.RootNote.Mode);
  };

  NotesWidget.prototype.SetAnswerVisibility = function (mode) {
        // make sure tags have been decoded.
    SA.AddHtmlTags(this.TextEditor.TextEntry);

    this.TextEditor.UpdateMode(mode);
  };

  NotesWidget.prototype.SetNavigationWidget = function (nav) {
    this.NavigationWidget = nav;
  };

  NotesWidget.prototype.SetModifiedCallback = function (callback) {
    this.ModifiedCallback = callback;
  };

  NotesWidget.prototype.SetModifiedClearCallback = function (callback) {
    this.ModifiedClearCallback = callback;
  };

    // Two types of select.  This one is from the views tab.
    // It sets the text from the note.
    // There has to be another from text links.  That does not set the
    // text.
  NotesWidget.prototype.SetNote = function (note) {
        // NOTE: Even if note === this.SelectedNote we still need to add the
        // user note annotations because display resets the annotations of
        // the view. this user may have changed annotations without
        // changing the note.

    var ancestor = note;
    while (ancestor !== this.RootNote &&
               ancestor.Parent &&
               ancestor.Type !== 'UserNote') {
      ancestor = ancestor.Parent;
    }

        // Check to see if we have to set a new root note.
        // If note is not in the root note's family, set a new root.
        // Avoid decendants of user notes.
    if (ancestor !== this.RootNote && ancestor.Type !== 'UserNote') {
            // This will call SetNote again when root note is set.
      this.SetRootNote(ancestor);
      return;
    }

        // This should method should be split between Note and NotesWidget
        // Make the permalink window fade out if it is visible.
    if (SA.LinkDiv.is(':visible')) { SA.LinkDiv.fadeOut(); }

        // If the note is a view link, use the text of the parent.
    if (ancestor.Type !== 'UserNote') {
      var textNote = note;
      while (textNote && textNote.Type === 'View') {
        textNote = textNote.Parent;
      }
      if (textNote) {
        this.TextEditor.LoadNote(textNote);
      }
    }

    if (note === this.SelectedNote) {
      return;
    }

        // Handle the note that is being unselected.
        // Clear the selected background of the deselected note.
    if (this.SelectedNote) {
      this.SelectedNote.TitleEntry.css({'background': 'white'});
            // Make the old hyper link normal color.
      $('#' + this.SelectedNote.Id).css({'background': 'white'});
    }

    this.SelectedNote = note;

        // Display the user note text.
    this.UpdateUserNotes();

        // Indicate which note is selected in the Views tab
    note.TitleEntry.css({'background': '#f0f0f0'});
        // Probably does nothing.
        // note.SelectHyperlink();

        // Indicate which note / view link is selected in the text.
    $('#' + note.Id).css({'background': '#e0e0ff'});
  };

  NotesWidget.prototype.MarkAsModified = function () {
    if (this.ModifiedCallback) {
      this.ModifiedCallback();
    }
    this.Modified = true;
  };

  NotesWidget.prototype.MarkAsNotModified = function () {
    if (this.ModifiedClearCallback) {
      this.ModifiedClearCallback();
    }
    this.Modified = false;
  };

  NotesWidget.prototype.SetRootNote = function (rootNote) {
    if (this.UpdateTimer) {
      clearTimeout(this.UpdateTimer);
      this.Update();
    }
        // this.Display.SetNote();

    this.RootNote = rootNote;
    this.DisplayRootNote();

    this.UpdateQuestionMode();
  };

    // TODO:
    // Hmmmm.  I do not think this is used yet.
    // SA.SaveButton setup should not be here though.
  NotesWidget.prototype.EditOn = function () {
    SA.SaveButton
            .prop('title', 'save to database')
            .attr('src', SA.ImagePathUrl + 'save22.png')
            .click(function () { self.SaveCallback(); });
    this.AddViewButton.show();
    this.TextEditor.EditOn();
  };

  NotesWidget.prototype.EditOff = function () {
    SA.SaveButton
            .prop('title', 'edit view')
            .attr('src', SA.ImagePathUrl + 'text_edit.png')
            .click(function () { self.EditOn(); });
    this.AddViewButton.hide();
    this.TextEditor.EditOff();

        /*
          .. note camera buttons....
          .. note title entry (content editable.) ....
          .. note remove button ...
          .. link and delete button ...
          .. Stack stuff ...
        */
  };

  NotesWidget.prototype.SaveCallback = function (finishedCallback) {
        // Process containers for diagnosis ....
    SA.AddHtmlTags(this.TextEditor.TextEntry);

    SA.display.RecordAnnotations();

    var note = this.GetCurrentNote();
    if (note) {
            // Lets try saving the camera for the current note.
            // This is a good comprise.  Do not record the camera
            // every time it moves, but do record it when the save button
            // is pressed.  This is ok, now that view links are visibly
            // selected. However, It is still not really obvious what will happen.
      note.RecordView(this.Display);
            // Record view does this too.
            // note.RecordAnnotations(this.Display);
    }

        // Root saves all the children with it.
        // There is always a root note.  Being over cautious.
        // May need to save text of the root note because it is displayed
        // even when view/camera links are the current note.
    if (this.RootNote) {
      note = this.RootNote;
    }
    note.NotesPanelOpen = (SA.resizePanel && SA.resizePanel.Visibility);
    var self = this;
    note.Save(function () {
      self.Modified = false;
      if (finishedCallback) {
        finishedCallback();
      }
    });
  };

    // ------------------------------------------------------------------------------

  NotesWidget.prototype.GetCurrentNote = function () {
    return this.Display.GetNote();
  };

  NotesWidget.prototype.SaveBrownNote = function () {
    // Create a new note.
    var note = new SA.Note();
    note.RecordView(this.Display);

    // This is not used and will probably be taken out of the scheme,
    note.SetParent(this.GetCurrentNote());
  };

    // Randomize the order of the children
  NotesWidget.prototype.RandomCallback = function () {
    var note = this.GetCurrentNote();
    note.Children.sort(function (a, b) { return Math.random() - 0.5; });
    note.UpdateChildrenGUI();
  };

    // Called when a new slide/view is loaded.
  NotesWidget.prototype.DisplayRootNote = function () {
    if (!this.RootNote) { return; }

        // Set the state of the notes widget.
        // Should we ever turn it off?
    if (SA.resizePanel) {
      SA.resizePanel.SetVisibility(this.RootNote.NotesPanelOpen, 0.0);
    }

    this.TextEditor.LoadNote(this.RootNote);
    this.LinksRoot.empty();
    this.RootNote.DisplayGUI(this.LinksRoot);
    this.SetNote(this.RootNote);

        // Add an obvious way to add a link / view to the root note.
    if (SA.Edit) {
      var self = this;
      this.AddViewButton
                .appendTo(this.LinksDiv)
                .click(function () {
                  var parentNote = SA.notesWidget.RootNote;
                  var childIdx = parentNote.Children.length;
                  var childNote = parentNote.NewChild(childIdx, 'New View');
                    // Setup and save
                  childNote.RecordView(self.Display);
                    // We need to save the note to get its Id (for the link div).
                  childNote.Save();
                  parentNote.UpdateChildrenGUI();
                  this.Display.SetNote(childNote);
                    // self.SetNote(childNote);
                });
    }
        // Default to old style when no text exists (for backward compatability).
    if (this.RootNote.Text === '') {
      this.TabbedWindow.ShowTabDiv(this.LinksDiv);
    } else {
      this.TabbedWindow.ShowTabDiv(this.TextDiv);
    }
  };

    // Add a user note to the currently selected notes children.
  NotesWidget.prototype.NewCallback = function () {
    var note = this.GetCurrentNote();
    var childIdx = 0;
    if (note.Parent) {
      var idx = note.Children.indexOf(note);
      if (idx >= 0) {
        childIdx = idx + 1;
        note = note.Parent;
      }
    }
        // Create a new note.
    var childNote = note.NewChild(childIdx, 'New View');
        // Setup and save
    childNote.RecordView(this.Display);
        // childNote.Save();
    note.UpdateChildrenGUI();

    note.Save();
        // this.SetNote(childNote);
    this.Display.SetNote(childNote);
  };

    // TODO: Make sure method names are consistent.  Update shoud be for
    // updating the GUI. Record should be for moving gui changes to notes.
    // Display the user notes text.
    // We have only one text editor so only display the text form the first
    // user note.
  NotesWidget.prototype.UpdateUserNotes = function () {
        // Even if the userNote did not change, we still need to render the annotation.
        // User notes are always editable. Unless it this the demo account.
    if (SA.User !== '' && SA.VIEWER1) {
      this.UserTextEditor.EditOn();
    }

    var note = this.SelectedNote;
    if (note && note.ViewerRecords.length > 0) {
      var userNote = note.ViewerRecords[note.StartIndex].UserNote;

            // Must display the text.
      this.UserTextEditor.LoadNote(userNote);
    }
  };

  SA.NotesWidget = NotesWidget;
})();

// Tabbed gui.

// Closure namespace
(function () {
  var Tabs = [];

    // If a tabbed object is specified, only one tab for the object
    // will be allowed open at a time.
  function Tab (parent, imageSrc, tabID) {
    var self = this; // trick to set methods in callbacks.
    if (!parent) { alert('null parent: tab'); }
    parent = parent || SA.MainDiv;

    this.Div = $('<div>')
            .appendTo(parent)
            .attr('id', tabID)
            .addClass('sa-view-div');

        // Button has to have the border (not the tab) to be covered by Div.
    this.Button = $('<img>')
            .appendTo(this.Div)
            .attr('type', 'image')
            .attr('src', imageSrc)
            .addClass('sa-view-button')
            .on('click touchstart', function () { self.TogglePanel(); })
            .attr('draggable', 'false')
            .on('dragstart', function () {
              return false;
            });

    this.Panel = $('<div>')
            .appendTo(this.Div)
            .hide()
            .addClass('sa-view-panel');

    Tabs.push(this);

        // I need to maintain this state even when the whole tab is not
        // visible.
    this.PanelOpen = false;
  }

  Tab.prototype.show = function () {
    this.Div.show();
  };
  Tab.prototype.hide = function () {
    this.Div.hide();
  };

  Tab.prototype.TogglePanel = function () {
    if (this.PanelOpen) {
      this.PanelOff();
    } else {
      this.PanelOn();
    }
  };

  Tab.prototype.PanelOn = function () {
    if (this.PanelOpen) { return; }
    this.PanelOpen = true;

        // position returns 0 if panel is hidden.
    this.Panel.show();

        // Close tabs that overlap.
    var minX0 = this.Panel.offset().left;
    var maxX0 = minX0 + this.Panel.outerWidth();
    for (var i = 0; i < Tabs.length; ++i) {
      if (Tabs[i] !== this) {
        var minX1 = Tabs[i].Panel.offset().left;
        var maxX1 = minX1 + Tabs[i].Panel.outerWidth();
                // Overlap
        minX1 = Math.max(minX0, minX1);
        maxX1 = Math.min(maxX0, maxX1);
        if (minX1 < maxX1) {
          Tabs[i].PanelOff();
        }
      }
    }

        // Make the tab look like it is part of the panel.
    this.Button.addClass('sa-active');
  };

  Tab.prototype.PanelOff = function () {
    this.PanelOpen = false;
    this.Panel.hide();
    this.Button.removeClass('sa-active');
  };

    // Export the tab object.
  SA.Tab = Tab;
})();

// Annotation widget toggles annotation visibility and also shows the drawing tools.
// Each view will need its own widget.
// I am less happy about this than the right click menu implementation.
// It would be nice to expand the drawing tools on hover, but
// the toggle for annotation visibility naturally suggests
// the same state should show drawing tool palette.

// Todo:
// - Make an object out of it to support two views.
// - Change behavior of text widget to first drag an arrow when created.
// - eliminate polyLine vertices when they are dragged on top of another vertex.
// or maybe the delete key.

(function () {
  'use strict';

  var ANNOTATION_OFF = 0;
  var ANNOTATION_ON = 2;

  function AnnotationWidget (layer, viewer) {
    var self = this; // trick to set methods in callbacks.
    this.Viewer = viewer;
    this.Layer = layer;
    layer.AnnotationWidget = this;

    SAM.detectMobile();
    this.Tab = new SA.Tab(layer.GetParent(),
                       SA.ImagePathUrl + 'pencil3Up.png',
                       'annotationTab');
    this.Tab.Div
        .css({'box-sizing': 'border-box',
          'position': 'absolute',
          'bottom': '0px',
          'right': '110px'});
        // .prop('title', 'Annotation');

    this.Tab.Panel.addClass('sa-view-annotation-panel');
    this.VisibilityDiv = $('<div>')
        .appendTo(this.Tab.Panel)
        .addClass('sa-view-annotation-vis')
        // .prop('title', 'Visibility')
        .on('click touchstart', function () { self.ToggleVisibility(); });
    this.VisibilityImage = $('<img>')
        .appendTo(this.VisibilityDiv)
        .addClass('sa-view-annotation-vis-img')
        .addClass('sa-active')
        .attr('type', 'image')
        .attr('src', SA.ImagePathUrl + 'toggleswitch.jpg');

    this.TextButton = $('<img>')
        .appendTo(this.Tab.Panel)
        .addClass('sa-view-annotation-button sa-flat-button-active')
        .addClass('sa-active')
        .attr('type', 'image')
        .attr('src', SA.ImagePathUrl + 'Text.png')
        // .prop('title', 'Text')
        .on('click touchstart', function () { self.NewText(); });
    this.CircleButton = $('<img>')
        .appendTo(this.Tab.Panel)
        .addClass('sa-view-annotation-button sa-flat-button-active')
        .addClass('sa-active')
        .attr('type', 'image')
        .attr('src', SA.ImagePathUrl + 'Circle.png')
        // .prop('title', 'Circle')
        .on('click touchstart', function () { self.NewCircle(); });
    this.RectButton = $('<img>')
        .appendTo(this.Tab.Panel)
        .addClass('sa-view-annotation-button sa-flat-button-active')
        .addClass('sa-active')
        .attr('type', 'image')
        .attr('src', SA.ImagePathUrl + 'rectangle.gif')
        // .prop('title', 'Rectangle')
        .on('click touchstart', function () { self.NewRect(); });
    this.GridButton = $('<img>')
        .appendTo(this.Tab.Panel)
        .addClass('sa-view-annotation-button sa-flat-button-active')
        .addClass('sa-active')
        .attr('type', 'image')
        .attr('src', SA.ImagePathUrl + 'grid.png')
        // .prop('title', 'Grid')
        .on('click touchstart', function () { self.NewGrid(); });
    this.PolylineButton = $('<img>')
        .appendTo(this.Tab.Panel)
        .addClass('sa-view-annotation-button sa-flat-button-active')
        .addClass('sa-active')
        .attr('type', 'image')
        .attr('src', SA.ImagePathUrl + 'FreeForm.gif')
        // .prop('title', 'Polygon')
        .on('click touchstart', function () { self.NewPolyline(); });
    this.PencilButton = $('<img>')
        .appendTo(this.Tab.Panel)
        .addClass('sa-view-annotation-button sa-flat-button-active')
        .addClass('sa-active')
        .attr('type', 'image')
        // .prop('title', 'Pencil')
        .attr('src', SA.ImagePathUrl + 'Pencil-icon.jpg')
        .on('click touchstart', function () { self.NewPencil(); });
    this.LassoButton = $('<img>')
        .appendTo(this.Tab.Panel)
        .addClass('sa-view-annotation-button sa-flat-button-active')
        .addClass('sa-active')
        .attr('type', 'image')
        .attr('src', SA.ImagePathUrl + 'select_lasso.png')
        // .prop('title', 'Lasso')
        .on('click touchstart', function () { self.NewLasso(); });
    if (window.SA && this.Viewer) {
      this.SectionsButton = $('<img>')
            .appendTo(this.Tab.Panel)
            .addClass('sa-view-annotation-button sa-flat-button-active')
            .addClass('sa-active')
            .attr('type', 'image')
            .attr('src', SA.ImagePathUrl + 'sections.png')
            // .prop('title', 'Segment')
            .on('click touchstart', function () { self.DetectSections(); });
    }
    /*
    this.FillButton = $('<img>')
        .appendTo(this.Tab.Panel)
        .css({'height': '28px',
              'opacity': '0.6',
              'margin': '1px',
              'border-style': 'outset',
              'border-radius': '4px',
              'border-thickness':'2px'})
        .attr('type','image')
        .attr('src',SA.ImagePathUrl+"brush1.jpg")
        .on('click touchstart', function(){self.NewFill();});
        */
  }

// Show hide the tool tab button
  AnnotationWidget.prototype.show = function () {
    this.Tab.show();
  };

  AnnotationWidget.prototype.hide = function () {
    this.Tab.hide();
  };

  AnnotationWidget.prototype.SetVisibility = function (visibility) {
    if (this.Layer.GetVisibility() === visibility) {
      return;
    }

    // Hack to make all stack viewers share a single annotation visibility
    // flag.
    if (SA.notesWidget) {
      var note = SA.notesWidget.GetCurrentNote();
      if (note && note.Type === 'Stack') {
        for (var i = 0; i < note.ViewerRecords.length; ++i) {
          note.ViewerRecords[i].AnnotationVisibility = visibility;
        }
      }
    }

    if (this.VisibilityImage) {
      if (visibility === ANNOTATION_OFF) {
        this.VisibilityImage.css({'top': '-30px'});
      } else {
        this.VisibilityImage.css({'top': '1px'});
      }
    }

    this.Layer.SetVisibility(visibility);
    this.Layer.EventuallyDraw();
  };

  AnnotationWidget.prototype.GetVisibility = function () {
    return this.Layer.GetVisibility();
  };

  AnnotationWidget.prototype.ToggleVisibility = function () {
    var vis = this.GetVisibility();
    if (vis === ANNOTATION_OFF) {
      vis = ANNOTATION_ON;
    } else {
      vis = ANNOTATION_OFF;
    }
    this.SetVisibility(vis);
    if (window.SA) { SA.RecordState(); }
  };

  AnnotationWidget.prototype.TogglePanel = function () {
    this.Panel.toggle();
    if (this.Panel.is(':visible')) {
      this.TabButton.addClass('sa-active');
    } else {
        // Should we deactivate any active widget tool?
      this.TabButton.removeClass('sa-active');
    }
  };

// I would like to change the behavior of this.
// First slide the arrow, then pop up the dialog to set text.
  AnnotationWidget.prototype.NewText = function () {
    var button = this.TextButton;
    var widget = this.ActivateButton(button, SAM.TextWidget);
    // The dialog is used to set the initial text.
    widget.ShowPropertiesDialog();
  };

// Probably want a singleton pencil.
  AnnotationWidget.prototype.NewPencil = function () {
    var button = this.PencilButton;
    this.ActivateButton(button, SAM.PencilWidget);
  };

  AnnotationWidget.prototype.NewLasso = function () {
    var button = this.LassoButton;
    this.ActivateButton(button, SAM.ImageWidget);
  };

  AnnotationWidget.prototype.NewPolyline = function () {
    var button = this.PolylineButton;
    this.ActivateButton(button, SAM.PolylineWidget);
  };

  AnnotationWidget.prototype.NewCircle = function () {
    var button = this.CircleButton;
    this.ActivateButton(button, SAM.CircleWidget);
  };

  AnnotationWidget.prototype.NewRect = function () {
    var button = this.RectButton;
    this.ActivateButton(button, SAM.RectWidget);
  };

  AnnotationWidget.prototype.NewGrid = function () {
    var button = this.GridButton;
    var widget = this.ActivateButton(button, SAM.GridWidget);
    var cam = this.Layer.GetCamera();
    var fp = cam.GetWorldFocalPoint();
    // Square grid elements determined by height
    widget.Grid.Origin = [fp[0], fp[1], 0.0];
    widget.Grid.Orientation = cam.GetWorldRotation();
    this.Layer.DeactivateWidget(widget);
  };

  AnnotationWidget.prototype.NewFill = function () {
    var button = this.FillButton;
    var widget = this.ActivateButton(button, SAM.FillWidget);
    widget.Initialize();
  };

// Boilerplate code that was in every "newWidget" method.
  AnnotationWidget.prototype.ActivateButton = function (button, WidgetFunction) {
    var widget = this.Layer.ActiveWidget;
    if (widget) {
      if (button.Pressed) {
            // The user pressed the button again (while it was active).
        widget.Deactivate();
        return;
      }
        // This call sets pressed to false as a side action..
      widget.Deactivate();
    }
    button.Pressed = true;
    button.addClass('sa-active');

    this.SetVisibility(ANNOTATION_ON);
    widget = new WidgetFunction(this.Layer, true);
    this.Layer.ActivateWidget(widget);

    // Button remains "pressed" until the circle deactivates.
    widget.DeactivateCallback =
        function () {
          button.removeClass('sa-active');
          widget.DeactivateCallback = undefined;
          button.Pressed = false;
        };
    // Keep track of annotation created by students
    // without edit
    // permission.
    if (!SA.Edit) {
      this.UserNoteFlag = true;
    }
    if (SA.notesWidget && SA.notesWidget.IsUserTextTabOpen()) {
      widget.UserNoteFlag = true;
    }
    return widget;
  };

  AnnotationWidget.prototype.DetectSections = function () {
    if (!window.SA) { return; }

    var widget = this.Layer.GetActiveWidget();
    var button = this.SectionsButton;
    if (widget) {
      if (button.Pressed) {
        // The user pressed the button again (while it was active).
        widget.Deactivate();
        return;
      }
      // This call sets pressed to false as a side action.
      widget.Deactivate();
    }
    button.Pressed = true;
    button.addClass('sa-active');

    // See if a SectionsWidget already exists.
    widget = null;
    var widgets = this.Layer.GetWidgets();
    for (var i = 0; i < widgets.length && widget == null; ++i) {
      var w = widgets[i];
      // if (w instanceOf SectionsWidget) {
      if (w.Type === 'sections') {
        widget = w;
      }
    }
    if (widget == null) {
      // Find sections to initialize sections widget.
      widget = new SA.SectionsWidget(this.Layer, this.Viewer, false);
      widget.ComputeSections(this.Viewer);
      if (widget.IsEmpty()) {
        this.Layer.RemoveWidget(widget);
        button.removeClass('sa-active');
        button.Pressed = false;
        return;
      }
    }

    widget.SetActive(true);
    widget.DeactivateCallback =
      function () {
        button.removeClass('sa-active');
        widget.DeactivateCallback = undefined;
        button.Pressed = false;
      };
  };

  SA.AnnotationWidget = AnnotationWidget;
})();

// This "widget" implements undo and redo as well as saving states in the database for a recording of a session.
// I save the recording state as a cookie so that the user can change slides or even sessions.
// I am going to have a separate recording collection.
// Each recording will be a single object.
// They will be tagged with start time, end time, user ID and a name (autogenerated or entered by user).

// NOTES:
// I will have to think about this ...
// save state vs. save delta state.
// State is simple .... Supports undo better .... Start with this.

// Maybe students can link to the instructor recording session.  The could add notes which are added to the recording.

// It might be nice to know where the mouse is pointing at all times.  We need a pointing tool. That is many events though.  LATER....

// Design issue:
// Should I save the state at the end of a move or the beginning?  I chose end.  Although beginning is easier,
// I like just popping the last state off the TIME_LINE and pushing to the REDO_STACK

// ------------------------------------------------------------------------------
// Records are now being used for notes.  Since page record may contain
// information about current note, I am using ViewerRecord as a shared object.

(function () {
  'use strict';

  SA.RECORDER_WIDGET = null;

  function ViewerRecord () {
    this.AnnotationVisibility = 0;
    this.Annotations = [];
    // UserNotes are bound to image ids so the need to be stored in
    // viewer records. They will always have one viewer record of the
    // their own. They may have children links ....
    this.UserNote = null;
  }

    // For copy slide in presentatations.  Serialize / load messup image.
  ViewerRecord.prototype.DeepCopy = function (source) {
    this.AnnotationVisibility = source.AnnotationVisibility;
    this.Annotations = JSON.parse(JSON.stringify(source.Annotations));
    this.Camera = new SAM.Camera();
    this.Camera.DeepCopy(source.Camera);
    this.Image = source.Image;
    this.OverViewBounds = source.OverViewBounds.slice(0);
    this.UserNote = source.UserNote;
  };

  // I am still trying to figure out a good pattern for loading
  // objects from mongo.
  // Cast to a ViewerObject by setting its prototype does not work on IE
  ViewerRecord.prototype.Load = function (obj) {
    if (!obj.Image.units && obj.Image.filename) {
      var tmp = obj.Image.filename.split('.');
      var ext = tmp[tmp.length - 1];
      if (ext === 'ptif') {
        obj.Image.spacing = [0.25, 0.25, 1.0];
        obj.Image.units = '\xB5m'; // um / micro meters
      }
    }

    if (!obj.Camera) {
      var bds = obj.Image.bounds;
      if (bds) {
        obj.Camera = {FocalPoint: [(bds[0] + bds[1]) / 2, (bds[2] + bds[3]) / 2],
          Height: bds[3] - bds[2],
          Width: bds[1] - bds[0],
          Roll: 0};
      }
    }

    for (var ivar in obj) {
      this[ivar] = obj[ivar];
    }
    if (this.OverviewBounds) {
      this.OverViewBounds = obj.OverviewBounds;
      delete this.OverviewBounds;
    }

    if (this.Camera.Width === undefined) {
      this.Camera.Width = this.Camera.Height * 1.62;
    }

    if (!this.OverViewBounds) {
      this.OverViewBounds = this.Image.bounds;
    }

    if (this.Annotations) {
      for (var i = 0; i < this.Annotations.length; ++i) {
        var a = this.Annotations[i];
        if (a && a.color) {
          a.color = SAM.ConvertColor(a.color);
        }
      }
    }

    if (this.Transform) {
      var t = new SA.PairTransformation();
      t.Load(this.Transform);
      this.Transform = t;
    }

    // Anytime thie image changes, we have to set the user note.
    if (this.UserNote) {
      // Will this ever happen?
      // Should we save the old if it does?
      // For now, let the caller worry about it.
      console.log('Loading over a user note');
    }

    if (!this.UserFlag) {
      if (!this.UserNote || this.UserNote.Parent !== this.Image._id) {
        // This returns a note if it has already been loaded.
        this.UserNote = SA.GetUserNoteFromImageId(this.Image._id);
        if (!this.UserNote) {
          this.UserNote = new SA.Note();
          this.UserNote.Parent = this.Image._id;
          // Copy the camera.
          var record = new SA.ViewerRecord();
          record.Camera = new SAM.Camera();
          record.Camera.DeepCopy(this.Camera);
          record.Image = this.Image;
          record.OverViewBounds = this.OverViewBounds.slice(0);
                    // Records of usernotes should not have usernotes
          record.UserFlag = true;
          this.UserNote.ViewerRecords = [record];
          this.UserNote.Type = 'UserNote';
          // User notes slowing down stack loading.
          // Make them load on demand.
        }
      }
    }
  };

  // Move to note.js
  ViewerRecord.prototype.RequestUserNote = function () {
    if (!this.UserNote) {
      return;
    }
    if (this.UserNote.LoadState !== 0) {
      return;
    }

    // TODO: Move this to note.js
    this.UserNote.LoadState = 1; // REQUESTED

    var self = this;
    $.ajax({
      type: 'get',
      url: '/webgl-viewer/getusernotes',
      data: {'imageid': this.UserNote.Parent},
      success: function (data, status) { self.LoadUserNote(data); },
      error: function () {
        SA.Debug('AJAX - error() : getusernotes');
        if (self.UserNote) {
          // TODO: Do not add notes to the SA.Notes
          // array until they are loaded.  Figure out
          // why this ajax call is failing for HM stack.
          SA.DeleteNote(self.UserNote);
          delete self.UserNote;
        }
      }
    });
  };

  // Move to note.js
  ViewerRecord.prototype.LoadUserNote = function (data) {
    if (data.Notes.length === 0) {
      return;
    }

    var userNote = this.UserNote;
    var noteData = data.Notes[0];

    // This should not happen, but if it does, merge notes as best as possible.
    if (data.Notes.length > 1) {
      SA.Debug('Warning: More than one user note for the same image..');
      for (var i = 1; i < data.Notes.length; ++i) {
                // TODO: line break.
                // TODO: Remove the duplicate note in the database.
        noteData.Text += '<br>' + data.Notes[i].Text;
        noteData.ViewerRecords[0].Annotations =
                    noteData.ViewerRecords[0].Annotations.concat(
                        data.Notes[i].ViewerRecords[0].Annotations);
      }
    }
    // If in the rare case that the user note took a long time to load
    // and user text or annotations were added while waiting, merge
    // them.
    if (userNote.Text !== '') {
      noteData.Text = userNote.Text + '<br>' + noteData.Text;
    }
    if (userNote.ViewerRecords[0].Annotations.length > 0) {
      noteData.ViewerRecords[0].Annotations =
                noteData.ViewerRecords[0].Annotations.concat(
                        userNote.ViewerRecords[0].Annotations);
    }

    userNote.Load(noteData);

    // The new notes need to be displayed.
    // I do not like that this is global. We could have callbacks????
    SA.UpdateUserNotes();
  };

  ViewerRecord.prototype.CopyViewer = function (viewer) {
    var cache = viewer.GetCache();
    if (!cache) {
      this.Camera = null;
      this.AnnotationVisibility = false;
      this.Annotations = [];
      return;
    }

    this.OverViewBounds = viewer.GetOverViewBounds();

    this.OverViewBounds = viewer.GetOverViewBounds();
    this.Image = cache.Image;
    this.UserNote = SA.GetUserNoteFromImageId(this.Image._id);
    this.Camera = viewer.GetCamera().Serialize();

    // TODO: get rid of this hack somehow. Generalize layers?
    var annotationLayer = viewer.Layers[0];
    if (!annotationLayer) { return; }

    this.AnnotationVisibility = annotationLayer.GetVisibility();
    this.Annotations = [];

    var widgets = annotationLayer.GetWidgets();
    for (var i = 0; i < widgets.length; ++i) {
      this.Annotations.push(widgets[i].Serialize());
    }
  };

  // For stacks.  A reduced version of copy view.
  ViewerRecord.prototype.CopyAnnotations = function (viewer, userNoteFlag) {
    this.Annotations = [];
    // TODO: get rid of this hack somehow. Generalize layers?
    if (viewer.Layers.length === 0) { return; }
    var annotationLayer = viewer.Layers[0];
    if (!annotationLayer) { return; }
    var widgets = viewer.Layers[0].GetWidgets();
    for (var i = 0; i < widgets.length; ++i) {
      var widget = widgets[i];
      // Keep user note annotations separate from other annotations
      // if ((userNoteFlag && widget.UserNoteFlag)) ||
      //    (!userNoteFlag && !widget.UserNoteFlag)){ // ! exclusive or.
      widget.UserNoteFlag = widget.UserNoteFlag || false;
      if (userNoteFlag === widget.UserNoteFlag) { // ! exclusive or.
        var o = widgets[i].Serialize();
        if (o) {
          this.Annotations.push(o);
        }
      }
    }
  };

  // I am not sure we need to serialize.
  // The annotations are already in database form.
  // Possibly we need to restrict which ivars get into the database.
  ViewerRecord.prototype.Serialize = function () {
    var rec = {};
    rec.Image = this.Image._id;
    rec.Database = this.Image.database;
    rec.NumberOfLevels = this.Image.levels;
    rec.Camera = this.Camera;
        // deep copy
    if (this.Annotations) {
      rec.Annotations = JSON.parse(JSON.stringify(this.Annotations));
    }
    rec.AnnotationVisibility = this.AnnotationVisibility;

    if (this.OverViewBounds) {
      rec.OverViewBounds = this.OverViewBounds;
    }

    if (this.Transform) {
      rec.Transform = this.Transform.Serialize();
    }

    return rec;
  };

  // This is a helper method to start preloading tiles for an up coming view.
  ViewerRecord.prototype.LoadTiles = function (viewport) {
    var cache = SA.FindCache(this.Image);
    // TODO:  I do not like the fact that we are keeping a serialized
    // version of the camera in the record object.  It should be a real
    // camera that is serialized when it is saved.
    var cam = new SAM.Camera();
    cam.Load(this.Camera);
    cam.SetViewport(viewport);
    cam.ComputeMatrix();

        // Load only the tiles we need.
    var tiles = cache.ChooseTiles(cam, 0, []);
    for (var i = 0; i < tiles.length; ++i) {
      SA.LoadQueueAddTile(tiles[i]);
    }
  };

  // legacy
  SA.RecordState = function () {
    if (SA.RECORDER_WIDGET) {
      SA.RECORDER_WIDGET.RecordState();
    }
  };

  // display is a set of viewers (like DualViewWidet)
  var RecorderWidget = function (display) {
    if (!SA.RECORDER_WIDGET) {
      SA.RECORDER_WIDGET = this;
    }

    var self = this;
    this.Display = display;
    this.RecordTimerId = 0;

    this.TimeLine = [];
    this.RedoStack = [];
    this.Recording = true;
    this.RecordingName = '';

    // The recording button indicates that recording is in
    // progress and also acts to stop recording.
    this.RecordButton = $('<img>')
            .appendTo('body')
            .css({
              'opacity': '0.5',
              'position': 'absolute',
              'height': '20px',
              'bottom': '120px',
              'right': '20px',
              'z-index': '1'})
            .attr('src', SA.ImagePathUrl + 'stopRecording2.png')
            .hide()
            .click(function () { self.RecordingStop(); });

    // Optional buttons.  Exposed for testing.
    // Undo (control z) and redo (control y) keys work,
    this.UndoButton = $('<img>').appendTo('body')
            .css({
              'opacity': '0.5',
              'position': 'absolute',
              'height': '30px',
              'bottom': '5px',
              'right': '100px',
              'z-index': '1'})
            .attr('src', SA.ImagePathUrl + 'undo.png')
            .hide()
            .click(function () { alert('undo'); });
    this.RedoButton = $('<img>').appendTo('body').css({
      'opacity': '0.5',
      'position': 'absolute',
      'height': '30px',
      'bottom': '5px',
      'right': '70px',
      'z-index': '1'})
            .attr('src', SA.ImagePathUrl + 'redo.png')
            .hide()
            .click(function () { alert('REDO'); });

    this.RecordingName = SA.getCookie('SlideAtlasRecording');
    if (this.RecordingName !== undefined && this.RecordingName !== 'false') {
      this.Recording = true;
      this.UpdateGUI();
    }

    // We have to start with one state (since we are recording states at the end of a move).
    this.RecordState();
  };

  // Should we name a recording?
  RecorderWidget.prototype.UpdateGUI = function () {
    if (this.Recording) {
      this.RecordButton.show();
    } else {
      this.RecordButton.hide();
    }
  };

  // Should we name a recording?
  RecorderWidget.prototype.RecordingStart = function () {
    if (this.Recording) { return; }
    this.Recording = true;
    // Generate a recording name as a placeholder.
    // User should be prompted for a name when recording stops.
    var d = new Date();
    this.RecordingName = 'Bev' + d.getTime();
    SA.setCookie('SlideAtlasRecording', this.RecordingName, 1);
    this.UpdateGUI();
        // Create a new recording object in the database.
    this.RecordState();
  };

  RecorderWidget.prototype.RecordingStop = function () {
    if (!this.Recording) { return; }
    this.Recording = false;
    SA.setCookie('SlideAtlasRecording', 'false', 1);
    this.UpdateGUI();

    // Prompt for a name and if the user want to keep the recording.
  };

  RecorderWidget.prototype.RecordStateCallback = function () {
    if (this.Display.GetNumberOfViewers() === 0) { return; }

    // Timer called this method.  Timer id is no longer valid.
    this.RecordTimerId = 0;
    // Redo is an option after undo, until we save a new state.
    this.RedoStack = [];

    // Create a new note.
    var note = new SA.Note();
    note.Type = 'Record';
    // This will probably have to be passed the viewers.
    note.RecordView(this.Display);

    // The note will want to know its context
    // The stack viewer does not have  notes widget.
    if (SA.display) {
      var parentNote = SA.display.GetNote();
      if (!parentNote || !parentNote.Id) {
        //  Note is not loaded yet.
        // Wait some more
        this.RecordState();
        return;
      }
      // ParentId should be depreciated.
      note.ParentId = parentNote.Id;
      note.SetParent(parentNote);
    }
    // Save the note in the admin database for this specific user.
    $.ajax({
      type: 'post',
      url: '/webgl-viewer/saveusernote',
      data: {'note': JSON.stringify(note.Serialize(true)),
        'col': 'tracking',
        'type': 'Record'},
      success: function (data, status) {
        note.Id = data;
      },
      error: function () {
        // SA.Debug( "AJAX - error() : saveusernote" );
      }
    });

    this.TimeLine.push(note);
    // Remove it from the serachable global list.
    // "Delete" recorder notes.  Once saved, we never user
    // them again. I do not think tileline will be an issue.
    SA.DeleteNote(note);
  };

  // Create a snapshot of the current state and push it on the TIME_LINE stack.
  // I still do not compress scroll wheel zoom, so I am putting a timer event
  // to collapse recording to lest than oner per second.
  RecorderWidget.prototype.RecordState = function () {
    if (this.Display.GetNumberOfViewers() === 0) { return; }
        // Delete the previous pending record timer
    if (this.RecordTimerId) {
      clearTimeout(this.RecordTimerId);
      this.RecordTimerId = 0;
    }
        // Start a record timer.
    var self = this;
    this.RecordTimerId = setTimeout(
            function () { self.RecordStateCallback(); },
            1000);
  };

  RecorderWidget.prototype.GetRecords = function () {
    var self = this;
    $.ajax({
      type: 'get',
      url: '/webgl-viewer/getfavoriteviews',
      data: {'col': 'tracking'},
      success: function (data, status) {
        self.Records = data.viewArray;
      },
      error: function () {
        SA.Debug('AJAX - error() : get records');
      }
    });
  };

  // Create a snapshot of the current state and push it on the TIME_LINE stack.
  // I still do not compress scroll wheel zoom, so I am putting a timer event
  // to collapse recording to lest than oner per second.
  RecorderWidget.prototype.RecordState = function () {
    // Delete the previous pending record timer
    if (this.RecordTimerId) {
      clearTimeout(this.RecordTimerId);
      this.RecordTimerId = 0;
    }
    // Start a record timer.
    var self = this;
    this.RecordTimerId = setTimeout(function () { self.RecordStateCallback(); }, 1000);
  };

  // Move the state back in time.
  RecorderWidget.prototype.UndoState = function () {
    if (this.TimeLine.length > 1) {
      // We need at least 2 states to undo.  The last state gets removed,
      // the second to last get applied.
      var recordNote = this.TimeLine.pop();
      this.RedoStack.push(recordNote);

      // Get the new end state
      recordNote = this.TimeLine[this.TimeLine.length - 1];
      // Now change the page to the state at the end of the timeline.
      SA.SetNote(recordNote);
    }
  };

  // Move the state forward in time.
  RecorderWidget.prototype.RedoState = function () {
    if (this.RedoState.length === 0) {
      return;
    }
    var recordNote = this.RedoStack.pop();
    this.TimeLine.push(recordNote);

    // Now change the page to the state at the end of the timeline.
    recordNote.DisplayView();
  };

  SA.ViewerRecord = ViewerRecord;
  SA.RecorderWidget = RecorderWidget;
})();

// VCR like buttons to get to next/previous note/slide.
// entwined with the notes widget at the moment.

(function () {
  'use strict';

// ------------------------------------------------------------------------------
// I intend to have only one object
  function NavigationWidget (parent, display) {
    this.Display = display;

    // Load the session slides from the localStorage
    this.SlideIndex = 0;
    this.Session = [];
    this.NoteIterator = new SA.NoteIterator();

    var self = this;
    var size = '40px';
    if (SAM.detectMobile()) {
      // fake a tab
      this.Tab = {};
      this.Tab.Panel = $('<div>')
            .appendTo(display.GetViewer(0).GetDiv())
            .hide()
            // .addClass("sa-view-navigation-div ui-responsive");
            .addClass('ui-responsive')
            .css({'position': 'absolute',
              'left': '50px',
              'bottom': '20px',
              'z-index': '5'});
      var panel = this.Tab.Panel;
      this.Tab.show = function () { panel.show(); };
      this.Tab.hide = function () {
        panel.hide();
      };
      // SA.OnStartInteraction( function () { panel.hide();} );
    } else {
      this.Tab = new SA.Tab(parent, SA.ImagePathUrl + 'nav.png', 'navigationTab');
      // this.Tab.Div.prop('title', 'Navigation');
      this.Tab.Div.addClass('sa-view-navigation-div');
      this.Tab.Panel.addClass('sa-view-navigation-panel');

      // Put the stack display in the navigation button
      this.NoteDisplay = $('<div>')
            .appendTo(this.Tab.Div)
            .addClass('sa-view-note')
            .html('');
    }

    this.PreviousSlideButton =
        $('<img>').appendTo(this.Tab.Panel)
        .addClass('sa-view-navigation-button')
        .attr('src', SA.ImagePathUrl + 'previousSlide.png')
        // .prop('title', 'Previous Slide. (page-up)')
        .click(function () { self.PreviousSlide(); });

    this.PreviousNoteButton =
        $('<img>').appendTo(this.Tab.Panel)
        .addClass('sa-view-navigation-button')
        .attr('src', SA.ImagePathUrl + 'previousNote.png')
        // .prop('title', 'Previous Note. (p)')
        .click(function () { self.PreviousNote(); });

    this.NextNoteButton =
        $('<img>').appendTo(this.Tab.Panel)
        .addClass('sa-view-navigation-button')
        .attr('src', SA.ImagePathUrl + 'nextNote.png')
        // .prop('title', 'Next Note, (n, space)')
        .click(function () { self.NextNote(); });

    this.NextSlideButton =
        $('<img>').appendTo(this.Tab.Panel)
        .addClass('sa-view-navigation-button')
        .attr('src', SA.ImagePathUrl + 'nextSlide.png')
        // .prop('title', 'Next Slide. (page-down)')
        .css({'z-index': '100'})
        .click(function () { self.NextSlide(); });
    this.NextSlideButton
        .on('touchend', function (event) {
          self.NextSlide();
          return false;
        });

    // TODO: Fix the main css file for mobile.  Hack this until fixed.
    if (SAM.MOBILE_DEVICE) {
      size = '80px';
      if (SAM.MOBILE_DEVICE === 'iPhone') {
        size = '100px';
      }
      this.PreviousSlideButton
            .css({'height': size,
              'width': size,
              'opacity': '0.8'})
            .on('touchend', function () { self.PreviousSlide(); });
      this.PreviousNoteButton
            .css({'height': size,
              'width': size,
              'opacity': '0.8'})
            .on('touchend', function () { self.PreviousNote(); });
      this.NextNoteButton
            .css({'height': size,
              'width': size,
              'opacity': '0.8'})
            .on('touchend', function () { self.NextNote(); });
      this.NextSlideButton
            .css({'height': size,
              'width': size,
              'opacity': '0.8'});
    }

    this.CopyrightWrapper =
        $('<div>').appendTo(parent)
        .css({
          'width': '100%',
          'text-align': 'center'
        }).html();
  }

// Making a stack navigator. Starting to abstract an interface.
  NavigationWidget.prototype.GetNote = function () {
    return this.NoteIterator.GetNote();
  };

  NavigationWidget.prototype.SetInteractionEnabled = function (flag) {
    var self = this;
    if (flag) {
      this.Display.Parent.on(
            'keydown.navigation',
            function (event) {
              return self.HandleKeyDown(event);
            });
    } else {
      this.Display.Parent.off('keydown.navigation');
    }
  };

  NavigationWidget.prototype.HandleKeyDown = function (event) {
    var keyCode = event.keyCode;
    // 34=page down, 78=n, 32=space
    if (keyCode === 34) {
      this.NextSlide();
      return false;
    }
    if (keyCode === 78 || keyCode === 32) {
      this.NextNote();
      return false;
    }
    // 33=page up, 80=p
    if (keyCode === 33) {
      this.PreviousSlide();
      return false;
    }
    if (keyCode === 80) {
      this.PreviousNote();
      return false;
    }

    return true;
  };

  NavigationWidget.prototype.SetNote = function (note) {
    if (this.GetNote() === note) {
      return;
    }

    var self = this;
    // Initialize the session neede to get the next slide.
    if (!this.SessionId) {
      if (SA.Session) {
        this.Session = SA.Session.session.views;
        this.SessionId = SA.Session.sessid;
        this.Update();
      } else if (note.SessionId && SA.RootNote.Type !== 'HTML') {
        this.SessionId = note.SessionId;
        $.ajax({
          type: 'get',
          url: SA.SessionUrl + '?json=true&sessid=' + this.SessionId,
          success: function (data, status) {
            if (self.SessionId !== data.sessid) {
                        // This will never happen.
              console.log('expecting a second session to load.');
              return;
            }
            self.Session = data.session.views;
            self.Update();
          },
          error: function () {
            SA.Debug('AJAX - error() : session');
          }
        });
      }
    } else {
      // Correct an error.  SessionId's are wrong because the
      // notes sessionId is not being updated when a session is
      // copied.
      note.SessionId = this.SessionId;
    }

    this.NoteIterator.SetNote(note);
    this.Update();
  };

  NavigationWidget.prototype.ToggleVisibility = function () {
    this.SetVisibility(!this.Visibility);
  };

  // Used on mobile.
  NavigationWidget.prototype.SetVisibility = function (v) {
    this.Visibility = v;
    if (v) {
      this.Tab.show();
    } else {
      this.Tab.hide();
    }
  };

  NavigationWidget.prototype.Update = function () {
    // Disable prev/next note buttons by default.
    this.PreviousNoteButton.removeClass('sa-active');
    this.NextNoteButton.removeClass('sa-active');
    var note = this.GetNote();
    if (note) {
      for (var i = 0; i < this.Session.length; ++i) {
        if (this.Session[i].id === note.Id) {
          this.SlideIndex = i;
        }
      }

      if (note.Type === 'Stack') {
        // Next note refers to ViewerRecords.
        if (note.StartIndex > 0) {
          note.ViewerRecords[note.StartIndex - 1].LoadTiles([0, 0, 200, 150]);
          this.PreviousNoteButton.addClass('sa-active');
        }
        if (note.StartIndex < note.ViewerRecords.length - 1) {
          note.ViewerRecords[note.StartIndex + 1].LoadTiles([0, 0, 200, 150]);
          this.NextNoteButton.addClass('sa-active');
        }
        if (note.StartIndex < note.ViewerRecords.length - 2) {
          note.ViewerRecords[note.StartIndex + 2].LoadTiles([0, 0, 200, 150]);
        }
      } else {
        // Next note refers to children.
        if (!this.NoteIterator.IsStart()) {
          this.PreviousNoteButton.addClass('sa-active');
        }
        if (!this.NoteIterator.IsEnd()) {
          this.NextNoteButton.addClass('sa-active');
        }
      }
    }

    // Disable and enable prev/next slide buttons so we cannot go past the end.
    if (this.SlideIndex <= 0) {
      this.PreviousSlideButton.removeClass('sa-active');
    } else {
      this.PreviousSlideButton.addClass('sa-active');
    }
    if (this.SlideIndex >= this.Session.length - 1) {
      this.NextSlideButton.removeClass('sa-active');
    } else {
      this.NextSlideButton.addClass('sa-active');
    }

    // Hack because next slide does not with presentations.
    if (SA.RootNote && SA.RootNote.Type === 'HTML') {
      this.PreviousSlideButton.removeClass('sa-active');
      this.NextSlideButton.removeClass('sa-active');
    }
  };

  NavigationWidget.prototype.PreviousNote = function () {
    SA.StackCursorFlag = false;

    // Make sure user not changes are not pending to be saved.
    if (SA.notesWidget) { SA.notesWidget.Flush(); }

    var current = this.GetNote();
    if (current.Type === 'Stack') {
      if (current.StartIndex <= 0) { return; }
      // Move camera
      // Hardcoded for dual display
      var viewer1 = this.Display.GetViewer(1);
      var viewer0 = this.Display.GetViewer(0);
      var cam = viewer0.GetCamera();
      var fp = cam.GetWorldFocalPoint();
      var rot = cam.GetWorldRotation();
      var height = cam.GetHeight();

      this.Display.RecordAnnotations();
      --current.StartIndex;
      // It was too slow to request a long stack of user notes when the
      // stack wasa first loaded.
      current.ViewerRecords[current.StartIndex].RequestUserNote();

      // We need to skip setting the camera.
      SA.display = this.Display;
      SA.SetNote(current);
      SA.UpdateUserNotes();
      // Set the camera after the note has been applied.
      viewer1.SetCamera(fp, rot, height);

      current.DisplayStack(this.Display);
      this.Display.SynchronizeViews(1, current);
      // activate or deactivate buttons.
      this.Update();
      if (this.NoteDisplay) {
        this.NoteDisplay.html('' + current.StartIndex);
      }
      return;
    }

    if (this.NoteIterator.IsStart()) {
      // if not previous notes move to the previous slide
      this.PreviousSlide();
      return;
    }

    SA.display.RecordAnnotations();
    var note = this.NoteIterator.Previous();
    this.SetNote(note);
    this.Update();
    // TODO: Check to make sure the call to this.SetNote(note) does nothing.
    // Hack for presentaitons. Global not set.
    SA.display = this.Display;
    SA.display.RecordAnnotations();
    SA.SetNote(note);
    SA.UpdateUserNotes();
  };

  NavigationWidget.prototype.NextNote = function () {
    SA.StackCursorFlag = false;

    // Make sure user not changes are not pending to be saved.
    if (SA.notesWidget) { SA.notesWidget.Flush(); }

    var current = this.GetNote();
    if (current.Type === 'Stack') {
      if (current.StartIndex >= current.ViewerRecords.length - 1) {
        return;
      }
      // Move camera
      // Hard coded for dual display.
      var viewer0 = this.Display.GetViewer(0);
      var viewer1 = this.Display.GetViewer(1);
      var cam = viewer1.GetCamera();
      var fp = cam.GetWorldFocalPoint();
      var rot = cam.GetWorldRotation();
      var height = cam.GetHeight();

      this.Display.RecordAnnotations();
      ++current.StartIndex;
      // It was too slow to request a long stack of user notes when the
      // stack wasa first loaded.
      current.ViewerRecords[current.StartIndex].RequestUserNote();

      // We need to skip setting the camera.
      SA.display = this.Display;
      SA.SetNote(current);
      SA.UpdateUserNotes();
      // Set the camera after the note has been applied.
      viewer0.SetCamera(fp, rot, height);
      current.DisplayStack(this.Display);
      this.Display.SynchronizeViews(0, current);
      // activate or deactivate buttons.
      this.Update();
      if (this.NoteDisplay) {
        this.NoteDisplay.html('' + current.StartIndex);
      }
      return;
    }

    if (this.NoteIterator.IsEnd()) {
        // If we have no more notes, then move to the next slide.
      this.NextSlide();
      return;
    }

    var note = this.NoteIterator.Next();
    this.Update();
    // TODO: Check to make sure the call to this.SetNote(note) does nothing.
    // Hack for presentaitons. Global not set.
    SA.display = this.Display;
    SA.display.RecordAnnotations();
    SA.SetNote(note);
    SA.UpdateUserNotes();
  };

  NavigationWidget.prototype.PreviousSlide = function () {
    // Make sure user not changes are not pending to be saved.
    if (SA.notesWidget) { SA.notesWidget.Flush(); }

    SA.StackCursorFlag = false;
    // Find the previous slide ( skip presentations)
    var prevSlideIdx = this.SlideIndex - 1;
    while (prevSlideIdx >= 0 &&
           this.Session[prevSlideIdx].Type === 'Presentation') {
      --prevSlideIdx;
    }
    if (prevSlideIdx < 0) { return; }

    var check = true;
    if (SA.notesWidget && SA.notesWidget.Modified && SA.Edit) {
      check = confirm('Unsaved edits will be lost.  Are you sure you want to move to the next slide?');
    }
    if (check) {
      // TODO: Improve the API here.  Get rid of global access.
      if (SA.notesWidget) { SA.notesWidget.MarkAsNotModified(); }
      this.SlideIndex = prevSlideIdx;
      SA.SetNoteFromId(this.Session[this.SlideIndex].id);

      if (this.NoteDisplay) {
        this.NoteDisplay.html('');
      }
    }
  };

  NavigationWidget.prototype.NextSlide = function () {
    // Make sure user not changes are not pending to be saved.
    if (SA.notesWidget) { SA.notesWidget.Flush(); }

    SA.StackCursorFlag = false;
    // Find the next slide ( skip presentations)
    var nextSlideIdx = this.SlideIndex + 1;
    while (nextSlideIdx < this.Session.length &&
           this.Session[nextSlideIdx].Type === 'Presentation') {
      ++nextSlideIdx;
    }
    if (nextSlideIdx >= this.Session.length) { return; }
    var check = true;
    if (SA.notesWidget && SA.notesWidget.Modified) {
      check = confirm('Unsaved edits will be lost.  Are you sure you want to move to the next slide?');
    }
    if (check) {
      if (SA.notesWidget) { SA.notesWidget.MarkAsNotModified(); }
      this.SlideIndex = nextSlideIdx;
      SA.SetNoteFromId(this.Session[this.SlideIndex].id);

      if (this.NoteDisplay) {
        this.NoteDisplay.html('');
      }
    }
  };

// ==============================================================================

// ------------------------------------------------------------------------------
// Iterator to perform depth first search through note tree.
// Collapsed branches (children not visible) are not traversed.
// This iterator is a bit over engineered.  I made it so we can subclasses
// that iterate over internal states.  However, internal states require
// notes so I made an array of answers (which are hidden).
  function NoteIterator (note) {
    this.Note = note;
    this.ChildIterator = null;
  }

  // Because of sorting, the child array gets reset on us.
  // I need a dynamic way to get the Children array based on the state.
  NoteIterator.prototype.GetChildArray = function () {
    if (!this.Note) {
      return [];
    }
    return this.Note.Children;
  };

  // Because of sorting, I have to make the index dynamic
  // and it cannot be stored as an ivar.
  NoteIterator.prototype.GetChildIndex = function () {
    if (this.ChildIterator === null) {
      return -1;
    }
    return this.GetChildArray().indexOf(this.ChildIterator.Note);
  };

  // Get the parent note of the current note.
  // Notes do not keep a pointer to parents.
  // The iterator has this information for active notes.
  NoteIterator.prototype.GetParentNote = function () {
    if (this.ChildIterator === null) {
      // We are at the current note.  Let the caller supply the parent.
      return null;
    }

    var parent = this.ChildIterator.GetParentNote();
    if (parent === null) {
      // This level contains the parent.
      parent = this.Note;
    }

    return parent;
  };

// We use this to see (peek) if next or previous should be disabled.
  NoteIterator.prototype.IsStart = function () {
    if (this.ChildIterator === null) {
      return true;
    }
    return false;
  };

  NoteIterator.prototype.IsEnd = function () {
    if (!this.Note) { return true; }

    // Case note is active.
    if (this.ChildIterator === null) {
      if (this.Note.Children.length > 0 && this.Note.ChildrenVisibility) {
        return false;
      }
      return true;
    }

    // sub answer is active.
    var childIndex = this.GetChildIndex();

    // sub child is active
    if (childIndex === this.GetChildArray().length - 1) {
      return this.ChildIterator.IsEnd();
    }
    return false;
  };

// Parent note is traversed before children.
// Move forward one step.  Return the new note. At end the last note returned again.
// IsEnd method used to detect terminal case.
  NoteIterator.prototype.Next = function () {
    if (!this.Note) { return; }

    // Case 1:  Iterator is on its own node.
    if (this.ChildIterator === null) {
      // Next check for children notes
      if (this.Note.Children.length > 0 && this.Note.ChildrenVisibility) {
        // Move to the first child.
        this.ChildIterator = this.GetChildArray()[0].NewIterator();
        return this.ChildIterator.GetNote();
      }
      // No answers or children: we are at the end.
      return this.Note;
    }

    // Try to advance the child iterator.
    if (!this.ChildIterator.IsEnd()) {
      return this.ChildIterator.Next();
    }

    // Child iterator is finished.
    // Try to create a new iterator with the next child in the array.
    var childIndex = this.GetChildIndex();
    if (childIndex < this.GetChildArray().length - 1) {
      this.ChildIterator = this.GetChildArray()[childIndex + 1].NewIterator();
      return this.ChildIterator.GetNote();
    }

    // We are at the end of the children array.
    return this.ChildIterator.GetNote();
  };

  // Move backward one step.  See "Next" method comments for description of tree traversal.
  NoteIterator.prototype.Previous = function () {
    if (!this.Note) { return; }

    if (this.ChildIterator === null) {
      // At start.
      return this.Note;
    }
    if (!this.ChildIterator.IsStart()) {
      return this.ChildIterator.Previous();
    }

    // Move to the previous child.
    var childIndex = this.GetChildIndex() - 1;
    if (childIndex >= 0) {
      this.ChildIterator = this.GetChildArray()[childIndex].NewIterator();
      this.ChildIterator.ToEnd();
      return this.ChildIterator.GetNote();
    }

    // No more sub notes left.  Move to the root.
    this.ChildIterator = null;
    return this.Note;
  };

  // Move the iterator to the start.
  NoteIterator.prototype.ToStart = function () {
    if (this.ChildIterator) {
      this.ChildIterator = null;
    }
  };

  // Move the iterator to the end. Used in Previous method.
  NoteIterator.prototype.ToEnd = function () {
    if (!this.Note) { return; }

    if (this.Note.Children.length > 0 && this.Note.ChildrenVisibility) {
      this.ChildArray = this.Note.Children;
      var childIndex = this.ChildArray.length - 1;
      this.ChildIterator = this.ChildArray[childIndex].NewIterator();
      return this.ChildIterator.ToEnd();
    }
    // leaf note
    this.ChildArray = null;
    this.ChildIterator = null;
    return this.Note;
  };

  // If the note is not in the tree, Set the note as root.
  // Otherwise, point the iterator to the note in the tree.
  NoteIterator.prototype.SetNote = function (note) {
    if (this.GetNote() === note) { return; }
    // See if the note is in the tree.
    this.ToStart();
    while (true) {
      if (this.GetNote() === note) {
        // Found the note in the tree.
        return;
      }
      if (this.IsEnd()) {
        // not found.  New tree.
        this.ToStart();
        this.Note = note;
        // BIG Hack here.
        // I got rid of a special SetRootNote call too soon.
        // if (SA.notesWidget) {
        //    SA.notesWidget.SetRootNote(note);
        // }
        return;
      }
      this.Next();
    }
  };

  NoteIterator.prototype.GetNote = function () {
    if (this.ChildIterator !== null) {
      return this.ChildIterator.GetNote();
    }
    return this.Note;
  };

  SA.NoteIterator = NoteIterator;
  SA.NavigationWidget = NavigationWidget;
})();

// Testing annotation widget with touch events.

(function () {
  'use strict';

// ------------------------------------------------------------------------------
// I intend to have only one object
  function MobileAnnotationWidget () {
    var size = '80px';
    if (SAM.detectMobile() === 'iPhone') {
      size = '100px';
    }

    // TODO: The css style is not working for mobile devices. fix it.
    // for now, hack back in the size dependancies.

    var self = this;
    this.Div =
        $('<div>').appendTo(SA.VIEWERS[0].GetDiv())
        .css({'position': 'absolute',
          'right': '0px',
          'bottom': '0px',
          'z-index': '5'});

    // .addClass("sa-view-annotation-div ui-responsive")

    // I cannot get touch events that start in the image to continue in
    // the document / viewer.  Press to place, then interact to position.
    this.CircleButton = $('<img>')
        .appendTo(this.Div)
        .css({'height': size,
          'width': size,
          'opacity': '0.6',
          'margin': '1px',
          'padding': '5px'})
        // .addClass("sa-view-annotation-button")
        .attr('src', SA.ImagePathUrl + 'Circle128.jpg')
        .on('touchend', function () { self.CircleCallback(); });
    this.CircleButton.prop('title', 'Circle Annotation');

    this.TextButton = $('<img>')
        .appendTo(this.Div)
        .css({'height': size,
          'width': size,
          'opacity': '0.6',
          'margin': '1px',
          'padding': '5px'})
        // .addClass("sa-view-annotation-button")
        .attr('src', SA.ImagePathUrl + 'Text128.jpg')
        .on('touchend', function () { self.TextCallback(); });
    this.TextButton.prop('title', 'Text Annotation');

    this.Visibility = false;

    // SA.OnStartInteraction( function () { self.SetVisibility(false);} );
  }

  MobileAnnotationWidget.prototype.CircleCallback = function () {
    console.log('New circle');

    // Hard code only a single view for now.
    this.Layer = SA.VIEWERS[0].GetAnnotationLayer();

    if (this.Layer.ActiveWidget !== undefined) {
      this.Layer.ActiveWidget.Deactivate();
    }
    var widget = new SAM.CircleWidget(this.Layer, false);
    var cam = this.Layer.GetCamera();
    var fp = cam.GetWorldFocalPoint();

    widget.Shape.Origin = fp;
    widget.Shape.Radius = cam.Height / 4.0;
    widget.Shape.UpdateBuffers(this.Layer.AnnotationView);
    this.Layer.EventuallyDraw();

    this.Layer.SetVisibility(true);
  };

  MobileAnnotationWidget.prototype.TextCallback = function () {
    this.Layer = SA.VIEWERS[0].GetAnnotationLayer();
    var widget = this.Layer.ActiveWidget;
    if (widget) {
      widget.Deactivate();
    }

    this.Layer.SetVisibility(true);
    widget = new SAM.TextWidget(this.Layer, '');
    var cam = this.Layer.GetCamera();
    var fp = cam.getWorldFocalPoint();
    widget.Text.Anchor = fp;
    this.Layer.EventuallyDraw();

    this.Layer.ActivateWidget(widget);

    // The dialog is used to set the initial text.
    widget.ShowPropertiesDialog();
  };

// Show the tool gui.
  MobileAnnotationWidget.prototype.SetVisibility = function (v) {
    this.Visibility = v;
    if (v) {
      this.Div.show();
    } else {
      this.Div.hide();
    }
  };

// Toggle the tool gui.
  MobileAnnotationWidget.prototype.ToggleVisibility = function () {
    this.SetVisibility(!this.Visibility);
  };

  SA.MobileAnnotationWidget = MobileAnnotationWidget;
})();


// ==============================================================================
// saElement: borders, shadow, drag and resize
// saRectangle: BackgroundColor / gradient.
// saText: padding, textSize, Line spacing, (in future font)
// saLightBox, click to expand.
// saLightBoxViewer, expand to a viewer. Manage turning events on and off.

// Abstracting the question.  It will not be editable text, but can be
// changed from a properties dialog. Subclass of rectangle.
// TODO:
// Bug: Pasting into textEditor leaves edit buttons hanging around.

// Clean up the whole editable / clickable / lock state.
//    Browser slides are completely passive.

// Modes:
// Edit:
//    Editable: on, off
//    draggable, deletable, properties menu, resizable, record viewer, text
//    click to edit, cursor changing.
// Student:
//    Interactive: on, off.
//    Click to expand viewer and image.
//    Interactive border.
// Thumb:
//    Both Editable and Interactive off.

// Insert / copy html note into presentation.
// Display html note "Text" in the view browser.
// LoadViewChildren has to tolerate notes with no viewer record (get rid of
//   image db stuff?

// make sure html notes still work.
// Copyright management not working for dual display.
// Open dual viewer: overview bounds different (foot)
// Open lightbox viewers do not consume key events.
// Save changes to a stack.
// Resize puts edit buttons in the wrong location.

// bug: question buttons div are active on load

// Make sure the active border stays on during resize.
// Finish pan zoom of presentation.
// Stack viewer / lightbox
// Question: Interactive

// Edit questions/
// Convert text to an SaElement.
// Option to hide with answers.
// Interactive question.
// Shuffle questions as note Text. No shuffle when answers are off.

// Replace an image. presesntation will not save.Intertent
//   WHen you delete an image, the next image should go where the last was.
// Menu when not logged in.

// ==============================================================================
// Sort of a superclass for all presentation elements.
// Start with draggable, resizable, deletable and click.
// Highlight border to indicate an active element.
// args = {click: function (dom) {...}
//         delete: function (dom) {...}
//         editable: true,
//         interactive: true,
//         aspectRatio: false}
// args = "dialog" => open the dialog.

(function () {
  'use strict';

  jQuery.prototype.saElement = function (arg1) { // 'arguments' handles extras.
    for (var i = 0; i < this.length; ++i) {
      if (!this[i].saElement) {
        var helper = new SaElement($(this[i]));
            // Add the helper as an instance variable to the dom object.
        this[i].saElement = helper;
        $(this[i]).addClass('sa-element');
      }
      this[i].saElement.ProcessArguments(arguments);
    }
    return this;
  };

  // TODO: Rename Edit
  function SaElement (div) {
    var self = this;

    this.Position = 'absolute';
    this.Editable = false;
    this.Interactive = true;
    this.Div = div;
    this.ClickCallback = null;
    this.DeleteCallback = null;
    // Hack to keep the element active.
    this.LockActive = false;
    this.Div
        .css({'overflow': 'hidden'}) // for borderRadius
        .hover(
            function () { self.ActiveOn(); },
            function () { self.ActiveOff(); });

    // I cannot move this to EditOn because we need the mouse down event
    // to detect clicks.
    this.Div
        .on('mousedown.element',
              function (event) {
                return self.HandleMouseDown(event);
              })
        .on('tap.element',
            function (event) {
              if (this.ClickCallback) {
                (this.ClickCallback)(this.Div[0]);
                return false;
              }
              return true;
            });

    // I could not get the key events working.  I had to restart the browser.
    this.ButtonDiv = $('<div>')
        .addClass('sa-edit-gui') // Remove before saHtml save.
        .css({'height': '20px',
          'position': 'absolute',
          'top': '0px',
          'left': '0px',
          'cursor': 'auto',
          'z-index': '1000'})
        // Block the expand event when the delete button is pressed.
        .mousedown(function () { return false; });
    this.DeleteButton = $('<img>')
        .appendTo(this.ButtonDiv)
        .addClass('editButton')
        .css({'height': '16px',
              // static put the buttons out of parent???????
              // Hack the positions with absolute
          'position': 'absolute',
          'top': '0px',
          'left': '0px'})
        .attr('src', SA.ImagePathUrl + 'remove.png')
        .prop('title', 'delete');
    this.MenuButton = $('<img>')
        .appendTo(this.ButtonDiv)
        .addClass('editButton')
        .css({'height': '16px',
              // static put the buttons out of parent???????
              // Hack the positions with absolute
          'position': 'absolute',
          'top': '0px',
          'left': '20px'})
        .attr('src', SA.ImagePathUrl + 'Menu.jpg')
        .prop('title', 'properties');

    this.InitializeDialog();
  }

  // This changes the border to active color.
  SaElement.prototype.ActiveOn = function () {
    var self = this;
    if (!this.Interactive) { return true; }
    if (!this.SavedBorder) {
      this.SavedBorder = this.Div[0].style.border;
    }
    this.Div.css({'border-color': '#7BF'});
    if (this.Editable) {
      this.ButtonDiv.appendTo(this.Div);
        // Remove an element destroys bindings.
      this.MenuButton
            .on('mousedown',
                function () {
                  self.OpenDialog();
                  return false;
                });
      this.DeleteButton
            .on('mousedown',
                function () {
                  if (self.DeleteCallback) {
                    (self.DeleteCallback)(self.Div[0]);
                  }
                  self.Div.remove();
                  return false;
                });
    }
  };

  SaElement.prototype.ActiveOff = function () {
    if (!this.Interactive) { return true; }
    if (this.SavedBorder) {
      this.Div[0].style.border = this.SavedBorder;
      delete this.SavedBorder;
    }
    this.ButtonDiv.remove();
  };

  SaElement.prototype.InitializeDialog = function () {
    var self = this;
    this.Dialog = new SAM.Dialog(function () { self.DialogApplyCallback(); });
    this.Dialog.Title.text('Properties');
    // Open callbacks allow default values to be set in the dialog.
    this.DialogInitializeFunctions = [];
    this.DialogApplyFunctions = [];

    // Indicate that this item should be hidden when in quize mode.
    this.Dialog.QuizPanel = this.AddAccordionTab(
        'Quiz',
        function () {
          self.Dialog.QuizCheck.prop('checked', self.Div.hasClass('sa-quiz-hide'));
        },
        function () {
          if (self.Dialog.QuizCheck.is(':checked')) {
            self.Div.addClass('sa-quiz-hide');
          } else {
            self.Div.removeClass('sa-quiz-hide');
          }
        });
    this.Dialog.QuizLabel = $('<div>')
        .appendTo(this.Dialog.QuizPanel)
        .css({'display': 'inline-block'})
        .text('Hide for quiz:');
    this.Dialog.QuizCheck = $('<input type="checkbox">')
        .appendTo(this.Dialog.QuizPanel);

    // Initialize the dialog with properties of border and shadow.
    // Border
    this.Dialog.BorderPanel = this.AddAccordionTab(
        'Border',
        function () { self.DialogInitialize(); },
        function () { self.DialogApply(); });

    // Border width and color.
    this.Dialog.BorderLine1 = $('<div>')
        .appendTo(this.Dialog.BorderPanel)
        .css({'width': '100%'});
    this.Dialog.BorderCheck = $('<input type="checkbox">')
        .appendTo(this.Dialog.BorderLine1)
        .change(function () {
          if ($(this).is(':checked')) {
            self.Dialog.BorderWidth.prop('disabled', false);
            self.Dialog.BorderColor.spectrum('enable');
          } else {
            self.Dialog.BorderWidth.prop('disabled', true);
            self.Dialog.BorderColor.spectrum('disable');
          }
        });
    this.Dialog.BorderWidthLabel = $('<div>')
        .appendTo(this.Dialog.BorderLine1)
        .css({'display': 'inline-block',
          'padding': '0px 5px',
          'width': '4em',
          'height': '20px',
          'text-align': 'right'})
        .text('Width');
    this.Dialog.BorderWidth = $('<input type="number">')
        .appendTo(this.Dialog.BorderLine1)
        .addClass('sa-view-annotation-modal-input')
        .css({'display': 'inline-block',
          'width': '3em'})
        .prop('disabled', true)
        .val(1)
        // Consume all events except return
        .keypress(function (event) { return event.keyCode !== 13; });
    this.Dialog.BorderColorDiv = $('<div>')
        .appendTo(this.Dialog.BorderLine1)
        .css({'float': 'right',
          'height': '18px'});
    this.Dialog.BorderColor = $('<input type="text">')
        .appendTo(this.Dialog.BorderColorDiv)
        .spectrum({showAlpha: true});

    // Rounded corners
    this.Dialog.BorderLine2 = $('<div>')
        .appendTo(this.Dialog.BorderPanel)
        .css({'width': '100%'});
    this.Dialog.BorderRadiusCheck = $('<input type="checkbox">')
        .appendTo(this.Dialog.BorderLine2)
        .change(function () {
          if ($(this).is(':checked')) {
            self.Dialog.BorderRadius.prop('disabled', false);
          } else {
            self.Dialog.BorderRadius.prop('disabled', true);
          }
        });
    this.Dialog.BorderRadiusLabel = $('<div>')
        .appendTo(this.Dialog.BorderLine2)
        .css({'display': 'inline-block',
          'padding': '0px 5px',
          'width': '4em',
          'height': '20px',
          'text-align': 'right'})
        .text('Radius');
    this.Dialog.BorderRadius = $('<input type="number">')
        .appendTo(this.Dialog.BorderLine2)
        .addClass('sa-view-annotation-modal-input')
        .prop('disabled', true)
        .css({'display': 'inline-block',
          'width': '3em'})
        .val(5)
        // Consume all events except return
        .keypress(function (event) { return event.keyCode !== 13; });

    // Shadow
    this.Dialog.BorderLine3 = $('<div>')
        .appendTo(this.Dialog.BorderPanel)
        .css({'width': '100%'});
    this.Dialog.ShadowCheck = $('<input type="checkbox">')
        .appendTo(this.Dialog.BorderLine3)
        .change(function () {
          if ($(this).is(':checked')) {
            self.Dialog.ShadowOffset.prop('disabled', false);
            self.Dialog.ShadowBlur.prop('disabled', false);
            self.Dialog.ShadowColor.spectrum('enable');
          } else {
            self.Dialog.ShadowOffset.prop('disabled', true);
            self.Dialog.ShadowBlur.prop('disabled', true);
            self.Dialog.ShadowColor.spectrum('disable');
          }
        });
    this.Dialog.ShadowLabel = $('<div>')
        .appendTo(this.Dialog.BorderLine3)
        .css({'display': 'inline-block',
          'padding': '0px 5px',
          'width': '4em',
          'height': '20px',
          'text-align': 'right'})
        .text('Shadow');
    this.Dialog.ShadowOffset = $('<input type="number">')
        .appendTo(this.Dialog.BorderLine3)
        .addClass('sa-view-annotation-modal-input')
        .prop('disabled', true)
        .css({'display': 'inline-block',
          'width': '3em'})
        .val(10)
        // Consume all events except return
        .keypress(function (event) { return event.keyCode !== 13; });
    this.Dialog.ShadowBlurLabel = $('<div>')
        .appendTo(this.Dialog.BorderLine3)
        .css({'display': 'inline-block',
          'padding': '0px 5px',
          'width': '3em',
          'height': '20px',
          'text-align': 'right'})
        .text('Blur');
    this.Dialog.ShadowBlur = $('<input type="number">')
        .appendTo(this.Dialog.BorderLine3)
        .addClass('sa-view-annotation-modal-input')
        .prop('disabled', true)
        .css({'display': 'inline-block',
          'width': '3em'})
        .val(5)
        // Consume all events except return
        .keypress(function (event) { return event.keyCode !== 13; });
    this.Dialog.ShadowColorDiv = $('<div>')
        .appendTo(this.Dialog.BorderLine3)
        .css({'float': 'right',
          'height': '18px'});
    this.Dialog.ShadowColor = $('<input type="text">')
        .appendTo(this.Dialog.ShadowColorDiv)
        .val('#AAAAAA')
        .prop('disabled', true)
        .css({'float': 'right',
          'height': '18px'})
        .spectrum({showAlpha: true});
  };

  SaElement.prototype.AddAccordionTab = function (title, open, apply) {
    if (open) {
      this.DialogInitializeFunctions.push(open);
    }
    if (apply) {
      this.DialogApplyFunctions.push(apply);
    }

    var tabDiv = $('<div>')
        .appendTo(this.Dialog.Body)
        .attr('title', title)
        .css({'width': '100%'});
    var tab = $('<div>')
        .appendTo(tabDiv)
        .text(title)
        .addClass('sa-accordion-tab');
    var panel = $('<div>')
        .appendTo(tabDiv)
        .css({'width': '100%',
          'padding': '5px',
          'border': '1px solid #AAA',
          'box-sizing': 'border-box'})
        .hide();
    var self = this;
    tab.on('click touchstart',
           function () {
             if (self.OpenAccordionPanel) {
               self.OpenAccordionPanel.hide(200);
             }
             if (self.OpenAccordionPanel === panel) {
               // Just closing the open panel.
               self.OpenAccordionPanel = null;
               return;
             }
             // Opening a new panel.
             panel.show(200);
             self.OpenAccordionPanel = panel;
           });
    // The last tab created is visible by default.
    // This should have worked, but did not.
    // tab.trigger('click');
    if (this.OpenAccordionPanel) {
      this.OpenAccordionPanel.hide();
    }
    this.OpenAccordionPanel = panel;
    panel.show();

    return panel;
  };

  SaElement.prototype.HideAccordionTab = function (title) {
    this.Div[0].saElement.Dialog.Body.children('[title=Quiz]').hide();
  };

  SaElement.prototype.OpenDialog = function (callback) {
    if (!this.DialogInitialized) {
        // Give 'subclasses' a chance to initialize their tabs.
      for (var i = 0; i < this.DialogInitializeFunctions.length; ++i) {
        (this.DialogInitializeFunctions[i])(this.Dialog);
      }
      this.DialogInitialized = true;
    }
    // Keep this onetime callback separate from DialogApplyCallbacks.
    this.OpenDialogCallback = callback;
    this.Dialog.Show(true);
  };

  SaElement.prototype.DialogInitialize = function () {
    // TODO: Does this work when 'border' is used?
    var str = this.Div[0].style.borderWidth;
    if (str !== '') {
      this.Dialog.BorderCheck.prop('checked', true);
      this.Dialog.BorderWidth.prop('disabled', false);
      this.Dialog.BorderColor.spectrum('enable');
      this.Dialog.BorderWidth.val(parseInt(str));
        // Current border is highlighted.  Use the saved color.
        // str = this.Div[0].style.borderColor;
      str = this.SavedBorder;
      if (!str || str === '') {
            // Called programatically
        str = this.Div[0].style.border;
      }
      if (str !== '') {
        str = str.substr(str.indexOf('rgb'));
        this.Dialog.BorderColor.spectrum('set', str);
      }
    }

    // Border Radius
    str = this.Div[0].style.borderRadius;
    if (str !== '') {
      this.Dialog.BorderRadiusCheck.prop('checked', true);
      this.Dialog.BorderRadius.prop('disabled', false);
      this.Dialog.BorderRadius.val(parseInt(str));
    }

    // Shadow
    str = this.Div[0].style.boxShadow;
    if (str !== '') {
      this.Dialog.ShadowCheck.prop('checked', true);
      var idx = str.indexOf(')') + 1;
      var color = str.substr(str.indexOf('rgb'), idx);
      this.Dialog.ShadowColor.spectrum('set', color);
      this.Dialog.ShadowColor.spectrum('enable');
      str = str.substr(idx + 1); // 1 more to skip the space
      var params = str.split(' ');
      this.Dialog.ShadowOffset.prop('disabled', false);
      this.Dialog.ShadowOffset.val(parseInt(params[0]));
      this.Dialog.ShadowBlur.prop('disabled', false);
      this.Dialog.ShadowBlur.val(parseInt(params[2]));
    }
  };

  SaElement.prototype.DialogApplyCallback = function () {
    // Giv 'subclasses' a chance to apply parameters in their tabs.
    for (var i = 0; i < this.DialogApplyFunctions.length; ++i) {
      (this.DialogApplyFunctions[i])(this.Dialog);
    }

    // External callback
    // I am not sure if I should put this here or in DialogApply.
    if (this.OpenDialogCallback) {
      (this.OpenDialogCallback)(this);
      delete this.OpenDialogCallback;
    }
  };

  SaElement.prototype.DialogApply = function () {
    // ActiveOff was setting border back after dialog changed it.
    delete this.SavedBorder;
    var width;
    if (this.Dialog.BorderCheck.is(':checked')) {
      var color = this.Dialog.BorderColor.spectrum('get');
      width = parseFloat(this.Dialog.BorderWidth.val());
      this.Div.css({'border': width + 'px solid ' + color});
    } else {
      this.Div.css('border', '');
    }

    // Border Radius
    if (this.Dialog.BorderRadiusCheck.is(':checked')) {
      width = parseFloat(this.Dialog.BorderRadius.val());
      this.Div.css({'borderRadius': width + 'px'});
    } else {
      this.Div.css('borderRadius', '');
    }

    // Shadow
    if (this.Dialog.ShadowCheck.is(':checked')) {
      var hexcolor = this.Dialog.ShadowColor.spectrum('get');
      var offset = parseInt(this.Dialog.ShadowOffset.val());
      var blur = parseInt(this.Dialog.ShadowBlur.val());
      this.Div.css({'box-shadow': offset + 'px ' + offset + 'px ' + blur + 'px ' + hexcolor});
    } else {
      this.Div.css('box-shadow', '');
    }
  };

  SaElement.prototype.ProcessArguments = function (args) {
    // No superclass

    // aspect ratio does something even with no arguments.
    if (args.length > 0) {
      // generic method call. Give jquery ui access to all this objects methods.
      if (typeof (this[args[0]]) === 'function') {
        // first list item is the method name,
        // the rest are arguments to the method.
        return this[args[0]].apply(this, Array.prototype.slice.call(args, 1));
      }
      // Handle the legacy behavior.
      // One argument: an object (like jqueryUI).
      args = args[0];
    } else {
      // looks like aspect processing with no args ...  Cannot just return?
      args = {};
    }

    if (args.position) {
      this.Position = args.position;
    }

    // It is important to set aspect ratio before EditOn is called.
    // AspectRatio is a boolean.
    if (args.aspectRatio !== undefined) {
      if (args.apsectRatio === '') {
        // Actively remove the aspect ratio.
        delete this.AspectRatio;
        this.Div.removeAttr('sa-aspect-ratio');
      } else {
            // Set a new aspect ratio
        this.AspectRatio = args.aspectRatio;
        this.Div.attr('sa-aspect-ratio', args.aspectRatio);
      }
    } else {
      // try and get a saved aspect ratio.
      this.AspectRatio = this.Div.attr('sa-aspect-ratio');
    }

    if (args.editable !== undefined) {
      if (args.editable) {
        this.EditableOn();
      } else {
        this.EditableOff();
        // hack hack hack (for view browser).
        // Trying to make slide thumbnails completly passive.
        this.Div.attr('contenteditable', 'false')
                .addClass('sa-noselect');
        this.Div.find('div').attr('contenteditable', 'false')
                .addClass('sa-noselect');
      }
    }

    if (args.interactive !== undefined) {
      this.Interactive = args.interactive;
      if (this.Interactive) {
        this.Div.removeClass('sa-noselect');
      } else {
        this.Div.addClass('sa-noselect');
      }
    }

    if (args.click !== undefined) {
      this.ClickCallback = args.click;
      this.Clickable = true;
    }

    if (args.delete !== undefined) {
      this.DeleteCallback = args.delete;
    }

    this.ConvertToPercentages();
  };

  SaElement.prototype.SetClickCallback = function (callback) {
    this.ClickCallback = callback;
    this.Clickable = true;
  };

  // Not the best function name.  Editable => draggable, expandable and deletable.
  SaElement.prototype.EditableOn = function () {
    this.Editable = true;
    this.Clickable = true;
    // I cannot get jqueryUI draggable to work.  Use my own events.
    var self = this;
    this.Div.on(
        'mousewheel.element',
        function (event) {
            // Resize from the middle.
          return self.HandleMouseWheel(event.originalEvent);
        });
    // NOTE: I could not get key events working for delete key.
    // Just had to restart chrome. Delete key is oldschool anyway.

    // Manage the cursor for drag versus resize.
    if (this.Position === 'absolute') {
      this.Div.on(
            'mousemove.elementCursor',
            function (event) {
              return self.HandleMouseMoveCursor(event);
            });
    }
  };

  SaElement.prototype.EditableOff = function () {
    this.Editable = false;
    this.Div.css({'cursor': 'auto'});
    // TODO: Remove wheel event.
    this.Div.off('mousewheel.element');
    this.Div.off('keyup.element');
    this.Div.off('mousemove.elementCursor');

    this.ButtonDiv.remove();
  };

  SaElement.prototype.HandleMouseDown = function (event) {
    if (!this.Interactive) { return true; }
    if (event.which === 1) {
      // Hack tp allow content editable to work with text editor.
      // This event does not let content editable receive events
      // if we return false.
      if (!this.Clickable) {
        return true;
      }

      var self = this;
      // To detect quick click for expansion.
      this.ClickStart = Date.now();
      $('body').on(
            'mouseup.element',
            function (e) {
              return self.HandleMouseUp(e);
            });

      if (this.Editable && this.Position === 'absolute') {
        // Setup dragging.
        this.DragLastX = event.screenX;
        this.DragLastY = event.screenY;
        // Add the event to stop dragging
        $('body').on(
                'mousemove.element',
                function (event) {
                  return self.HandleMouseMove(event);
                });
        $('body').on(
                'mouseleave.element',
                function (e) {
                  return self.HandleMouseUp(e);
                });
        // Hack to keep active even when mouse leaves the div.
        this.Div[0].saElement.LockActive = true;
      }
      return false;
    }
    return true;
  };

  // raise to the top of the draw order.
  // Note: it will not override z-index
  SaElement.prototype.RaiseToTop = function () {
    var parent = this.Div.parent();
    this.Div.detach();
    this.Div.appendTo(parent);
  };

  SaElement.prototype.HandleMouseMoveCursor = function (event) {
    if (!this.Interactive) { return true; }
    SA.FirefoxWhich(event);
    if (event.which === 0) {
      // Is it dangerous to modify the event object?
      while (event.srcElement && event.srcElement !== this.Div[0]) {
        event.offsetX += event.srcElement.offsetLeft;
        event.offsetY += event.srcElement.offsetTop;
        event.srcElement = event.srcElement.parentElement;
      }
      var x = event.offsetX;
      var y = event.offsetY;
      var width = this.Div.outerWidth();
      var height = this.Div.outerHeight();
      var handleSize = (width + height) / 100;
      if (handleSize < 6) {
        handleSize = 6;
      }
      var xMax = width - handleSize;
      var yMax = height - handleSize;
      if (x < handleSize && y < handleSize) {
        this.Div.css({'cursor': 'nwse-resize'});
        this.MoveState = 5;
      } else if (x > xMax && y > yMax) {
        this.Div.css({'cursor': 'nwse-resize'});
        this.MoveState = 6;
      } else if (x < handleSize && y > yMax) {
        this.Div.css({'cursor': 'nesw-resize'});
        this.MoveState = 7;
      } else if (x > xMax && y < handleSize) {
        this.Div.css({'cursor': 'nesw-resize'});
        this.MoveState = 8;
      } else if (x < handleSize) {
        this.Div.css({'cursor': 'ew-resize'});
        this.MoveState = 1;
      } else if (x > xMax) {
        this.Div.css({'cursor': 'ew-resize'});
        this.MoveState = 2;
      } else if (y < handleSize) {
        this.Div.css({'cursor': 'ns-resize'});
        this.MoveState = 3;
      } else if (y > yMax) {
        this.Div.css({'cursor': 'ns-resize'});
        this.MoveState = 4;
      } else {
        this.Div.css({'cursor': 'move'});
        this.MoveState = 0;
      }
    }
    return true;
  };

  SaElement.prototype.HandleMouseMove = function (event) {
    SA.FirefoxWhich(event);
    if (event.which === 1) {
      // Wait for the click duration to start dragging.
      if (Date.now() - this.ClickStart < 200) {
        return true;
      }

      if (!this.Dragging) {
        this.RaiseToTop();
        this.Dragging = true;
      }

      var dx = event.screenX - this.DragLastX;
      var dy = event.screenY - this.DragLastY;
      this.DragLastX = event.screenX;
      this.DragLastY = event.screenY;

      // Maybe we should not let the object leave the page.
      var pos = this.Div.position();
      // It is odd.  First setting width has the same value as getting
      // outerWidth. Now it behaves as expected (consistent outer set / get).
      var width = this.Div.outerWidth();
      var height = this.Div.outerHeight();
      // Hack,  I cannot figure out how jquery deals with box-sizing.
      var sizing = this.Div.css('box-sizing');
      if (this.AspectRatio && typeof (this.AspectRatio) !== 'number') {
        this.AspectRatio = width / height;
      }
      var left;
      var top;
      if (this.MoveState === 0) {
        left = pos.left + dx;
        top = pos.top + dy;
        this.Div[0].style.top = top.toString() + 'px';
        this.Div[0].style.left = left.toString() + 'px';
        return false;
      } else if (this.MoveState === 1) {
        left = pos.left + dx;
        width = width - dx;
        this.Div[0].style.left = left.toString() + 'px';
        if (sizing === 'border-box') {
          this.Div.width(width);
        } else {
          this.Div.outerWidth(width);
        }
        if (this.AspectRatio) {
          this.Div.innerHeight(this.Div.innerWidth / this.AspectRatio);
        }
        this.Div.trigger('resize');
        return false;
      } else if (this.MoveState === 2) {
        width = width + dx;
        if (sizing === 'border-box') {
          this.Div.width(width);
        } else {
          this.Div.outerWidth(width);
        }
        if (this.AspectRatio) {
          this.Div.innerHeight(this.Div.innerWidth() / this.AspectRatio);
        }
        this.Div.trigger('resize');
        return false;
      } else if (this.MoveState === 3) {
        top = pos.top + dy;
        height = height - dy;
        this.Div[0].style.top = top.toString() + 'px';
        if (sizing === 'border-box') {
          this.Div.height(height);
        } else {
          this.Div.outerHeight(height);
        }
        if (this.AspectRatio) {
          this.Div.innerWidth(this.Div.innerHeight() * this.AspectRatio);
        }
        this.Div.trigger('resize');
        return false;
      } else if (this.MoveState === 4) {
        height = height + dy;
        if (sizing === 'border-box') {
          this.Div.height(height);
        } else {
          this.Div.outerHeight(height);
        }
        if (this.AspectRatio) {
          this.Div.innerWidth(this.Div.innerHeight() * this.AspectRatio);
        }
        this.Div.trigger('resize');
        return false;
      } else if (this.MoveState === 5) {
        // upper left corner resize
        left = pos.left + dx;
        top = pos.top + dy;
        width = width - dx;
        height = height - dy;
        this.Div[0].style.top = top.toString() + 'px';
        this.Div[0].style.left = left.toString() + 'px';
        if (sizing === 'border-box') {
          this.Div.width(width);
          this.Div.height(height);
        } else {
          this.Div.outerWidth(width);
          this.Div.outerHeight(height);
        }
        if (this.AspectRatio) {
          this.Div.innerWidth(this.Div.innerHeight() * this.AspectRatio);
        }
        this.Div.trigger('resize');
        return false;
      } else if (this.MoveState === 6) {
        // lower right corner resize
        width = width + dx;
        height = height + dy;
        if (sizing === 'border-box') {
          this.Div.width(width);
          this.Div.height(height);
        } else {
          this.Div.outerWidth(width);
          this.Div.outerHeight(height);
        }
        if (this.AspectRatio) {
          this.Div.innerWidth(this.Div.innerHeight() * this.AspectRatio);
        }
        this.Div.trigger('resize');
        return false;
      } else if (this.MoveState === 7) {
        // lower left corner resize
        left = pos.left + dx;
        width = width - dx;
        height = height + dy;
        this.Div[0].style.left = left.toString() + 'px';
        if (sizing === 'border-box') {
          this.Div.width(width);
          this.Div.height(height);
        } else {
          this.Div.outerWidth(width);
          this.Div.outerHeight(height);
        }
        if (this.AspectRatio) {
          this.Div.innerWidth(this.Div.innerHeight() * this.AspectRatio);
        }
        this.Div.trigger('resize');
        return false;
      } else if (this.MoveState === 8) {
        // upper right corner resize
        top = pos.top + dy;
        width = width + dx;
        height = height - dy;
        this.Div[0].style.top = top.toString() + 'px';
        if (sizing === 'border-box') {
          this.Div.width(width);
          this.Div.height(height);
        } else {
          this.Div.outerWidth(width);
          this.Div.outerHeight(height);
        }
        if (this.AspectRatio) {
          this.Div.innerWidth(this.Div.innerHeight() * this.AspectRatio);
        }
        this.Div.trigger('resize');
        return false;
      }
    }
    return true;
  };

  SaElement.prototype.HandleMouseUp = function (event) {
    // mouse up is not conditional on edit because it
    // is also used tio trigger click callback.
    $('body').off('mouseup.element');

    if (this.Editable) {
      if (this.Dragging) {
        this.Dragging = false;
        this.ConvertToPercentages();
      }
      $('body').off('mousemove.element');
      $('body').off('mouseleave.element');
      // hack
      this.Div[0].saElement.LockActive = false;
      this.Div[0].saElement.ActiveOff();
    }

    // Quick click...
    var clickDuration = Date.now() - this.ClickStart;
    if (clickDuration < 200 && this.ClickCallback) {
      (this.ClickCallback)(this.Div[0]);
    }

    return false;
  };

  SaElement.prototype.HandleMouseWheel = function (event) {
    var width = this.Div.width();
    var height = this.Div.height();
    var dWidth = 0;
    var dHeight = 0;

    var tmp = 0;
    if (event.deltaY) {
      tmp = event.deltaY;
    } else if (event.wheelDelta) {
      tmp = event.wheelDelta;
    }
    // Wheel event seems to be in increments of 3.
    // depreciated mousewheel had increments of 120....
    // Initial delta cause another bug.
    // Lets restrict to one zoom step per event.
    if (tmp > 0) {
      dWidth = 0.05 * width;
      dHeight = 0.05 * height;
    } else if (tmp < 0) {
      dWidth = width * (-0.0476);
      dHeight = height * (-0.0476);
    }

    width += dWidth;
    this.Div[0].style.width = width.toString() + 'px';
    height += dHeight;
    this.Div[0].style.height = height.toString() + 'px';

    // We have to change the top and left ot percentages too.
    // I might have to make my own resizable to get the exact behavior
    // I want.
    var pos = this.Div.position();
    var left = pos.left - (dWidth / 2);
    var top = pos.top - (dHeight / 2);
    this.Div[0].style.top = top.toString() + 'px';
    this.Div[0].style.left = left.toString() + 'px';

    // the resize callback might deal with converting to percentages.
    // this.ConvertToPercentages();
    this.Div.trigger('resize');
    return false;
  };

// Change left, top, widht and height to percentages.
  SaElement.prototype.ConvertToPercentages = function () {
    // I had issues with previous slide shows that had images with no width
    // set. Of course it won't scale right but they will still show up.
    // NOTE: this.Div.width() also misbehaves when the div is not visible.
    // It does not convert percent to pixels (returns percent).
    var width = this.Div[0].style.width;
    if (width.indexOf('%') === -1) {
      width = parseFloat(width);
      width = 100 * width / this.Div.parent().width();
      this.Div[0].style.width = width.toString() + '%';
    }
    var height = this.Div[0].style.height;
    if (height.indexOf('%') === -1) {
      height = parseFloat(height);
      height = 100 * height / this.Div.parent().height();
      this.Div[0].style.height = height.toString() + '%';
    }

    // Note: We cannot use this.Div.position() when the div is hidden.
    var top = this.Div.css('top');
    if (top.indexOf('%') === -1) {
      top = parseFloat(top);
      top = 100 * top / this.Div.parent().height();
      this.Div[0].style.top = top.toString() + '%';
    }
    var left = this.Div.css('left');
    if (left.indexOf('%') === -1) {
      left = parseFloat(left);
      left = 100 * left / this.Div.parent().width();
      this.Div[0].style.left = left.toString() + '%';
    }
  };

// ==============================================================================
// Just editing options to a rectangle.  I could make the text editor a
// "subclass" of this rectangle object.

  jQuery.prototype.saRectangle = function (arg1) { // 'arguments' handles extras.
    // Setup the superclass saElement.
    this.saElement();
    this.addClass('sa-presentation-rectangle');
    for (var i = 0; i < this.length; ++i) {
      var dom = this[i];
      if (!dom.saRectangle) {
        dom.saRectangle = new SaRectangle($(dom));
      }
      dom.saRectangle.ProcessArguments(arguments);
    }

    return this;
  };

  function SaRectangle (div) {
    var self = this;
    this.Div = div;
    var element = div[0].saElement;
    this.BackgroundPanel = element.AddAccordionTab(
        'Background',
        function () { self.DialogInitialize(); },
        function () { self.DialogApply(); });

    // Background with gradient option.
    this.BackgroundLine1 = $('<div>')
        .appendTo(this.BackgroundPanel)
        .css({'width': '100%'});
    this.BackgroundCheck = $('<input type="checkbox">')
        .appendTo(this.BackgroundLine1)
        .change(function () {
          if ($(this).is(':checked')) {
            self.BackgroundColor.spectrum('enable');
          } else {
            self.BackgroundColor.spectrum('disable');
          }
        });
    this.BackgroundColorLabel = $('<div>')
        .appendTo(this.BackgroundLine1)
        .css({'display': 'inline-block',
          'padding': '0px 5px',
          'width': '4em',
          'height': '20px',
          'text-align': 'right'})
        .text('Color');
    this.BackgroundColorDiv = $('<div>')
        .appendTo(this.BackgroundLine1)
        .css({'display': 'inline-block',
          'height': '18px',
          'margin-left': '1em'});
    this.BackgroundColor = $('<input type="text">')
        .appendTo(this.BackgroundLine1)
        .val('#005077')
        .spectrum({showAlpha: true});
    this.BackgroundColor.spectrum('disable');

    // Gradient
    this.BackgroundLine2 = $('<div>')
        .appendTo(this.BackgroundPanel)
        .css({'width': '100%'});
    this.GradientCheck = $('<input type="checkbox">')
        .appendTo(this.BackgroundLine2)
        .change(function () {
          if ($(this).is(':checked')) {
            self.GradientColor.spectrum('enable');
            self.GradientColor.spectrum('show');
          } else {
            self.GradientColor.spectrum('disable');
            self.GradientColor.spectrum('hide');
          }
        });
    this.GradientLabel = $('<div>')
        .appendTo(this.BackgroundLine2)
        .css({'display': 'inline-block',
          'padding': '0px 5px',
          'width': '4em',
          'height': '20px',
          'text-align': 'right'})
        .text('Gradient');
    this.GradientColorDiv = $('<div>')
        .appendTo(this.BackgroundLine2)
        .css({'display': 'inline-block',
          'height': '18px',
          'margin-left': '1em'});
    this.GradientColor = $('<input type="text">')
        .appendTo(this.GradientColorDiv)
        .val('#005077')
        .spectrum({showAlpha: true});
  }

  SaRectangle.prototype.ProcessArguments = function (args) {
    if (args.length === 0) { return; }

    // Superclass
    this.Div[0].saElement.ProcessArguments(args);

    // generic method call. Give jquery ui access to all this objects methods.
    if (typeof (this[args[0]]) === 'function') {
      // first list item is the method name,
      // the rest are arguments to the method.
      return this[args[0]].apply(this, Array.prototype.slice.call(args, 1));
    }
  };

  SaRectangle.prototype.DialogInitialize = function () {
    var color = this.Div[0].style.background;
    if (color === '') {
      color = this.Div[0].style.backgroundColor;
    }
    if (color === '') {
      this.BackgroundCheck.prop('checked', false);
      this.BackgroundColor.spectrum('disable');
      this.GradientCheck.prop('checked', false);
      this.GradientColor.spectrum('disable');
      this.GradientColor.spectrum('hide');
      return;
    }
    if (color.substring(0, 3) === 'rgb') {
      // Single color in background (no 'linear-gradient')
      this.BackgroundCheck.prop('checked', true);
      this.BackgroundColor.spectrum('set', color);
      this.BackgroundColor.spectrum('enable');
      this.GradientCheck.prop('checked', false);
      this.GradientColor.spectrum('disable');
      this.GradientColor.spectrum('hide');
      return;
    }
    // parsing the gradient is a bit harder.
    if (color.substring(0, 15) === 'linear-gradient') {
      var idx0 = color.indexOf('rgb');
      var idx1 = color.indexOf(')') + 1;
      this.BackgroundCheck.prop('checked', true);
      this.BackgroundColor.spectrum('enable');
      this.BackgroundColor.spectrum('set', color.substring(idx0, idx1));
      idx0 = color.indexOf('rgb', idx1);
      idx1 = color.indexOf(')', idx1) + 1;
      this.GradientCheck.prop('checked', true);
      this.GradientColor.spectrum('enable');
      this.GradientColor.spectrum('show');
      this.GradientColor.spectrum('set', color.substring(idx0, idx1));
      return;
    }
    SA.Debug('parse error: ' + color);
  };

  SaRectangle.prototype.DialogApply = function () {
    if (!this.BackgroundCheck.is(':checked')) {
      this.Div.css('background', '');
      return;
    }
    var color = this.BackgroundColor.spectrum('get');
    if (!this.GradientCheck.is(':checked')) {
      this.Div.css({'background': color});
      return;
    }
    var color2 = this.GradientColor.spectrum('get');
    this.Div.css({'background': 'linear-gradient(' + color + ',' + color2 + ')'});
  };

// ==============================================================================
// Text: dialog to set margin, text size, spacing, (font in the future)

  jQuery.prototype.saText = function (arg1) { // 'arguments' handles extras.
    // Setup the superclass saElement.
    this.saRectangle();
    this.addClass('sa-text');
    for (var i = 0; i < this.length; ++i) {
      var dom = this[i];
      if (!dom.saText) {
        dom.saText = new SaText($(dom));
      }
      dom.saText.ProcessArguments(arguments);
    }

    return this;
  };

  function SaText (div) {
    var self = this;
    this.Div = div;
    var element = div[0].saElement;
    this.PaddingPanel = element.AddAccordionTab(
        'Margins',
        function () { self.DialogPaddingInitialize(); },
        function () { self.DialogPaddingApply(); });
    // Padding (text margins)
    // Left
    this.PaddingLeftLine = $('<div>')
        .appendTo(this.PaddingPanel)
        .css({'width': '100%'});
    this.PaddingLeftLabel = $('<div>')
        .appendTo(this.PaddingLeftLine)
        .css({'display': 'inline-block',
          'padding': '0px 5px',
          'width': '4em',
          'height': '20px',
          'text-align': 'right'})
        .text('Left:');
    this.PaddingLeft =
            $('<input type="number">')
            .appendTo(this.PaddingLeftLine)
            .keypress(function (event) { return event.keyCode !== 13; });
    // Top
    this.PaddingTopLine = $('<div>')
        .appendTo(this.PaddingPanel)
        .css({'width': '100%'});
    this.PaddingTopLabel = $('<div>')
        .appendTo(this.PaddingTopLine)
        .css({'display': 'inline-block',
          'padding': '0px 5px',
          'width': '4em',
          'height': '20px',
          'text-align': 'right'})
        .text('Top:');
    this.PaddingTop =
            $('<input type="number">')
            .appendTo(this.PaddingTopLine)
            .keypress(function (event) { return event.keyCode !== 13; });
    // Right
    this.PaddingRightLine = $('<div>')
        .appendTo(this.PaddingPanel)
        .css({'width': '100%'});
    this.PaddingRightLabel = $('<div>')
        .appendTo(this.PaddingRightLine)
        .css({'display': 'inline-block',
          'padding': '0px 5px',
          'width': '4em',
          'height': '20px',
          'text-align': 'right'})
        .text('Right:');
    this.PaddingRight =
            $('<input type="number">')
            .appendTo(this.PaddingRightLine)
            .keypress(function (event) { return event.keyCode !== 13; });
    // Bottom
    this.PaddingBottomLine = $('<div>')
        .appendTo(this.PaddingPanel)
        .css({'width': '100%'});
    this.PaddingBottomLabel = $('<div>')
        .appendTo(this.PaddingBottomLine)
        .css({'display': 'inline-block',
          'padding': '0px 5px',
          'width': '4em',
          'height': '20px',
          'text-align': 'right'})
        .text('Bottom:');
    this.PaddingBottom =
            $('<input type="number">')
            .appendTo(this.PaddingBottomLine)
            .keypress(function (event) { return event.keyCode !== 13; });
  }

  SaText.prototype.ProcessArguments = function (args) {
    if (args.length === 0) { return; }

    // Superclass
    this.Div[0].saRectangle.ProcessArguments(args);

    // generic method call. Give jquery ui access to all this objects methods.
    if (typeof (this[args[0]]) === 'function') {
      // first list item is the method name,
      // the rest are arguments to the method.
      return this[args[0]].apply(this, Array.prototype.slice.call(args, 1));
    }
  };

  SaText.prototype.DialogPaddingInitialize = function () {
    var txt;

    txt = this.Div[0].style.paddingLeft;
    // Convert to something like pixels.
    this.PaddingLeft.val(8 * parseFloat(txt)); // window 800 pixels high

    txt = this.Div[0].style.paddingTop;
    // Convert to something like pixels.
    this.PaddingTop.val(8 * parseFloat(txt)); // window 800 pixels high

    txt = this.Div[0].style.paddingRight;
    // Convert to something like pixels.
    this.PaddingRight.val(8 * parseFloat(txt)); // window 800 pixels high

    txt = this.Div[0].style.paddingBottom;
    // Convert to something like pixels.
    this.PaddingBottom.val(8 * parseFloat(txt)); // window 800 pixels high
  };

  SaText.prototype.DialogPaddingApply = function () {
    this.Div[0].style.paddingLeft = (this.PaddingLeft.val() / 8) + '%';
    this.Div[0].style.paddingTop = (this.PaddingTop.val() / 8) + '%';
    this.Div[0].style.paddingRight = (this.PaddingRight.val() / 8) + '%';
    this.Div[0].style.paddingBottom = (this.PaddingBottom.val() / 8) + '%';
  };

// ==============================================================================
// Questions
//
  jQuery.prototype.saQuestion = function (arg1) { // 'arguments' handles extras.
    // Setup the superclass saRectangle.
    this.saText();
    for (var i = 0; i < this.length; ++i) {
      if (!this[i].saQuestion) {
            // Add the helper as an instance variable to the dom object.
        this[i].saQuestion = new SaQuestion($(this[i]));
        this[i].saElement.HideAccordionTab('Quiz');
      }
      this[i].saQuestion.ProcessArguments(arguments);
    }

    return this;
  };

  function SaQuestion (div) {
    var self = this;
    this.Div = div;
    this.Div.addClass('sa-question');

    var element = div[0].saElement;
    element.Dialog.Dialog.css({'width': '500px'});

    this.QuestionPanel = element.AddAccordionTab(
        'Question',
        function () { self.DialogInitialize(); },
        function () { self.DialogApply(); });

    this.DialogInitialize();
  }

  // Meant to be acll externally.
  // Assumes multiple choice for now.
  SaQuestion.prototype.SetQuestionText = function (text) {
    var question = this.Div.find('.sa-q');
    if (question.length === 0) {
      question = $('<div>').addClass('sa-q').appendTo(this.Div);
    }
    question.text(text);
    this.Div.attr('type', 'multiple-choice');
  };
  SaQuestion.prototype.AddAnswerText = function (text, correct) {
    var answerText = text;
    // get rid of bullets
    if (text[0] === '-') {
      answerText = text.substring(1);
    } else if (text[1] === '.' || text[1] === ':') {
      answerText = text.substring(2);
    }
    // Get rid of whitespace
    answerText = answerText.trim();

    var answers = this.Div.find('ol');
    if (answers.length === 0) {
      answers = $('<ol>').appendTo(this.Div);
    }
    var answer = $('<li>').appendTo(answers).addClass('sa-answer');
    answer.text(answerText);
    if (correct) {
      answer.addClass('sa-true');
    }
  };

  SaQuestion.prototype.ProcessArguments = function (args) {
    if (args.length === 0) { return; }

    // Superclass
    this.Div[0].saText.ProcessArguments(args);

    // generic method call. Give jquery ui access to all this objects methods.
    if (typeof (this[args[0]]) === 'function') {
      // first list item is the method name,
      // the rest are arguments to the method.
      return this[args[0]].apply(this, Array.prototype.slice.call(args, 1));
    }
  };

  SaQuestion.prototype.SetMode = function (mode) {
    // Clear wrong answers selected by user.
    this.Div.find('.sa-answer').css({'color': '#000'});
    if (mode === 'answer-show') {
      this.Div.find('.sa-quiz-hide').show();
      this.Div.find('.sa-true').css({'font-weight': 'bold'});
      this.Div.find('.sa-short-answer')
            .css({'color': '#00C'})
            .show();
    } else {
      this.Div.find('.sa-quiz-hide').hide();
      this.Div.find('.sa-true').css({'font-weight': 'normal'});
      this.Div.find('.sa-short-answer')
            .hide();
    }

    if (mode === 'answer-interactive') {
      // Bind response to the user selecting an answer.
      this.Div.find('.sa-answer')
            .css({'cursor': 'pointer',
              'color': '#057'})
            .hover(function () { $(this).css({'background': '#DDD'}); },
                   function () { $(this).css({'background': '#FFF'}); })
            .on('click.answer',
                function () {
                  if ($(this).hasClass('sa-true')) {
                    $(this).css({'font-weight': 'bold',
                      'color': '#000'});
                  } else {
                    $(this).css({'color': '#C00'});
                  }
                });
    } else {
      this.Div.find('.sa-answer')
            .css({'color': '#000'})
            .css('cursor', '')
            .off('hover')
            .off('click.answer');
    }
  };

  SaQuestion.prototype.AddAnswerTo = function (parent, answerList, text, checked) {
    // Make a new answer box;
    var answerDiv = $('<div>')
        .appendTo(parent)
        .css({'width': '100%',
          'position': 'relative'});
    var check = $('<input type="checkbox">')
        .appendTo(answerDiv);
    var answer = $('<div>')
        .appendTo(answerDiv)
        .css({'border': '1px solid #AAA',
          'position': 'absolute',
          'left': '30px',
          'right': '2px',
          'top': '2px'})
        .attr('contenteditable', 'true');
    check.change(
        function () {
          if ($(this).is(':checked')) {
            answer.css({'font-weight': 'bold'});
          } else {
            answer.css({'font-weight': 'normal'});
          }
        });

    if (text) {
      answer.text(text);
      if (checked) {
        check.attr('checked', 'true');
        answer.css({'font-weight': 'bold'});
      }
    }

    // Answers are complicated enough that I am going to have to break down
    // and create differt gui object.
    var answerObj = {Div: answerDiv,
      Check: check,
      Input: answer};
    answerList.push(answerObj);
    return answerObj;
  };

  SaQuestion.prototype.DialogInitialize = function () {
    var self = this;
    // Create/recreate the question dialog panel.
    var panel = this.QuestionPanel;
    panel.empty();

    this.QuestionTypeSelect = $('<select>')
        .appendTo(panel);
    this.QuestionTypeMultipleChoice = $('<option>')
        .appendTo(this.QuestionTypeSelect)
        .text('Multiple Choice');
    this.QuestionTypeSortAnswer = $('<option>')
        .appendTo(this.QuestionTypeSelect)
        .text('Short Answer');
    // this.QuestionTypeTrueFalse = $('<option>')
    //    .appendTo(this.QuestionTypeSelect)
    //    .text("True or False");
    this.QuestionTypeSelect.change(
        function () {
          if ($(this).val() === 'Multiple Choice') {
            self.MultipleChoiceDiv.show();
            self.TrueFalseDiv.hide();
            self.ShortAnswerDiv.hide();
          }
          if ($(this).val() === 'True or False') {
            self.MultipleChoiceDiv.hide();
            self.TrueFalseDiv.show();
            self.ShortAnswerDiv.hide();
          }
          if ($(this).val() === 'Short Answer') {
            self.MultipleChoiceDiv.hide();
            self.TrueFalseDiv.hide();
            self.ShortAnswerDiv.show();
          }
        });

    this.QuestionLabel = $('<div>')
        .appendTo(panel)
        .text('Question:');
    this.Question = $('<div>')
        .appendTo(panel)
        .css({'border': '1px solid #AAA',
          'margin': '2px'})
        .attr('contenteditable', 'true');

    // The div itself is the answer input.
    this.ShortAnswerDiv = $('<div>')
        .appendTo(panel)
        .css({'border': '1px solid #AAA',
          'width': '100%',
          'height': '3em',
          'margin': '1px'})
        .attr('contenteditable', 'true')
        .hide();

    this.TrueFalseDiv = $('<div>')
        .appendTo(panel)
        .hide();
    this.TrueFalseAnswers = [];
    this.AddAnswerTo(this.TrueFalseDiv, this.TrueFalseAnswers, 'True');
    this.AddAnswerTo(this.TrueFalseDiv, this.TrueFalseAnswers, 'False');

    this.MultipleChoiceDiv = $('<div>')
        .appendTo(panel);
    this.MultipleChoiceAnswerLabel = $('<div>')
        .appendTo(this.MultipleChoiceDiv)
        .addClass('sa-mutliple-choice-answer')
        .text('Answers:');
    this.MultipleChoiceAnswers = [];

    // Initialize the question panel values from a question div (saQuestion).

    // Get the question information from the html.
    var questionDiv = this.Div.find('.sa-q');
    if (questionDiv.length > 0) {
      this.Question.text(questionDiv.text());
      var type = this.Div.attr('type');
      if (type === 'multiple-choice') {
        this.QuestionTypeSelect.val('Multiple Choice');
        var options = this.Div.find('.sa-answer');
        for (var i = 0; i < options.length; ++i) {
          var item = $(options[i]);
          var checked = item.hasClass('sa-true');
          this.AddAnswerTo(this.MultipleChoiceDiv,
                                 this.MultipleChoiceAnswers,
                                 item.text(), checked);
        }
      } else if (type === 'short-answer') {
        this.ShortAnswerDiv.text($('.sa-short-answer').text());
        this.QuestionTypeSelect.val('Short Answer');
        this.ShortAnswerDiv.show();
        this.MultipleChoiceDiv.hide();
      }
    }

    // Empty answer that adds another when it is filled.
    this.AddBlankMultipleChoiceAnswer();
  };

  SaQuestion.prototype.AddBlankMultipleChoiceAnswer = function () {
    var self = this;
    var answerObj = this.AddAnswerTo(this.MultipleChoiceDiv,
                                   this.MultipleChoiceAnswers);
    answerObj.Input.on('focus.answer',
                       function () {
                         self.AddBlankMultipleChoiceAnswer();
                       });
  };

  SaQuestion.prototype.DialogApply = function () {
    this.Div.find('.sa-q').remove();
    this.Div.find('ol').remove();
    this.Div.find('.sa-short-answer').remove();

    var tmp = $('<div>')
        .appendTo(this.Div)
        .addClass('sa-q')
        .text(this.Question.text());

    var i;
    if (this.QuestionTypeSelect.val() === 'Multiple Choice') {
      this.Div.attr('type', 'multiple-choice');
      tmp = $('<ol>')
            .appendTo(this.Div)
            .css({'margin': '0px 0px 0px 0.5em'});

        // Shuffle the answers.
      var shuffled = [];
      var answer;
      var a;
      while (this.MultipleChoiceAnswers.length > 0) {
        var idx = Math.floor(Math.random() * this.MultipleChoiceAnswers.length);
        answer = this.MultipleChoiceAnswers.splice(idx, 1)[0];
        shuffled.push(answer);
      }
      this.MultipleChoiceAnswers = shuffled;

      // Convert to html
      for (i = 0; i < this.MultipleChoiceAnswers.length; ++i) {
        answer = this.MultipleChoiceAnswers[i];
        if (answer.Input.text() !== '') {
          a = $('<li>')
                    .appendTo(tmp)
                    .addClass('sa-answer')
                    .text(answer.Input.text());
          if (answer.Check.is(':checked')) {
            a.css({'font-weight': 'bold'});
            a.addClass('sa-true');
          }
        }
      }
    }
    if (this.QuestionTypeSelect.val() === 'True or False') {
      this.Div.attr('type', 'true-false');
      // TODO: Share code with multiple choice
      // TODO: Make true false be mutually exclusive (radio button).
      tmp = $('<ol>')
            .appendTo(this.Div)
            .css({'margin': '0px 0px 0px 0.5em'});
      for (i = 0; i < this.TrueFalseAnswers.length; ++i) {
        answer = this.TrueFalseAnswers[i];
        if (answer.Input.text() !== '') {
          a = $('<li>')
                    .appendTo(tmp)
                    .addClass('sa-true-false-answer')
                    .text(answer.Input.text());
          if (answer.Check.is(':checked')) {
            a.css({'font-weight': 'bold'});
            a.addClass('sa-true');
          }
        }
      }
    }
    if (this.QuestionTypeSelect.val() === 'Short Answer') {
      this.Div.attr('type', 'short-answer');
      tmp = $('<div>')
            .appendTo(this.Div)
            .css({'color': '#00C'})
            .addClass('sa-short-answer')
            .text(this.ShortAnswerDiv.text());
    }
  };

// ==============================================================================
// Make any div into a text editor.
// Will be used for the presentation html editor.
// Note,  scalable font should be set before text editor if you want scale buttons.
// TODO:
// - The editor is position 'absolute' and is placed with percentages.
//   Make pixel positioning an option

// args: {dialog: true}
  jQuery.prototype.saTextEditor = function (args) {
    for (var i = 0; i < this.length; ++i) {
      if (!this[i].saTextEditor) {
        var textEditor = new SaTextEditor($(this[i]), args);
        // Add the viewer as an instance variable to the dom object.
        this[i].saTextEditor = textEditor;
        // TODO: Hide any dialog tabs?
      }
      this[i].saTextEditor.ProcessArguments(arguments);
    }

    return this;
  };

// TODO: Figure out a way to get rid of this.
// content editable in divs do not consume key events.
// They propagate to parents. i.e. space causes a slide to advance.
// SA.ContentEditableHasFocus = false;

  function SaTextEditor (div) {
    var self = this;
    this.Div = div;
    this.Div.addClass('sa-text-editor');

    div.saText({click: function () {
      self.EditingOn();
    }});

    // Dialog tab
    var element = div[0].saElement;
    this.TextPanel = element.AddAccordionTab(
        'Text',
        function () { self.DialogInitialize(); },
        function () { self.DialogApply(); });

    // Font Size
    this.FontSizeDiv = $('<div>')
        .appendTo(this.TextPanel)
        .css({'height': '32px'})
        .addClass('sa-view-annotation-modal-div');
    this.FontSizeLabel = $('<div>')
        .appendTo(this.FontSizeDiv)
        .text('Font Size:')
        .addClass('sa-view-annotation-modal-input-label');
    this.FontSize = $('<input type="number">')
        .appendTo(this.FontSizeDiv)
        .addClass('sa-view-annotation-modal-input')
        .keypress(function (event) { return event.keyCode !== 13; });

    // Font Color
    this.FontColorDiv = $('<div>')
        .appendTo(this.TextPanel)
        .css({'height': '32px'})
        .addClass('sa-view-annotation-modal-div');
    this.FontColorLabel = $('<div>')
        .appendTo(this.FontColorDiv)
        .text('Color:')
        .addClass('sa-view-annotation-modal-input-label');
    this.FontColor =
        $('<input type="text">')
        .appendTo(this.FontColorDiv)
        .val('#050505')
        .spectrum({showAlpha: true});

    // Line Height
    this.LineHeightDiv = $('<div>')
        .appendTo(this.TextPanel)
        .css({'height': '32px'})
        .addClass('sa-view-annotation-modal-div');
    this.LineHeightLabel = $('<div>')
        .appendTo(this.LineHeightDiv)
        .text('Line Height %:')
        .addClass('sa-view-annotation-modal-input-label');
    this.LineHeight = $('<input type="number">')
        .appendTo(this.LineHeightDiv)
        .addClass('sa-view-annotation-modal-input')
        .val(1)
        .keypress(function (event) { return event.keyCode !== 13; });

    // Create a div for the editor options.
    // These will only become visible when you click / select
    this.Div.css({'overflow': 'visible'}); // so the buttons are not cut off
    this.EditButtonDiv = $('<div>')
        .appendTo(this.Div.parent())
        .addClass('sa-edit-gui') // Remove before saHtml save.
        .css({'height': '20px',
          'position': 'absolute',
          'width': '275px',
          'cursor': 'auto'})
        .hide()
        // Block the saElement click event.
        .mousedown(function () { return false; });

    this.AddButton(SA.ImagePathUrl + 'link.png', 'link URL',
                   function () { self.InsertUrlLink(); });
    this.AddButton(SA.ImagePathUrl + 'font_bold.png', 'bold',
                   function () {
                     document.execCommand('bold', false, null);
                   });
    this.AddButton(SA.ImagePathUrl + 'text_italic.png', 'italic',
                   function () { document.execCommand('italic', false, null); });
    this.AddButton(SA.ImagePathUrl + 'edit_underline.png', 'underline',
                   function () { document.execCommand('underline', false, null); });
    this.AddButton(SA.ImagePathUrl + 'list_bullets.png', 'unorded list',
                   function () { document.execCommand('InsertUnorderedList', false, null); });
    this.AddButton(SA.ImagePathUrl + 'list_numbers.png', 'ordered list',
                   function () { document.execCommand('InsertOrderedList', false, null); });
    this.AddButton(SA.ImagePathUrl + 'indent_increase.png', 'indent',
                   function () { document.execCommand('indent', false, null); });
    this.AddButton(SA.ImagePathUrl + 'indent_decrease.png', 'outdent',
                   function () { document.execCommand('outdent', false, null); });
    this.AddButton(SA.ImagePathUrl + 'alignment_left.png', 'align left',
                   function () { document.execCommand('justifyLeft', false, null); });
    this.AddButton(SA.ImagePathUrl + 'alignment_center.png', 'align center',
                   function () { document.execCommand('justifyCenter', false, null); });
    this.AddButton(SA.ImagePathUrl + 'alignment_full.png', 'align full',
                   function () { document.execCommand('justifyFull', false, null); });
    this.AddButton(SA.ImagePathUrl + 'edit_superscript.png', 'superscript',
                   function () { document.execCommand('superscript', false, null); });
    this.AddButton(SA.ImagePathUrl + 'edit_subscript.png', 'subscript',
                   function () { document.execCommand('subscript', false, null); });
  }

  SaTextEditor.prototype.EditingOn = function () {
    // Keep text editors from stepping on eachothers events.
    // Only one text editor can edit at a time.
    // I could look if body has the binding 'mousedown.textEditor', but the
    // is now a pain.
    if ($('body')[0].saTextEditing) {
      $('body')[0].saTextEditing.EditingOff();
    }
    $('body')[0].saTextEditing = this;

    var offset = 20;
    var pos = this.Div.position();
    var width = this.Div.outerWidth();
    if (width < 275) { width = 275; }
    var height = this.Div.outerHeight() + offset;
    this.EditButtonDiv
        .css({'left': pos.left + 'px',
          'top': (pos.top - offset) + 'px',
          'width': width + 'px',
          'height': height + 'px'})
        .show();

    // mouse up because it should always propagate.
    var self = this;

    $('body').on(
        'mousedown.textEditor',
        function (e) {
          // We do not want click in the text box (or buttons) to turn
          // off editing.
          if (self.Div[0] !== e.srcElement &&
                 self.EditButtonDiv[0] !== e.srcElement &&
                 !$.contains(self.Div[0], e.srcElement) &&
                 !$.contains(self.EditButtonDiv[0], e.srcElement)) {
            self.EditingOff();
          }
        });

    // Bad name. Actually movable.
    // TODO: Change this name.
    // hack
    this.Div[0].saElement.LockActive = true;
    this.SavedMovable = this.Div[0].saElement.Editable;
    this.Div[0].saElement.EditableOff();
    this.Div[0].saElement.Clickable = false;

    this.Div
        .attr('contenteditable', 'true')
        .css({'cursor': 'text'});

    SA.ContentEditableHasFocus = true;
  };

  SaTextEditor.prototype.EditingOff = function () {
    delete $('body')[0].saTextEditing;
    $('body').off('mousedown.textEditor');

    // Convert the line heights of pasted text to percentages.
    // It will over ride line height set in the properties, maybe I can
    // clear the decendant line heights when the text line height is set
    // explicitly.  I could also ally line height to selected text, but
    // that would be messy.
    var decendants = this.Div.find('*');
    for (var i = 0; i < decendants.length; ++i) {
      if (decendants[i].style.lineHeight.indexOf('px') > -1) {
        var percentage = parseFloat(decendants[i].style.lineHeight);
        percentage = 100 * percentage / parseFloat($(decendants[i]).css('font-size'));
        decendants[i].style.lineHeight = percentage.toString() + '%';
      }
    }

    // Grow the parent div to contain the text.
    var textHeight = this.Div[0].scrollHeight;
    if (textHeight > this.Div.outerHeight()) {
      if (this.Div.css('box-sizing') === 'border-box') {
        this.Div.height(textHeight + 4);
      } else {
        this.Div.outerHeight(textHeight + 4);
      }
      // Aspect ratio on TextEditor is not supported.
      this.Div.trigger('resize');
      this.Div[0].saElement.ConvertToPercentages();
    }

    this.EditButtonDiv.hide();
    // hack
    this.Div[0].saElement.LockActive = false;
    this.Div[0].saElement.ActiveOff();

    if (this.SavedMovable) {
      this.Div[0].saElement.EditableOn();
    }
    this.Div[0].saElement.Clickable = true;
    this.Div
        .attr('contenteditable', 'false')
        .off('mouseleave.textEditor')
        .css('cursor', '');

    SA.ContentEditableHasFocus = false;
  };

  SaTextEditor.prototype.AddButton = function (src, tooltip, callback, prepend) {
    var buttonsDiv = this.EditButtonDiv;

    var button = $('<img>')
        .addClass('editButton')
        .css({'height': '16px'})
        .attr('src', src);
    if (callback) {
      button.click(callback);
    }

    if (tooltip) {
      button.prop('title', tooltip);
    }

    if (prepend) {
      button.prependTo(buttonsDiv);
    } else {
      button.appendTo(buttonsDiv);
    }

    return button;
  };

  SaTextEditor.prototype.ProcessArguments = function (args) {
    args = args || {dialog: true};
    this.Div[0].saText.ProcessArguments(args);

    // generic method call. Give jquery ui access to all this objects methods.
    if (typeof (this[args[0]]) === 'function') {
      // first list item is the method name,
      // the rest are arguments to the method.
      return this[args[0]].apply(this, Array.prototype.slice.call(args, 1));
    }
  };

  SaTextEditor.prototype.DialogInitialize = function () {
    var str;

    // iniitalize the values.
    if (this.Div[0].saScalableFont) {
      var scale = this.Div[0].saScalableFont.scale;
      var fontSize = Math.round(scale * 800);
      this.FontSize.val(fontSize);
    }

    var color = '#000000';
    str = this.Div[0].style.color;
    if (str !== '') {
      color = SAM.ConvertColorToHex(str);
    }
    this.FontColor.spectrum('set', color);

    var lineHeight = 120; // default value?
    str = this.Div[0].style.lineHeight;
    if (str !== '') {
      if (str.substring(str.length - 1) === '%') {
        lineHeight = parseFloat(str.substr(0, str.length - 1));
      }
    }
    this.LineHeight.val(lineHeight);
  };

  SaTextEditor.prototype.DialogApply = function () {
    // this.Div.css({'padding'      : '1%',
    //              'border-radius': '3px'});

    if (this.FontSize) {
      var scale = parseFloat(this.FontSize.val()) / 800;
      var jSel = this.Div;
      // It is contained in a parent scalable font, so just set the attribute.
      // jSel.setAttribute('sa-font-scale', scale.toString());
      jSel.saScalableFont({scale: scale});
    }

    if (this.LineHeight) {
      var lineHeight = parseFloat(this.LineHeight.val());
      this.Div[0].style.lineHeight = lineHeight + '%';
    }

    var color;
    if (this.FontColor) {
      color = this.FontColor.spectrum('get');
      this.Div[0].style.color = color;
    }

    color = '#000000';
    var str = this.Div[0].style.color;
    if (str !== '') {
      color = str;
    }
    this.FontColor.spectrum('set', color);
  };

  SaTextEditor.prototype.Delete = function () {
    this.Div.remove();
  };

  SaTextEditor.prototype.InsertUrlLink = function () {
    var self = this;
    var sel = window.getSelection();
    // This call will clear the selected text if it is not in this editor.
    var range = SA.GetSelectionRange(this.Div);
    var selectedText = sel.toString();

    if (!this.UrlDialog) {
      var dialog = new SAM.Dialog(
            function () {
              self.InsertUrlLinkAccept();
            });
      this.UrlDialog = dialog;
      dialog.Dialog.css({'width': '40em'});
      dialog.Title.text('Paste URL link');
      dialog.TextDiv =
            $('<div>')
            .appendTo(dialog.Body)
            .css({'display': 'table-row',
              'width': '100%'});
      dialog.TextLabel =
            $('<div>')
            .appendTo(dialog.TextDiv)
            .text('Text to display:')
            .css({'display': 'table-cell',
              'height': '2em',
              'text-align': 'left'});
      dialog.TextInput =
            $('<input>')
            .appendTo(dialog.TextDiv)
            .val('#30ff00')
            .css({'display': 'table-cell',
              'width': '25em'});

      dialog.UrlDiv =
            $('<div>')
            .appendTo(dialog.Body)
            .css({'display': 'table-row'});
      dialog.UrlLabel =
            $('<div>')
            .appendTo(dialog.UrlDiv)
            .text('URL link:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
      dialog.UrlInput =
            $('<input>')
            .appendTo(dialog.UrlDiv)
            .val('#30ff00')
            .css({'display': 'table-cell',
              'width': '25em'})
            .on('input', function () {
              var url = self.UrlDialog.UrlInput.val();
              if (self.UrlDialog.LastUrl === self.UrlDialog.TextInput.val()) {
                // The text is same as the URL. Keep them synchronized.
                self.UrlDialog.TextInput.val(url);
              }
              self.UrlDialog.LastUrl = url;
              // Deactivate the apply button if the url is blank.
              if (url === '') {
                self.UrlDialog.ApplyButton.attr('disabled', true);
              } else {
                self.UrlDialog.ApplyButton.attr('disabled', false);
              }
            });
    }

    // We have to save the range/selection because user interaction with
    // the dialog clears the text entry selection.
    this.UrlDialog.SelectionRange = range;
    this.UrlDialog.TextInput.val(selectedText);
    this.UrlDialog.UrlInput.val('');
    this.UrlDialog.LastUrl = '';
    this.UrlDialog.ApplyButton.attr('disabled', true);
    this.UrlDialog.Show(true);
  };

  SaTextEditor.prototype.InsertUrlLinkAccept = function () {
    var sel = window.getSelection();
    var range = this.UrlDialog.SelectionRange;
    if (!range) {
      range = SA.MakeSelectionRange(this.Div);
    }

    // Simply put a span tag around the text with the id of the view.
    // It will be formated by the note hyperlink code.
    var link = document.createElement('a');
    link.href = this.UrlDialog.UrlInput.val();
    link.target = '_blank';

    // It might be nice to have an id to get the href for modification.
    // span.id = note.Id;

    // Replace or insert the text.
    if (!range.collapsed) {
      // Remove the seelcted text.
      range.extractContents(); // deleteContents(); // cloneContents
      range.collapse(true);
    }
    var linkText = this.UrlDialog.TextInput.val();
    if (linkText === '') {
      linkText = this.UrlDialog.UrlInput.val();
    }
    link.appendChild(document.createTextNode(linkText));

    range.insertNode(link);
    if (range.noCursor) {
      // Leave the selection the same as we found it.
      // Ready for the next link.
      sel.removeAllRanges();
    }
  };

  // This does not work yet.!!!!!!!!!!!!!!!
  // Returns the jquery object selected.  If a partial object is selected,
  // the dom is split up into fragments.
  SaTextEditor.prototype.GetSelection = function () {
    var sel = window.getSelection();
    var range;
    var parent = null;

    // Two conditions when we just return the top level div:
    // nothing selected, and something selected in wrong parent.
    // use parent as a flag.
    if (sel.rangeCount > 0) {
      // Something is selected
      range = sel.getRangeAt(0);
      range.noCursor = false;
      // Make sure the selection / cursor is in this editor.
      parent = range.commonAncestorContainer;
      // I could use jquery .parents(), but I bet this is more efficient.
      while (parent && parent !== this.Div[0]) {
            // if ( ! parent) {
                // I believe this happens when outside text is selected.
                // We should we treat this case like nothing is selected.
                // console.log("Wrong parent");
                // return;
            // }
        if (parent) {
          parent = parent.parentNode;
        }
      }
    }
    if (!parent) {
      return this.Div;
    }

    // Insert the fragments without a container.
    var children = range.extractContents().children;
    for (var i = 0; i < children.length; ++i) {
      range.insertNode(children[i]);
    }
    return $(children);

    // Create a new span around the fragment.
    // var newNode = document.createElement('span');
    // newNode.appendChild(range.extractContents());
    // range.insertNode(newNode)
    // return $(newNode);
  };

// Set in position in pixels
  SaTextEditor.prototype.SetPositionPixel = function (x, y) {
    if (this.Percentage) {
      x = 100 * x / this.Div.parent().width();
      y = 100 * y / this.Div.parent().height();
      this.Div[0].style.left = x.toString() + '%';
      this.Div[0].style.top = y.toString() + '%';
    } else {
      this.Div[0].style.left = x + 'px';
      this.Div[0].style.top = y + 'px';
    }
  };

// ==============================================================================
// a "subclass" of SaElement.
// Click expands the element.
// TODO:
// Do not expand images larger than their native resolution (double maybe?)
// Change answer to question in the properties menu.
// Camera gets restored on shrink (even in edit mode)
//   Maybe push pin or camera icon to capture changes

  jQuery.prototype.saLightBox = function (arg1) { // 'arguments' handles extras.
    // Superclass constructor.
    this.saElement();
    this.addClass('sa-light-box');
    for (var i = 0; i < this.length; ++i) {
      if (!this[i].saLightBox) {
        var helper = new SaLightBox($(this[i]));
        // Add the helper as an instance variable to the dom object.
        this[i].saLightBox = helper;
      }
      this[i].saLightBox.ProcessArguments(arguments);
    }

    return this;
  };

  function SaLightBox (div) {
    var self = this;
    div[0].saElement.SetClickCallback(function () { self.Expand(true); });

    this.Div = div;
    this.Expanded = false;
    this.ExpandCallback = null;
    this.AspectRatio = false;
    this.Interactive = true;

    // Mask is to gray out background and consume events.
    // All lightbox items in this parent will share a mask.
    var parent = div.parent();
    this.Mask = parent.find('.sa-light-box-mask');
    if (this.Mask.length === 0) {
      this.Mask = $('<div>')
            .appendTo(parent)
            .addClass('sa-light-box-mask') // So it can be retrieved.
            .addClass('sa-edit-gui') // Remove before saHtml save.
            .hide()
            .css({'position': 'absolute',
              'left': '0px',
              'top': '0px',
              'width': '100%',
              'height': '100%',
              'z-index': '99',
              'opacity': '0.5',
              'background-color': '#000'});
    }
  }

  SaLightBox.prototype.ProcessArguments = function (args) {
    if (args.length === 0) { return; }

    // Superclass
    this.Div[0].saElement.ProcessArguments(args);

    // generic method call. Give jquery ui access to all this objects methods.
    if (typeof (this[args[0]]) === 'function') {
      // first list item is the method name,
      // the rest are arguments to the method.
      return this[args[0]].apply(this, Array.prototype.slice.call(args, 1));
    }

    // Handle the legacy behavior.
    // One argument: an object (like jqueryUI).
    args = args[0];

    if (args.aspectRatio !== undefined) {
      this.AspectRatio = args.aspectRatio;
    }

    // lightbox and element editable flags are not always the same.
    // When expanded, The element editable is turned off.
    if (args.editable !== undefined) {
      this.Editable = args.editable;
    }

    // External control of expanding or shrinking.
    if (args.expand !== undefined) {
      this.Expand(args.expand, args.animate);
    }

    if (args.Interactive !== undefined) {
      this.Interactive = args.interactive;
    }

    // Callback when expanded state changes.
    // Viewer interaction is only enabled when the element expands.
    if (args.onExpand) {
      this.ExpandCallback = args.onExpand;
    }

    // generic method call. Give jquery ui access to all this objects methods.
    if (typeof (this[args[0]]) === 'function') {
      // first list item is the method name,
      // the rest are arguments to the method.
      return this[args[0]].apply(this, Array.prototype.slice.call(args, 1));
    }
  };

// I cannot put this directly as a callback because it
// overwrites the viewer resize method.
  SaLightBox.prototype.UpdateSize = function () {
    if (!this.Expanded) { return; }

    var self = this;
    var left = '5%';
    var top = '5%';
    var width = '90%';
    var height = '90%';
    if (this.AspectRatio) {
      // Hack to get expanded images to resize.
      if (!this.Div[0].onresize) {
        this.Div[0].onresize =
                function () {
                  self.UpdateSize();
                };
        this.Div.addClass('sa-resize');
      }

      // Compute the new size.
      var ratio = this.Div.width() / this.Div.height();
      var pWidth = this.Div.parent().width();
      var pHeight = this.Div.parent().height();
      width = Math.floor(pWidth * 0.9);
      height = Math.floor(pHeight * 0.9);
      if (width / height > ratio) {
        width = Math.floor(height * ratio);
      } else {
        height = Math.floor(width / ratio);
      }
      left = Math.floor(0.5 * (pWidth - width)) + 'px';
      top = Math.floor(0.5 * (pHeight - height)) + 'px';
      width = width + 'px';
      height = height + 'px';
    }

    // Make the image big
    // Not resize handles have z-index 1000 !
    // I am close to just implementing my own resize feature.
    this.Div.css({'z-index': '1001'});
    this.Div.css({'left': left,
      'top': top,
      'width': width,
      'height': height});
  };

  SaLightBox.prototype.Expand = function (flag, animate) {
    if (!this.Interactive) { return; }
    if (flag === this.Expanded) { return; }
    var self = this;
    if (flag) {
      this.Div.saElement({editable: false});
      // We have to disable teh expand behavior too.
      this.Expanded = true;

      // Save the current position and size.
      this.SavedTop = this.Div[0].style.top;
      this.SavedLeft = this.Div[0].style.left;
      this.SavedWidth = this.Div[0].style.width;
      this.SavedHeight = this.Div[0].style.height;
      this.SavedZIndex = this.Div[0].style.zIndex;

      // Make the image big
      // Not resize handles have z-index 1000 !
      // I am close to just implementing my own resize feature.
      this.Div.css({'z-index': '1001'});
      this.UpdateSize();
      this.Div.trigger('resize');

      // Show the mask.
      this.Mask.show();
      // Clicking outside the div will cause the div to shrink back to
      // its original size.
      this.Mask.on(
            'mousedown.lightbox',
            function () {
              self.Expand(false, true);
            });
    } else {
      // Reverse the expansion.
      // hide the mask
      this.Mask.hide();
      // remove event to shrink div.
      this.Mask.off('mousedown.lightbox');
      if (animate) {
        this.Div.animate({'top': self.SavedTop,
          'left': self.SavedLeft,
          'width': self.SavedWidth,
          'height': self.SavedHeight,
          'z-index': self.SavedZIndex},
                             {step: function () { self.Div.trigger('resize'); }});
      } else {
        this.Div.css({'top': self.SavedTop,
          'left': self.SavedLeft,
          'width': self.SavedWidth,
          'height': self.SavedHeight,
          'z-index': self.SavedZIndex});
      }
      this.Expanded = false;
      if (this.Editable) {
        this.Div.saElement({editable: true});
      }
    }

    // External changes with editability (viewer interaction).
    if (this.ExpandCallback) {
      (this.ExpandCallback)(flag);
    }
    this.Div.trigger('resize');
  };

// ==============================================================================
// Combination of lightbox and viewer.
// This simply manages the switch betweenlight box interaction and viewer
// interaction.

  jQuery.prototype.saLightBoxViewer = function (args) {
    if (!args.hideCopyright) {
      args.hideCopyright = true;
    }
    // No zoom widget when minimized.
    if (!args.zoomWidget) {
      args.zoomWidget = false;
    }
    if (!args.dualWidget) {
      args.dualWidget = false;
    }
    if (!args.navigation) {
      args.navigation = false;
    }
    if (!args.drawWidget) {
      args.drawWidget = false;
    }
    if (args.interaction === undefined) {
      args.interaction = false;
    }

    // Small viewer does not have overview
    args.overview = false;

    // sa viewer is separate.  We need to pass the args to saLightBoxToo.
    this.saViewer(args);
    // sa viewer is separate.  We need to pass the args to saLightBoxToo.
    args.onExpand =
        function (expanded) {
          this.Div.saViewer({interaction: expanded});
          if (expanded) {
            this.Div.saViewer({overview: true,
              navigation: true,
              menu: true,
              zoomWidget: true,
              dualWidget: true,
              drawWidget: true});
          } else {
            this.Div.saViewer({overview: false,
              navigation: false,
              menu: false,
              zoomWidget: false,
              dualWidget: false,
              drawWidget: false});
                // This is here to restore the viewer to its
                // initial state when it shrinks
                // TODO: Formalize this hack. Viewer formally needs a note.
                // If not editable, restore the note.
            var display = this.Div[0].saViewer;
            var note = display.saNote;
            if (!this.Div[0].saLightBox.Editable && note) {
              var index = display.saViewerIndex || 0;
              display.SetNote(note, index);
            }
          }
        };
    this.saLightBox(args);
    this.addClass('sa-lightbox-viewer');

    return this;
  };

  // ==============================================================================
  // This is legacy and not used anymore.
  // A common parent for all sa buttons (for this element).
  // Handle showing and hiding buttons.  Internal helper.

  // Just for enabling and disabling the edit buttons
  // cmd: "enable" or "disable"

  // Only one set of buttons are visible at a time.
  var SA_BUTTONS_VISIBLE = null;

  jQuery.prototype.saButtons = function (cmd) {
    var i;
    if (cmd === 'enable') {
      for (i = 0; i < this.length; ++i) {
        saButtonsEnable(this[i]);
      }
    }
    if (cmd === 'disable') {
      for (i = 0; i < this.length; ++i) {
        saButtonsDisable(this[i]);
      }
    }
  };

  function saGetButtonsDiv (domElement) {
    if (!domElement.saButtons) {
      // Edit buttons.
      var helper = new SaButtons($(domElement));
      domElement.saButtons = helper;
    }
    return domElement.saButtons.ButtonsDiv;
  }

  function SaButtons (div) {
    this.Enabled = true;
    this.Div = div;
    this.TimerId = -1;
    var pos = div.position();
    this.ButtonsDiv = $('<div>')
        .appendTo(div.parent())
        .addClass('sa-edit-gui') // So we can remove it when saving.
        .hide()
        .css({'position': 'absolute',
          'left': (pos.left + 10) + 'px',
          'top': (pos.top - 20) + 'px',
          'width': '360px', // TODO: see if we can get rid of the width.
          'z-index': '10'});
    // Make it easy to enable and disable these edit buttons.
    this.ButtonsDiv[0].saButtons = this;
    // Show the buttons on hover.
    var self = this;
    this.ButtonsDiv
        .mouseenter(function () { self.ShowButtons(2); })
        .mouseleave(function () { self.HideButtons(); });

    this.Div
        .mouseenter(function () { self.ShowButtons(1); })
        .mouseleave(function () { self.HideButtons(); });
  }

  SaButtons.prototype.PlaceButtons = function () {
    var pos = this.Div.position();
    this.ButtonsDiv
        .css({'left': (pos.left + 10) + 'px',
          'top': (pos.top - 20) + 'px'});
  };

  SaButtons.prototype.ShowButtons = function (level) {
    if (this.TimerId >= 0) {
      clearTimeout(this.TimerId);
      this.TimerId = -1;
    }
    if (this.Enabled) {
      if (SA_BUTTONS_VISIBLE && SA_BUTTONS_VISIBLE !== this.ButtonsDiv) {
        SA_BUTTONS_VISIBLE.fadeOut(200);
        SA_BUTTONS_VISIBLE = this.ButtonsDiv;
      }
      this.PlaceButtons();
      if (level === 1) {
        this.ButtonsDiv
                .fadeIn(400);
        this.ButtonsDiv.children()
                .css({'opacity': '0.4'});
      } else {
        this.ButtonsDiv
                .show();
        this.ButtonsDiv.children()
                .css({'opacity': '1.0'});
      }
    }
  };

  SaButtons.prototype.HideButtons = function () {
    if (this.TimerId < 0) {
      var self = this;
      this.TimerId =
            setTimeout(function () {
              if (SA_BUTTONS_VISIBLE === self.ButtonsDiv) {
                SA_BUTTONS_VISIBLE = null;
              }
              self.ButtonsDiv.fadeOut(200);
            }, 200);
    }
  };

  function saAddButton (domElement, src, tooltip, callback, prepend) {
    var buttonsDiv = saGetButtonsDiv(domElement);

    var button = $('<img>')
        .addClass('editButton')
        .css({'height': '16px'})
        .attr('src', src);
    if (callback) {
      button.on('click touchstart', callback);
    }

    if (tooltip) {
      button.prop('title', tooltip);
    }

    if (prepend) {
      button.prependTo(buttonsDiv);
    } else {
      button.appendTo(buttonsDiv);
    }

    return button;
  }

  // private functions.
  // TODO: Make an api through jquery to do this.
  function saButtonsDisable (element) {
    if (!element.saButtons) { return; }
    element.saButtons.Enabled = false;
    element.saButtons.ButtonsDiv.hide();
  }

  function saButtonsEnable (element) {
    if (!element.saButtons) { return; }
    element.saButtons.Enabled = true;
  }

// Remove the buttons div.
  function saButtonsDelete (element) {
    if (!element.saButtons) { return; }
    element.saButtons.ButtonsDiv.remove();
  }

// ==============================================================================
// Load html into a div just like .html, but setup slide atlas jquery
// extensions.  The state of these extensions is saved in attributes.
// The extension type is saved as a class.

  jQuery.prototype.saHtml = function (string) {
    if (string) {
      this.html(string);
      this.find('.sa-scalable-font').saScalableFont();
      // this.find('.sa-full-window-option').saFullWindowOption();
      // TODO: Move this out of this file.
      this.find('.sa-presentation-rectangle').saRectangle();
      // Change legacy sa-presentation-view into sa-lightbox-viewer
      this.find('.sa-presentation-view')
            .addClass('sa-lightbox-viewer')
            .removeClass('sa-presentation-view');
      // Get rid of the extra handles we no longer use.
      // the ui-resiable was flakey.  It was eaiser just to code the
      // behavior myself.
      this.find('.ui-resizable-handle').remove();
      this.find('.ui-resizable').removeClass('ui-resizable');

      // We need to load the note.
      var viewDivs = this.find('.sa-lightbox-viewer');
      viewDivs.saLightBoxViewer({'hideCopyright': true,
        'interaction': false});

      for (var i = 0; i < viewDivs.length; ++i) {
        var display = viewDivs[i].saViewer;
        var noteId = $(viewDivs[i]).attr('sa-note-id');
        var viewerIdx = $(viewDivs[i]).attr('sa-viewer-index') || 0;
        viewerIdx = parseInt(viewerIdx);
        // var viewerIdx = $(viewDivs[i]).attr('sa-viewer-index') || 0;
        // viewerIdx = parseInt(viewerIdx);
        // TODO: This should not be here.
        // The saViewer should handle this internally.
        if (noteId) {
          display.SetNoteFromId(noteId, viewerIdx);
        }
      }

      if (SA.Edit) {
        var items = this.find('.sa-resizable');
        // temporary to make previous editors draggable.
        items = this.find('.sa-text-editor');
        items.saTextEditor({editable: true});

        items = this.find('.sa-presentation-rectangle');
        items.saRectangle({editable: true});

        items = this.find('.sa-question');
        items.saQuestion({editable: true});

        items = this.find('.sa-presentation-image');
        items.saLightBox({aspectRatio: true,
          editable: true});

        items = this.find('.sa-lightbox-viewer');
        items.saViewer({drawWidget: false});
      } else {
        // I need the text to show when the bounds are too small.
        items = this.find('.sa-text-editor');
        items.css({'overflow': 'visible'});
      }

      return;
    }

    // Shrink any light box elements that are expanded.
    this.find('.sa-light-box').saLightBox({'expand': false, 'animate': false});

    // Items that are not visible loos their position.
    this.find('.sa-quiz-hide').show();
    this.find('.sa-presentation-title').show();

    // Get rid of the <gui elements when returning the html.
    var copy = this.clone();
    copy.find('.sa-edit-gui').remove();
    copy.find('.sa-standin').remove();
    copy.find('.ui-resizable').resizable('destroy');
    // copy.find('.ui-resizable-handle').remove();

    // Get rid of the children of the sa-presentation-view.
    // They will be recreated by viewer when the html is loaded.
    copy.find('.sa-lightbox-viewer').empty();

    return copy.html();
  };

// ==============================================================================
// LEGACY
// Just add the feature of setting width and height as percentages.

  jQuery.prototype.saResizable = function (args) {
    args = args || {};
    args.start = function (e, ui) {
      if (this.saViewer) {
            // Translate events were being triggered in the viewer.
        this.saViewer.DisableInteraction();
      }
    };
    args.stop = function (e, ui) {
      // change the width to a percentage.
      var width = $(this).width();
      width = 100 * width / $(this).parent().width();
      this.style.width = width.toString() + '%';
      // change the height to a percentage.
      var height = $(this).height();
      height = 100 * height / $(this).parent().height();
      this.style.height = height.toString() + '%';

      // We have to change the top and left ot percentages too.
      // I might have to make my own resizable to get the exact behavior
      // I want.
      var pos = $(this).position();
      var top = 100 * pos.top / $(this).parent().height();
      var left = 100 * pos.left / $(this).parent().width();
      this.style.top = top.toString() + '%';
      this.style.left = left.toString() + '%';
    };

    this.addClass('sa-resizable');

    return this;
  };

// ==============================================================================
// Attempting to make the viewer a jqueryUI widget.
// Note:  It does not make sense to call this on multiple divs at once when
//        the note/view is being set.
// args = {interaction:true,
//         overview:true,
//         menu:true,
//         drawWidget:true,
//         zoomWidget:true,
//         viewId:"55f834dd3f24e56314a56b12", note: {...}
//         viewerIndex: 0,
//         hideCopyright: false}
// viewId (which loads a note) or a preloaded note can be specified.
// the viewId has precedence over note if both are given.
// viewerIndex of the note defaults to 0.
// Note: hideCopyright will turn off when a new note is loaded.
  jQuery.prototype.saViewer = function (args) {
    return SAViewer(this, args);
  };
  // Non jquery api
  var SAViewer = function (element, args) {
    // default
    args = args || {};
    if (typeof (args) === 'object') {
      // This is ignored if there is not viewId or note.
      args.viewerIndex = args.viewerIndex || 0;
    }
    // get the note object if an id is specified.
    if (args.viewId) {
      args.note = SA.GetNoteFromId(args.viewId);
      if (args.note === null) {
        // It has not been loaded yet.  Get if from the server.
        args.note = new SA.Note();
        args.note.LoadViewId(
                args.viewId,
                function () {
                  saViewerSetup(arguments);
                });
        return element;
      }
    }

    // User can call a viewer method through thie jquery api.
    // Pass on the return value if it has one.
    if (arguments.length === 0) {
      return saViewerSetup([element, args]) || element;
    }
    return saViewerSetup(arguments) || element;
  };

  // I am struggling for an API to choose between single view and dual view.
  // - I considered saDualViewer, but it is nearly identical to saViewer and
  // saLightBoxViewer does not know which to create because it does not have
  // the note early enough.
  // - I consider hinging it on the existence of sa-viewer-index but that is
  // hidden and not obvious.
  // I choose to pass an argument flag "dual", but am sure how to store the
  // flag in html. I could have an attribute "dual", but I think I like to
  // change the class from sa-viewer to sa-dual-viewer better.
  // TODO: Make the argument calls not dependant on order.
  function saViewerSetup (args) {
    // TODO: Think about making this viewer specific rather than a global.

    var self = args[0];

    // legacy api: params encoded in second arguement object.
    var params;
    if (typeof (args[1]) === 'object') {
      params = args[1];
    }

    if (params && params.prefixUrl) {
      SA.ImagePathUrl = params.prefixUrl;
      SAM.ImagePathUrl = params.prefixUrl;
    }

    $(window)
        .off('resize.sa')
        .on('resize.sa', saResizeCallback);

    for (var i = 0; i < self.length; ++i) {
      if (args[1] === 'destroy') {
        $(self[i]).removeClass('sa-resize');
        // This should not cause a problem.
        // Only one resize element should be using this element.
        $(self[i]).removeClass('sa-resize');
        $(self[i]).removeClass('sa-viewer');
        if (self[i].saViewer) {
          self[i].saViewer.Delete();
          delete self[i].saViewer;
        }
        continue;
      }

      if (!self[i].saViewer) {
        if (params) {
          // look for class name.
          if (self.hasClass('sa-dual-viewer')) {
            params.dual = true;
          }
          // Add the viewer as an instance variable to the dom object.
          if (params.dual) {
            // TODO: dual has to be set on the first call.  Make this
            // order independant. Also get rid of args here. We should
            // use process arguments to setup options.
            self[i].saViewer = new SA.DualViewWidget($(self[i]));
          } else {
            self[i].saViewer = new SA.Viewer($(self[i]));
          }
        }

        // When the div resizes, we need to synch the camera and
        // canvas.
        self[i].onresize =
                function () {
                  this.saViewer.UpdateSize();
                };
        // Only the body seems to trigger onresize.  We need to trigger
        // it explicitly (from the body onresize function).
        $(self[i]).addClass('sa-resize');
      }
      // generic method call. Give jquery ui access to all this objects methods.
      // jquery puts the query results as the first argument.
      var viewer = self[i].saViewer;
      if (viewer && typeof (viewer[args[1]]) === 'function') {
        // first list item is the method name,
        // the rest are arguments to the method.
        return viewer[args[1]].apply(viewer, Array.prototype.slice.call(args, 2));
      }

      if (params) {
        self[i].saViewer.ProcessArguments(params);
      }
      self[i].saViewer.EventuallyRender();
    }
  }

  // This put changes from the viewer in to the note.
  // Is there a better way to do this?
  // Maybe a save method?
  jQuery.prototype.saRecordViewer = function () {
    for (var i = 0; i < this.length; ++i) {
      if (this[i].saViewer && this[i].saViewer.saNote) {
        var idx = this[i].saViewer.saViewerIndex || 0;
        var note = this[i].saViewer.saNote;
        this[i].saViewer.Record(note, idx);
      }
    }
  };

// ==============================================================================
// JQuery items are not responding to resize events.  This fixes the
// problem by using window resize event for all
// NOTE: This depends on saFullSize callbacks.
  jQuery.prototype.saOnResize = function (callback) {
    this.addClass('sa-resize');
    for (var i = 0; i < this.length; ++i) {
      this[i].onresize = callback;
    }

    return this;
  };

  jQuery.prototype.saTriggerResize = function () {
    $(window).trigger('resize');
  };

// ==============================================================================
// jQuery extension for a full window div.
// parent must be the body?  Maybe not.  Lets see if a full height is better.
// I think position should be set to fixed or absolute.

// TODO: Convert the viewer to use this.

  function saResizeCallback () {
    var height = window.innerHeight;
    var items = $('.sa-full-height');
    for (var i = 0; i < items.length; ++i) {
      var item = items[i];
      $(item).css({'top': '0px',
        'height': height + 'px'});
    }
    // Hack until I can figure out why the resize event is not
    // firing for descendants.
    // This did not work.  It also triggered resize on the window
    // causeing infinite recusion.
    // $('.sa-resize').trigger('resize');
    // call onresize manually.
    var elements = $('.sa-resize');
    for (i = 0; i < elements.length; ++i) {
      if (elements[i].onresize) {
        elements[i].onresize();
      }
    }
  }

  // ==============================================================================
  // Non jquery api
  // Building block for an accordian viewer.
  // TODO: open and close callbacks.
  var saAccordianDiv = function (parent, label) {
    var labelDiv = $('<div>')
      .appendTo(parent)
      .css({'display': 'block'});
    var openCloseIcon = $('<img>')
      .appendTo(labelDiv)
      .attr('src', SA.ImagePathUrl + 'plus.png');
    var labelSpan = $('<span>')
      .appendTo(labelDiv)
      .css({'padding-left': '5px'})
      .text(label);
    var contents = $('<div>')
      .appendTo(parent)
      .css({
        'display': 'block',
        'padding-left': '17px'})
      .hide();
    var open = false;
    // Hack?  Still trying to combine objects with jquery api.
    // I want to return the jquery  reference, but also have methods.
    // Attach methods to the dom object.
    contents[0].open = function () {
      open = true;
      contents.slideDown();
      openCloseIcon.attr('src', SA.ImagePathUrl + 'minus.png');
      if (this.openCallback) {
        this.openCallback();
      }
    };
    contents[0].setOpenCallback = function (callback) {
      this.openCallback = callback;
    };

    contents[0].close = function () {
      open = false;
      contents.slideUp();
      openCloseIcon.attr('src', SA.ImagePathUrl + 'plus.png');
    };
    contents[0].getOpen = function () {
      return open;
    };
    contents[0].getLabel = function () {
      return labelSpan;
    };
    openCloseIcon.on('click touchstart',
                     function () {
                       if (open) {
                         contents[0].close();
                       } else {
                         contents[0].open();
                       }
                     });
    return contents;
  };

  // ==============================================================================
  // Non jquery api
  // Give any div the option to go fullscreen. This returns a jquery
  // reference to the full screen button so the user can position in.
  // The user can even choose their own image for the button.
  // TODO: callbacks for start and stop full screen.
  var SAFullScreenButton = function (parent) {
    var fullScreenFlag = false;
    var savedHeight = 'auto';
    var savedParent = parent;

    var fullScreenButton = $('<img>')
        .appendTo(parent)
        .prop('title', 'full screen')
        .addClass('sa-view-button')
        .attr('src', SA.ImagePathUrl + 'fullScreen32.png')
        .css({
          'position': 'absolute',
          'height': '24px',
          'z-index': '300'});

    // Attach variables to the dom button
    var self = fullScreenButton[0];
    fullScreenButton.on(
      'click touchend',
      function (e) {
        e.preventDefault();
        // variable 'this' is probably the same as 'self' here.
        var elem = parent[0];

        if (SAM.MOBILE_DEVICE === 'iPad') {
          fullScreenFlag = !fullScreenFlag;
          if (fullScreenFlag) {
            savedHeight = parent.css('height');

            // just make the viewer fill the body.
            var height = window.innerHeight;
            $(elem).appendTo('body');
            $(elem)
              .css({
                'z-index': '100',
                'background-color': '#fff',
                'position': 'fixed',
                'left': '0',
                'top': '0',
                'width': '100%',
                'height': height + 'px'});
            fullScreenButton.attr('src', SA.ImagePathUrl + 'fullScreenOff32.png');
          } else {
            $(elem)
              .appendTo(savedParent)
              .css({
                'position': 'static',
                'height': savedHeight});
            console.log(savedHeight);
            fullScreenButton.attr('src', SA.ImagePathUrl + 'fullScreen32.png');
          }
          $(window).trigger('resize');
        } else {
          fullScreenFlag = !fullScreenFlag;
          if (fullScreenFlag) {
            var req;
            req = elem.requestFullScreen ||
              elem.webkitRequestFullScreen ||
              elem.mozRequestFullScreen;
            req.call(elem);
          } else {
            if (document.exitFullscreen) {
              document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
              document.webkitExitFullscreen();
            } else if (document.mozCancelFullScreen) {
              document.mozCancelFullScreen();
            } else if (document.msExitFullscreen) {
              document.msExitFullscreen();
            }
          }
        }
        $(window).trigger('resize');
      });

    // detect when we leave full screen.
    parent.on(
        'webkitfullscreenchange mozfullscreenchange fullscreenchange',
        function (e) {
          var state = document.fullScreen || document.mozFullScreen ||
                document.webkitIsFullScreen;
          if (state) {
            // Entering full screen
            savedHeight = parent.css('height');
            fullScreenFlag = true;
            fullScreenButton.attr('src', SA.ImagePathUrl + 'fullScreenOff32.png');
            parent.css({'height': '100%'});
          } else {
            // Exiting full screen
            $(self).show();
            fullScreenFlag = false;
            fullScreenButton.attr('src', SA.ImagePathUrl + 'fullScreen32.png');
            // parent.css({'height': 'auto'});
            parent.css({'height': savedHeight});
            console.log(savedHeight);
          }
          $(window).trigger('resize');
        });
    return fullScreenButton;
  };

  // Args: not used
  jQuery.prototype.saFullHeight = function (args) {
    return SAFullHeight(this, args);
  };

  // ==============================================================================
  // Non jquery api
  // Add resize callbacks that make a jquery element fit the windows height.
  var SAFullHeight = function (element, args) {
    element.css({'top': '0px'});
    element.addClass('sa-full-height');
    for (var i = 0; i < element.length; ++i) {
      // I want to put the resize event on "element[i]",
      // but, I am afraid it might not get trigerend always, or
      // setting the height would cause recursive calls to resize.
      element[i].saFullHeight = args;
    }

    $(window)
        .off('resize.sa')
        .on('resize.sa', saResizeCallback)
        .trigger('resize');

    return element;
  };

  // ==============================================================================
  // Make this window as large as possible in parent, but keep the aspect
  // ratio. This is for presentation windows.
  // Note:  Position of parent has to be not static.
  //        Should I make the position relative rather than absolute?
  jQuery.prototype.saPresentation = function (args) {
    this.addClass('sa-presentation');
    this.addClass('sa-resize');

    $(window)
        .off('resize.sa')
        .on('resize.sa', saResizeCallback)
        .trigger('resize');

    for (var i = 0; i < this.length; ++i) {
      var item = this[i];
      if (!item.saPresentation) {
        item.saPresentation = new SaPresentation($(item), args);
        item.onresize =
                function () {
                  this.saPresentation.Resize();
                };
      }
      // Trouble if their is more than 1.  Maybe trigger
      // a window resize?
      setTimeout(function () { item.saPresentation.Resize(); }, 300);
    }

    return this;
  };

  function SaPresentation (div, args) {
    this.Div = div;
    this.AspectRatio = args.aspectRatio;
    this.Zoom = 1.0;
    this.ShiftX = 0;
    this.ShiftY = 0;

    // Setup events to pan and zoom the presentation window.
    /* var self = this;
    this.Div.on(
        'mousedown.presentation',
        function (e) {
            return self.HandleMouseDown(e);
        });
    */
    // Text is not scaling properly
    /*
    this.Div.on(
        'mousewheel.presentation',
        function(event){
            // Resize from the middle.
            return self.HandleMouseWheel(event.originalEvent);
        });
        */
  }

  SaPresentation.prototype.Resize = function () {
    var ar = this.AspectRatio;
    var parent = this.Div.parent();
    var pWidth = parent.innerWidth();
    var pHeight = parent.innerHeight();
    var width = pWidth;
    var height = pHeight;
    if (width / height > ar) {
      // Window is too wide.
      width = height * ar;
    } else {
      // Window is too tall.
      height = width / ar;
    }
    width = width * this.Zoom;
    height = height * this.Zoom;
    var left = (pWidth - width) * 0.5 + this.ShiftX;
    var top = (pHeight - height) * 0.5 + this.ShiftY;

    this.Div.css({
      'position': 'absolute',
      'top': top + 'px',
      'height': height + 'px',
      'left': left + 'px',
      'width': width + 'px'});
  };

  SaPresentation.prototype.HandleMouseDown = function (event) {
    var self = this;
    // For tap/click rather than drag.
    this.ClickStart = Date.now();

    if (event.which === 1 || event.which === 3) {
      $('body').on(
            'mouseup.presentation',
            function (e) {
              return self.HandleMouseUp(e);
            });
    }

    if (event.which === 1) {
      $('body').on(
            'mousemove.presentation',
            function (e) {
              return self.HandleMouseMove(e);
            });
      $('body').on(
            'mouseleave.presentation',
            function (e) {
              return self.HandleMouseUp(e);
            });
      this.DragLastX = event.screenX;
      this.DragLastY = event.screenY;

      return false;
    }
  };

  // TODO: rethink offset/zoom.  Scale from the middle. Offset should
  // be in percentages maybe
  SaPresentation.prototype.HandleMouseWheel = function (event) {
    var tmp = 0;
    if (event.deltaY) {
      tmp = event.deltaY;
    } else if (event.wheelDelta) {
      tmp = event.wheelDelta;
    }
    if (tmp === 0) { return; }
    // Wheel event seems to be in increments of 3.
    // depreciated mousewheel had increments of 120....
    // Initial delta cause another bug.
    // Lets restrict to one zoom step per event.
    if (tmp > 0) {
      this.Zoom *= 1.01;
    } else if (tmp < 0) {
      this.Zoom *= 0.99;
    }
    this.Resize();

    return false;
  };

  SaPresentation.prototype.HandleMouseMove = function (event) {
    // Wait for the click duration to start dragging.
    if (Date.now() - this.ClickStart < 200) {
      return true;
    }

    if (event.which === 1) {
      var dx = event.screenX - this.DragLastX;
      var dy = event.screenY - this.DragLastY;
      this.DragLastX = event.screenX;
      this.DragLastY = event.screenY;

      this.ShiftX += dx;
      this.ShiftY += dy;
      this.Resize();
      return false;
    }
    return true;
  };

  SaPresentation.prototype.HandleMouseUp = function (event) {
    $('body').off('mouseup.presentation');
    if (event.which === 1) {
      $('body').off('mousemove.presentation');
      $('body').off('mouseleave.presentation');
    }

    return true;
  };

// ==============================================================================
// Font is set as a percentage of the parent height.
// args.size: string i.e. "12%" More work would be needed to make this
// units in pixels.
  jQuery.prototype.saScalableFont = function (args) {
    this.addClass('sa-scalable-font');
    this.addClass('sa-resize');

    $(window)
        .off('resize.sa')
        .on('resize.sa', saResizeCallback);

    for (var i = 0; i < this.length; ++i) {
      var text = this[i];
      if (!text.saScalableFont) {
        text.onresize =
                function () {
                  scale = this.saScalableFont.scale;
                  // Scale it relative to the window.
                  var height = $(this).parent().innerHeight();
                  var fontSize = Math.round(scale * height) + 'px';
                  this.style.fontSize = fontSize;
                  // Getting and setting the html creates text chidlren
                  // with their own font size.
                  $(this).children('font').css({'font-size': fontSize});
                };
        text.saScalableFont = {};
        text.saScalableFont.scale = 0.1;
      }
      var scale = text.saScalableFont.scale;
      // html() saves this attribute.
      // this will restore the scale.
      var scaleStr = text.getAttribute('sa-font-scale');
      if (scaleStr) {
        scale = parseFloat(scaleStr);
      }
      // This overrides the previous two.
      if (args && args.scale) {
        // convert to a decimal.
        scale = args.scale;
        if (typeof (scale) === 'string') {
          if (scale.substring(-1) === '%') {
            scale = parseFloat(scale.substr(0, scale.length - 1)) / 100;
          } else {
            scale = parseFloat(scale);
          }
        }
      }
      // I can either keep this up to date or set it when the
      // saHtml is called. Keeping it set is more local.
      text.setAttribute('sa-font-scale', scale.toString());
      text.saScalableFont.scale = scale;
      text.onresize();
    }

    return this;
  };

// ==============================================================================
// legacy: not used anymore
// draggable with a handle
// TODO: This uses percentages now.  Exxtend with the option to position
// with pixel units.
// args = {grid: [xDivisions, yDivisions]}
  jQuery.prototype.saDraggable = function (args) {
    args = args || {grid: [30, 39]};
    this.addClass('sa-draggable');
    for (var i = 0; i < this.length; ++i) {
      if (!this[i].saDraggable) {
        var helper = new SaDraggable($(this[i]));
        // Add the helper as an instance variable to the dom object.
        this[i].saDraggable = helper;
      }
      this[i].saDraggable.ProcessArguments(args);
    }

    return this;
  };

  function SaDraggable (div) {
    this.XStops = null;
    this.YStops = null;
    this.Percentage = true;
    this.Div = div;

    var self = this;
    var d = saAddButton(div[0], SA.ImagePathUrl + 'fullscreen.png',
                        'drag', null, true);
    d.mousedown(
        function (e) {
          // raise to the top of the layers.
          // this did not work for text boxes on top of views.
          // it did work for mutiple views.
          var parent = self.Div.parent();
          self.Div.detach();
          self.Div.appendTo(parent);

          self.Div.css({'z-index': '5'});

          self.OldX = e.pageX;
          self.OldY = e.pageY;

          var pos = self.Div.position();
          var x = pos.left;
          var y = pos.top;
          var width = self.Div.parent().width();
          var height = self.Div.parent().height();
          if (self.XStops) { self.XStops.Start(x, width); }
          if (self.YStops) { self.YStops.Start(y, height); }
          $('body').on('mousemove.saDrag',
                      function (e) {
                        self.Drag(e.pageX - self.OldX, e.pageY - self.OldY);
                        self.OldX = e.pageX;
                        self.OldY = e.pageY;
                        return false;
                      });
          $('body').on('mouseup.saDrag',
                      function (e) {
                        self.Div.css('z-index', '');
                        $('body').off('mousemove.saDrag');
                        $('body').off('mouseup.saDrag');
                        return false;
                      });
          return false;
        });
  }

  SaDraggable.prototype.ProcessArguments = function (args) {
    if (args.grid) {
      // The grid is not shared.
      this.XStops = new SaStops(args.grid[0]);
      this.YStops = new SaStops(args.grid[1]);
    }

    // generic method call. Give jquery ui access to all this objects methods.
    if (typeof (this[args[0]]) === 'function') {
      // first list item is the method name,
      // the rest are arguments to the method.
      return this[args[0]].apply(this, Array.prototype.slice.call(args, 1));
    }
  };

  // (dx, dy) drag vector in pixels.
  SaDraggable.prototype.Drag = function (dx, dy) {
    var pos = this.Div.position();
    var x = pos.left;
    var y = pos.top;

    var width = this.Div.parent().width();
    var height = this.Div.parent().height();
    var nx = x + dx;
    var ny = y + dy;
    if (this.XStops) {
      nx = this.XStops.Drag(dx);
    }
    if (this.YStops) {
      ny = this.YStops.Drag(dy);
    }

    if (this.Percentage) {
      nx = nx / width;
      ny = ny / height;
      nx = nx * 100;
      ny = ny * 100;
      this.Div[0].style.left = nx + '%';
      this.Div[0].style.top = ny + '%';
    } else {
      this.Div[0].style.left = nx + 'px';
      this.Div[0].style.top = ny + 'px';
    }

    this.Div[0].saButtons.PlaceButtons();
  };

  function SaStops (divisions) {
    // How far do we hve to pass a stop before the item snaps to the mouse.
    this.Threshold = 25;
    // Current Stop
    this.Stopped = false;
    this.Stop = 0;  // TODO: This is not necessary.  Just use last.
    // The amount of drag saved up so far to get out of a stop.
    this.Delta = 0;

    // For speed up factor to account for stopped regions.
    this.Target = 0;
    this.Gap = 100.0;

    // Even positioning of the division.
    this.Divisions = divisions;
    // The current position of the item.
    this.Last = 0;
  }

  SaStops.prototype.Start = function (last, size) {
    this.Stopped = false;
    this.Delta = 0;
    this.Last = last;
    this.Size = size;

    this.Target = last;
    this.Gap = size / this.Divisions;
  };

// last and size could have changed since the last time this was called,
// so pass them in again.
// return:
//   the new position of the item (same units as args).
// arguments (all in the same units):
//   size: width of window
//   last: The current position of the item.
//   delta: The distance the mouse has moved.
  SaStops.prototype.Drag = function (delta) {
    // Put a compensation factor so item follows mouse.
    this.Target += delta;
    delta = delta + 3 * (this.Target - this.Last) / this.Gap;

    // Where we should be without the stop.
    var next = this.Last + delta;

    if (this.Stopped) {
      // Acculilate the movement.
      this.Delta = this.Delta + delta;
      // Have we passed the threshold to exit?
      if (Math.abs(this.Delta) > this.Threshold) {
        // yes
        this.Stopped = false;
        this.Delta = 0;
        this.Last = next;
        return next;
      }
      // no
      return this.Stop;
    }

    // We are note stopped yet.
    // Have we passed a stop?  Get the nearest stop value.
    var stop = this.GetStop(this.Last, next);

    if (stop < this.Last && stop < next) {
      // We did not pass a stop.
      this.Delta = 0;
      this.Last = next;
      return next;
    }
    if (stop > this.Last && stop > next) {
      // We did not pass a stop.
      this.Delta = 0;
      this.Last = next;
      return next;
    }

    // Stop is in middle.  Start the Stopped behavior.
    this.Delta = next - stop;
    this.Last = stop;
    this.Stop = stop;
    this.Stopped = true;

    return stop;
  };

  SaStops.prototype.GetStop = function (last, next) {
    // Put the stops at integer values.
    var last2 = last * this.Divisions / this.Size;
    var next2 = next * this.Divisions / this.Size;
    // transform motion to be positive;
    if (next2 < last2) {
      var tmp = last2;
      last2 = next2;
      next2 = tmp;
    }
    // Find the last stop passed.
    var stop = Math.floor(next2);
    stop = stop * this.Size / this.Divisions;

    return stop;
  };

// ==============================================================================
// DUPLICATE feature
// TODO: remove this
// Option to go full window.  This is intended for viewers, but might be
// made general.

// TODO: We need callbacks when it goes full and back.

// args: "off"  turns full window off.
  jQuery.prototype.saFullWindowOption = function (args) {
    this.addClass('sa-full-window-option');
    for (var i = 0; i < this.length; ++i) {
      if (!this[i].saFullWindowOption) {
        var helper = new SaFullWindowOption($(this[i]));
        // Add the helper as an instance variable to the dom object.
        this[i].saFullWindowOption = helper;
      }
      if (args === 'off') {
        this[i].saFullWindowOption.SetFullWindow($(this[i]), false);
      }
    }

    return this;
  };

  function SaFullWindowOption (div) {
    var self = this;
    this.FullWindowOptionButton = $('<img>')
      .appendTo(div)
      .attr('src', SA.ImagePathUrl + 'fullscreenOn.png')
      .prop('title', 'full window')
      .css({
        'position': 'absolute',
        'width': '12px',
        'left': '-5px',
        'top': '-5px',
        'opacity': '0.5',
        'z-index': '-1'})
      .hover(function () { $(this).css({'opacity': '1.0'}); },
             function () { $(this).css({'opacity': '0.5'}); })
      .on('click touchstart',
          function () {
            self.SetFullWindow(div, true);
          });

    this.FullWindowOptionOffButton = $('<img>')
      .appendTo(div)
      .hide()
      .attr('src', SA.ImagePathUrl + 'fullscreenOff.png')
      .prop('title', 'full window off')
      .css({
        'position': 'absolute',
        'background': '#FFF',
        'width': '16px',
        'left': '1px',
        'top': '1px',
        'opacity': '0.5',
        'z-index': '-1'})
      .hover(function () { $(this).css({'opacity': '1.0'}); },
             function () { $(this).css({'opacity': '0.5'}); })
      .on('click touchstart',
          function () {
            self.SetFullWindow(div, false);
          });
  }

  // TODO: Turn off other editing options: drag, delete, resize.
  SaFullWindowOption.prototype.SetFullWindow = function (div, flag) {
    if (flag) {
      // TODO: Put this in a call back.
      saButtonsDisable(div[0]);
      this.FullWindowOptionOffButton.show();
      this.FullWindowOptionButton.hide();
      // Save the css values to undo.
      this.Left = div[0].style.left;
      this.Width = div[0].style.width;
      this.Top = div[0].style.top;
      this.Height = div[0].style.height;
      this.ZIndex = div[0].style.zIndex;
      div.css({
        'left': '0px',
        'width': '100%',
        'top': '0px',
        'height': '100%',
        'z-index': '10'});
    } else {
      saButtonsEnable(div[0]);
      this.FullWindowOptionOffButton.hide();
      this.FullWindowOptionButton.show();
      div.css({
        'left': this.Left,
        'width': this.Width,
        'top': this.Top,
        'height': this.Height,
        'z-index': this.ZIndex});
    }
    // The viewers need a resize event to change their cameras.
    $(window).trigger('resize');
  };

  // ==============================================================================
  // LEGACY
  // Add a delete button to the jquery objects.

  jQuery.prototype.saDeletable = function (args) {
    this.addClass('sa-deletable');
    for (var i = 0; i < this.length; ++i) {
      var domItem = this[i];
      if (!domItem.saDeletable) {
        // for closure (save element)
        domItem.saDeletable = new SaDeletable(domItem);
      }
    }
    return this;
  };

  // check dom
  function SaDeletable (domItem) {
    this.Button = saAddButton(
        domItem, SA.ImagePathUrl + 'remove.png', 'delete',
        function () {
          // if we want to get rid of the viewer records,
          if (domItem.saViewer) {
            saPruneViewerRecord(domItem.saViewer);
          }
          saButtonsDelete(domItem);
          $(domItem).remove();
        },
        true);
  }

  function saPruneViewerRecord (viewer) {
    // In order to prune, we will need to find the other viewers associated
    // with records in the notes.
    // This is sort of hackish.
    var viewerIdx = viewer.saViewerIndex;
    var note = viewer.saNote;
    var items = $('.sa-lightbox-viewer');
    // Shift all the larger indexes down one.
    for (var i = 0; i < items.length; ++i) {
      if (items[i].saViewer &&
            items[i].saViewer.saNote === note &&
            items[i].saViewer.saViewerIndex > viewerIdx) {
        --items[i].saViewer.saViewerIndex;
      }
    }
    // Remove the viewer record for this viewer.
    note.ViewerRecords.splice(viewerIdx, 1);
  }

// ==============================================================================
// I am having such troubles setting the right panel width to fill.
// Solution is to have this element control too divs (panel and main).
// If the panel overlaps the main, we do not need to manage the main panel.
// It would have to be implemented on the panel div, not the parent div.

// TODO: Verify this works in a stand alone page.
// args
// option to specify the handle.
// option to place panel: left, right, top, bottom.
// Use it for the Notes panel.
// Use it for the presentation edit panel
// use it for dual view.

  function ResizePanel (parent) {
    var self = this;

    // For animating the display of the notes window (DIV).
    this.Width = 353;

    this.PanelDiv = $('<div>').appendTo(parent)
        .css({
          'background-color': 'white',
          'position': 'absolute',
          'top': '0px',
          'bottom': '0px',
          'left': '0px',
          'width': this.Width + 'px'})
        .attr('draggable', 'false')
        .on('dragstart', function () { return false; });
    this.MainDiv = $('<div>').appendTo(parent)
        .css({
          'position': 'absolute',
          'top': '0px',
          'bottom': '0px',
          'left': this.Width + 'px',
          'right': '0px',
          'border-left': '1px solid #AAA'})
        .attr('draggable', 'false')
        .on('dragstart', function () { return false; });

    this.OpenButton = $('<img>')
        .appendTo(this.MainDiv)
        .css({'position': 'absolute',
          'height': '20px',
          'width': '20px',
          'top': '0px',
          'left': '1px',
          'opacity': '0.6',
          '-moz-user-select': 'none',
          '-webkit-user-select': 'none',
          'z-index': '6'})
        .attr('src', SA.ImagePathUrl + 'dualArrowRight2.png')
        .on('click touchstart',
            function () { self.SetVisibility(true); })
        .attr('draggable', 'false')
        .hide()
        .on('dragstart', function () {
          return false;
        });

    // I have no idea why the position right does not work.
    this.CloseButton = $('<img>')
        .appendTo(this.MainDiv)
        .css({'position': 'absolute',
          'height': '20px',
          'top': '0px',
          'left': '-22px',
          'opacity': '0.6',
          '-moz-user-select': 'none',
          '-webkit-user-select': 'none',
          'z-index': '6'})
        // .hide()
        .attr('src', SA.ImagePathUrl + 'dualArrowLeft2.png')
        .on('click touchstart',
            function () { self.SetVisibility(false); })
        .attr('draggable', 'false')
        .on('dragstart', function () {
          return false;
        });

    this.Visibility = true;
    this.Dragging = false;

    this.ResizeEdge = $('<div>')
        .appendTo(parent)
        .css({'position': 'absolute',
          'height': '100%',
          'width': '3px',
          'top': '0px',
          'left': this.Width + 'px',
          'background': '#BDF',
          'z-index': '10',
          'cursor': 'col-resize'})
        .hover(function () { $(this).css({'background': '#9BF'}); },
               function () { $(this).css({'background': '#BDF'}); })
        .mousedown(function () {
          self.StartDrag();
          return false;
        });
  }

  // TODO: Remove reference to body directly
  // Maybe use parent.
  ResizePanel.prototype.StartDrag = function () {
    this.Dragging = true;
    var self = this;
    this.TmpDrag = function (e) { return self.ResizeDrag(e); };
    this.TmpStop = function (e) { return self.ResizeStopDrag(e); };
    $('body').on('mousemove', this.TmpDrag);
    $('body').on('mouseup', this.TmpStop);
    $('body').css({'cursor': 'col-resize'});
  };

  ResizePanel.prototype.ResizeDrag = function (e) {
    this.SetWidth(e.pageX - 1);
    if (this.Width < 200) {
      this.ResizeStopDrag();
      this.SetVisibility(false);
    }

    return false;
  };

  ResizePanel.prototype.ResizeStopDrag = function () {
    $('body').off('mousemove', this.TmpDrag);
    $('body').off('mouseup', this.TmpDrag);
    $('body').css({'cursor': 'auto'});
    return false;
  };

  // TODO: Notes widget should just follow the parent.
  // Get rid of this.
  ResizePanel.prototype.SetWidth = function (width) {
    this.Width = width;
    this.PanelDiv.css({'width': this.Width + 'px'});
    this.MainDiv.css({'left': this.Width + 'px'});
    this.ResizeEdge.css({'left': (this.Width - 2) + 'px'});

    // Needed for viewers to sync canvas size.
    $(window).trigger('resize');
  };

  ResizePanel.prototype.AnimateNotesWindow = function () {
    var animationTime = new Date().getTime() - this.AnimationStartTime;
    if (animationTime > this.AnimationDuration || this.AnimationDuration <= 0) {
      // end the animation.
      this.SetWidth(this.AnimationTarget);

      if (this.Visibility) {
        this.CloseButton.show();
        this.OpenButton.hide();
        this.PanelDiv.fadeIn();
      } else {
        this.CloseButton.hide();
        this.OpenButton.show();
      }
      clearInterval(this.AnimationId);
      delete this.AnimationId;
      delete this.AnimationStartTime;
      delete this.AnimationDuration;
      delete this.AnimationTarget;

      return;
    }

    var k = animationTime / this.AnimationDuration;

    // update
    this.SetWidth(this.Width + (this.AnimationTarget - this.Width) * k);
  };

  // Open and close the panel
  ResizePanel.prototype.SetVisibility = function (visibility, duration) {
    if (duration === undefined) { duration = 1000.0; }
    if (this.Visibility === visibility) { return; }
    this.Visibility = visibility;

    this.AnimationCurrent = this.Width;
    if (this.Visibility) {
      this.AnimationTarget = 353;
    } else {
      this.PanelDiv.hide();
      this.AnimationTarget = 0;
    }

    this.AnimationDuration = duration;
    this.AnimationStartTime = new Date().getTime();
    // NOTE: tiles are not requestAnimationFrame does not let the image tiles get drawn.
    // Do the same animation with setInterval
    var self = this;
    this.AnimationLastTime = new Date().getTime();
    this.AnimationId = setInterval(function () { self.AnimateNotesWindow(); }, 10);
  };

  // Show / hide the panel and handles.
  // I keep the "visibility" state and restore it.
  ResizePanel.prototype.Show = function () {
    this.Visibility = true;
    this.ResizeEdge.show();
    if (this.Visibility) {
      this.Visibility = false; // hack
      this.SetVisibility(true);
    } else {
      this.OpenButton.show();
    }
  };

  ResizePanel.prototype.Hide = function () {
    this.Visibility = false;
    // Do not use "SetVisibility" because we need to instantly close the panel.
    // arg:duration = 0 works but is not perfect.
    this.PanelDiv.hide();
    this.SetWidth(0);
    this.OpenButton.hide();
    this.CloseButton.hide();
    this.ResizeEdge.hide();

    $(window).trigger('resize');
  };

// ==============================================================================

  // args: { label: function, ...}
  jQuery.prototype.saMenuButton = function (args) {
    if (this.length === 0) { return this; }
    var item = this[0];

    if (!item.saMenuButton) {
      item.saMenuButton = new SaMenuButton(args, this);
    }

    return this;
  };

  function SaMenuButton (args, menuButton) {
    this.InsertMenuTimer = 0;
    this.InsertMenu = $('<ul>')
        .appendTo(menuButton)
        // How do I customize the menu location?
        .css({'position': 'absolute',
          'left': '-110px',
          'top': '25px',
          'width': '150px',
          'font-size': '18px',
          'box-shadow': '10px 10px 5px #AAA',
          'z-index': '5'})
        .hide();

    for (var label in args) {
      this.AddMenuItem(label, args[label]);
    }
    // Jquery UI formatting
    this.InsertMenu.menu();

    // Make it easy to select the first item
    var self = this;
    label = Object.keys(args)[0];
    menuButton.on('click touchstart',
                  function () {
                    (args[label])();
                    self.InsertMenu.hide();
                  });

    menuButton.mouseover(
        function () { self.ShowInsertMenu(); });
    this.InsertMenu.mouseover(
        function () { self.ShowInsertMenu(); });

    menuButton.mouseleave(
        function () { self.EventuallyHideInsertMenu(); });
    this.InsertMenu.mouseleave(
        function () { self.EventuallyHideInsertMenu(); });
  }

  SaMenuButton.prototype.AddMenuItem = function (label, callback) {
    var self = this;

    this[label] = $('<li>')
      .appendTo(this.InsertMenu)
      .text(label)
      .addClass('saButton') // for hover effect
      .on('click touchstart', function () {
        (callback)();
        self.InsertMenu.hide();
        return false;
      });
  };

  SaMenuButton.prototype.ShowInsertMenu = function () {
    if (this.InsertMenuTimer) {
      clearTimeout(this.InsertMenuTimer);
      this.InsertMenuTimer = 0;
    }
    this.InsertMenu.show();
  };

  SaMenuButton.prototype.EventuallyHideInsertMenu = function () {
    if (this.InsertMenuTimer) {
      clearTimeout(this.InsertMenuTimer);
      this.InsertMenuTimer = 0;
    }
    var self = this;
    this.InsertMenuTimer = setTimeout(
        function () {
          self.InsertMenuTimer = 0;
          self.InsertMenu.fadeOut();
          this.InsertMenuTimer = 0;
        }, 500);
  };

// ==============================================================================
// Although this is only an option for saViewers,  Make it separate to keep
// it clean. NOTE: .saViewer has to be setup before this call.

// This is not compatable with the dual viewer.  We need two widgets (one
// per viewer).  Legacy now.

// args:
  jQuery.prototype.saAnnotationWidget = function (args) {
    for (var i = 0; i < this.length; ++i) {
      var item = this[i];
      if (!item.saViewer) {
        return this;
      } else if (!item.saAnnotationWidget) {
        $(item).addClass('sa-annotation-widget');
        item.saAnnotationWidget = new SA.AnnotationWidget(item.saViewer);
        item.saAnnotationWidget.SetVisibility(2);
      }
      // This hides and shows the button/tools but does not change the
      // visibility of the annotations in the viewer.
      if (args === 'hide') {
        item.saAnnotationWidget.hide();
      } else if (args === 'show') {
        item.saAnnotationWidget.show();
      }
    }

    return this;
  };

  // I have struggled with the issue of making a second div fill
  // available space when the first div fits its contents with any size.
  // Here is a programmatic solution.

  SA.FillDiv = function (div) {
    div.saOnResize(
      function () {
        var height = div.parent().height() - div.position().top;
        div.height(height);
      });
  };

  SA.ResizePanel = ResizePanel;
  SA.SAFullHeight = SAFullHeight;
  SA.SAViewer = SAViewer;
  SA.SAFullScreenButton = SAFullScreenButton;
  SA.AccordianDiv = saAccordianDiv;
})();

// CME

// Bugs:
// Get short answer questions working.

// Question resizable only after reload.
// Images have a minimum size.

// My feature requests from creating poster:
// Snap to objects.
// Text background options like rectangle (gradient)
//   option to enter css text, or select color gui
// Group objects.
// Copy and paste object or group.
// Select objects.
// Move selected objects with arrow.
// Undo edits
// padding option in text dialog (conversion for px to %?)

// Feature Requests
// Text should selectively resize.
//    This is hard.  I cannot change a selection into a dom that can be manipulated.
// Full window should have overview window and dual view option.
// True false / short answer question.
// Mobile users: first view in session is off the edge.

// Snap
//    to objects.
//    some indication of snap.
//    look at google.
// Slide menu/edit buttons
// Stack and subnotes.
// Improve session browser:
//   Close sessions.
//   Open notes with children.
//   Show multiple viewer records.
//   Choose Images and Notes
//   Merge search with browser.

//   Allow for relative font sizes in a saScalableFontDiv.
// Add GUI to add slides and slide items.
// Background of thumbs should be white.
// Embed option of viewer.

(function () {
  'use strict';

// ==============================================================================
// TODO:
// - Resize the view area to fit the note text.
// - Edit mode: resize views
// - Allow views to go full screen.
// - Sortable slides in slide div.
// - Stop the timer when we leave full screen. Turn editing back on if EDIT.

// ==============================================================================
  function Presentation (rootNote, edit) {
    var self = this;
    this.RootNote = rootNote;
    this.Edit = edit;
    // We need this to know what to return to when a view goes full screen.
    this.FullScreen = false;

    // Setup default global properties.
    if (typeof (rootNote.TypeData) === 'undefined') {
      rootNote.TypeData = {};
    }
    if (!rootNote.TypeData.Background) {
      rootNote.TypeData.Background = '#EEEEEE';
    }
    if (!rootNote.TypeData.AspectRatio) {
      rootNote.TypeData.AspectRatio = 1.3333;
    }

    // Eliminate the GUI in the viewers.
    $('body').css({'overflow-x': 'hidden'});

    this.WindowDiv = $('<div>')
        .appendTo('body')
        .css({
          'position': 'fixed',
          'left': '0px',
          'width': '100%'})
        .saFullHeight();

    // Hack so all viewers will share the same browser.
    // We should really use the brower tab in the left panel.
    SA.VIEW_BROWSER = new SA.ViewBrowser(this.WindowDiv);

    this.ResizePanel = new SA.ResizePanel(this.WindowDiv);

    // this.PresentationDiv = $('<div>')
    //    .appendTo(this.WindowDiv)
    //    .css({'position':'absolute',
    //          'top':'0px',
    //          'left':'0px',
    //          'width':'100%',
    //          'height':'100%'});
    this.PresentationDiv = this.ResizePanel.MainDiv;

    // Wow, really?  Timing caused the swipe bug?
    this.WindowDiv.on(
        'swipeleft',
        function (e) {
          if (self.ResizePanel.Visibility &&
                 e.swipestop.coords[0] < self.ResizePanel.Width) {
            self.ResizePanel.SetVisibility(false);
            return false;
          }
          self.GotoSlide(self.Index + 1);
        });
    this.WindowDiv.on(
        'swiperight',
        function (e) {
          if (!self.ResizePanel.Visibility &&
                 e.swipestart.coords[0] < 10) {
            self.ResizePanel.Show();
            return false;
          }
          self.GotoSlide(self.Index - 1);
        });

    // A window with a constant aspect ratio that fits in
    // the PresentationDiv.
    this.AspectDiv = $('<div>')
        .css({'border': '1px solid #AAA'})
        .appendTo(this.PresentationDiv)
        .saPresentation({aspectRatio: this.RootNote.TypeData.AspectRatio});

    this.LeftPanel = this.ResizePanel.PanelDiv;
    this.InitializeLeftPanel(this.LeftPanel);
    // Left panel is closed by default on mobile devices.
    if (SAM.detectMobile()) {
      this.ResizePanel.Hide();
    }

    // Float the two slide show buttons in the upper right corner.
    this.ShowButton = $('<img>')
        .appendTo(this.PresentationDiv)
        .prop('title', 'present')
        .addClass('editButton')
        .attr('src', SA.ImagePathUrl + 'slide_show.png')
        .css({'position': 'absolute',
          'top': '2px',
          'right': '20px',
          'width': '20px',
          'z-index': '5'})
        .click(function () {
          self.StartFullScreen();
        });
    this.TimerButton = $('<img>')
        .appendTo(this.PresentationDiv)
        .prop('title', 'present timed')
        .addClass('editButton')
        .attr('src', SA.ImagePathUrl + 'timer.png')
        .css({'position': 'absolute',
          'top': '2px',
          'right': '46px',
          'width': '20px',
          'z-index': '5'})
        .click(function () {
          self.StartTimerShow();
        });

    // TODO: Fix this.  At least hide the button for the title page,
    // or get rid of the title page.
    if (edit) {
        // Temporary way to delete a this.
      this.DeleteSlideButton = $('<img>')
            .appendTo(this.AspectDiv)
            .attr('src', SA.ImagePathUrl + 'remove.png')
            .prop('title', 'delete slide')
            .addClass('editButton')
            .css({'position': 'absolute',
              'width': '12px',
              'height': '12px',
              'left': '0px',
              'top': '0px',
              'z-index': '5'})
            .click(function () {
                // Hack to reload viewer records.
              self.DeleteCurentSlide();
            });
    }

    this.TitlePage = new TitlePage(this.AspectDiv, edit);
    this.SlidePage = new SlidePage(this.AspectDiv, edit);
    this.HtmlPage = new HtmlPage(this.AspectDiv, edit,
                                  rootNote.TypeData.Background);

    this.GotoSlide(0);

    // Keep the browser from showing the left click menu.
    document.oncontextmenu = SA.cancelContextMenu;

    $('body').on(
        'keydown',
        function (e) {
          return self.HandleKeyDown(e);
        });

    this.UpdateSlidesTab();
  }

  Presentation.prototype.StartTimerShow = function () {
    var self = this;
    // hack to turn off key events.

    SA.ContentEditableHasFocus = true;
    var dialog = $('<div>')
        .dialog({
          modal: false,
          resizable: false,
          position: {
            my: 'left top',
            at: 'left top',
            of: window
          },
          beforeClose: function () {
            SA.ContentEditableHasFocus = false;
          },
          buttons: {
            'Start': function () {
              self.StartFullScreen();
                    // Change seconds to milliseconds
              var duration = parseInt(self.DurationInput.val()) * 1000;
                    // Also linger on the current slide.
              setTimeout(function () { self.TimerCallback(duration); }, duration);
                    // Should we just close and resuse the dialog?
              $(this).dialog('destroy');
            }
          }
        });
    this.DurationLabel = $('<label>')
        .appendTo(dialog)
        .text('Seconds:');
    this.DurationInput = $('<input type="number" min="1" step="1">')
        .appendTo(dialog)
        .val(30)
        .css({'width': '4em'});
  };

  Presentation.prototype.StartFullScreen = function () {
    var elem = document.body;

    this.ResizePanel.Hide();
    this.EditOff();
    $(window).trigger('resize');
    this.ShowButton.hide();
    this.TimerButton.hide();

    if (elem.requestFullscreen) {
      elem.requestFullscreen();
    } else if (elem.msRequestFullscreen) {
      elem.msRequestFullscreen();
    } else if (elem.mozRequestFullScreen) {
      elem.mozRequestFullScreen();
    } else if (elem.webkitRequestFullscreen) {
      elem.webkitRequestFullscreen();
    }

    this.FullScreen = true;

    // detect when we leave full screen.
    var self = this;
    $(elem).bind(
        'webkitfullscreenchange mozfullscreenchange fullscreenchange',
        function (e) {
          var state = document.fullScreen || document.mozFullScreen ||
                document.webkitIsFullScreen;
            // var event = state ? 'FullScreenOn' : 'FullScreenOff';

          self.FullScreen = state;
          if (!self.FullScreen) {
            self.ResizePanel.Show();
            self.EditOn();
            self.ShowButton.show();
            self.TimerButton.show();
                // TODO: Stop the timer when we leave full screen.
          }
        });
  };

  Presentation.prototype.EditOff = function () {
    if (SA.Edit && this.Edit) {
      this.Edit = false;

      this.SaveButton.hide();
      this.InsertMenuButton.hide();
      this.DeleteSlideButton.hide();
        // QuizMenu / label?
      this.EditTabs.DisableTabDiv(this.BrowserDiv);
      this.EditTabs.DisableTabDiv(this.SearchDiv);
      this.EditTabs.DisableTabDiv(this.ClipboardDiv);

      this.TitlePage.EditOff();
      this.SlidePage.EditOff();
      this.HtmlPage.EditOff();
    }
  };

  Presentation.prototype.EditOn = function () {
    if (this.FullScreen) { return; }
    if (SA.Edit && !this.Edit) {
      this.Edit = true;

      this.SaveButton.show();
      this.InsertMenuButton.show();
      this.DeleteSlideButton.show();
      this.EditTabs.EnableTabDiv(this.BrowserDiv);
      this.EditTabs.EnableTabDiv(this.SearchDiv);
      this.EditTabs.EnableTabDiv(this.ClipboardDiv);

      this.TitlePage.EditOn();
      this.SlidePage.EditOn();
      this.HtmlPage.EditOn();
      this.DeleteSlideButton.show();
    }
  };

  Presentation.prototype.InitializeLeftPanel = function (parent) {
    this.EditTabs = new SA.TabbedDiv(parent);
    this.EditTabs.Div.css({'width': '100%',
      'height': '100%'});

    this.SlidesDiv = this.EditTabs.NewTabDiv('Slides');
    this.SlidesDiv
        .css({'text-align': 'left',
          'color': '#303030',
          'font-size': '18px'});
    // The div that will hold the list of slides.
    this.SlideList = $('<div>')
        .appendTo(this.SlidesDiv)
        .css({'position': 'absolute',
          'width': '100%',
          'top': '32px',
          'bottom': '3px',
          'overflow-y': 'auto'});

    if (SA.Edit) {
      this.BrowserDiv = this.EditTabs.NewTabDiv('Browse');
      this.SearchDiv = this.EditTabs.NewTabDiv('Search');
      this.ClipboardDiv = this.EditTabs.NewTabDiv('Clipboard');
      var self = this;

      this.SaveButton = $('<img>')
            .appendTo(this.SlidesDiv)
            .prop('title', 'save')
            .addClass('editButton')
            .attr('src', SA.ImagePathUrl + 'save22.png')
            .css({'float': 'right'})
            .click(function () { self.Save(); });
      this.InsertMenuButton = $('<div>')
            .appendTo(this.SlidesDiv)
            .addClass('editButton')
            .css({'float': 'right',
              'position': 'relative'})
            .saMenuButton({
              'New Slide': function () {
                self.InsertNewSlide('HTML');
              },
              'Copy Slide': function () { self.InsertSlideCopy(); },
              'Insert Text': function () {
                self.HtmlPage.InsertTextBox()
                        .css({'height': '25%'});
              },
              'Insert Question': function () { self.HtmlPage.InsertQuestion(); },
              'Insert Rectangle': function () {
                self.HtmlPage.InsertRectangle('#073E87', '0%', '60%', '97.5%', '14%');
              },
              'Insert Image': function () { self.InsertImage(); },
              'Insert MP4': function () { self.InsertVideo(); },
              'Embed Youtube': function () { self.InsertYoutube(); }
            });

      $('<img>')
            .appendTo(this.InsertMenuButton)
            .attr('src', SA.ImagePathUrl + 'new_window.png');

      this.QuizMenu = $('<select name="quiz" id="quiz">')
            .appendTo(this.SlidesDiv)
            .css({'float': 'right',
              'margin': '3px'})
            .change(function () {
              if (this.value === 'review') {
                self.RootNote.Mode = 'answer-show';
              } else if (this.value === 'hidden') {
                self.RootNote.Mode = 'answer-hide';
              } else if (this.value === 'interactive') {
                self.RootNote.Mode = 'answer-interactive';
              }
              self.UpdateQuestionMode();
            });
      $('<option>')
            .appendTo(this.QuizMenu)
            .text('review');
      $('<option>')
            .appendTo(this.QuizMenu)
            .text('hidden');
      $('<option>')
            .appendTo(this.QuizMenu)
            .text('interactive');
      this.QuizLabel = $('<div>')
            .appendTo(this.SlidesDiv)
            .css({'float': 'right',
              'font-size': 'small',
              'margin-top': '4px'})
            .text('quiz');
        // Set the question mode
      if (this.RootNote.Mode === 'answer-hide') {
        this.QuizMenu.val('hidden');
      } else if (this.RootNote.Mode === 'answer-interactive') {
        this.QuizMenu.val('interactive');
      } else {
        this.RootNote.Mode = 'answer-show';
        this.QuizMenu.val('review');
      }

      this.BrowserPanel = new SA.BrowserPanel(
            this.BrowserDiv,
            function (viewObj) {
              self.AddViewCallback(viewObj);
            });
      this.BrowserDiv.css({'overflow-y': 'auto'});

      this.SearchPanel = new SA.SearchPanel(
            this.SearchDiv,
            function (imageObj) {
              self.AddImageCallback(imageObj);
            });
      this.ClipboardPanel = new SA.ClipboardPanel(
            this.ClipboardDiv,
            function (viewObj) {
              self.AddViewCallback(viewObj);
            });
    }

    this.UserTextDiv = this.EditTabs.NewTabDiv('Notes', 'private notes');
    // Private notes.
    this.UserNoteEditor = new UserNoteEditor(this.UserTextDiv);

    this.EditTabs.ShowTabDiv(this.SlidesDiv);
  };

// ==============================================================================
// What should i do if the user starts editing before the note loads?
// Editor will not be active until it has a note.
  function UserNoteEditor (parent) {
    this.Modified = false;
    this.UpdateTimer = null;
    this.ParentNote = null;
    // this.UserNote = null;
    this.TextEditor = $('<div>')
        .appendTo(parent)
        .css({'display': 'inline-block',
          'position': 'absolute',
          'overflow-y': 'auto',
          'padding': '5px',
          'fontFamily': 'Verdana,sans-serif',
          'left': '2px',
          'right': '2px',
          'top': '20px',
          'bottom': '2px'});

    var self = this;
    this.TextEditor.attr('contenteditable', 'false')
        .bind('input', function () {
          self.Modified = true;
            // Leave events are not triggering.
          self.EventuallyUpdate();
        })
        .focusin(function () {
          SA.ContentEditableHasFocus = true;
        })
        .focusout(function () {
          SA.ContentEditableHasFocus = false;
          self.UpdateNote();
        })
        // Mouse leave events are not triggering.
        .mouseleave(function () { // back button does not cause loss of focus.
          self.UpdateNote();
        });

    this.TextEditor.change(function () { self.UpdateNote(); });
  }

  UserNoteEditor.prototype.EventuallyUpdate = function () {
    if (this.UpdateTimer) {
      clearTimeout(this.UpdateTimer);
      this.UpdateTimer = null;
    }
    var self = this;
    this.UpdateTimer = setTimeout(function () { self.UpdateNote(); }, 5000);
  };

  UserNoteEditor.prototype.UpdateNote = function () {
    if (this.ParentNote && this.ParentNote.UserNote) {
      var userNote = this.ParentNote.UserNote;
      userNote.Text = this.TextEditor.html();
        // Do not save the user not until the parent has been saved.
      if (this.ParentNote.Id && this.Modified) {
        var self = this;
        userNote.Save(function () { self.Modified = false; });
      }
    }
  };

// The parent not is set.  A user not is retrieved or created, and the
// editor is attached to the user note.
// TODO: Get rid of the local iVar UserNote.
// TODO: Make sure this works with temp note ids.
  UserNoteEditor.prototype.SetNote = function (parentNote) {
    if (this.ParentNote === parentNote) { return; }

    // Save the previous note incase the user is in mid edit
    // TODO: Do not save it has not been modified.
    this.UpdateNote();
    // clear the editor and make not editable until we have another user note.
    this.ParentNote = null;
    // this.UserNote = null;
    this.TextEditor.html('');
    this.TextEditor
        .attr('contenteditable', 'false')
        .css('border', '');

    // Null note means save previous and clear editor and make it no longer editable.
    if (!parentNote) {
      return;
    }

    this.ParentNote = parentNote;

    if (parentNote.UserNote) {
        // this.UserNote = parentNote.UserNote;
      this.TextEditor
            .html(parentNote.UserNote.Text)
            .attr('contenteditable', 'true')
            .css({'border': '2px inset #DDD'});
      return;
    }

    if (!parentNote.Id) {
        // If the parent does not have an id, it must be new and will not
        // have a user note.  Make a new one (do not try to load user note).
        // A new note.  I do not want to save empty user notes for every
        // note.  The check will be in the save method.
      parentNote.SetUserNote(new SA.Note());
      this.TextEditor
            .attr('contenteditable', 'true')
            .css({'border': '2px inset #DDD'});
      return;
    }

    // NOTE: This is probably not necessary because the server embeds user
    // notes when the parent is sent to the client.
    var self = this;
    $.ajax({
      type: 'get',
      url: '/webgl-viewer/getusernotes',
      data: {'parentid': parentNote.Id},
      success: function (data, status) { self.LoadUserNote(data, parentNote.Id); },
      error: function () { SA.Debug('AJAX - error() : getusernotes'); }
    });
  };

  UserNoteEditor.prototype.LoadUserNote = function (data, parentNoteId) {
    if (!this.ParentNote || this.ParentNote.Id !== parentNoteId) {
        // Many things could happen while waiting for the note to load.
      return;
    }

    var parentNote = this.ParentNote;
    parentNote.SetUserNote(new SA.Note());

    if (data.Notes && data.Notes.length > 0) {
      if (data.Notes.length > 1) {
        SA.Debug('Warning: Only showing the first user note.');
      }
      var noteData = data.Notes[0];
      parentNote.UserNote.Load(noteData);
    }

    // Must display the text.
    this.TextEditor.html(parentNote.UserNote.Text);
    this.TextEditor.attr('contenteditable', 'true')
        .css({'border': '2px inset #DDD'});
  };

// ==============================================================================

  Presentation.prototype.UpdateQuestionMode = function () {
    if (!this.RootNote) { return; }
    $('.sa-question').saQuestion('SetMode', this.RootNote.Mode);

    // Do not hide the Title page title
    if (this.RootNote.Mode === 'answer-hide' && this.Index !== 0) {
        // Experiment with hiding titles too.
      var title = $('.sa-presentation-title');
      var standin = title.clone();
      title.hide();
      standin
            .appendTo(title.parent())
            .html('#' + this.Index)
            .addClass('sa-standin')
            .attr('contenteditable', 'false')
            .saScalableFont();
    } else {
        // Experiment with hiding titles too.
      $('.sa-standin').remove();
      $('.sa-presentation-title').show();
    }
    this.UpdateSlidesTab();
  };

  Presentation.prototype.TimerCallback = function (duration) {
    if (this.Index === this.GetNumberOfSlides() - 1) {
        // Stop but stay in full screen mode.
      this.GotoSlide(0);
      SA.ContentEditableHasFocus = false;
      return;
    }

    this.GotoSlide(this.Index + 1);

    // Hack to get rid of anwers.
    // Select everything in the editor.
    var editor = this.SlidePage.List.TextEntry[0];
    $(editor).attr('contenteditable', 'true');
    var sel = window.getSelection();
    var range = document.createRange();
    range.selectNodeContents(editor);
    sel.removeAllRanges();
    sel.addRange(range);
    // remove bold formating
    document.execCommand('bold', false, null);
    document.execCommand('bold', false, null);
    // Hide annotations
    // legacy
    if (this.SlidePage.AnnotationWidget1) {
      this.SlidePage.AnnotationWidget1.SetVisibility(false);
    }
    if (this.SlidePage.AnnotationWidget2) {
      this.SlidePage.AnnotationWidget2.SetVisibility(false);
    }
    // remove the selection
    range.collapse(false);
    // The collapse has no effect without this.
    sel.removeAllRanges();
    sel.addRange(range);
    $(editor).attr('contenteditable', 'false');

    // Wait before advancing.
    var self = this;
    setTimeout(function () { self.TimerCallback(duration); }, duration);
  };

// Adds a view to the current slide.
  Presentation.prototype.AddViewCallback = function (viewObj) {
    if (viewObj.Type === 'HTML') {
        // What will happen if you insert a whole presentation (root)?
        // Insert a new slide
      var idx = this.Index + 1;
      var note = new SA.Note();
      note.Load(viewObj);
        // Record changes in the note before the copy.
      this.HtmlPage.UpdateEdits();

      this.RootNote.Children.splice(idx - 1, 0, note);
      this.GotoSlide(idx);
      this.UpdateSlidesTab();
      return;
    }

    if (this.Note.Type === 'HTML') {
        // TODO: Change this to pass a viewer record of the view.
        //       Maybe show all the records as options.
      this.HtmlPage.InsertView(viewObj);
      return;
    }

    var record = new SA.ViewerRecord();
    record.Load(viewObj.ViewerRecords[0]);
    this.Note.ViewerRecords.push(record);

    this.SlidePage.DisplayNote(this.Note, SA.presentation.Index);
  };

// Callback from search.
  Presentation.prototype.AddImageCallback = function (image) {
    var record = new SA.ViewerRecord();
    record.OverViewBounds = image.bounds;
    record.Image = image;
    record.Camera = {FocalPoint: [(image.bounds[0] + image.bounds[1]) / 2,
      (image.bounds[2] + image.bounds[3]) / 2, 0],
      Roll: 0,
      Height: (image.bounds[3] - image.bounds[2]),
      Width: (image.bounds[1] - image.bounds[0])};

    if (this.Note.Type === 'HTML') {
        // This will be the primar path in the future.
      this.HtmlPage.InsertViewerRecord(record);
      return;
    }
    if (this.Note !== this.RootNote) {
      var note = new SA.Note();
      note.ViewerRecords[0] = record;
      this.SlidePage.InsertViewNote(note);
      return;
    }

    // The root needs a record to show up in the session.
    // never executed because I add a presentation icon
    // NOTE: This might be a problem with the new html title page.
    //       Viewers inthe title pages are stored as records.
    if (this.RootNote.ViewerRecords.length === 0) {
      this.RootNote.ViewerRecords.push(record);
    }
  };

  Presentation.prototype.HandleKeyDown = function (event) {
    // Hack to keep the slides from changing when editing.
    if (SA.ContentEditableHasFocus) {
      return true;
    }

    // I cannot get the browser to paste into a new div
    // First, paste is executed before this callback.
    // Second, the execCommand paste does not appear to work.
    // if (event.keyCode === "86" && ! event.ctrlKey) { // check for control v paste
    //    if (this.Note.Type === "HTML") {
    //        this.HtmlPage.Paste();
    //   }
    // }

    if (event.keyCode === '32' || // space
        event.keyCode === '34' || // page down
        event.keyCode === '78' || // n
        event.keyCode === '39' || // right arrow
        event.keyCode === '40' || // down arrow
        event.keyCode === '13') { // enter
      this.GotoSlide(this.Index + 1);
      return false;
    }
    if (event.keyCode === '80' || // p
        event.keyCode === '37' || // back arrow
        event.keyCode === '38' || // up arrow
        event.keyCode === '33') { // page up
      this.GotoSlide(this.Index - 1);
      return false;
    }
    if (event.keyCode === '36') { // home
      this.GotoSetSlide(0);
      return false;
    }
    if (event.keyCode === '35') { // end
      this.GotoSlide(this.GetNumberOfSlides() - 1);
      return false;
    }
  };

  Presentation.prototype.Save = function () {
    // Get rid of interactive question formating.
    this.HtmlPage.Div.find('.sa-answer')
        .css({'color': '#000'});

    this.TitlePage.UpdateEdits();
    this.SlidePage.UpdateEdits();
    this.HtmlPage.UpdateEdits();

    // NOTE: light boxes are saved as viewerRecords. (but not always?)
    // Insert viewer record versus note?
    // Save the user notes.  They are not saved with the parent notes like
    // the children are.
    for (var i = 0; i < SA.Notes.length; ++i) {
      var note = SA.Notes[i];
      if (note.Type === 'UserNote') {
        if (note.LoadState || note.Text !== '') {
          note.Save();
        }
      }
    }

    // TODO:
    // Fix this. Session page needs every member view to have an image.
    // The root needs a record to show up in the session.
    var rootNote = this.RootNote;
    if (rootNote.ViewerRecords.length < 1) {
      var record = new SA.ViewerRecord();
      record.Load(
        {AnnotationVisibility: 2,
          Annotations: [],
          Camera: {FocalPoint: [510, 519],
            Height: 1009,
            Roll: 0,
            Width: 1066},
          Database: '507f34a902e31010bcdb1366',
          Image: {
            TileWidth: 256,
            TileHeight: 256,
            _id: '55b4e5c03ed65909a84cd938',
            bounds: [0, 1020, 15, 1024],
            components: 3,
            database: '507f34a902e31010bcdb1366',
            dimensions: [1020, 1009],
            filename: 'projection-screen.jpg',
            label: 'projection-screen.jpg',
            levels: 3,
            origin: [0, 0, 0],
            spacing: [1, 1, 1],
            NumberOfLevels: 3,
            OverViewBounds: [0, 1020, 15, 1024]}
        });
      rootNote.ViewerRecords.push(record);
    }

    // this.SaveButton.css({'color':'#F00'});
    // And finally, we can save the presentation.
    this.RootNote.Save();

    // Check to see if the root is in the session. If not, add it.
    var noteInSession = false;
    var session = SA.Session.session.views;
    for (i = 0; i < session.length && !noteInSession; ++i) {
      if (session[i].id === this.RootNote.Id) {
        noteInSession = true;
      }
    }
    if (!noteInSession) {
        // Should we bother making a dummy view?
        // move-view is now smart enough to avoid adding twice.
      session.splice(0, 0, {id: this.RootNote.Id});
        // if this is the first time we are saving the root note, then
        // add it to the session.
      $.ajax({
        type: 'post',
        data: {'to': SA.SessionId,
          'view': this.RootNote.Id},
        url: 'webgl-viewer/move-view',
        success: function (data, status) {
          if (status !== 'Success') {
            SA.Debug(data);
          }
        },
        error: function () {
          SA.Debug('AJAX - error() : session-add-view');
        }
      });
    }
  };

  Presentation.prototype.DeleteSlide = function (index) {
    var maxIdx = this.GetNumberOfSlides() - 1;
    if (index < 1 || index > maxIdx) {
      return;
    }
    this.RootNote.Children.splice(index - 1, 1);
    // The case when we are not deleting the current slide.
    // All slides after the one deleted cahnge their index.
    if (this.Index > index) { this.Index -= 1; }

    // Case where we are deleting the current slide.
    if (index === this.Index) {
        // index becomes the sldie we are going to.
        // Handles the case where we are on the last slide.
        // Move to the previous rather then the next.
      if (index === maxIdx) { --index; }
        // force GotoSlide to
      this.Index = -1;
      this.GotoSlide(index);
    }

    this.UpdateSlidesTab();
  };

  Presentation.prototype.DeleteCurentSlide = function () {
    this.DeleteSlide(this.Index);
  };

  Presentation.prototype.InsertNewSlide = function (type) {
    var idx = this.Index + 1;
    var note = new SA.Note();
    if (type) { note.Type = type; }
    this.RootNote.Children.splice(idx - 1, 0, note);
    note.Parent = this.RootNote;
    this.GotoSlide(idx);
    this.UpdateSlidesTab();
    if (type === 'HTML') {
      this.HtmlPage.InitializeSlidePage();
    }
    this.UpdateQuestionMode();
  };

  Presentation.prototype.InsertSlideCopy = function (type) {
    var idx = this.Index + 1;
    var note = new SA.Note();

    // Record changes in the note before the copy.
    this.HtmlPage.UpdateEdits();
    // Deep copy of note with children.
    note.DeepCopy(this.Note);

    this.RootNote.Children.splice(idx - 1, 0, note);
    this.GotoSlide(idx);
    this.UpdateSlidesTab();
  };

  Presentation.prototype.InsertImage = function () {
    var src = prompt('Image URL', 'https://slide-atlas.org/static/img/SlideAtlas_home.jpg');
    this.HtmlPage.InsertImage(src);
  };

  Presentation.prototype.InsertVideo = function () {
    var src = prompt('Video URL', 'https://slide-atlas.org/api/v2/sessions/53ac02d5a7a14110d929adcc/attachments/55fef0e6a7a14162dfb4da32');
    this.HtmlPage.InsertVideo(src);
  };

  Presentation.prototype.InsertYoutube = function () {
    var src = prompt('Video IFrame URL', '<iframe width="420" height="315" src="https://www.youtube.com/embed/9tCafgGZtxQ" frameborder="0" allowfullscreen></iframe>');
    this.HtmlPage.InsertIFrame(src);
  };

// 0->Root/titlePage
// Childre/slides start at index 1
  Presentation.prototype.GotoSlide = function (index) {
    if (index < 0 || index >= this.GetNumberOfSlides() || index === this.Index) {
      return;
    }

    // Clear previous slides settings.
    this.TitlePage.ClearNote();
    this.SlidePage.ClearNote();
    this.HtmlPage.ClearNote();

    this.AspectDiv.show();
    this.Index = index;
    if (index === 0) { // Title page
      this.Note = this.RootNote;
      if (this.Note.Type === 'Presentation') {
            // legacy
        this.SlidePage.Div.hide();
        this.HtmlPage.Div.hide();
        this.TitlePage.DisplayNote(this.Note);
      } else if (this.Note.Type === 'HTML') {
        this.TitlePage.Div.hide();
        this.SlidePage.Div.hide();
        this.HtmlPage.Div.show();
        this.HtmlPage.DisplayNote(this.Note);
        if (this.Note.Text === '') {
          this.HtmlPage.InitializeTitlePage();
        }
      }
      this.UserNoteEditor.SetNote(this.Note);
    } else { // Slide page
      this.Note = this.GetSlide(index);
      if (this.Note.Type === 'HTML') {
        this.TitlePage.Div.hide();
        this.SlidePage.Div.hide();
        this.HtmlPage.Div.show();
        this.HtmlPage.DisplayNote(this.Note);
        this.UserNoteEditor.SetNote(this.Note);
      } else {
        this.TitlePage.Div.hide();
        this.HtmlPage.Div.hide();
        this.SlidePage.DisplayNote(this.Note, index);
      }
    }
    // Start preloading the next slide.
    if (index < this.RootNote.Children.length) {
      var nextNote = this.RootNote.Children[index];
        // TODO: Better arg for LoadTiles.
        // Should I pass in the jquery selection or viewer.
      if (nextNote.ViewerRecords.length > 0) {
            // Hack: What size viewer will we be using?
        nextNote.ViewerRecords[0].LoadTiles([0, 0, 400, 300]);
      }
      if (nextNote.ViewerRecords.length > 1) {
            // Hack: What size viewer will we be using?
        nextNote.ViewerRecords[1].LoadTiles([0, 0, 400, 300]);
      }
    }

    this.UpdateSlidesTab();
    this.UpdateQuestionMode();

    // Font was not scaling when first loaded.
    $(window).trigger('resize');
  };

  Presentation.prototype.GetNumberOfSlides = function () {
    return this.RootNote.Children.length + 1;
  };

  Presentation.prototype.GetSlide = function (idx) {
    if (idx < 0 || idx > this.RootNote.Children.length) {
      return null;
    }
    if (idx === 0) {
      return this.RootNote;
    }
    return this.RootNote.Children[idx - 1];
  };

  Presentation.prototype.SortCallback = function () {
    // Change the list of GUI items into a list of notes.
    var items = this.SlideList.find('div');
    var newChildren = [];
    var newIndex = 0;
    for (var i = 0; i < items.length; ++i) {
      var idx = parseInt($(items[i]).data('index'));
      if (idx !== 0) { // we have to skip the title page because it is
            // root.
        newChildren.push(this.GetSlide(idx));
      }
      if (this.Index === idx) {
            // If the current slide moved, update the index.
            // Note the offset by one to account for the root / title.
            // length is one more than the notes index.
        newIndex = newChildren.length;
      }
    }
    this.RootNote.Children = newChildren;
    this.Index = newIndex;
    this.UpdateSlidesTab();
  };

  Presentation.prototype.UpdateSlidesTab = function () {
    var self = this;

    if (!this.SlideList) { return; }

    // Add the title page
    this.SlideList.empty();

    if (SA.Edit) {
      this.SlideList
            .sortable({update: function (event, ui) { self.SortCallback(); },
              handle: '.ui-icon'});
    }

    for (var i = 0; i < this.GetNumberOfSlides(); ++i) {
      // get a title
      var note = this.GetSlide(i);
      var title = note.Text;
      var idx = title.indexOf('sa-presentation-text');
      if (idx === -1) {
        title = note.Title;
        if (title === '') {
          // Nothing i the text / html to use as a title.
          title = 'Slide ' + i;
        }
      } else {
        title = title.substring(idx);
        idx = title.indexOf('>');
        title = title.substring(idx + 1);
        idx = title.indexOf('<');
        // We may have other formating blocks.
        // An xml parser would be nice.
        while (idx === 0) {
          idx = title.indexOf('>');
          title = title.substring(idx + 1);
          idx = title.indexOf('<');
        }
        title = title.substring(0, idx);
        if (note.Title === '') {
          note.Title = title;
        }
      }
        // Hide titles
      if (this.RootNote.Mode === 'answer-hide') {
        title = '#' + i;
      }

      var slideDiv = $('<div>')
            .appendTo(this.SlideList)
            .css({'position': 'relative',
              'padding-left': '1.5em',
              'padding-right': '1.5em',
              'margin': '5px',
              'color': '#29C',
              'cursor': 'pointer'})
            .hover(function () { $(this).css('color', 'blue'); },
                   function () { $(this).css('color', '#29C'); })
            .text(title)
            .data('index', i)
            .click(function () {
              SA.presentation.GotoSlide($(this).data('index'));
            });
      var sortHandle = $('<span>')
            .appendTo(slideDiv)
            .css({'position': 'absolute',
              'left': '7px',
              'top': '2px',
              'opacity': '0.5'})
            .addClass('ui-icon ui-icon-bullet');
      if (SA.Edit) {
        sortHandle.addClass('sa-sort-handle');
      }

      if (this.Note === note) {
        slideDiv.css({'background': '#EEE'});
      }
    }
  };

// ==============================================================================
  function SlidePage (parent, edit) {
    var self = this;
    this.FullWindowView = null;
    this.Edit = edit;
    this.Note = null;
    this.Records = []; // views.

    this.Div = $('<div>')
        .appendTo(parent)
        .hide()
        .addClass('sa-resize') // hack to get resize triggered.
        .css({
          'position': 'absolute',
          'width': '100%',
          'height': '100%',
          'border': '1px solid #AAA'});
    this.Div[0].onresize =
        function () {
          self.ResizeViews();
        };

    this.ViewPanel = $('<div>')
            .appendTo(this.Div)
            .css({'background': '#FFF',
              'position': 'absolute',
              'top': '0px',
              'bottom': '300px',
              'left': '0px',
              'width': '100%',
              'height': 'auto'});

    this.BottomDiv = $('<div>')
        .appendTo(this.Div)
        .css({'position': 'absolute',
          'bottom': '0px',
          'width': '100%',
          'height': '300px'});

    this.TitleBar = $('<div>')
        .appendTo(this.BottomDiv)
        .css({'position': 'absolute',
          'top': '0px',
          'height': '80px',
          'line-height': '80px',
          'width': '100%',
          'padding-left': '3.3em',
          'color': 'white',
          'font-size': '160%',
          'background': '#444',
          'font-family': 'Arial'});
    this.Title = $('<span>')
        .appendTo(this.TitleBar)
        .css({'display': 'inline-block',
          'vertical-align': 'middle',
          'line-height': 'normal'})
        .text('Slide: 1');

    this.TextDiv = $('<div>')
        .appendTo(this.BottomDiv)
        .css({'position': 'absolute',
          'padding-left': '2em',
          'height': '210px',
          'bottom': '5px',
          'width': '100%'});
    // List of question answers.
    this.List = new SA.TextEditor(this.TextDiv, SA.VIEWERS);
    if (!edit) {
      this.List.EditOff();
    }

    // Add the viewers.
    this.ViewerDiv1 = $('<div>')
        .appendTo(this.ViewPanel)
        .css({'position': 'absolute',
          'box-shadow': '10px 10px 5px #AAA'});
    // Make the viewer look like jquery
    // this.ViewerDiv1.viewer({overview:false});
    this.ViewerDiv1.saViewer();

    this.ViewerDiv2 = $('<div>')
        .appendTo(this.ViewPanel)
        .css({'position': 'absolute',
          'box-shadow': '10px 10px 5px #AAA'});
    // Make the viewer look like jquery
    this.ViewerDiv2.saViewer();

    if (this.Edit) {
        // TODO: Better API (jquery) for adding widgets.
        // TODO: Better placement control for the widget.

      var viewer = this.ViewerDiv1[0].saViewer;
      this.AnnotationWidget1 = new SA.AnnotationWidget(
            viewer.GetAnnotationLayer(), viewer);
      this.AnnotationWidget1.SetVisibility(2);

      viewer = this.ViewerDiv2[0].saViewer;
      this.AnnotationWidget2 = new SA.AnnotationWidget(
            viewer.GetAnnotationLayer(), viewer);
      this.AnnotationWidget2.SetVisibility(2);

        // TODO: Move this to bind in jquery.  (not sure how to do this yet)
      this.ViewerDiv1[0].saViewer.OnInteraction(function () { self.RecordView1(); });
      this.ViewerDiv2[0].saViewer.OnInteraction(function () { self.RecordView2(); });
      this.RemoveView1Button = $('<img>')
            .appendTo(this.ViewerDiv1)
            .attr('src', SA.ImagePathUrl + 'remove.png')
            .prop('title', 'remove view')
            .addClass('editButton')
            .css({'position': 'absolute',
              'right': '0px',
              'top': '0px',
              'width': '12px',
              'height': '12px',
              'z-index': '5'})
            .click(function () {
              SA.presentation.Note.ViewerRecords.splice(0, 1);
                // Redisplay the viewers
              self.DisplayNote(self.Note, SA.presentation.Index);
            });
      this.RemoveView2Button = $('<img>')
            .appendTo(this.ViewerDiv2)
            .attr('src', SA.ImagePathUrl + 'remove.png')
            .prop('title', 'remove view')
            .addClass('editButton')
            .css({'position': 'absolute',
              'right': '0px',
              'top': '0px',
              'width': '12px',
              'height': '12px',
              'z-index': '5'})
            .click(function () {
              SA.presentation.Note.ViewerRecords.splice(1, 1);
                // Redisplay the viewers
              self.DisplayNote(self.Note, SA.presentation.Index);
            });

        // Setup view resizing.
      this.ViewerDiv1.resizable();
        // For a method to get called when resize stops.
        // Gets call on other mouse ups, but this is ok.
      this.ViewerDiv1
            .mouseup(function () {
              this.saViewer.EnableInteraction();
              self.UpdateEdits();
              $(window).trigger('resize');
            });
      this.ViewerDiv1
            .resize(function () {
              this.saViewer.DisableInteraction();
              var vp = this.saViewer.GetViewport();
              vp[2] = $(this).width();
              vp[3] = $(this).height();
              this.saViewer.SetViewport(vp);
              this.saViewer.EventuallyRender(true);
              return false;
            });

      this.ViewerDiv2.resizable();
        // For a method to get called when resize stops.
        // Gets call on other mouse ups, but this is ok.
      this.ViewerDiv2
            .mouseup(function () {
              this.saViewer.EnableInteraction();
              self.UpdateEdits();
              $(window).trigger('resize');
            });
      this.ViewerDiv2
            .resize(function () {
              this.saViewer.DisableInteraction();
              var vp = this.saViewer.GetViewport();
              vp[2] = $(this).width();
              vp[3] = $(this).height();
              this.saViewer.SetViewport(vp);
              this.saViewer.EventuallyRender(true);
              return false;
            });
    }
    // Give the option for full screen
    // on each of the viewers.
    this.FullWindowView1Button = $('<img>')
        .appendTo(this.ViewerDiv1)
        .attr('src', SA.ImagePathUrl + 'fullscreenOn.png')
        .prop('title', 'full window')
        .css({'position': 'absolute',
          'width': '12px',
          'left': '-5px',
          'top': '-5px',
          'opacity': '0.5',
          'z-index': '-1'})
        .hover(function () { $(this).css({'opacity': '1.0'}); },
               function () { $(this).css({'opacity': '0.5'}); })
        .click(function () {
          self.SetFullWindowView(self.ViewerDiv1);
        });
    this.FullWindowView2Button = $('<img>')
        .appendTo(this.ViewerDiv2)
        .attr('src', SA.ImagePathUrl + 'fullscreenOn.png')
        .prop('title', 'full window')
        .css({'position': 'absolute',
          'width': '12px',
          'left': '-5px',
          'top': '-5px',
          'opacity': '0.5',
          'z-index': '-1'})
        .hover(function () { $(this).css({'opacity': '1.0'}); },
               function () { $(this).css({'opacity': '0.5'}); })
        .click(function () {
          self.SetFullWindowView(self.ViewerDiv2);
        });

    this.FullWindowViewOffButton = $('<img>')
        .appendTo(this.ViewPanel)
        .hide()
        .attr('src', SA.ImagePathUrl + 'fullscreenOff.png')
        .prop('title', 'full window off')
        .css({'position': 'absolute',
          'background': '#FFF',
          'width': '16px',
          'left': '1px',
          'top': '1px',
          'opacity': '0.5',
          'z-index': '1'})
        .hover(function () { $(this).css({'opacity': '1.0'}); },
               function () { $(this).css({'opacity': '0.5'}); })
        .click(function () {
          self.SetFullWindowView(null);
        });
  }

  SlidePage.prototype.SetFullWindowView = function (viewerDiv) {
    if (viewerDiv) {
      SA.presentation.EditOff();
      this.FullWindowViewOffButton.show();
      this.FullWindowView1Button.hide();
      this.FullWindowView2Button.hide();
      this.BottomDiv.hide();
      this.ViewPanel.css({'height': '100%'});
    } else {
      this.FullWindowViewOffButton.hide();
      this.FullWindowView1Button.show();
      this.FullWindowView2Button.show();
      this.BottomDiv.show();
      this.ViewPanel.css({
        'bottom': '300px',
        'height': 'auto'});
      if (SA.Edit) {
        SA.presentation.EditOn();
      }
    }
    this.FullWindowView = viewerDiv;
    this.ResizeViews();
  };

  SlidePage.prototype.RecordView1 = function () {
    if (this.Edit && this.Note &&
        this.Note.ViewerRecords.length > 0 &&
        this.Note.ViewerRecords[0]) {
      this.Note.ViewerRecords[0].CopyViewer(this.ViewerDiv1[0].saViewer);
    }
  };

  SlidePage.prototype.RecordView2 = function () {
    if (this.Edit && this.Note &&
        this.Note.ViewerRecords.length > 1 &&
        this.Note.ViewerRecords[1]) {
      this.Note.ViewerRecords[1].CopyViewer(this.ViewerDiv2[0].saViewer);
    }
  };

  SlidePage.prototype.EditOff = function () {
    if (SA.Edit && this.Edit) {
      this.Edit = false;
      this.Div.css({'width': '100%', 'left': '0px'});
      this.AnnotationWidget1.hide();
      this.AnnotationWidget2.hide();
        // Clear the event callbacks
      this.ViewerDiv1[0].saViewer.OnInteraction();
      this.ViewerDiv2[0].saViewer.OnInteraction();
      this.RemoveView1Button.hide();
      this.RemoveView2Button.hide();
      this.List.EditOff();
        // This causes the viewers to look transparent.
        // SA.VIEWER.MainView.Parent.resizable('disable');
    }
  };

  SlidePage.prototype.EditOn = function () {
    if (SA.Edit && !this.Edit) {
      this.Edit = true;
        // this.Div.css({'width': '100%', 'left': '0px'}); ???
      this.AnnotationWidget1.show();
      this.AnnotationWidget2.show();
        // Set the event callbacks
      var self = this;
      this.ViewerDiv1[0].saViewer.OnInteraction(function () { self.RecordView1(); });
      this.ViewerDiv2[0].saViewer.OnInteraction(function () { self.RecordView2(); });
      this.RemoveView1Button.show();
      this.RemoveView2Button.show();
      this.List.EditOn();
    }
  };

// Adds a margin, and keeps the aspect ratio of view.
  SlidePage.prototype.PlaceViewer = function (viewerDiv, record, viewport) {
    var vWidth = viewport[2] * 0.8;
    var vHeight = viewport[3] * 0.8;
    var cam = record.Camera;
    var scale = vHeight / cam.Height;
    vWidth = scale * cam.Width;
    if (vWidth > viewport[2] * 0.8) {
      vWidth = viewport[2] * 0.8;
      scale = vWidth / cam.Width;
      vHeight = scale * cam.Height;
    }

    var vLeft = viewport[0] + (viewport[2] - vWidth) / 2;
    var vTop = viewport[1] + (viewport[3] - vHeight) / 2;

    if (viewerDiv) {
      viewerDiv[0].saViewer.SetViewport([vLeft, vTop, vWidth, vHeight]);
      viewerDiv[0].saViewer.EventuallyRender(false);
    }
  };

// Records === views.
  SlidePage.prototype.ResizeViews = function () {
    var width = this.ViewPanel.width();
    var height = this.ViewPanel.height();
    if (this.FullWindowView) {
      this.ViewerDiv1[0].saViewer.SetViewport([0, 0, 0, height]);
      this.ViewerDiv2[0].saViewer.SetViewport([0, 0, 0, height]);
      this.FullWindowView[0].saViewer.SetViewport([0, 0, width, height]);
      this.FullWindowView[0].saViewer.EventuallyRender(false);
      return;
    }

    var numRecords = this.Records.length;
    var record;

    if (numRecords === 0) {
        // Poor way to hide a viewer.
      this.ViewerDiv1[0].saViewer.SetViewport([0, 0, 0, height]);
        // Poor way to hide a viewer.
      this.ViewerDiv2[0].saViewer.SetViewport([0, 0, 0, height]);
    }
    if (numRecords === 1) {
      record = this.Records[0];
      this.PlaceViewer(this.ViewerDiv1, record, [0, 0, width, height]);
        // Poor way to hide a viewer.
      this.ViewerDiv2[0].saViewer.SetViewport([0, 0, 0, height]);
    }
    if (numRecords > 1) {
      var halfWidth = width / 2;
      record = this.Records[0];
      this.PlaceViewer(this.ViewerDiv1, record, [0, 0, halfWidth, height]);
      record = this.Records[1];
      this.PlaceViewer(this.ViewerDiv2, record, [halfWidth, 0, halfWidth, height]);
    }
    if (this.Edit) {
      if (numRecords === 0) {
            // TODO: View should have hide/show methods and manage this.
        this.AnnotationWidget1.hide();
        this.AnnotationWidget2.hide();
      }
      if (numRecords === 1) {
        this.AnnotationWidget1.show();
        this.AnnotationWidget2.hide();
      }
      if (numRecords === 2) {
        this.AnnotationWidget1.show();
        this.AnnotationWidget2.show();
      }
    }
  };

  SlidePage.prototype.ClearNote = function () {
    if (this.Edit && this.Note) {
      this.UpdateEdits();
    }
    this.Note = null;
  };

  SlidePage.prototype.DisplayNote = function (note, index) {
    this.Div.show();
    this.Note = note;
    this.ViewerDiv1[0].saViewer.Reset();
    this.ViewerDiv2[0].saViewer.Reset();
    this.Records = note.ViewerRecords; // save this for resizing.

    this.Title.text('Slide: ' + index);
    // Text
    this.List.LoadNote(note);
    // Views
    if (this.Records.length > 0) {
      this.ViewerDiv1[0].saViewer.SetViewerRecord(this.Records[0]);
    }
    if (this.Records.length > 1) {
      this.ViewerDiv2[0].saViewer.SetViewerRecord(this.Records[1]);
    }
    this.ViewerDiv1[0].saViewer.CopyrightWrapper.hide();
    this.ViewerDiv2[0].saViewer.CopyrightWrapper.hide();
    this.ResizeViews();
  };

// We need to copy the annotation (maybe view in the future)
// Interaction does not actach all annotation changes.
  SlidePage.prototype.UpdateEdits = function () {
    if (this.Note &&
        this.Note.ViewerRecords.length > 0 &&
        this.Note.ViewerRecords[0]) {
      this.Note.ViewerRecords[0].CopyViewer(this.ViewerDiv1[0].saViewer);
    }

    if (this.Note &&
        this.Note.ViewerRecords.length > 1 &&
        this.Note.ViewerRecords[1]) {
      this.Note.ViewerRecords[1].CopyViewer(this.ViewerDiv2[0].saViewer);
    }
  };

  SlidePage.prototype.InsertViewNote = function (note) {
    if (note.ViewerRecords.length < 1) { return; }

    // we just use the record for slide pages.
    var record = note.ViewerRecords[0];

    this.Note.ViewerRecords.push(record);

    // Hack: Since GotoSlide copies the viewer to the record,
    // We first have to push the new record to the view.
    if (this.Note.ViewerRecords.length === 1) {
        // TODO: jquery arg
      this.ViewerDiv1[0].saViewer.SetViewerRecord(this.Note.viewerRecords[0]);
    } else if (this.Note.ViewerRecords.length === 2) {
      this.ViewerDiv2[0].saViewer.SetViewerRecord(this.Note.viewerRecords[1]);
    }

    this.DisplayNote(this.Note, SA.presentation.Index);
  };

// ==============================================================================
  function TitlePage (parent, edit) {
    this.Edit = edit;
    this.Note = null;
    this.Div = $('<div>')
        .appendTo(parent)
        .css({
          'background': '#FFF',
          'position': 'absolute',
          'width': '100%',
          'height': '100%',
          'border': '1px solid #AAA'});

    this.TopBar = $('<div>')
        .appendTo(this.Div)
        .css({'position': 'absolute',
          'top': '0%',
          'height': '2%',
          'left': '13%',
          'right': '3%',
          'background': '#DDF1FD'});

    this.Image = $('<img>')
        .appendTo(this.Div)
        .attr('src', 'https://slide-atlas.org/static/img/SlideAtlas_home.jpg')
        .css({'position': 'absolute',
          'top': '46%',
          'height': '50%',
          'left': '13%',
          'box-shadow': '10px 10px 5px #888'});

    this.TitleBar = $('<div>')
        .appendTo(this.Div)
        .css({'position': 'absolute',
          'top': '18%',
          'bottom': '58%',
          'left': '0%',
          'right': '3%',
          'background': '#073E87',
          'color': '#FFF'});
    this.Title = $('<span>')
        .appendTo(this.TitleBar)
        .attr('contenteditable', 'true')
        .css({'position': 'absolute',
          'top': '1em',
              // 'min-height':'3em',
              // 'min-width':'10em',
          'left': '13%'})
        .saScalableFont({scale: '0.3'});

    this.AuthorBar = $('<div>')
        .appendTo(this.Div)
        .css({'position': 'absolute',
          'top': '42%',
          'bottom': '0%',
          'left': '62%',
          'right': '3%',
          'background': '#E9F5FE',
          'color': '#888',
          'padding-left': '2em'});
    this.AuthorText = $('<span>')
        .appendTo(this.AuthorBar)
        .attr('contenteditable', 'true')
        .css({'position': 'absolute',
              // 'minimum-height':'4em',
              // 'minimum-width':'10em',
          'top': '2em'})
        .saScalableFont({scale: '0.1'});

    if (this.Edit) {
      this.Title
            .focusin(function () { SA.ContentEditableHasFocus = true; })
            .focusout(function () { SA.ContentEditableHasFocus = false; });
      this.AuthorText
            .focusin(function () { SA.ContentEditableHasFocus = true; })
            .focusout(function () { SA.ContentEditableHasFocus = false; });
    }
  }

  TitlePage.prototype.EditOff = function () {
    if (SA.Edit && this.Edit) {
      this.Edit = false;
      this.Div.css({'width': '100%', 'left': '0px'});
      this.Title
            .attr('readonly', 'readonly')
            .attr('spellcheck', 'false')
            .unbind('focusin')
            .unbind('focusout')
            .blur();
      this.AuthorText.attr('readonly', 'readonly')
            .attr('readonly', 'readonly')
            .attr('spellcheck', 'false')
            .unbind('focusin')
            .unbind('focusout')
            .blur();
    }
  };

  TitlePage.prototype.EditOn = function () {
    if (SA.Edit && !this.Edit) {
      this.Edit = true;
        // this.Div.css({'width': '100%', 'left': '0px'}); ???
      this.Title
            .attr('contenteditable', 'true')
            .attr('spellcheck', 'true')
            .focusin(function () { SA.ContentEditableHasFocus = true; })
            .focusout(function () { SA.ContentEditableHasFocus = false; });
      this.AuthorText.attr('readonly', 'readonly')
            .attr('contenteditable', 'true')
            .attr('spellcheck', 'true')
            .focusin(function () { SA.ContentEditableHasFocus = true; })
            .focusout(function () { SA.ContentEditableHasFocus = false; });
    }
  };

  TitlePage.prototype.ClearNote = function () {
    if (this.Edit && this.Note) {
      this.UpdateEdits();
    }
    this.Note = null;
  };

  TitlePage.prototype.DisplayNote = function (note) {
    this.Note = note;
    this.Div.show();
    this.Title.html(note.HiddenTitle);
    this.AuthorText.html(note.Text);

    // What is this doing?
    // Select the title?
    var sel = window.getSelection();
    var range;
    range = document.createRange();
    range.noCursor = true;
    range.selectNodeContents(this.Title[0]);
    sel.removeAllRanges();
    sel.addRange(range);
    // Changes it to be bigger and white
    document.execCommand('foreColor', false, '#FFF');
    document.execCommand('fontSize', false, '6');
    document.execCommand('fontName', false, 'Arial');

    // Format the author text.
    // Bad way to format.  Title page should go away and
    // be replaced by HtmlPage.
    range.selectNodeContents(this.AuthorText[0]);
    sel.removeAllRanges();
    sel.addRange(range);

    document.execCommand('fontSize', false, '5');
    document.execCommand('fontName', false, 'Arial');

    sel.removeAllRanges();
    // Remove focus from the two text boxes.
    this.Title.blur();
    this.AuthorText.blur();
  };

  TitlePage.prototype.UpdateEdits = function () {
    if (this.Note) {
      this.Note.Text = this.AuthorText.html();
      this.Note.HiddenTitle = this.Title.html();
    }
  };

// ==============================================================================
// How to save css stuff?
// embedded viewers will be children (what to do about multiple records, stacks?).
// Ignore edit for now.
  function HtmlPage (parent, edit, background) {
    this.Edit = edit;
    this.Note = null;
    // Should I make another div or just use the parent?
    this.Div = $('<div>')
        .appendTo(parent)
        .hide()
        .css({
          'background-color': background,
          'position': 'absolute',
          'width': '100%',
          'height': '100%'});
  }

  HtmlPage.prototype.EditOff = function () {
    if (SA.Edit && this.Edit) {
      this.Edit = false;
      this.Div.css({'width': '100%', 'left': '0px'});
      this.SaEditOff();
    }
  };
  HtmlPage.prototype.EditOn = function () {
    if (SA.Edit && !this.Edit) {
      this.Edit = true;
        // this.Div.css({'width': '100%', 'left': '0px'}); ???
      this.SaEditOn();
    }
  };

// Hide/show the edit gui on all the sa elements
  HtmlPage.prototype.SaEditOff = function () {
    $('.sa-edit-gui').saButtons('disable');
    $('.sa-presentation-text').attr('contenteditable', 'false');
    $('.sa-presentation-rectangle').saElement({'editable': false,
      'interactive': false});
    $('.sa-light-box').saLightBox({'editable': false,
      'interactive': true});
  };

  HtmlPage.prototype.SaEditOn = function () {
    $('.sa-edit-gui').saButtons('enable');
    $('.sa-presentation-text').attr('contenteditable', 'true');
    $('.sa-presentation-rectangle').saElement({'editable': true,
      'interactive': true});
    $('.sa-light-box').saLightBox({'editable': true,
      'interactive': true});
  };

  HtmlPage.prototype.ClearNote = function () {
    if (this.Edit && this.Note) {
      this.UpdateEdits();
    }
    this.Note = null;
  };

  HtmlPage.prototype.DisplayNote = function (note) {
    // Lets record to position of the previous slides viewers to use
    // as the position of any viewers in the new slide.
    this.DefaultViewerPositions = [];
    var lastViewers = $('.sa-lightbox-viewer');
    for (var i = 0; i < lastViewers.length; ++i) {
      this.DefaultViewerPositions.push(
        {left: lastViewers[i].style.left,
          top: lastViewers[i].style.top,
          width: lastViewers[i].style.width,
          height: lastViewers[i].style.height});
    }

    this.Note = note;
    this.Div.show();
    // This version setsup the saTextEditor and other jquery extensions.
    this.Div.saHtml(note.Text);

    if (!this.Edit) {
        // TODO: Reevaulate SaEdit functions.
      this.SaEditOff();
    } else {
      this.SaEditOn();
    }
    // hack
    // Do not let students edit text.
    if (!SA.Edit) {
      $('.sa-text-editor').attr('contenteditable', 'false');
    }

    // Change the edit status of the elements.
    var self = this;
    this.Div.find('.sa-presentation-image')
        .saLightBox({'editable': SA.Edit,
          'aspectRatio': true});
    this.Div.find('.sa-lightbox-viewer')
        .saLightBoxViewer({
          'editable': SA.Edit,
          'delete': function (dom) { self.ViewDeleteCallback(dom); }});
    this.Div.find('.sa-presentation-rectangle')
        .saRectangle({'editable': SA.Edit});
    // Make viewers into lightbox elements.
    // MOVE
    // this.InitializeViews(this.Div.find('.sa-presentation-view'));

    // Set stops.
    $('sa-draggable').saDraggable();
    // still needed for iframes.
    this.BindElements();
    // I do not want to shuffle questions between test and review.
    // if (SA.Edit) {
    //    this.ShuffleQuestion();
    // }
  };

// Add the initial html for a title page.
  HtmlPage.prototype.InitializeTitlePage = function () {
    this.Div.empty();
    this.Div[0].className = 'sa-presentation-title-page';
    // Title bar
    this.InsertRectangle('#073E87', '0%', '31%', '97.5%', '25%');
    // Should everything be have Div as parent?
    // Todo: make this look like jquery.
    this.InsertTextBox(50)
        .addClass('sa-presentation-title')
        .css({'color': 'white',
          'left': '10%',
          'width': '88%',
          'top': '40%'})
        .text('Title');

    this.InsertTextBox(28)
        .css({'left': '10%',
          'width': '88%',
          'top': '59%'})
        .text('Author');

    this.UpdateEdits();
    this.BindElements();
  };

// Add the initial html for a slide page.
  HtmlPage.prototype.InitializeSlidePage = function () {
    this.Div.empty();
    this.Div[0].className = 'sa-presentation-slide-page';

    // Title bar
    this.InsertRectangle('#073E87', '0%', '6%', '97.5%', '14%');

    // Should everything be have Div as parent?
    // Todo: make this look like jquery.
    this.InsertTextBox(42)
        .css({'color': 'white',
          'left': '18%',
          'width': '70%',
          'top': '7.25%',
          'height': '11.5%'})
        .text('Title')
        .addClass('sa-presentation-title');

    this.UpdateEdits();
    this.BindElements();
  };

// TODO: make sa jquery handle this.
  HtmlPage.prototype.InsertImage = function (src) {
    var imgDiv;
    var left = 5 + Math.floor(Math.random() * 10);
    var top = 20 + Math.floor(Math.random() * 10);

    /* // link option
    if (ref !== "") {
        imgDiv = $('<a>')
            .appendTo(this.Div)
            .attr('href', ref)
            .css({'position':'absolute',
                  'left'    :left+'%',
                  'top'     :top+'%',
                  'z-index' :'1'})
            .addClass('sa-presentation-image')
            .saLightBox();
    } else { */
    imgDiv = $('<div>')
        .appendTo(this.Div)
        .css({'position': 'absolute',
          'left': left + '%',
          'top': top + '%',
          'z-index': '1'})
        .saLightBox({aspectRatio: true,
          editable: SA.Edit})
        .addClass('sa-presentation-image');
    var img = $('<img>')
        .appendTo(imgDiv)
        .css({'width': '100%',
          'height': '100%'});
    img[0].onload = function () {
        // Bug.  imgDiv had no style.width
        // Not scalling
      this.parentNode.style.width = this.width + 'px';
      this.parentNode.style.height = this.height + 'px';
      this.parentNode.saElement.ConvertToPercentages();
    };
    img.attr('src', src);

    return imgDiv;
  };

// TODO: Change type based on extension
  HtmlPage.prototype.InsertVideo = function (src) {
    // resizable makes a containing div anyway.
    var vidDiv = $('<div>')
        .appendTo(this.Div)
        .css({'position': 'absolute',
          'left': '10%',
          'top': '30%',
          'z-index': '1'})
        .addClass('sa-presentation-video')
        .saDraggable()
        .saDeletable();

    var vid = $('<video controls>')
        .appendTo(vidDiv);
    src = $('<source type="video/mp4">')
        .appendTo(vid)
        .attr('src', src);

    vid[0].addEventListener('loadeddata', function () {
        // Video is loaded
        // compute the aspect ratio.
      var aRatio = $(this).width() / $(this).height();
      vidDiv.saResizable({
        aspectRatio: aRatio
      });
      vid.css({'height': '100%',
        'width': '100%'});
    }, false);

    return vidDiv;
  };

// Make the title bar movable and resizable.
// left, top, width and height should be in percentages. i.e. '50%'
  HtmlPage.prototype.InsertRectangle = function (color, left, top, width, height) {
    $('<div>')
        .appendTo(this.Div)
        .css({'background-color': color,
          'border': '1px solid rgba(255, 255, 255, 0)',
          'position': 'absolute',
          'left': left,
          'width': width,
          'top': top,
          'height': height})
        .saRectangle({editable: SA.Edit});
  };

// The execCommand paste does not work
  HtmlPage.prototype.Paste = function () {
    // resizable makes a containing div anyway.
    var containerDiv = $('<div>')
        .appendTo(this.Div)
        .css({'position': 'absolute',
          'left': '5%',
          'top': '25%'})
        .text('paste here')
        .saDraggable()
        .saDeletable();

    // Select the container
    containerDiv
        .attr('contenteditable', 'true')
        .focus();

    // Select everything.
    var sel = window.getSelection();
    var range = document.createRange();
    range.noCursor = true;
    range.selectNodeContents(containerDiv[0]);
    sel.removeAllRanges();
    sel.addRange(range);
    // This does not work.
    document.execCommand('paste', false, null);
  };

// Embed youtube.
// '<iframe width="420" height="315" src="https://www.youtube.com/embed/9tCafgGZtxQ" frameborder="0" allowfullscreen></iframe>');
  HtmlPage.prototype.InsertIFrame = function (html) {
    // Youtube size has to be set in the original html string.
    var width, height;
    var start = html.indexOf('width');
    var str;
    var end;
    var tmp;
    if (start !== -1) {
      str = html.substring(start + 7);
      end = str.indexOf('"');
      tmp = str.substr(0, end);
      width = parseInt(tmp) / (800 * 1.333);
      width = Math.round(width * 100);
      width = width + '%';
      html = html.replace(tmp, width);
    }
    start = html.indexOf('height');
    if (start !== -1) {
      str = html.substring(start + 8);
      end = str.indexOf('"');
      tmp = str.substr(0, end);
      height = parseInt(tmp) / 800;
      height = Math.round(height * 100);
      height = height + '%';
      html = html.replace(tmp, height);
    }

    var frame = $(html)
        .appendTo(this.Div)
        .css({'position': 'absolute',
          'display': 'block',
          'left': '5%',
          'top': '5%',
          'z-index': '1'})
        .saDraggable()
        .saDeletable();

    return frame;
  };

  HtmlPage.prototype.InsertURL = function (src) {
    // iframes do not scale with css.  I have to have a resize callback.
    var div = $('<div>')
        .appendTo(this.Div)
        .css({'position': 'absolute',
          'left': '5%',
          'right': '2.5%',
          'top': '25%',
          'bottom': '10%',
          'z-index': '1'})
        .saDraggable()
        .saDeletable()
        .resizable();
    var frame = $('<iframe>')
        .appendTo(div)
        .css({'position': 'absolute',
          'display': 'block',
          'width': '100%',
          'height': '100%'})
        .attr('src', src)
        .attr('scrolling', 'no')
        .addClass('sa-presentation-iframe');

    this.BindElements();
    return frame;
  };

// This could be eliminated and just use the jquery saTextEditor.
// Interactively place the initial box.
// First lets see if we can reposition it.
  HtmlPage.prototype.InsertTextBox = function (size) {
    size = size || 30;

    // Arbitrary height so I do not need to specify
    // text in percentages.
    var scale = size / 800;

    // Should everything be have Div as parent?
    var text = $('<div>')
        // note: parent has to be set before saTextEditor is called.
        .appendTo(this.Div)
        .css({'display': 'inline-block',
          'position': 'absolute',
          'overflow': 'visible',
          'fontFamily': 'Verdana,sans-serif',
          'border': '1px solid rgba(255, 255, 255, 0)',
              // defaults caller can reset these.
          'box-sizing': 'border-box',
          'left': '5%',
          'width': '50%',
          'top': '30%',
          'height': '10%',
          'padding': '2% 1% 1% 1%', // top right bottom left
          'z-index': '1'})
        .addClass('sa-presentation-text')
        // This makes the font scale with height of the window.
        .saScalableFont({scale: scale,
          editable: SA.Edit})
        // default content
        .text('Text');

    if (this.Edit) {
        // Make this div into a text editor.
      text.saTextEditor({dialog: true,
        editable: true});
    }

    return text;
  };

  HtmlPage.prototype.ShuffleQuestion = function () {
    var questions = this.Div.find('.sa-q [type="multiple-choice"]');
    for (var i = 0; i < questions.length; ++i) {
      var q = questions[i];
        // Shuffle the list.
      for (var j = q.childNodes.length; j > 0; --j) {
        var idx = Math.floor(Math.random() * j);
        q.appendChild(q.removeChild(q.childNodes[idx]));
      }
    }
  };

// Multiple choice for now.
// Answers stored as list items <li>.
  HtmlPage.prototype.InsertQuestion = function () {
    var bar = $('<div>')
        .css({'position': 'absolute',
          'left': '2%',
          'width': '92%',
          'top': '75%',
          'height': '22.5%',
          'background': '#FFF',
          'border': '1px solid #AAA',
          'padding': '1% 1% 1% 1%', // top right bottom left
          'z-index': '1'})
        .saScalableFont({scale: '0.03'})
        .saQuestion({editable: SA.Edit});

    // This is for interactive adding new question from the GUI / dialog.
    // Do not apped the question until apply is selected.
    var self = this;
    bar.saQuestion('OpenDialog',
                   function () {
                     bar.appendTo(self.Div);
                     bar.trigger('resize');
                   });
  };

// Should save the view as a child notes, or viewer record?
// For saving, it would be easy to encode the view id into the html as an
// attribute, but what would I do with the other viewer records?  Ignore
// them. One issue:  I have to save the new note to get the id, which is
// necessary, for the saViewer.  Well, maybe not.  I could pass in the
// note, and then get the id when saHtml() is called to save.
  HtmlPage.prototype.InsertView = function (viewObj) {
    if (!this.Note) {
      return;
    }

    // First make a copy of the view as a child.
    var newNote = new SA.Note();
    var tmpId = newNote.Id;
    newNote.Load(viewObj);
    delete newNote.Id;
    newNote.Id = tmpId;
    if (newNote.ViewerRecords.length === 0) {
      SA.Debug('Insert failed: Note has no viewer records.');
    } else if (this.Note.Parent) {
      this.Note.Children.push(newNote);
      newNote.Parent = this.Note;
      this.InsertView2(newNote);
    } else {
        // We cannot add a dual view to a tile page because the child note
        // will be interpreted as a new slide.
      this.InsertViewerRecord(newNote.ViewerRecords[0]);
    }
  };

// The html page is a note.  It contains viewer whose states are saved in
// viewerRecords.
// Helper method
// TODO: Change newNote to viewerRecord.
  HtmlPage.prototype.InsertViewerRecord = function (viewerRecord) {
    if (!this.Note) {
      return;
    }

    var viewerIdx = this.Note.ViewerRecords.length;
    this.Note.ViewerRecords.push(viewerRecord);

    var defaultPosition = {left: '5%', top: '25%', width: '40%', height: '40%'};
    if (this.DefaultViewerPositions.length > 0) {
      defaultPosition = this.DefaultViewerPositions.splice(0, 1)[0];
    } else {
      var n = (this.Div.children().length) * 5;
      defaultPosition.left = n.toString() + '%';
      defaultPosition.top = (n + 15).toString() + '%';
    }

    var self = this;
    var viewerDiv = $('<div>')
        .appendTo(this.Div)
        .css({'position': 'absolute',
          'box-shadow': '10px 10px 5px #AAA',
          'background-color': '#FFF',
          'opacity': '1.0',
          'left': defaultPosition.left,
          'width': defaultPosition.width,
          'top': defaultPosition.top,
          'height': defaultPosition.height})
        .saLightBoxViewer({
          'note': this.Note,
          'viewerIndex': viewerIdx,
          'hideCopyright': true,
          'editable': SA.Edit,
          'delete': function (dom) { self.ViewDeleteCallback(dom); }});

    return viewerDiv;
  };
// The html page is a note.  It contains viewer whose states are saved in
// viewerRecords.
// Helper method
// TODO: Change newNote to viewerRecord.
  HtmlPage.prototype.InsertView2 = function (view) {
    if (!this.Note) {
      return;
    }

    var defaultPosition = {left: '5%', top: '25%', width: '45%', height: '45%'};
    if (this.DefaultViewerPositions.length > 0) {
      defaultPosition = this.DefaultViewerPositions.splice(0, 1)[0];
    }

    var self = this;
    var viewerDiv = $('<div>')
        .appendTo(this.Div)
        .css({'position': 'absolute',
          'box-shadow': '10px 10px 5px #AAA',
          'background-color': '#FFF',
          'opacity': '1.0',
          'left': defaultPosition.left,
          'width': defaultPosition.width,
          'top': defaultPosition.top,
          'height': defaultPosition.height})
        .saLightBoxViewer({
          'note': view,
          'dual': true,
          'hideCopyright': true,
          'delete': function (dom) { self.ViewDeleteCallback(dom); },
          'editable': SA.Edit});

    return viewerDiv;
  };
// This was for development debugging
  HtmlPage.prototype.InsertViewId2 = function (viewId) {
    if (!this.Note) {
      return;
    }

    var defaultPosition = {left: '5%', top: '25%', width: '45%', height: '45%'};
    if (this.DefaultViewerPositions.length > 0) {
      defaultPosition = this.DefaultViewerPositions.splice(0, 1)[0];
    }

    var viewerDiv = $('<div>')
        .appendTo(this.Div)
        .css({'position': 'absolute',
          'box-shadow': '10px 10px 5px #AAA',
          'background-color': '#FFF',
          'opacity': '1.0',
          'left': defaultPosition.left,
          'width': defaultPosition.width,
          'top': defaultPosition.top,
          'height': defaultPosition.height})
        .saLightBoxViewer({
          'viewId': viewId,
          'dual': true,
          'hideCopyright': true,
          'editable': SA.Edit});

    return viewerDiv;
  };

  HtmlPage.prototype.ViewDeleteCallback = function (dom) {
    // When a viewer is deleted the next should replace it.
    this.DefaultViewerPositions.push(
      {left: dom.style.left,
        top: dom.style.top,
        width: dom.style.width,
        height: dom.style.height});

    // Extra viewer records get pruned when the page is converted to html
    // Get rid of dual viewer notes.
    if (dom.saViewer.saNote !== this.Note) {
      var childIdx = this.Note.Children.indexOf(dom.saViewer.saNote);
      if (childIdx >= 0) {
        this.Note.Children.splice(childIdx, 1);
      }
    }
  };

// NOTE: This should be lagacy now.  The jquery extensions should handle this.
// Text elements need to resize explicitly.
// TODO: Activate text (saScalatFont, saTextEditor, resize) on load.
// I could make this scalabe ifram as a jquery extension too.
  HtmlPage.prototype.BindElements = function () {
    // Similar to text, we need to scale the content.
    var frameElements = $('.sa-presentation-iframe');
    frameElements.addClass('sa-resize');
    for (var i = 0; i < frameElements.length; ++i) {
      var frame = frameElements[i];
      frame.onresize =
            function () {
              var w = $(this).parent().width();
              var h = $(this).parent().height();
              var scale = Math.min(h, w / 1.62) / 700;
              var scaleStr = scale.toString();
              w = (Math.floor(w / scale)).toString();
              h = (Math.floor(h / scale)).toString();

              $(this).css({'-ms-zoom': scaleStr,
                '-ms-transform-origin': '0 0',
                '-moz-transform': 'scale(' + scaleStr + ')',
                '-moz-transform-origin': '0px 50px',
                '-o-transform': 'scale(' + scaleStr + ')',
                '-o-transform-origin': '0px 50px',
                '-webkit-transform': 'scale(' + scaleStr + ')',
                '-webkit-transform-origin': '0 0',
                'width': w + 'px',
                'height': h + 'px'});
            };
      frame.onresize();
    }
  };

  HtmlPage.prototype.UpdateEdits = function () {
    if (this.Note) {
        // Record the camera position (and annotations).
      this.Div.find('.sa-lightbox-viewer').saRecordViewer();
        // Doing this here forces us to save the notes
        // TODO: This may created orphaned views. fix this be either
        // delaying copying saHtml to note, or incrementally saving
        // presentation to the database.
      var htmlDiv = this.Div;
      var note = this.Note;

        // prune deleted records.
        // I should really do this when a view is deleted, but there are
        // deleted records in the database.
        // NOTE: THIS ASSUME THAT ALL THE SA.VIEWERS USE THIS NOTE!!!
      var newRecords = [];
      for (var i = 0; i < this.Note.ViewerRecords.length; ++i) {
        var record = this.Note.ViewerRecords[i];
        var str = i.toString();
        var items = $('[sa-viewer-index=' + str + ']');
        if (items.length > 0) {
                // Replace the index with the new index
          items.attr('sa-viewer-index', newRecords.length);
          newRecords.push(record);
        }
      }
      this.Note.ViewerRecords = newRecords;

      note.Text = htmlDiv.saHtml();
    }
  };

// ==============================================================================
  function SearchPanel (parent, callback) {
    var self = this;
    this.UserCallback = callback;
    this.Parent = parent;

    // List of image data needed for callback.
    this.SearchData = [];

    // TODO:
    // User should probably be formating the parent.
    parent
        .css({'overflow': 'auto',
          'text-align': 'left',
          'color': '#303030',
          'font-size': '18px'});
    this.SearchForm = $('<form>')
        .appendTo(parent)
        .css({'width': '100%',
          'display': 'table'})
        .submit(function (e) { self.SearchCallback(); return false; });
    this.SearchLabel = $('<span>')
        .appendTo(this.SearchForm)
        .css({'display': 'table-cell',
          'padding': '8px',
          'width': '3.5em'})
        .text('Search:');
    this.SearchInput = $('<input>')
        .appendTo(this.SearchForm)
        .css({'width': '95%',
          'display': 'table-cell',
          'border': '2px inset #CCC'})
        .focusin(function () { SA.ContentEditableHasFocus = true; })
        .focusout(function () { SA.ContentEditableHasFocus = false; });
    this.SearchResults = $('<div>')
        .appendTo(parent)
        .css({'position': 'absolute',
          'top': '2em',
          'bottom': '0px',
          'width': '100%',
          'overflow-y': 'auto'});
  }

  SearchPanel.prototype.SearchCallback = function () {
    var self = this;
    var terms = this.SearchInput.val();

    this.Parent.css({'cursor': 'progress'});
    $.ajax({
      type: 'get',
      url: '/webgl-viewer/query',
      data: {'terms': terms},
      success: function (data, status) {
        self.LoadSearchResults(data);
        self.Parent.css({'cursor': 'default'});
      },
      error: function () {
        SA.Debug('AJAX - error() : query');
        self.Parent.css({'cursor': 'default'});
      }
    });
  };

  SearchPanel.prototype.LoadSearchResults = function (data) {
    var self = this;
    this.SearchResults.empty();
    this.SearchData = data.images;

    // These are in order of best match.
    for (var i = 0; i < data.images.length; ++i) {
      var imgObj = data.images[i];

      var imageDiv = $('<div>')
            .appendTo(this.SearchResults)
            .css({'float': 'left',
              'margin': '5px',
              'border': '1px solid #AAA'})
            .attr('id', imgObj._id)
            .data('index', i)
            .hover(function () { $(this).css({'border-color': '#00F'}); },
                   function () { $(this).css({'border-color': '#AAA'}); })
            .click(function () {
              self.SelectCallback($(this).data('index'));
            });

      var image = {img: imgObj._id,
        db: imgObj.database,
        levels: imgObj.levels,
        tile_width: imgObj.TileWidth,
        tile_height: imgObj.TileHeight,
        bounds: imgObj.bounds,
        label: imgObj.label};
      if (!image.bounds) {
        image.bounds = [0, imgObj.dimensions[0], 0,
          imgObj.dimensions[1]];
      }
      var thumb = new SA.CutoutThumb(image, 100);
      thumb.Div.appendTo(imageDiv);
      $('<div>')
            .css({'font-size': '50%'})
            .appendTo(imageDiv)
            .text(imgObj.label); // Should really have the image label.
    }
  };

  SearchPanel.prototype.SelectCallback = function (index) {
    // Search data is just a list of image objects.
    if (this.UserCallback && index >= 0 && index < this.SearchData.length) {
      (this.UserCallback)(this.SearchData[index]);
    }
  };

// ==============================================================================

  function ClipboardPanel (parent, callback) {
    var self = this;
    this.UserCallback = callback;

    parent
        .css({'overflow': 'auto',
          'text-align': 'left',
          'color': '#303030',
          'font-size': '18px'});
    this.ClearButton = $('<button>')
        .appendTo(parent)
        .click(function () { self.ClipboardDeleteAll(); })
        .text('Remove All');
    this.ClipboardDiv = $('<div>')
        .css({'overflow_y': 'auto'})
        .appendTo(parent);

    $.ajax({
      type: 'get',
      url: 'webgl-viewer/getfavoriteviews',
      success: function (data, status) {
        if (status === 'success') {
          self.LoadClipboardCallback(data);
        } else { SA.Debug('ajax failed - get favorite views 2'); }
      },
      error: function () {
        SA.Debug('AJAX - error() : getfavoriteviews 2');
      }
    });
  }

  ClipboardPanel.prototype.LoadClipboardCallback = function (sessionData) {
    var self = this;
    this.ClipboardDiv.empty();
    this.ClipboardViews = sessionData.viewArray;

    for (var i = 0; i < this.ClipboardViews.length; ++i) {
      var view = this.ClipboardViews[i];
      if (view.Thumb.substring(0, 6) === 'http:/') {
        view.Thumb = view.Thumb.substring(6);
      }
      $('<img>')
            .appendTo(this.ClipboardDiv)
            .attr('src', view.Thumb)
            .prop('title', view.Title)
            .css({'float': 'left',
              'margin': '5px',
              'border': '1px solid #AAA',
              'height': '60px'})
            .attr('index', i)
            .hover(function () { $(this).css({'border-color': '#00F'}); },
                   function () { $(this).css({'border-color': '#AAA'}); })
            .click(function () {
              self.ClickViewCallback(parseInt(this.getAttribute('index')));
            });
    }
  };

  ClipboardPanel.prototype.ClickViewCallback = function (idx) {
    if (this.UserCallback && idx >= 0 && idx < this.ClipboardViews.length) {
      (this.UserCallback)(this.ClipboardViews[idx]);
    }
  };

  ClipboardPanel.prototype.ClipboardDeleteAll = function () {
    this.ClipboardDiv.empty();

    for (var i = 0; i < this.ClipboardViews.length; ++i) {
      $.ajax({
        type: 'post',
        url: '/webgl-viewer/deleteusernote',
        data: {'noteId': this.ClipboardViews[i]._id,
          'col': 'views'}, // "favorites"
        success: function (data, status) {
        },
        error: function () {
          SA.Debug('AJAX - error() : deleteusernote');
        }
      });
    }
  };

  SA.SearchPanel = SearchPanel;
  SA.ClipboardPanel = ClipboardPanel;
  SA.Presentation = Presentation;
})();

// Make this a singlton (effectively) for now.
// Two levels of caching and pruning.
// Image without an associated texture map.
// Texture maps (scarcer resource).

(function () {
  'use strict';

  // TODO: Mny of these can remain private.
  SA.TileLoader = 'http';

  // Keep a queue of tiles to load so we can sort them as
  // new requests come in.
  SA.LoadQueue = [];
  SA.LoadingCount = 0;
  SA.LoadingMaximum = 10;
  SA.LoadTimeoutId = 0;

  SA.TimeStamp = 0;
  SA.NumberOfTiles = 0;
  SA.NumberOfTextures = 0;
  // SA.MaximumNumberOfTiles = 50000;
  SA.MaximumNumberOfTiles = 3000;
  SA.MaximumNumberOfTextures = 5000;
  SA.PruneTimeTiles = 0;
  SA.PruneTimeTextures = 0;

  if (SA.MOBILE_DEVICE) {
    SA.MaximumNumberOfTiles = 5000;
  }

  SA.LoadProgressMax = 0;
  SA.ProgressBar = null;

  // Only used for saving images right now.
  SA.FinishedLoadingCallbacks = [];

  SA.InitProgressBar = function () {
    if (SA.ProgressBar) { return; }
    SA.ProgressBar = $('<div>')
            .appendTo('body')
            .addClass('sa-view-progress-bar');
  };

  SA.AdvanceTimeStamp = function () {
    ++SA.TimeStamp;
  };

  SA.GetCurrentTime = function () {
    return SA.TimeStamp;
  };

  // Prunning could be rethought to avoid so much depdency on the cache.
  SA.Prune = function () {
    var prune = false;
    if (SA.NumberOfTiles >= SA.MaximumNumberOfTiles) {
      // Overflow may be possible after running for a while.
      if (SA.PruneTimeTiles > SA.TimeStamp) {
        SA.PruneTimeTiles = 0;
      }
      // Advance the prune threshold.
      SA.PruneTimeTiles += 0.05 * (SA.TimeStamp - SA.PruneTimeTiles);
      prune = true;
    }

    if (SA.NumberOfTextures >= SA.MaximumNumberOfTextures) {
      // Overflow may be possible after running for a while.
      if (SA.PruneTimeTextures > SA.TimeStamp) {
        SA.PruneTimeTextures = 0;
      }
      // Advance the prune threshold.
      SA.PruneTimeTextures += 0.05 * (SA.TimeStamp - SA.PruneTimeTextures);
      prune = true;
    }

    // console.log("Prune test " + SA.NumberOfTiles + ", limit " + SA.MaximumNumberOfTiles);

    if (prune) {
      console.log('prune !!!!!!');
      for (var i in SA.Caches) {
        var cache = SA.Caches[i];
        cache.PruneTiles();
      }
    }
  };

  SA.ClearQueue = function () {
    for (var i = 0; i < SA.LoadQueue.length; ++i) {
      var tile = SA.LoadQueue[i];
      if (tile) {
        tile.LoadState = 0;
      }
    }
    SA.LoadQueue = [];
    SA.LoadQueueUpdate();
  };

  // You have to call LoadQueueUpdate after adding tiles.
  // We could chop off the lowest priority tiles if the queue gets too long.
  // Simply add the tile to the queue.
  SA.LoadQueueAddTile = function (tile) {
    if (tile.LoadState === 0 || tile.LoadState === 4) {
      // New tile or error
      tile.LoadState = 1;
      // Add the tile at the front of the queue.
      SA.LoadQueue.push(tile);
    }
  };

  // Push the best tile to the end of the queue.
  var PushBestToLast = function () {
    // Do a sort pass (pushing high priority items to the end.
    var t0 = SA.LoadQueue[0];
    for (var i = 1; i < SA.LoadQueue.length; ++i) {
      var t1 = SA.LoadQueue[i];
      var swap = false;
      if (t1 !== null) {
        if (t0 === null) {
          swap = true;
        } else if (t0.TimeStamp > t1.TimeStamp) {
          swap = true;
        } else if (t0.TimeStamp === t1.TimeStamp && t0.Level < t1.Level) {
          swap = true;
        }
      }
      if (swap) {
        // Swap the pair.
        SA.LoadQueue[i] = t0;
        SA.LoadQueue[i - 1] = t1;
      } else {
        t0 = t1;
      }
    }
  };

  // I need a way to remove tiles from the queue when they are deleted.
  // I know this is inefficient.
  SA.LoadQueueRemove = function (tile) {
    var length = SA.LoadQueue.length;
    for (var i = 0; i < length; ++i) {
      if (SA.LoadQueue[i] === tile) {
        tile.LoadState = 0;
        SA.LoadQueue[i] = null;
        return;
      }
    }
  };

  var LoadTimeout = function () {
    // 4 images requests are too slow.  Reset
    // I do not know which requests failed so I cannot mak another request.
    // TODO: Remember loading tiles (even if only for debugging).
    SA.LoadingCount = 0;
    SA.LoadQueueUpdate();
  };

  // We will have some number of tiles loading at one time.
  // Take the first N tiles from the queue and start loading them.
  // Too many and we cannot abort loading.
  // Too few and we will serialize loading.
  SA.LoadQueueUpdate = function () {
    if (SA.LoadingCount < 0) {
      // Tiles must have arrived after timeout.
      SA.LoadingCount = 0;
    }
    while (SA.LoadingCount < SA.LoadingMaximum &&
           SA.LoadQueue.length > 0) {
      PushBestToLast();
      var tile = SA.LoadQueue.pop();
      if (tile !== null && tile.LoadState === 1) {
        tile.StartLoad(tile.Cache);
        tile.LoadState = 2; // Loading.
        ++SA.LoadingCount;
      }
    }

    // Observed bug: If 4 tile requests never return, loading stops.
    // Do a time out to clear this hang.
    if (SA.LoadTimeoutId) {
      clearTimeout(SA.LoadTimeoutId);
      SA.LoadTimeoutId = 0;
    }
    if (SA.LoadingCount) {
      SA.LoadTimeoutId = setTimeout(function () { LoadTimeout(); }, 1000);
    }

    if (SA.ProgressBar) {
      if (SA.LoadProgressMax < SA.LoadQueue.length) {
        SA.LoadProgressMax = SA.LoadQueue.length;
      }
      var width = (100 * SA.LoadQueue.length / SA.LoadProgressMax).toFixed();
      width = width + '%';
      SA.ProgressBar.css({'width': width});
      // Reset maximum
      if (SA.LoadQueue.length === 0) {
        SA.LoadProgressMax = 0;
      }
    }

    if (SA.FinishedLoadingCallbacks.length > 0 &&
            SA.LoadQueue.length === 0 && SA.LoadingCount === 0) {
      var tmp = SA.FinishedLoadingCallbacks.slice(0); // copy
      SA.FinishedLoadingCallbacks = [];
      for (var i = 0; i < tmp.length; ++i) {
        (tmp[i])();
      }
    }
  };

  SA.AddFinishedLoadingCallback = function (callback) {
    SA.FinishedLoadingCallbacks.push(callback);
    SA.LoadQueueUpdate();
  };

  SA.ClearFinishedLoadingCallbacks = function () {
    SA.FinishedLoadingCallbacks = [];
  };

  // Issue: Tiles call this method when their image gets loaded.
  // How does the tile know which cache it belongs too.
  // Marks a tile as loaded so another can start.
  SA.LoadQueueLoaded = function (tile) {
    --SA.LoadingCount;
    tile.LoadState = 3; // Loaded
    // Cache has a LoadRootsCallback
    if (tile.Cache.LoadTileCallback) {
      (tile.Cache.LoadTileCallback)();
      tile.Cache.LoadTileCallback = undefined;
    }
    SA.LoadQueueUpdate();
  };

  // This is called if their was a 404 image not found error.
  SA.LoadQueueError = function (tile) {
    tile.LoadState = 4; // Error Loading
    --SA.LoadingCount;
    SA.LoadQueueUpdate();
  };
})();

// ==============================================================================
// Camera Object
// Set the viewport separately

window.SAM = window.SAM || {};

(function () {
  'use strict';

  function Camera () {
    // This transformation is from global/world to slide coordinate system
    this.WorldToImageTransform = [1, 0, 0, 1, 0, 0];

    // Better managmenet of layers and sub layers.
    // Assign a range of the z buffer  for the view to use exclusively.
    // The full range is -1->1.  -1 is in front.
    this.ZRange = [-1.0, 1.0];
    this.WorldRoll = 0;
    this.WorldMatrix = mat4.create();
    this.ImageMatrix = mat4.create();
    this.Height = 16000;
    this.Width = this.Height * 1.62;
    this.WorldFocalPoint = [128.0 * 64.0, 128.0 * 64.0];
    this.ComputeMatrix();
    // for drawing the view bounds.
    this.Points = [];
    this.Buffer = null;
    this.CreateBuffer();
    this.Mirror = false;

    // When rotating, I want to stop at 0, 90, 180, and 270.
    this.RollStopFlag = false;
    this.RollStopCounter = 0.0;

    // Placeholders
    this.ViewportWidth = 162;
    this.ViewportHeight = 100;
  }

  // User can draw in image coordinates.
  /*
  Camera.prototype.ContextSetImageTransform = function (ctx) {
    // Start with a transform that flips the y axis.
    ctx.setTransform(1, 0, 0, -1, 0, this.ViewportHeight);
    // Map (-1->1, -1->1) to the viewport.
    ctx.transform(0.5 * this.ViewportWidth, 0.0,
                  0.0, 0.5 * this.ViewportHeight,
                  0.5 * this.ViewportWidth,
                  0.5 * this.ViewportHeight);
    // Apply the image matrix
    var m = this.GetImageMatrix();
    var h = 1.0 / m[15];
    ctx.transform(m[0] * h, m[1] * h,
                  m[4] * h, m[5] * h,
                  m[12] * h, m[13] * h);
  }; */
  // Get the image to viewer transformation (for the canvas).
  Camera.prototype.GetImageToViewerTransform = function () {
    // Start with a transform that flips the y axis.
    var t1 = [1, 0, 0, -1, 0, this.ViewportHeight];
    // Map (-1->1, -1->1) to the viewport.
    var t2 = [
      0.5 * this.ViewportWidth, 0.0,
      0.0, 0.5 * this.ViewportHeight,
      0.5 * this.ViewportWidth,
      0.5 * this.ViewportHeight
    ];
    // Apply the image matrix
    var m = this.GetImageMatrix();
    var h = 1.0 / m[15];
    var t3 = [
      m[0] * h, m[1] * h,
      m[4] * h, m[5] * h,
      m[12] * h, m[13] * h
    ];
    var t = SAM.MultiplyTransforms(t1, t2);
    t = SAM.MultiplyTransforms(t, t3);
    return t;
  };

  // This transformation is from global/world to slide coordinate system
  Camera.prototype.SetWorldToImageTransform = function (trans) {
    this.WorldToImageTransform = trans;
    this.ComputeMatrix();
  };

  Camera.prototype.GetViewportHeight = function () {
    return this.ViewportHeight;
  };

  Camera.prototype.GetViewportWidth = function () {
    return this.ViewportWidth;
  };

  // Spacing of pixels of the screen.
  Camera.prototype.GetSpacing = function () {
    return this.GetHeight() / this.ViewportHeight;
  };

  // Copies the world view but not the slide to world transform.
  Camera.prototype.WorldCopy = function (inCam) {
    if (inCam.ZRange) { this.ZRange = inCam.ZRange.slice(0); }
    this.WorldRoll = inCam.WorldRoll;
    this.Height = inCam.Height;
    this.Width = inCam.Width;
    this.SetWorldFocalPoint(inCam.WorldFocalPoint);
    if (inCam.ViewportWidth) { this.ViewportWidth = inCam.ViewportWidth; }
    if (inCam.ViewportHeight) { this.ViewportHeight = inCam.ViewportHeight; }
    this.ComputeMatrix();
  };

  Camera.prototype.DeepCopy = function (inCam) {
    this.WorldToImageTransform = inCam.WorldToImageTransform.slice(0);
    this.WorldCopy(inCam);
  };

  Camera.prototype.SetViewport = function (viewport) {
    if (10 * viewport[3] < viewport[2]) {
      // alert('Unusual viewport ' + viewport[3]);
      return;
    }
    this.ViewportWidth = viewport[2];
    this.ViewportHeight = viewport[3];
    this.Width = this.Height * this.ViewportWidth / this.ViewportHeight;
    this.ComputeMatrix();
  };

  Camera.prototype.Serialize = function () {
    var obj = {};
    obj.WorldFocalPoint = [this.WorldFocalPoint[0], this.WorldFocalPoint[1]];
    obj.WorldRoll = this.WorldRoll;
    obj.Height = this.GetHeight();
    obj.Width = this.GetWidth();
    return obj;
  };

  Camera.prototype.Load = function (obj) {
    this.SetWorldFocalPoint(obj.FocalPoint);
    this.WorldRoll = obj.Roll;
    this.Height = obj.Height;
    if (obj.Width) {
      this.Width = obj.Width;
    } else {
      this.Width = this.Height * this.ViewportWidth / this.ViewportHeight;
    }

    // Width is computed from height and aspect.
    this.ComputeMatrix();
  };

  // Roll is in Radians
  // Rotation is in Degrees
  Camera.prototype.GetWorldRotation = function () {
    return this.WorldRoll * 180.0 / 3.1415926535;
  };

  Camera.prototype.GetImageRotation = function () {
    return this.GetImageRoll() * 180.0 / 3.1415926535;
  };

  Camera.prototype.GetWorldRoll = function () {
    return this.WorldRoll;
  };

  // Legacy: What a pain.
  Camera.prototype.GetImageRoll = function () {
    // Create a world up vector.
    var x = Math.cos(this.WorldRoll);
    var y = Math.sin(this.WorldRoll);
    // Transform to image coordinate system.
    var t = this.WorldToImageTransform;
    var imx = (t[0] * x) + (t[2] * y);
    var imy = (t[1] * x) + (t[3] * y);
    // Now normalize.
    var mag = Math.sqrt(imx * imx + imy * imy);
    imx = imx / mag;
    imy = imy / mag;
    // Now convert back into radians.
    return Math.atan2(imy, imx);
  };

  Camera.prototype.GetWorldFocalPoint = function () {
    // Copy to avoid bugs because arrays are shared.
    // These are nasty to find.
    return [this.WorldFocalPoint[0], this.WorldFocalPoint[1]];
  };

  Camera.prototype.GetImageFocalPoint = function () {
    return SAM.ApplyTransform(this.WorldToImageTransform, this.WorldFocalPoint);
  };

  // This is in global/world coordinate system.
  Camera.prototype.SetWorldFocalPoint = function (fp) {
    if (isNaN(fp[0]) || isNaN(fp[1])) {
      return;
    }
    this.WorldFocalPoint[0] = fp[0];
    this.WorldFocalPoint[1] = fp[1];
    // Ignore z on purpose.
  };

  // View is in screen pixel coordinates.
  Camera.prototype.ConvertPointViewerToImage = function (x, y) {
    // Convert to world coordinate system
    // Compute focal point from inverse overview camera.
    var m = this.ImageMatrix;
    x = x / this.ViewportWidth;
    y = y / this.ViewportHeight;
    x = (x * 2.0 - 1.0) * m[15];
    y = (1.0 - y * 2.0) * m[15];
    var det = m[0] * m[5] - m[1] * m[4];
    var xNew = (x * m[5] - y * m[4] + m[4] * m[13] - m[5] * m[12]) / det;
    var yNew = (y * m[0] - x * m[1] - m[0] * m[13] + m[1] * m[12]) / det;

    return [xNew, yNew];
  };

  // View is in screen pixel coordinates.
  Camera.prototype.ConvertPointViewerToWorld = function (x, y) {
    // Convert to world coordinate system
    // Compute focal point from inverse overview camera.
    var m = this.WorldMatrix;
    x = x / this.ViewportWidth;
    y = y / this.ViewportHeight;
    x = (x * 2.0 - 1.0) * m[15];
    y = (1.0 - y * 2.0) * m[15];
    var det = m[0] * m[5] - m[1] * m[4];
    var xNew = (x * m[5] - y * m[4] + m[4] * m[13] - m[5] * m[12]) / det;
    var yNew = (y * m[0] - x * m[1] - m[0] * m[13] + m[1] * m[12]) / det;

    return [xNew, yNew];
  };

  Camera.prototype.ConvertPointWorldToViewer = function (x, y) {
    var m = this.WorldMatrix;

    // Convert from world coordinate to view (-1->1);
    var h = (x * m[3] + y * m[7] + m[15]);
    var xNew = (x * m[0] + y * m[4] + m[12]) / h;
    var yNew = (x * m[1] + y * m[5] + m[13]) / h;
    // Convert from view to screen pixel coordinates.
    xNew = (1.0 + xNew) * 0.5 * this.ViewportWidth;
    yNew = (1.0 - yNew) * 0.5 * this.ViewportHeight;

    return [xNew, yNew];
  };

  Camera.prototype.ConvertScaleViewerToImage = function (dist) {
    // It looks like ImageMatrix is scaled to width so to keep things
    // simple ....
    var m = this.ImageMatrix;
    return dist * 2.0 * m[15] / this.ViewportWidth;
  };

  Camera.prototype.ConvertScaleWorldToViewer = function (dist) {
    // It looks like ImageMatrix is scaled to width so to keep things
    // simple ....
    var m = this.WorldMatrix;
    return dist * this.ViewportWidth / (2.0 * m[15]);
  };

  // dx, dy are in view coordinates [-0.5,0.5].
  // The camera world matrix converts world to view.
  Camera.prototype.HandleTranslate = function (dx, dy) {
    // Convert view vector to world vector.
    // We could invert the matrix to get the transform, but this is easier for now.....
    var s = Math.sin(this.WorldRoll);
    var c = Math.cos(this.WorldRoll);
    var w = this.GetWidth();

    if (this.Mirror) {
      dy = -dy;
    }

    // Scale to world.
    dx = dx * w;
    dy = dy * w;
    // Rotate
    var rx = dx * c + dy * s;
    var ry = dy * c - dx * s;

    this.Translate(rx, ry, 0.0);
  };

  // x,y are in display coordiantes (origin at the center).
  // dx,dy are in the same coordinates system (scale).
  // Scale does not matter because we only care about rotation.
  Camera.prototype.HandleRoll = function (x, y, dx, dy) {
    // Avoid divide by zero / singularity
    if (x === 0 && y === 0) {
      return;
    }
    // Orthogonal (counter clockwise) dot dVect.
    var dRoll = -y * dx + x * dy;
    // Remove magnitude of location.
    // Scale by R to get correct angle.
    dRoll = dRoll / (x * x + y * y);
    if (this.Mirror) {
      dRoll = -dRoll;
    }
    this.IncrementRollWithStops(dRoll);
  };

  Camera.prototype.IncrementRollWithStops = function (dRoll) {
    // Keep roll in radians.
    var newRoll = this.WorldRoll + dRoll;
    // Logic for 90 degree stops
    var rad90 = Math.PI * 0.5;

    // How long to stop in units radians.
    var stopDuration = rad90 / 9; // 10 degrees
    var quadrant = ((Math.floor(this.WorldRoll / rad90) % 4) + 4) % 4;
    var newQuadrant = ((Math.floor(newRoll / rad90) % 4) + 4) % 4;
    // Are we going to pass a stop?
    if (!this.RollStopFlag && quadrant !== newQuadrant) {
      // Yes, compute the stop angle.
      var stopAngle = 0;
      if (Math.abs(quadrant - newQuadrant) < 2) {
        stopAngle = (((quadrant + newQuadrant) / 2.0) + 0.5) * rad90;
      }
      this.RollStopFlag = true;
      // Rotate upto the stop (update dRoll) and let remaining cases execute..
      dRoll -= (this.WorldRoll - stopAngle);
      // Handle the 360->0 boundaries.
      var rad360 = Math.PI * 2.0;
      while (dRoll > Math.PI) {
        dRoll -= rad360;
      }
      while (dRoll < -Math.PI) {
        dRoll += rad360;
      }
      this.WorldRoll = stopAngle;
      if (dRoll > 0) {
        this.RollStopCounter = 0;
      } else {
        this.RollStopCounter = stopDuration;
      }
      dRoll = 0;
    }
    // If we are at a stop, advance the stop by dRoll.
    if (this.RollStopFlag) {
      this.RollStopCounter += dRoll;
      console.log('roll stop counter: ' + this.RollStopCounter);
      dRoll = 0;
      if (this.RollStopCounter < 0.0) {
        this.RollStopFlag = false;
        dRoll = this.RollStopCounter;
      }
      if (this.RollStopCounter > stopDuration) {
        this.RollStopFlag = false;
        dRoll = this.RollStopCounter - stopDuration;
      }
    }
    // Handle normal rotation.
    this.WorldRoll += dRoll;

    this.ComputeMatrix();
  };

  Camera.prototype.Translate = function (dx, dy, dz) {
    if (isNaN(dx) || isNaN(dy) || isNaN(dz)) {
      return;
    }
    // I will leave this as an exception.
    // Everything else uses SetWorldFocalPoint([x,y]);
    this.WorldFocalPoint[0] += dx;
    this.WorldFocalPoint[1] += dy;
    this.ComputeMatrix();
  };

  Camera.prototype.GetHeight = function () {
    return this.Height;
  };

  Camera.prototype.SetHeight = function (height) {
    if (isNaN(height)) {
      return;
    }
    this.Height = height;
    // Width tracks height.
    this.Width = height * this.ViewportWidth / this.ViewportHeight;
  };

  Camera.prototype.GetWidth = function () {
    return this.Width;
  };

  Camera.prototype.SetWidth = function (width) {
    if (isNaN(width)) {
      return;
    }
    this.Width = width;
    // Width tracks height.
    this.Height = width * this.ViewportHeight / this.ViewportWidth;
  };

  // In radians
  Camera.prototype.SetWorldRoll = function (roll) {
    this.WorldRoll = roll;
  };

  // Image coordinates.
  Camera.prototype.GetImageBounds = function () {
    var w = this.ViewportWidth;
    var h = this.ViewportHeight;

    var pt = this.ConvertPointViewerToImage(0, 0);
    var sBds = [pt[0], pt[0], pt[1], pt[1]];
    pt = this.ConvertPointViewerToImage(w, h);
    sBds[0] = Math.min(sBds[0], pt[0]);
    sBds[1] = Math.max(sBds[1], pt[0]);
    sBds[2] = Math.min(sBds[2], pt[1]);
    sBds[3] = Math.max(sBds[3], pt[1]);

    return sBds;
  };

  // World Matrix (world -> view)?
  Camera.prototype.GetWorldMatrix = function () {
    return this.WorldMatrix;
  };

  // Image Matrix (slide -> view)?
  Camera.prototype.GetImageMatrix = function () {
    return this.ImageMatrix;
  };

  // Camera matrix transforms points into camera coordinate system
  // X:(-1->1)
  // Y:(-1->1) (-1 is bottom)
  // Z:(-1->1) (-1 is front)
  // Image may not have a perfect matrix in the future We may support
  // nonlinear slide to world transformationss
  Camera.prototype.ComputeMatrix = function () {
    var fp = this.GetWorldFocalPoint();
    var roll = this.GetWorldRoll();
    var s = Math.sin(roll);
    var c = Math.cos(roll);
    var x = fp[0];
    var y = fp[1];
    var z = 10;
    var w = this.GetWidth();
        // var ht = this.GetHeight();  The iPad got this wrong?????
    var ht = this.Height;

    if (w < 0) { return; }

    if (this.Mirror) { ht = -ht; }

    mat4.identity(this.WorldMatrix);

    this.WorldMatrix[0] = c;
    this.WorldMatrix[1] = -s * w / ht;
    this.WorldMatrix[4] = -s;
    this.WorldMatrix[5] = -c * w / ht;
    this.WorldMatrix[9] = 0;
    this.WorldMatrix[10] = (this.ZRange[1] - this.ZRange[0]) * 0.5;
    this.WorldMatrix[12] = -c * x + s * y;
    this.WorldMatrix[13] = -(w / ht) * (-s * x - c * y);
    this.WorldMatrix[14] = -z + (this.ZRange[1] + this.ZRange[0]) * 0.25 * w;
    this.WorldMatrix[15] = 0.5 * w;

    // Now the ImageMatrix.  In the future slide to world transform will be
    // more general so the matrix will not capture the entire
    // transformation.
    var slideToWorld = SAM.InvertTransform(this.WorldToImageTransform);

    mat4.identity(this.ImageMatrix);
    this.ImageMatrix[0] = this.WorldMatrix[0];
    this.ImageMatrix[1] = this.WorldMatrix[1];
    this.ImageMatrix[4] = this.WorldMatrix[4];
    this.ImageMatrix[5] = this.WorldMatrix[5];
    this.ImageMatrix[9] = this.WorldMatrix[9];
    this.ImageMatrix[10] = this.WorldMatrix[10];
    this.ImageMatrix[12] = this.WorldMatrix[12];
    this.ImageMatrix[13] = this.WorldMatrix[13];
    this.ImageMatrix[14] = this.WorldMatrix[14];
    this.ImageMatrix[15] = this.WorldMatrix[15];

    // Concatenate the section mmatrix.

    var m0 = this.ImageMatrix[0];
    var m1 = this.ImageMatrix[1];
    var m4 = this.ImageMatrix[4];
    var m5 = this.ImageMatrix[5];
    this.ImageMatrix[0] = (m0 * slideToWorld[0]) + (m4 * slideToWorld[1]);
    this.ImageMatrix[1] = (m1 * slideToWorld[0]) + (m5 * slideToWorld[1]);
    this.ImageMatrix[4] = (m0 * slideToWorld[2]) + (m4 * slideToWorld[3]);
    this.ImageMatrix[5] = (m1 * slideToWorld[2]) + (m5 * slideToWorld[3]);
    this.ImageMatrix[12] += (m0 * slideToWorld[4]) + (m4 * slideToWorld[5]);
    this.ImageMatrix[13] += (m1 * slideToWorld[4]) + (m5 * slideToWorld[5]);
  };

  // Currenly assumes parallel projection and display z range = [-1,1].
  // Also no rotation!
  // a.k.a. This method does not work.
  Camera.prototype.DisplayToWorld = function (x, y, z) {
    var scale = this.Height / this.ViewportHeight;
    x = x - (0.5 * this.ViewportWidth);
    y = y - (0.5 * this.ViewportHeight);
    var worldPt = [];
    worldPt[0] = this.WorldFocalPoint[0] + (x * scale);
    worldPt[1] = this.WorldFocalPoint[1] + (y * scale);
    worldPt[2] = 10 + (z * this.Height * 0.5);

    return worldPt;
  };

  Camera.prototype.AddPoint = function (x, y, z) {
    this.Points.push(x);
    this.Points.push(y);
    this.Points.push(z);
  };

  Camera.prototype.CreateBuffer = function (gl) {
    if (gl) {
      if (this.Buffer !== null) {
        gl.deleteBuffer(this.Buffer);
      }
      this.Buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this.Buffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.Points),
                          gl.STATIC_DRAW);
    }
  };

  // Getting rid of this.
  Camera.prototype.UpdateBuffer = function () {
    this.Points = [];
    var cx = this.WorldFocalPoint[0];
    var cy = this.WorldFocalPoint[1];
    var rx = this.GetWidth() * 0.5;
    var ry = this.GetHeight() * 0.5;
    this.AddPoint(cx - rx, cy - ry);
    this.AddPoint(cx + rx, cy - ry);
    this.AddPoint(cx + rx, cy + ry);
    this.AddPoint(cx - rx, cy + ry);
    this.AddPoint(cx - rx, cy - ry);
    this.CreateBuffer();
  };

  // Camera is already set.
  Camera.prototype.Draw = function (overview, gl) {
    var overviewCam = overview.Camera;
    var viewport = overview.Viewport;

    var fp = this.GetWorldFocalPoint();
    var rx = this.GetWidth() * 0.5;
    var ry = this.GetHeight() * 0.5;

    // To handle rotation, I need to pass the center through
    // the overview camera matrix. Coordinate system is -1->1
    var newCx = (fp[0] * overviewCam.WorldMatrix[0] + fp[1] * overviewCam.WorldMatrix[4] +
                     overviewCam.WorldMatrix[12]) / overviewCam.WorldMatrix[15];
    var newCy = (fp[0] * overviewCam.WorldMatrix[1] + fp[1] * overviewCam.WorldMatrix[5] +
                     overviewCam.WorldMatrix[13]) / overviewCam.WorldMatrix[15];

    if (gl) { /*
            // I having trouble using the overview camera, so lets just compute
            // the position of the rectangle here.
            var ocx = overviewCam.WorldFocalPoint[0];
            var ocy = overviewCam.WorldFocalPoint[1];
            var orx = overviewCam.GetWidth() * 0.5;
            var ory = overviewCam.GetHeight() * 0.5;

            program = SA.polyProgram;
            gl.useProgram(program);
            gl.uniform3f(program.colorUniform, 0.9, 0.0, 0.9);

            gl.viewport(viewport[0],viewport[1],viewport[2],viewport[3]);
            mat4.identity(pMatrix);
            gl.uniformMatrix4fv(program.pMatrixUniform, false, pMatrix);

            var viewFrontZ = overviewCam.ZRange[0]+0.001;

            mat4.identity(mvMatrix);
            //mvMatrix[12] = ((cx-rx)-ocx)/orx;
            //mvMatrix[13] = ((cy-ry)-ocy)/ory;
            mvMatrix[12] = newCx-(rx/orx);
            mvMatrix[13] = newCy-(ry/ory);
            mvMatrix[14] = viewFrontZ;
            mvMatrix[0] = 2*rx/orx;
            mvMatrix[5] = 2*ry/ory;

            gl.bindBuffer(gl.ARRAY_BUFFER, SA.squareOutlinePositionBuffer);
            gl.vertexAttribPointer(program.vertexPositionAttribute,
                                   SA.squareOutlinePositionBuffer.itemSize,
                                   gl.FLOAT, false, 0, 0);
            gl.uniformMatrix4fv(program.mvMatrixUniform, false, mvMatrix);
            gl.drawArrays(gl.LINE_STRIP, 0,
            SA.squareOutlinePositionBuffer.numItems);
            */
    } else {
      // Transform focal point from -1->1 to viewport
      newCx = (1.0 + newCx) * viewport[2] * 0.5;
      newCy = (1.0 - newCy) * viewport[3] * 0.5;
      // Scale width and height from world to viewport.
      rx = rx * viewport[3] / overviewCam.GetHeight();
      ry = ry * viewport[3] / overviewCam.GetHeight();

      // The 2d canvas was left in world coordinates.
      var ctx = overview.Context2d;
      /*
        ctx.beginPath();
        //ctx.strokeStyle='#E500E5';
        ctx.rect(this.WorldFocalPoint[0]-(0.5*width),
                 this.WorldFocalPoint[1]-(0.5*height),width,height);
        //ctx.fillStyle='#E500E5';
        //ctx.fillRect(this.WorldFocalPoint[0]-(0.5*width),
                       this.WorldFocalPoint[1]-(0.5*height),width,height);
        ctx.stroke();
      */
      ctx.save();
      // ctx.setTransform(1,0,0,1,0,0);
      // Now that the while slide / overview canvas is rotating
      // We have to rotate the rectangle.
      var c = Math.cos(this.WorldRoll);
      var s = Math.sin(this.WorldRoll);
      ctx.setTransform(c, -s, +s, c,
                       (1 - c) * newCx - s * newCy,
                       (1 - c) * newCy + s * newCx);

      ctx.strokeStyle = '#4011E5';
      ctx.beginPath();
      ctx.rect(newCx - rx, newCy - ry, 2 * rx, 2 * ry);
      ctx.stroke();
      ctx.restore();
    }
  };

  SAM.Camera = Camera;

  // Transform utilites.
  SAM.ApplyTransform = function (t, pt) {
    var x = (t[0] * pt[0]) + (t[2] * pt[1]) + t[4];
    var y = (t[1] * pt[0]) + (t[3] * pt[1]) + t[5];
    return [x, y];
  };

  SAM.TransformBounds = function (t, bds) {
    var pt, out;
    pt = SAM.ApplyTransform(t, [bds[0], bds[2]]);
    out = [pt[0], pt[0], pt[1], pt[1]];
    pt = SAM.ApplyTransform(t, [bds[1], bds[2]]);
    out[0] = Math.min(out[0], pt[0]);
    out[1] = Math.max(out[1], pt[0]);
    out[2] = Math.min(out[2], pt[1]);
    out[3] = Math.max(out[3], pt[1]);
    pt = SAM.ApplyTransform(t, [bds[0], bds[3]]);
    out[0] = Math.min(out[0], pt[0]);
    out[1] = Math.max(out[1], pt[0]);
    out[2] = Math.min(out[2], pt[1]);
    out[3] = Math.max(out[3], pt[1]);
    pt = SAM.ApplyTransform(t, [bds[1], bds[3]]);
    out[0] = Math.min(out[0], pt[0]);
    out[1] = Math.max(out[1], pt[0]);
    out[2] = Math.min(out[2], pt[1]);
    out[3] = Math.max(out[3], pt[1]);
    return out;
  };

  SAM.MultiplyTransforms = function (t1, t2) {
    return [
      (t1[0] * t2[0]) + (t1[2] * t2[1]),
      (t1[1] * t2[0]) + (t1[3] * t2[1]),
      (t1[0] * t2[2]) + (t1[2] * t2[3]),
      (t1[1] * t2[2]) + (t1[3] * t2[3]),
      (t1[0] * t2[4]) + (t1[2] * t2[5]) + t1[4],
      (t1[1] * t2[4]) + (t1[3] * t2[5]) + t1[5]];
  };

  SAM.InvertTransform = function (t) {
    var p = (t[0] * t[3]) - (t[1] * t[2]);
    var q = (t[2] * t[5]) - (t[3] * t[4]);
    var s = (t[0] * t[5]) - (t[1] * t[4]);
    var inv = [t[3] / p, -t[1] / p, -t[2] / p, t[0] / p, q / p, -s / p];
    return inv;
  };
})();

// Generate an image of any resolution and size.

// You can use "FindCache(image)" to get the cache.
// image is the database image object with all the image meta data.

// How can you use the image data returned?
// canvasContext.putImageData(data, 0, 0);
// image = document.createElement('img');
// image.src = canvas.toDataURL('image/png');

// - cache: references the image source.
// - dimensions [xDim,yDim]: Final image dimensions in image pixels.
// - focalPoint [x,y,z]: the center of the image in slide coordinates.
// - rotation: Rotation around the focal point in degrees.
// - scale:  Image pixel size in slide coordinates. 1 is highest resolution.
// - returnCallback(data): Since non blocking ajax calls get the tiles necessary
//     to construct the image, we return the image data with a callback
//     function. The data returned is same as "ctx.getImageData(0,0,w,h);",
//     but we add data.Camera for conversion to the slide coordinate system.

(function () {
  'use strict';

  SA.DownloadImageData = function (data, filename) {
        // The only way I know if is to put in into a canvas.

        // Construct a view to render the image on the client.
    var width = data.width;
    var height = data.height;
    var viewport = [0, 0, width, height];

    var view = new SA.TileView();
    view.InitializeViewport(viewport, 1, true);
    view.Canvas.attr('width', width);
    view.Canvas.attr('height', height);
    view.Context2d.putImageData(data, 0, 0);

    view.Canvas[0].toBlob(function (blob) { saveAs(blob, filename); }, 'image/png');
  };

    // If file name is not null or "", this image is save to the client.
    // cache: The image/tile source.
    // dimensions: size of the image in pixels [xDim,yDim]
    // focalPoint: Center of the image in world / slide coordinates.
    // scale:  Size of a pixel in world coordinates.
    // roll: in radians?
    // fileName: name of file to download. (null, or "" means do not download).
    // returnCallback:  function to call (with data as argument) when done.
  SA.GetCutoutImage = function (cache, dimensions, focalPoint, scale, roll, fileName,
                                  returnCallback) {
        // Construct a view to render the image on the client.
    var width = dimensions[0];
    var height = dimensions[1];
    var viewport = [0, 0, width, height];

    var view = new SA.TileView();
    view.SetCache(cache);
    view.SetViewport(viewport);
    var newCam = view.Camera;
    newCam.SetWorldFocalPoint(focalPoint);
    newCam.SetWorldRoll(roll);
    newCam.SetHeight(height * scale);
    // TODO:  Hide matrix computation.  Make it automatic.
    newCam.ComputeMatrix();

    // Load only the tiles we need.
    var tiles = cache.ChooseTiles(newCam, 0, []);
    for (var i = 0; i < tiles.length; ++i) {
      SA.LoadQueueAddTile(tiles[i]);
    }

    SA.AddFinishedLoadingCallback(
            function () { SA.GetCutoutImage2(view, fileName, returnCallback); }
        );

    SA.LoadQueueUpdate();

    console.log('trigger ' + SA.LoadQueue.length + ' ' + SA.LoadingCount);
  };

  // This probably does not need to be exposed.
  SA.GetCutoutImage2 = function (view, fileName, returnCallback) {
    // All the tiles are loaded and waiting in the cache.
    view.DrawTiles();

    if (fileName && fileName !== '') {
      view.Canvas[0].toBlob(function (blob) { saveAs(blob, fileName); }, 'image/png');
    }

    if (returnCallback) {
      var data = view.GetImageData();
      returnCallback(data);
    }
  };

  // This works great!
  // Light weight viewer.
  // Attempt to make a div with multiple images.
  // image = database image object.
  // height = height in screen pixels of the returned div image.
  // request = (optional) bounds of cropped image in slide pixel units.
  //           if request is not defined, it defaults to the whole image bounds.
  // Events are funny,  The mouse position is relative to
  // the tiles.  click and bounds are callback functions to make
  // interaction simpler.
  var CutoutThumb = function (image, height, request) {
    if (!request) {
      request = image.bounds;
    }

    this.ImageData = image;
    this.Height = height;
    this.Width = Math.ceil(height * (request[1] - request[0]) / (request[3] - request[2]));
    this.Div = $('<div>')
            .css({'width': this.Width + 'px',
              'height': this.Height + 'px' })
            .addClass('sa-view-cutout-thumb-div');
        // Crop the request so we do not ask for tiles that do not exist.
    var levelReq;
    if (image.bounds) {
      levelReq = [
        Math.max(request[0], image.bounds[0]),
        Math.min(request[1], image.bounds[1]),
        Math.max(request[2], image.bounds[2]),
        Math.min(request[3], image.bounds[3])];
    } else {
      levelReq = [
        Math.max(request[0], 0),
        request[1],
        Math.max(request[2], 0),
        request[3]];
    }

    // Size of each tile.
    var tileDim = 256;
    if (image.tile_size) {
      tileDim = image.tile_size;
    }

    // Pick the level to use.
    this.Level = 0; // 0 = leaves
    while ((levelReq[3] - levelReq[2]) > this.Height &&
               this.Level < image.levels - 1) {
      this.Level += 1;
      levelReq[0] *= 0.5;
      levelReq[1] *= 0.5;
      levelReq[2] *= 0.5;
      levelReq[3] *= 0.5;
    }

    // Size of each tile.
    tileDim = 256;
    if (image.tile_size) {
      tileDim = image.tile_size;
    }

    this.ScreenPixelSpacing = (request[3] - request[2]) / this.Height;
    var imgSize = (tileDim << this.Level) / this.ScreenPixelSpacing;

    // grid of tiles to render.
    this.GridReq = [Math.floor(levelReq[0] / tileDim),
      Math.floor(levelReq[1] / tileDim),
      Math.floor(levelReq[2] / tileDim),
      Math.floor(levelReq[3] / tileDim)];

    // Compute the origin: the upper left corner of the upper left image.
    this.ScreenPixelOrigin = [this.GridReq[0] * (tileDim << this.Level),
      this.GridReq[2] * (tileDim << this.Level)];

    // loop over the tiles.
    for (var y = this.GridReq[2]; y <= this.GridReq[3]; ++y) {
      for (var x = this.GridReq[0]; x <= this.GridReq[1]; ++x) {
        // Compute the tile name.
        var tx = x;
        var ty = y;
        var tl = this.Level;
        var tileName = '';
        while (tl < image.levels - 1) {
          if ((tx & 1) === 0 && (ty & 1) === 0) { tileName = 'q' + tileName; }
          if ((tx & 1) === 1 && (ty & 1) === 0) { tileName = 'r' + tileName; }
          if ((tx & 1) === 0 && (ty & 1) === 1) { tileName = 't' + tileName; }
          if ((tx & 1) === 1 && (ty & 1) === 1) { tileName = 's' + tileName; }
          tx = (tx >> 1);
          ty = (ty >> 1);
          ++tl;
        }
        var left = (((x << this.Level) * tileDim) - request[0]) / this.ScreenPixelSpacing;
        var top = (((y << this.Level) * tileDim) - request[2]) / this.ScreenPixelSpacing;
        // img
        $('<img>')
          .appendTo(this.Div)
          .attr('width', imgSize)
          .attr('height', imgSize)
          .attr('src', '/tile?img=' + image.img + '&db=' + image.db + '&name=t' + tileName + '.jpg')
          .attr('alt', image.label)
          .css({'left': left.toString() + 'px', 'top': top.toString() + 'px'})
          .addClass('sa-view-cutout-thumb-tile');
      }
    }
  };

  CutoutThumb.prototype.AppendTo = function (parent) {
    this.Div.appendTo(parent);
    return this;
  };

    // Call back argument is this thumb object.
    // slideX, and slideY are set to mouse in slide coordinates.
  CutoutThumb.prototype.Click = function (callback) {
    var self = this;
    this.ClickCallback = callback;
    this.Div.click(function (e) {
            // It is a real pain to get the mouse position relative to the div.
      var x = e.pageX;
      var y = e.pageY;
            // Now get the location of this thumb on the screen.
      var offset = self.Div.offset();
      x -= offset.left;
      y -= offset.top;
      console.log('click: ' + x + ', ' + y);

      self.SlideX = (x * self.ScreenPixelSpacing) + self.ScreenPixelOrigin[0];
      self.SlideY = (y * self.ScreenPixelSpacing) + self.ScreenPixelOrigin[1];
      (self.ClickCallback)(self);
    });

    return this;
  };

    // todo:
    // - Bind delete key to stack creator.
    // - debug why some slides are not working.
    // - Get the average color of sections and get rid of outliers.
    //     (Maybe after delete)?
    // - First pass rigid alignment in stack creator.
    // - save the contour with the stack sections.
    // - move the transformations to load with the sections.
    // - Toggle slide / section view in stack viewer.
    // - Implement a way to reorder the sections.
    // - Implement a way to add a section in the slide stack viewer.
    // - Implement multiple pieces in a single section.
    // - Improve the gradient descent to be less sensitive to outliers
    //     (mismatched contours.)

  SA.CutoutThumb = CutoutThumb;
})();

// I want to avoid adding a Cache instance variable.
// I need to create the temporary object to hold pointers
// to both the cache and the tile which we are waiting for
// the image to load.  The callback only gives a single reference.

window.SA = window.SA || {};

(function () {
  'use strict';

  function LoadTileCallback (tile, cache) {
    this.Tile = tile;
    this.Cache = cache;
  }

  // Cache is now saved in tile ivar.
  LoadTileCallback.prototype.HandleLoadedImage = function () {
    var curtime = new Date().getTime();
    TILESTATS.add({
      'name': this.Tile.Name,
      'loadtime': curtime - this.Tile.starttime
    });
    SA.LoadQueueLoaded(this.Tile);
  };

  // If we cannot load a tile, we need to inform the cache so it can start
  // loading another tile.
  LoadTileCallback.prototype.HandleErrorImage = function () {
    console.log('LoadTile error ' + this.Tile.Name);

    SA.LoadQueueError(this.Tile);
  };

  function TileStats () {
    this.tiles = [];
  }

  TileStats.prototype.add = function (atile) {
    this.tiles.push(atile);
  };

  TileStats.prototype.report = function () {
    var total = 0;

    for (var i = 0; i < this.tiles.length; i++) {
      total = total + this.tiles[i].loadtime;
    }

    var report = {};
    report.count = this.tiles.length;
    report.average = total / this.tiles.length;
    report.total = total;
    console.log(report);
  };

  function GetLoadImageFunction (callback) {
    return function () { callback.HandleLoadedImage(); };
  }
  function GetErrorImageFunction (callback) {
    return function () { callback.HandleErrorImage(); };
  }

  var TILESTATS = new TileStats();

  // Three stages to loading a tile: (texture map is created when the tile is rendered.
  // 1: Create a tile object.
  // 2: Initialize the texture.
  // 3: onload is called indicating the image has been loaded.
  function Tile (x, y, z, level, name, cache) {
    // This should be implicit.
    // this is just for debugging
    // this.Id = x + (y<<level)
    //
    this.Cache = cache;
    this.X = x;
    this.Y = y;
    this.Z = z;
    this.Level = level;
    this.Children = [null, null, null, null];
    this.Parent = null;
    this.LoadState = 0;

    this.Name = name;
    this.Texture = null;
    this.TimeStamp = SA.TimeStamp;
    this.BranchTimeStamp = SA.TimeStamp;

    this.Matrix = mat4.create();
    mat4.identity(this.Matrix);
    this.Matrix[14] = z * cache.RootSpacing[2] - (0.1 * this.Level);

    // TODO: Warping depends on a global GL (which I am getting rid of) Fix
    // on demand :)
    // Default path is to shared geometry and move/scale it with the matrix.
    // The shared polygon is a square [(0,0),(1,0),(1,1),(0,1)]
    // The matrix transforms it into world coordinates.
    if (!cache.Warp) {
      // TODO: We should have a simple version of warp that creates this matrix for us.
      // Use shared buffers and place them with the matrix transformation.
      var xScale = cache.TileDimensions[0] * cache.RootSpacing[0] / (1 << this.Level);
      var yScale = cache.TileDimensions[1] * cache.RootSpacing[1] / (1 << this.Level);
      this.Matrix[0] = xScale;
      this.Matrix[5] = -yScale;
      this.Matrix[12] = this.X * xScale;
      this.Matrix[13] = (this.Y + 1) * yScale;
      this.Matrix[15] = 1.0;

      // Note:  I am breaking the warping to test multiple gl Contexts.
      // We do not have the view at this spot to build buffers.
      /*
        if (view && view.gl) {
        // These tiles share the same buffers.  Do not crop when there
        // is no warp. Actually, we should crop.
        this.VertexPositionBuffer = view.tileVertexPositionBuffer;
        this.VertexTextureCoordBuffer = view.tileVertexTextureCoordBuffer;
        this.CellBuffer = view.tileCellBuffer;
        }
      */

      // Trying to crop away the padding.
      // Compute bounds in tile pixel coordinate system.
      var bds = cache.Image.bounds.slice(0);
      var tileSpacingX = cache.RootSpacing[0] / (1 << this.Level);
      var tileSpacingY = cache.RootSpacing[1] / (1 << this.Level);
      var tileOriginX = this.X * cache.TileDimensions[0];
      var tileOriginY = this.Y * cache.TileDimensions[1];
      bds[0] = (bds[0] / tileSpacingX) - tileOriginX;
      bds[1] = (bds[1] / tileSpacingX) - tileOriginX;
      bds[2] = (bds[2] / tileSpacingY) - tileOriginY;
      bds[3] = (bds[3] / tileSpacingY) - tileOriginY;
      // Do we need to crop?
      if (bds[0] > 0 || bds[1] < cache.TileDimensions[0] ||
                bds[1] > 0 || bds[3] < cache.TileDimensions[1]) {
        // Yes we need to crop. Put it in
        // [minx,miny,sizex,sizey]
        // Useful for draw image.
        this.Crop = [];
        this.Crop[0] = Math.max(bds[0], 0);
        this.Crop[1] = Math.max(bds[2], 0);
        this.Crop[2] = (Math.min(bds[1], cache.TileDimensions[0])) - this.Crop[0];
        this.Crop[3] = (Math.min(bds[3], cache.TileDimensions[1])) - this.Crop[1];
      }
    } else {
      // Warp model.
      // In draw now.
      // this.CreateWarpBuffer(cache.Warp);
    }

    ++SA.NumberOfTiles;
  }

  // It is upto the caller to clean up references to this tile.
  Tile.prototype.destructor = function (gl) {
    --SA.NumberOfTiles;
    if (gl) {
      this.DeleteTexture(gl);
    }
    delete this.Matrix;
    this.Matrix = null;
    if (this.Image) {
      delete this.Image;
      this.Image = 0;
    }
    for (var i = 0; i < 4; ++i) {
      if (this.Children[i] !== null) {
        this.Children[i].delete(gl);
        this.Children[i] = null;
      }
    }
    delete this.Children;
    delete this.Parent;
    delete this.Cache;
  };

  // Youy have to call LoadQueueUpdate after adding tiles.
  // Add the first unloaded ancestor to the load queue.
  Tile.prototype.LoadQueueAdd = function () {
    // Record that the tile is used (for prioritizing loading and pruning).
    // Mark all lower res tiles so they will be loaded inthe correct order.
    var tmp = this;
    while (tmp && tmp.TimeStamp !== SA.TimeStamp) {
      tmp.TimeStamp = SA.TimeStamp;
      tmp = tmp.Parent;
    }

    if (this.LoadState !== 0) { // === 2
      // This tiles is already in the load queue or loaded.
      return;
    }

    // Now I want progressive loading so I will not add tiles to the queue if their parents are not completely loaded.
    // I could add all parent and children to the que at the same time, but I have seen children rendered before parents
    // (levels are skipped in progresive updata).  So, lets try this.
    // Now that I am prioritizing the queue on the tiles time stamp and level,  the previous issues should be resolved.
    if (this.Parent) {
      if (this.Parent.LoadState === 0) {
        // Not loaded and not in the queue.
        return this.Parent.LoadQueueAdd();
      } else if (this.Parent.LoadState === 1) {
        // Not loaded but in the queue
        return;
      }
    }

    // The tile's parent is loaded.  Add the tile to the load queue.
    SA.LoadQueueAddTile(this);
  };

  // This is for connectome stitching.  It uses texture mapping
  // to dynamically warp images.  It only works with webGL.
  Tile.prototype.CreateWarpBuffer = function (warp, gl) {
    // Compute the tile bounds.
    var tileDimensions = this.Cache.TileDimensions;
    var rootSpacing = this.Cache.RootSpacing;
    var p = (1 << this.Level);
    var size = [rootSpacing[0] * tileDimensions[0] / p, rootSpacing[1] * tileDimensions[1] / p];
    var bds = [size[0] * this.X, size[0] * (this.X + 1),
      size[1] * this.Y, size[1] * (this.Y + 1),
      this.Level, this.Level];

    // Tile geometry buffers.
    var vertexPositionData = [];
    var tCoordsData = [];
    var cellData = [];

    warp.CreateMeshFromBounds(bds, vertexPositionData, tCoordsData, cellData);

    this.VertexTextureCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.VertexTextureCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(tCoordsData), gl.STATIC_DRAW);
    this.VertexTextureCoordBuffer.itemSize = 2;
    this.VertexTextureCoordBuffer.numItems = tCoordsData.length / 2;

    this.VertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.VertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), gl.STATIC_DRAW);
    this.VertexPositionBuffer.itemSize = 3;
    this.VertexPositionBuffer.numItems = vertexPositionData.length / 3;

    this.CellBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.CellBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cellData), gl.STATIC_DRAW);
    this.CellBuffer.itemSize = 1;
    this.CellBuffer.numItems = cellData.length;
  };

  // This starts the loading of the tile.
  // Loading is asynchronous, so the tile will not
  // immediately change its state.
  Tile.prototype.StartLoad = function (cache) {
    if (this.LoadState >= 2) {
      return;
    }

    // Reusing the image caused problems.
    // if (this.Image === null) {
    this.Image = new Image();

    this.starttime = new Date().getTime();
    // Setup callbacks
    var callback = new LoadTileCallback(this, cache);
    this.Image.onload = GetLoadImageFunction(callback);
    this.Image.onerror = GetErrorImageFunction(callback);
    // This starts the loading.

    // SA.TileLoader === "http"
    this.LoadHttp(cache);
  };

  Tile.prototype.LoadHttp = function (cache) {
    // For http simply set the data url and wait
    if (cache.TileSource) {
      // This should eventually displace all other methods
      // of getting the tile source.
      this.Name = cache.TileSource.getTileUrl(this.Level,
                                              this.X, this.Y, this.Z);
      // Name is just for debugging.
      this.Image.src = this.Name;

      return;
    }

    // Legacy
    var imageSrc;
    if (cache.Image.type && cache.Image.type === 'stack') {
      imageSrc = cache.GetSource() + this.Name + '.png';
    } else {
      imageSrc = cache.GetSource() + this.Name + '.jpg';
    }

    if (cache.UseIIP) {
      var level = this.Level + 2;
      var xDim = Math.ceil(cache.Image.dimensions[0] / (cache.Image.TileWidth << (cache.Image.levels - this.Level - 1)));
      var idx = this.Y * xDim + this.X;
      imageSrc = 'http://iip.slide-atlas.org/iipsrv.fcgi?FIF=' + cache.Image.filename + '&jtl=' + level + ',' + idx;
    }

    this.Image.src = imageSrc;
  };

  // TODO: Put program as iVar of view.
  Tile.prototype.Draw = function (program, view) {
    // Load state 0 is: Not loaded and not scheduled to be loaded yet.
    // Load state 1 is: not loaded but in the load queue.
    if (this.LoadState !== 3) {
      // This should never happen.
      return;
    }

    /* sacrifice clipped/warped tiles so tiles can be shared between views.
    // Initialization has to be here because we do not have the view in
    // the constructor.  NOTE: tiles cannot be shared between views
    if (view.gl && ! this.VertexPositionBuffer) {
    if ( ! cache.Warp) {
    this.VertexPositionBuffer = view.tileVertexPositionBuffer;
    this.VertexTextureCoordBuffer = view.tileVertexTextureCoordBuffer;
    this.CellBuffer = view.tileCellBuffer;
    } else {
    // Warp model.
    this.CreateWarpBuffer(cache.Warp, view.gl);
    }
    }
    */

    if (view.gl) {
      if (this.Texture === null) {
        this.CreateTexture(view.gl);
      }
      // These are the same for every tile.
      // Vertex points (shifted by tiles matrix)
      view.gl.bindBuffer(view.gl.ARRAY_BUFFER, view.tileVertexPositionBuffer);
      // Needed for outline ??? For some reason, DrawOutline did not work
      // without this call first.
      view.gl.vertexAttribPointer(view.ShaderProgram.vertexPositionAttribute,
                                        view.tileVertexPositionBuffer.itemSize,
                                        view.gl.FLOAT, false, 0, 0);     // Texture coordinates
      view.gl.bindBuffer(view.gl.ARRAY_BUFFER, view.tileVertexTextureCoordBuffer);
      view.gl.vertexAttribPointer(view.ShaderProgram.textureCoordAttribute,
                                        view.tileVertexTextureCoordBuffer.itemSize,
                                        view.gl.FLOAT, false, 0, 0);
      // Cell Connectivity
      view.gl.bindBuffer(view.gl.ELEMENT_ARRAY_BUFFER, view.tileCellBuffer);

      // Texture
      view.gl.activeTexture(view.gl.TEXTURE0);
      view.gl.bindTexture(view.gl.TEXTURE_2D, this.Texture);

      view.gl.uniform1i(program.samplerUniform, 0);
      // Matrix that tranforms the vertex p
      view.gl.uniformMatrix4fv(program.mvMatrixUniform, false, this.Matrix);

      view.gl.drawElements(view.gl.TRIANGLES, view.tileCellBuffer.numItems, view.gl.UNSIGNED_SHORT, 0);
    } else {
      // It is harder to flip the y axis in 2d canvases because the image turns upside down too.
      // WebGL handles this by flipping the texture coordinates.  Here we have to
      // translate the tiles to the correct location.
      view.Context2d.save(); // Save the state of the transform so we can restore for the next tile.

      // Map tile to image.
      // Context is in image coordinate system
      view.Context2d.transform(this.Matrix[0], this.Matrix[1],
                               this.Matrix[4], this.Matrix[5],
                               this.Matrix[12], this.Matrix[13]);

      // Flip the tile upside down, but leave it in the same place
      view.Context2d.transform(1.0, 0.0, 0.0, -1.0, 0.0, 1.0);

      // map pixels to Tile

      var tileWidth = this.Cache.Image.TileWidth;
      // This should not be necessary, quick hack around a bug in __init__.py
      if (tileWidth === undefined) {
        tileWidth = 256;
      }
      var tileHeight = this.Cache.Image.TileHeight;
      if (tileHeight === undefined) {
        tileHeight = 256;
      }
      view.Context2d.transform(1.0 / tileWidth, 0.0, 0.0, 1.0 / tileHeight, 0.0, 0.0);
      if (this.Crop) {
        view.Context2d.drawImage(this.Image, this.Crop[0], this.Crop[1], this.Crop[2], this.Crop[3],
                                         this.Crop[0], this.Crop[1], this.Crop[2], this.Crop[3]);
      } else {
        view.Context2d.drawImage(this.Image, 0, 0);
      }
      if (SA.WaterMark) {
        var angle = (this.X + 1) * (this.Y + 1) * 4.0;
        view.Context2d.translate(128, 128);
        view.Context2d.rotate(angle);
        view.Context2d.translate(-128, -128);
        view.Context2d.fillStyle = 'rgba(0, 0, 0, 0.016)';
        view.Context2d.strokeStyle = 'rgba(50,50,50, 0.05)';
        view.Context2d.font = '30px Comic Sans MS';
        // view.Context2d.strokeText("SlideAtlas",10,100);
        view.Context2d.fillText('SlideAtlas', 10, 10);
      }

      //  Transform to map (0->1, 0->1)
      view.Context2d.restore();
    }
  };

  Tile.prototype.CreateTexture = function (gl) {
    if (!gl) {
      alert('Textures need a gl instance');
      return;
    }
    if (this.Texture !== null) { return; }

    ++SA.NumberOfTextures; // To determine when to prune textures.
    this.Texture = gl.createTexture();
    var texture = this.Texture;
    // alert(tile);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.Image);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.bindTexture(gl.TEXTURE_2D, null);
  };

  Tile.prototype.DeleteTexture = function (gl) {
    if (!this.Texture) {
      return;
    }
    if (!gl) {
      alert('Textures need a gl instance');
      return;
    }
    --SA.NumberOfTextures; // To determine when to prune textures.
    gl.deleteTexture(this.Texture);
    this.Texture = null;
  };

  SA.Tile = Tile;
})();

(function () {
  'use strict';

  // The levels are causing a problem for very large images.
  // They are preallocated and take up too much space.
  // TODO:
  // 1: (finished) No access to level except through API.
  // 2: (finished) Allocate on demand
  // 3: Make them into a fat tree (64x64 children).
  //    Two levels should hold us over for a long time.

  // I am adding a levels with grids to index tiles in addition
  // to the tree.  Eventually I want to get rid fo the tree.
  // I am trying to get rid of the roots now.

// ==============================================================================

  var CacheLevel = function (xGridDim, yGridDim) {
    this.GridDims = [xGridDim, yGridDim];
  };

  // No bounds checking.
  CacheLevel.prototype.SetTile = function (tile) {
    if (this.Tiles === undefined) {
      this.Tiles = new Array(this.GridDims[0] * this.GridDims[1]);
    }

    this.Tiles[tile.X + (tile.Y * this.GridDims[0])] = tile;
    return tile;
  };

  CacheLevel.prototype.GetTile = function (x, y) {
    if (this.Tiles === undefined) {
      return null;
    }
    var idx = x + (y * this.GridDims[0]);
    var tile = this.Tiles[idx];
    if (tile && !tile.Matrix) {
      this.Tiles[idx] = undefined;
      return;
    }
    return tile;
  };

  // We only need an iterator for pruning.  BUild it right into the Cache Level.
  CacheLevel.prototype.StartIteration = function () {
    if (this.Tiles === undefined || this.Tiles.length === 0) {
      this.IteratorIndex = undefined;
    } else {
      this.IteratorIndex = 0;
    }
  };

  CacheLevel.prototype.Next = function () {
    if (this.IteratorIndex === undefined) {
      this.IteratorIndex = undefined;
      return null;
    }

    var idx = this.IteratorIndex;
    while (this.Tiles[idx] === null) {
      idx += 1;
      if (idx >= this.Tiles.length) {
        this.IteratorIndex = undefined;
        return null;
      }
    }

    return this.Tiles[idx];
  };

// ==============================================================================

  // A stripped down source object.
  // A source object must have a getTileUrl method.
  // It can have any instance variables it needs to
  // compute the URL.
  SA.SlideAtlasSource = function () {
    this.Prefix = undefined;

    // Higher levels are higher resolution.
    // x, y, slide are integer indexes of tiles in the grid.
    this.getTileUrl = function (level, x, y, z) {
      var name = this.Prefix + 't';
      while (level > 0) {
        --level;
        var cx = (x >> level) & 1;
        var cy = (y >> level) & 1;
        var childIdx = cx + (2 * cy);
        if (childIdx === 0) { name += 'q'; }
        if (childIdx === 1) { name += 'r'; }
        if (childIdx === 2) { name += 't'; }
        if (childIdx === 3) { name += 's'; }
      }
      name = name + '.jpg';
      return name;
    };
  };

  SA.GigamacroSource = function () {
    this.Prefix = 'http://www.gigamacro.com/content/AMNH/unit_box_test2_05-01-2015/zoomify/';
    this.GridSizeDebug = [[1, 1], [2, 2], [4, 3], [7, 5], [14, 9], [28, 17], [56, 34]];

    this.setDimensions = function (xDim, yDim) {
      this.Dimensions = [xDim, yDim];
      this.GridSize = [];
      this.Levels = 0;
      while (true) {
        var gridLevelDim = [Math.ceil(xDim / 256), Math.ceil(yDim / 256)];
        this.GridSize.splice(0, 0, gridLevelDim);
        this.Levels += 1;
        if (gridLevelDim[0] === 1 && gridLevelDim[1] === 1) {
          return;
        }
        xDim = xDim / 2;
        yDim = yDim / 2;
      }
    };

    // Higher levels are higher resolution.
    // x, y, slide are integer indexes of tiles in the grid.
    this.getTileUrl = function (level, x, y, z) {
      var g = this.GridSize[level];
      if (x < 0 || x >= g[0] || y < 0 || y >= g[1]) {
        return '';
      }
      var num = y * g[0] + x;
      for (var i = 0; i < level; ++i) {
        g = this.GridSize[i];
        num += g[0] * g[1];
      }
      var tileGroup = Math.floor(num / 256);
      var name = this.Prefix + 'TileGroup' + tileGroup + '/' + level + '-' + x + '-' + y + '.jpg';
      return name;
    };
  };

  // Our subdivision of leaves is arbitrary.
  SA.IIIFSource = function () {
    this.Prefix = 'http://ids.lib.harvard.edu/ids/view/Converter?id=834753&c=jpgnocap';
    alert('Hard coded tile size');
    this.TileWidth = this.TileHeight = 256;

    this.setDimensions = function (xDim, yDim) {
      this.Dimensions = [xDim, yDim];
      this.GridSize = [];
      this.Levels = 0;
      while (true) {
        var gridLevelDim = [Math.ceil(xDim / 256), Math.ceil(yDim / 256)];
        this.Levels += 1;
        if (gridLevelDim[0] === 1 && gridLevelDim[1] === 1) {
          return;
        }
        xDim = xDim / 2;
        yDim = yDim / 2;
      }
    };

    // Higher levels are higher resolution. (0 is the root).
    // x, y, slide are integer indexes of tiles in the grid.
    this.getTileUrl = function (level, x, y, z) {
      // compute the dimensions of this resolution.
      var x0 = x * 256;
      var y0 = y * 256;
      var x1 = x0 + 256;
      var y1 = y0 + 256;
      // crop the tile
      var res = this.Levels - level - 1;
      var dx = this.Dimensions[0] >> res;
      var dy = this.Dimensions[1] >> res;
      if (x1 > dx) { x1 = dx; }
      if (y1 > dy) { y1 = dy; }
      dx = x1 - x0;
      dy = y1 - y0;
      // Compute the scale.
      res = 1.0 / (1 << res);

      var name = this.Prefix + '&s=' + res + '&r=0&x=' + x0 + '&y=' + y0 + '&w=' + dx + '&h=' + dy;
      return name;
    };
  };

  SA.DanielSource = function () {
    this.Prefix = 'http://dragon.krash.net:2009/data/1';
    this.MinLevel = 0;
    this.MaxLevel = 7;

    // Higher levels are higher resolution.
    // x, y, slide are integer indexes of tiles in the grid.
    this.getTileUrl = function (level, x, y, z) {
      if (z < this.MinLevel) { return ''; }
      if (z > this.MaxLevel) { return ''; }
      var name = this.Prefix + level + '-' + x + '-' + y;
      return name;
    };
  };

// ==============================================================================
  SA.FindCache = function (image) {
    // Look through existing caches and reuse one if possible
    for (var i = 0; i < SA.Caches.length; ++i) {
      if (SA.Caches[i].Image._id === image._id) {
        return SA.Caches[i];
      }
    }
    var cache = new SA.Cache();
    cache.SetImageData(image);

    return cache;
  };

// ==============================================================================
  function Cache () {
    //  this.UseIIP = Boolean(image.filename !== undefined && image.filename.split(".")[1] === 'ptif');
    this.UseIIP = false;
    this.Levels = [];

    // Keep a global list for pruning tiles.
    SA.Caches.push(this);
    this.NumberOfSections = 1;
  }

  Cache.prototype.destructor = function () {
  };

  Cache.prototype.GetImageData = function () {
    return this.Image;
  };

  // This is specific for slideAtlas images.
  Cache.prototype.SetImageData = function (image) {
    if (!image.TileWidth) {
      image.TileWidth = 256;
    }
    if (!image.TileHeight) {
      image.TileHeight = image.TileWidth;
    }

    this.Image = image;

    if (image.copyright === undefined) {
      image.copyright = 'Copyright 2019. All Rights Reserved.';
    }

    this.Levels = new Array(image.levels);
    for (var i = 0; i < image.levels; ++i) {
      var level = image.levels - 1 - i;
      this.Levels[i] = new CacheLevel(
            Math.ceil(image.dimensions[0] / (image.TileWidth << level)),
            Math.ceil(image.dimensions[1] / (image.TileHeight << level)));
    }

    if (!this.TileSource) {
      // TODO:  This should not be here.
      // Source should be initialized someplace else.
      // Other sources have to overwrite this default.
      this.TileSource = new SA.SlideAtlasSource();
      this.TileSource.Prefix = '/tile?img=' + image._id + '&db=' + image.database + '&name=';
    }
    this.Warp = null;
    this.RootSpacing = [1 << (image.levels - 1), 1 << (image.levels - 1), 10.0];

    if (image.type && image.type === 'stack') {
      this.NumberOfSections = image.dimensions[2];
      this.TileDimensions = [image.dimensions[0], image.dimensions[1]];
      var qTile;
      for (var slice = 1; slice <= this.NumberOfSections; ++slice) {
        qTile = this.GetTile(slice, 0, 0);
        qTile.LoadQueueAdd();
      }
      SA.LoadQueueUpdate();
    } else {
      this.TileDimensions = [image.TileWidth, image.TileHeight];
      this.NumberOfSections = 1;
    }
  };

  Cache.prototype.SetTileSource = function (source) {
    var w = source.width;
    var h = source.height;
    this.TileSource = source;
    // Make an id for the image so it can be reused.
    var image = {levels: source.maxLevel + 1,
      dimensions: [w, h],
      bounds: [0, w - 1, 0, h - 1]};
    if (source.bounds) {
      image.bounds = source.bounds;
    }
    if (source.TileWidth) {
      image.TileWidth = source.TileWidth;
    }
    if (source.TileHeight) {
      image.TileHeight = source.TileHeight;
    }

    if (source.filename) {
      image.filename = source.filename;
      image.label = source.filename;
    }
    this.SetImageData(image);
  };

  Cache.prototype.GetLeafSpacing = function () {
    return this.RootSpacing[0] / (1 << (this.Image.levels - 1));
  };

  Cache.prototype.GetBounds = function () {
    if (this.Image && this.Image.bounds) {
      return this.Image.bounds;
    }
    return [0, 10000, 0, 10000];
  };

  // This method converts a point in image coordinates to a point in world coordinates.
  Cache.prototype.ImageToWorld = function (imagePt) {
    if (this.Warp) {
      return this.Warp.ImageToWorld(imagePt);
    }
    // Just shift by the origin.
    // Assume spacing is 1.
    // This should be a simple matrix version of warp.
    return [imagePt[0] + this.Origin[0], imagePt[1] + this.Origin[1]];
  };

  // This method converts a point in world coordinates to a point in cache-image coordinates.
  Cache.prototype.WorldToImage = function (worldPt) {
    if (this.Warp) {
      return this.Warp.WorldToImage(worldPt);
    }
    // Just shift by the origin.
    // Assume spacing is 1.
    // TODO:
    // This should be a simple matrix version of warp.
    return [worldPt[0] - this.Origin[0], worldPt[1] - this.Origin[1]];
  };

  Cache.prototype.GetSource = function () {
    return this.Source;
  };

  Cache.prototype.LoadRoots = function (callback) {
    var qTile;
    if (this.Image.dimensions === undefined) {
      return;
    }
    // Callback handled by the loaded which deletes the callback after it
    // is executed.
    this.LoadTileCallback = callback;
    if (this.Image.dimensions.length < 3) {
      qTile = this.GetTile(0, 0, 0);
      qTile.LoadQueueAdd();
    } else {
      for (var slice = 1; slice <= this.Image.dimensions[2]; ++slice) {
        qTile = this.GetTile(slice, 0, 0);
        qTile.LoadQueueAdd();
      }
    }
    SA.LoadQueueUpdate();
  };

  // ------ I think this method really belongs in the view! -----------
  // This could get expensive because it is called so often.
  // Eventually I want a quick coverage test to exit early.
  // iPad flag includes low resolution ancestors to get rid of white lines between tiles.
  // Tiles is actually the return value.  It is not used for anything else.
  Cache.prototype.ChooseTiles = function (camera, slice, tiles) {
    // I am prioritizing tiles in the queue by time stamp.
    // Loader sets the the tiles time stamp.
    // Time stamp only progresses after a whole render.
    SA.AdvanceTimeStamp();

    // I am putting this here to avoid deleting tiles
    // in the rendering list.
    SA.Prune();

    // Pick a level to display.
    // var fast = document.getElementById("fast").checked;
    // level 0 is the root.  This chooses too high a level (resolution).
    // WHen I fixed it, the snap between levels was too noticable.
    // THis must be a problem with creation of the pyramid!!!!!
    var canvasHeight = camera.GetViewportHeight();
    var tmp = this.TileDimensions[1] * this.RootSpacing[1] / camera.GetHeight();
    // if (fast) {
    //  tmp = tmp * 0.5;
    // }
    tmp = tmp * canvasHeight / this.TileDimensions[1];
    var level = 0;
    while (tmp > 1.0) {
      ++level;
      tmp = tmp * 0.5;
    }
    if (level >= this.Image.levels) {
      level = this.Image.levels - 1;
    }
    // Alternative code
    // var level = this.Image.levels - 1; // The highest resolution / leaves
    // var canvasHeight = camera.ViewportHeight;
    // // At the current level(0), each screen pixel covers this many image
    // // pixels. If this is above 1, then we would render too many pixels.
    // var pixelRatio = camera.Height / camera.ViewportHeight;
    // while (pixelRatio > 1.1 && level > 0) { // a little slop.
    //    pixelRatio = pixelRatio * 0.5;
    //    level = level - 1;
    // }

    // TODO: Have camera return world bounds and compute this stuff internally.
    var bounds = camera.GetImageBounds();

    // Some logic for progressive rendering is in the loader:
    // Do not load a tile if its parent is not loaded.

    var tile;
    var tileIds;
    tiles = [];
    // TODO: Make a "GetVisibleTiles" method.
    // Render all tiles from low res to high.
    // Although this is extra work, it covers up cracks.
    // Rendering just level 0 (root) should be enough, but that
    // messed up progressive rendering logic in section.js.
    // Just do this until I unify the progressive rendering
    // Probably in this method. (check is loaded).
    for (var i = level; i >= 0; --i) {
      tileIds = this.GetVisibleTileIds(i, bounds);
      for (var j = 0; j < tileIds.length; ++j) {
        tile = this.GetTile(slice, i, tileIds[j]);
        // If the tile is loaded or loading,
        // this does nothing.
        if (tile) {
          tile.LoadQueueAdd();
          tiles.push(tile);
        }
      }
    }

    SA.LoadQueueUpdate();

    return tiles;
  };

  // Get ids of all visible tiles (including ones that have not been
  // loaded yet.)
  Cache.prototype.GetVisibleTileIds = function (level, bounds) {
    // Intersect the view bounds with the image bounds.
    // The ptif reader gives wrong times when out of bounds.
    if (this.Image.bounds) {
      bounds[0] = Math.max(bounds[0], this.Image.bounds[0]);
      bounds[1] = Math.min(bounds[1], this.Image.bounds[1]);
      bounds[2] = Math.max(bounds[2], this.Image.bounds[2]);
      bounds[3] = Math.min(bounds[3], this.Image.bounds[3]);
    }

    var idList = [];
    var dim = 1 << level;
    var bds = [];
    bds[0] = Math.floor(bounds[0] * dim / (this.TileDimensions[0] * this.RootSpacing[0]));
    bds[1] = Math.ceil(bounds[1] * dim / (this.TileDimensions[0] * this.RootSpacing[0])) - 1.0;
    bds[2] = Math.floor(bounds[2] * dim / (this.TileDimensions[1] * this.RootSpacing[1]));
    bds[3] = Math.ceil(bounds[3] * dim / (this.TileDimensions[1] * this.RootSpacing[1])) - 1.0;
    // I am allowing level 0 to have a grid of tiles (not just one root).
    // This will not work for the trsq tile names, but is used for grid
    // indexing of tiles that every other server uses.
    // This will only work NOW for the y axis (the case I am trying to
    // solve).  To work for the z axis, tile indexing has to change.
    // Javascript currently can handle 16 levels safely (32 bits) with the
    // current indexing scheme.

    /*
    var id;
    for (var y = bds[2]; y <= bds[3]; ++y) {
      for (var x = bds[0]; x <= bds[1]; ++x) {
        id = x | (y << level);
        idList.push(id);
      }
    }
    */
    // Experiment: Lets try sorting from middle to outside to simulate
    // fovia sorted request priority.
    // Reverse order of priority.
    var cx = Math.floor((bds[0] + bds[1]) * 0.5);
    var cy = Math.floor((bds[2] + bds[3]) * 0.5);
    var radius = Math.max((cx - bds[0]), (bds[1] - cx), (cy - bds[2]), (bds[3] - cy));
    var x, y, i;
    while (radius > 0) {
      for (i = -radius; i < radius; ++i) {
        x = cx - radius;
        y = cy - i;
        if (x >= bds[0] && x <= bds[1] && y >= bds[2] && y <= bds[3]) {
          idList.push(x | (y << level));
        }
        x = cx + i;
        y = cy - radius;
        if (x >= bds[0] && x <= bds[1] && y >= bds[2] && y <= bds[3]) {
          idList.push(x | (y << level));
        }
        x = cx + radius;
        y = cy + i;
        if (x >= bds[0] && x <= bds[1] && y >= bds[2] && y <= bds[3]) {
          idList.push(x | (y << level));
        }
        x = cx - i;
        y = cy + radius;
        if (x >= bds[0] && x <= bds[1] && y >= bds[2] && y <= bds[3]) {
          idList.push(x | (y << level));
        }
      }
      radius -= 1;
    }
    // Add the special case center.
    idList.push(cx | (cy << level));
    return idList;
  };

// I do not think this ever gets called.  No class calls this method.
  Cache.prototype.GetTileIdContainingPoint = function (level, wPt) {
    var dim = 1 << level;
    var xIdx = Math.floor(wPt[0] * dim);
    var yIdx = Math.floor(wPt[1] * dim);
    if (xIdx < 0) { xIdx = 0; }
    if (xIdx >= dim) { xIdx = dim - 1; }
    if (yIdx < 0) { yIdx = 0; }
    if (yIdx >= dim) { yIdx = dim - 1; }
    var id = xIdx | (yIdx << level);
    return id;
  };

// Set parent to be minimum of children.
  Cache.prototype.UpdateBranchTimeStamp = function (tile) {
    var min = SA.GetCurrentTime();
    if (tile.Children[0] !== null) {
      if (tile.Children[0].BranchTimeStamp < min) {
        min = tile.Children[0].BranchTimeStamp;
      }
    }
    if (tile.Children[1] !== null) {
      if (tile.Children[1].BranchTimeStamp < min) {
        min = tile.Children[1].BranchTimeStamp;
      }
    }
    if (tile.Children[2] !== null) {
      if (tile.Children[2].BranchTimeStamp < min) {
        min = tile.Children[2].BranchTimeStamp;
      }
    }
    if (tile.Children[3] !== null) {
      if (tile.Children[3].BranchTimeStamp < min) {
        min = tile.Children[3].BranchTimeStamp;
      }
    }
    if (min === SA.GetCurrentTime()) { // no children
      min = tile.TimeStamp;
    }
    if (min !== tile.BranchTimeStamp) {
      tile.BranchTimeStamp = min;
      if (tile.Parent !== null) {
        this.UpdateBranchTimeStamp(tile.Parent);
      }
    }
  };

  Cache.prototype.GetTile = function (slice, level, id) {
    // Separate x and y.
    var dim = 1 << level;
    var x = id & (dim - 1);
    var y = id >> level;

    return this.RecursiveGetTile(level, x, y, slice);
  };

  Cache.prototype.RecursiveGetTile = function (level, x, y, z) {
    if (!this.Levels[level]) { return null; }
    var tile = this.Levels[level].GetTile(x, y);
    if (tile) {
      return tile;
    }
    tile = new SA.Tile(x, y, z, level,
                       this.TileSource.getTileUrl(level, x, y, z),
                       this);
    this.Levels[level].SetTile(tile);
    if (level > 0) {
      var parent = this.RecursiveGetTile(level - 1, x >> 1, y >> 1, z);
      // I do not know if this is still valid.
      // This is to fix a bug. Root.BranchTime larger
      // than all children BranchTimeStamps.  When
      // long branch is added, node never gets updated.
      if (parent.Children[0] === null && parent.Children[1] === null &&
            parent.Children[2] === null && parent.Children[3] === null) {
        parent.BranchTimeStamp = SA.GetCurrentTime();
      }
      var cx = x & 1;
      var cy = y & 1;
      var childIdx = cx + (2 * cy);
      parent.Children[childIdx] = tile;
      tile.Parent = parent;
    }
    return tile;
  };

  // Find the oldest tile, remove it from the tree and return it to be recycled.
  // This also prunes texture maps.
  // SA.PruneTimeTiles and SA.PruneTimeTextures are compared with used time of tile.
  Cache.prototype.PruneTiles = function () {
    this.Levels[0].StartIteration();
    var node = this.Levels[0].Next();
    if (node.LoadState === 3) {
      if (node.BranchTimeStamp < SA.PruneTimeTiles || node.BranchTimeStamp < SA.PruneTimeTextures) {
        var count = this.RecursivePruneTiles(node);
        if (count > 0) {
          console.log('prune ' + count + ' from ' + this.Image.label);
        }
      }
    }
  };

  Cache.prototype.RecursivePruneTiles = function (node) {
    var leaf = true;
    var count = 0;

    for (var i = 0; i < 4; ++i) {
      var child = node.Children[i];
      if (child !== null) {
        leaf = false;
        if (child.BranchTimeStamp < SA.PruneTimeTiles ||
          child.BranchTimeStamp < SA.PruneTimeTextures) {
          count += this.RecursivePruneTiles(child);
        }
      }
    }
    if (leaf && node.Parent !== null) { // Roots have null parents.  Do not prune roots.
      if (node.BranchTimeStamp < SA.PruneTimeTextures) {
        // when using webgl, texture memery was a more limited resource.
        node.DeleteTexture();
      }
      if (node.BranchTimeStamp < SA.PruneTimeTiles) {
        if (node.LoadState === 1) {
          SA.LoadQueueRemove(node);
        }
        var parent = node.Parent;
        // nodes will always have parents because we do not steal roots.
        if (parent.Children[0] === node) {
          parent.Children[0] = null;
        } else if (parent.Children[1] === node) {
          parent.Children[1] = null;
        } else if (parent.Children[2] === node) {
          parent.Children[2] = null;
        } else if (parent.Children[3] === node) {
          parent.Children[3] = null;
        }
        node.Parent = null;
        this.UpdateBranchTimeStamp(parent);
        node.destructor();
        count += 1;
      }
    }
    return count;
  };

  SA.Cache = Cache;
})();

// ==============================================================================
// Section Object
// Leftover from Connectome.
// Sections were a montage of multiple images (transformed and cropped)

// I have just started implementing an API for a section transformation.
// Use the same API as the canvas transform,
// TODO: Generatlize to mesh based transformation.
//   A transformation for each cache.
//   (but not stored in the cache.  Sections can share a cache.)

(function () {
  'use strict';

  var SLICE = 0;

  function Section () {
    // Warping to align this section with previous / next.
    // This is only a matrix transformation.
    this.Matrix = mat4.create();
    mat4.identity(this.Matrix);
    // The list of caches is really just a list of images in the montage.
    this.Caches = [];
    // For debugging stitching.
    this.Markers = [];
    this.Transform = [1, 0, 0, 1, 0, 0];
  }

  Section.prototype.GetNumberOfCaches = function () {
    return this.Caches.length;
  };

  Section.prototype.GetCache = function (idx) {
    if (idx < 0 || idx >= this.Caches.length) {
      return undefined;
    }
    return this.Caches[idx];
  };

  Section.prototype.SetCache = function (cache) {
    if (cache === undefined) {
      this.Caches = [];
    } else {
      this.Caches = [cache];
    }
    this.Bounds = undefined;
  };

  // Set the tranform for cache 0.  Same api as html canvas transform.
  // This tranform is applied before the camera.  It converts world to image
  // coordinates.
  Section.prototype.SetTransform = function (tran) {
    this.Transform = tran.slice(0);
  };

  Section.prototype.AddCache = function (cache) {
    if (cache) {
      this.Caches.push(cache);
      this.Bounds = undefined;
    }
  };

  // For limiting interaction.
  Section.prototype.GetBounds = function () {
    if (this.Bounds === undefined) {
      this.ComputeBounds();
    }
    return this.Bounds;
  };

  // For limiting interaction.
  Section.prototype.ComputeBounds = function () {
    this.Bounds = [0, 10000, 0, 10000];

    for (var cIdx = 0; cIdx < this.Caches.length; ++cIdx) {
      var cache = this.Caches[cIdx];
      var bds = cache.GetBounds();
      if (cIdx === 0) {
        this.Bounds = [bds[0], bds[1], bds[2], bds[3]];
      } else {
        if (bds[0] < this.Bounds[0]) {
          this.Bounds[0] = bds[0];
        }
        if (bds[1] > this.Bounds[1]) {
          this.Bounds[1] = bds[1];
        }
        if (bds[2] < this.Bounds[2]) {
          this.Bounds[2] = bds[2];
        }
        if (bds[3] < this.Bounds[3]) {
          this.Bounds[3] = bds[3];
        }
      }
    }
  };

  // Size of a pixel at the highest resolution.
  Section.prototype.GetLeafSpacing = function () {
    if (!this.LeafSpacing) {
      for (var cIdx = 0; cIdx < this.Caches.length; ++cIdx) {
        var cache = this.Caches[cIdx];
        var spacing = cache.GetLeafSpacing();
        if (!this.LeafSpacing || spacing < this.LeafSpacing) {
          this.LeafSpacing = spacing;
        }
      }
    }
    return this.LeafSpacing;
  };

  Section.prototype.LoadRoots = function () {
    for (var cIdx = 0; cIdx < this.Caches.length; ++cIdx) {
      var cache = this.Caches[cIdx];
      if (cache) {
        cache.LoadRoots();
      }
    }
  };

  Section.prototype.FindImage = function (imageCollectionName) {
    for (var i = 0; i < this.Caches.length; ++i) {
      var cache = this.Caches[i];
      if (cache.Image._id === imageCollectionName) {
        return cache;
      }
    }
    return null;
  };

  // I do not like passing in the whole view.
  // Could we get away with just passing the camera?
  // No, we need the viewport too.
  // Could the viewport be part of the camera?
  // Returns true if all the tiles to render were available.
  // False implies that the user shoudl render again.
  Section.prototype.Draw = function (view) {
    var finishedRendering = true;
    view.Camera.SetWorldToImageTransform(this.Transform);
    // var m = view.Camera.GetImageMatrix();

    if (view.gl) {
      // Draw tiles.
      var program = view.ShaderProgram;
      var gl = view.gl;
      gl.viewport(view.Viewport[0], view.Viewport[1],
                        view.Viewport[2], view.Viewport[3]);
      // program not defined ... gl.uniformMatrix4fv(program.pMatrixUniform, false, m);
    } else {
      // The camera maps the world coordinate system to (-1->1, -1->1).
      var t = view.Camera.GetImageToViewerTransform();
      view.Context2d.setTransform(t[0], t[1], t[2], t[3], t[4], t[5]);
    }

    for (var i = 0; i < this.Caches.length; ++i) {
      var cache = this.Caches[i];
      // Select the tiles to render first.
      this.Tiles = cache.ChooseTiles(view.Camera, SLICE, view.Tiles);
      // Trying to get rid of flashing by putting the clear closer to the draw.
      if (this.Tiles.length > 1 && view.ClearPending) {
        view.Clear();
        view.ClearPending = undefined;
      }

      // For the 2d viewer, the order the tiles are drawn is very important.
      // Low-resolution tiles have to be drawn first.  Make a new sorted array.
      // The problem is that unloaded tiles fall back to rendering parents.
      // Make  copy (although we could just destroy the "Tiles" array which is not really used again).
      var tiles = this.Tiles.slice(0);
      var loadedTiles = [];
      var j = 0;
      while (j < tiles.length) { // We add tiles in the loop so we need a while.
        var tile = tiles[j];
        if (tile.LoadState === 3) {
          loadedTiles.push(tile);
        } else {
          if (tiles[j].LoadState < 3) {
            // Keep rendering until we have all the tiles.
            finishedRendering = false;
          }
          // if (tile.Parent) { // Queue up the parent.
          //   Note: Parents might be added multiple times by different siblings.
          //   Ok, lets render the whole tree (low res first) to
          //   cover cracks.  This is done in choose tiles.
          //   This is not needed for prgressive rendering then.
          //   tiles.push(tile.Parent);
          // }
        }
        ++j;
      }

      // Reverse order to render low res tiles first.
      for (j = loadedTiles.length - 1; j >= 0; --j) {
        loadedTiles[j].Draw(program, view);
      }
    }
    return finishedRendering;
  };

  Section.prototype.LoadTilesInView = function (view) {
    for (var i = 0; i < this.Caches.length; ++i) {
      var cache = this.Caches[i];
      // Select the tiles to render first.
      // This also adds the tiles returned to the loading queue.
      this.Tiles = cache.ChooseTiles(view.Camera, SLICE, view.Tiles);
    }
  };

  // The above will load the first ancestor not loaded and will stop.
  // I need to pre load the actual high res tiles for connectome.
  Section.prototype.LoadTilesInView2 = function (view) {
    for (var cIdx = 0; cIdx < this.Caches.length; ++cIdx) {
      var cache = this.Caches[cIdx];
      // Select the tiles to load (loading is a byproduct).
      var tiles = cache.ChooseTiles(view.Camera, SLICE);
      for (var i = 0; i < tiles.length; ++i) {
        tiles[i].LoadState = 1;
        // Add the tile at the front of the queue.
        SA.LoadQueue.push(tiles[i]);
      }
    }
    SA.LoadQueueUpdate();
  };

  // This load tiles in the view like draw but does not render them.
  // I want to preload tiles in the next section.
  Section.prototype.LoadTilesInView = function (view) {
    for (var cIdx = 0; cIdx < this.Caches.length; ++cIdx) {
      var cache = this.Caches[cIdx];
      // Select the tiles to load (loading is a byproduct).
      cache.ChooseTiles(view.Camera, SLICE);
    }
  };

  SA.Section = Section;
})();

// ==============================================================================
// Subclass of view that renders tiled images.

(function () {
  'use strict';

  function TileView (parent, useWebGL) {
    SAM.View.call(this, parent, useWebGL);

    // connectome : default section so we cen set cache
    this.DefaultSection = new SA.Section();
    this.Section = this.DefaultSection;

    this.Tiles = []; // Not really used

    if (useWebGL) {
      this.gl = this.Canvas[0].getContext('webgl') || this.Canvas[0].getContext('experimental-webgl');
    }
    if (this.gl) {
      // Probably need a canvas object that keep track of
      // initialization (shared between layers).
      SA.initWebGL(this);
    } else {
      this.Context2d = this.Canvas[0].getContext('2d');
    }
  }
  TileView.prototype = new SAM.View();

  TileView.prototype.GetBounds = function () {
    return this.Section.GetBounds();
  };
  TileView.prototype.GetLeafSpacing = function () {
    return this.Section.GetLeafSpacing();
  };

  TileView.prototype.SetSection = function (section) {
    this.Section = section;
    if (section.Transform) {
      this.GetCamera().SetWorldToImageTransform(section.Transform);
    } else {
      this.GetCamera().SetWorldToImageTransform([1, 0, 0, 1, 0, 0]);
    }
  };

  TileView.prototype.AddCache = function (cache) {
    if (cache === undefined) { return; }
    if (this.Section === undefined) {
      this.Section = this.DefaultSection;
    }
    this.Section.Caches.push(cache);
  };

  // Non connectome API, simple.
  // Just use the default section.
  TileView.prototype.SetCache = function (cache) {
    this.Section = this.DefaultSection;
    if (!cache) {
      this.Section.Caches = [];
    } else {
      this.Section.Caches = [cache];
    }
  };

  TileView.prototype.GetCache = function () {
    // connectome: This makes less sense with a section with many caches.
    // TODO: try to get rid of this
    return this.Section.Caches[0];
  };

  // Not used at the moment
  TileView.prototype.Draw = function (masterView) {
    if (masterView) {
      var cam = masterView.Camera;
      if (this.Transform) {
        this.Transform.ForwardTransformCamera(cam, this.Camera);
      } else {
        this.Camera.WorldCopy(cam);
      }
    }

    if (this.gl) {
      var gl = this.gl;
      gl.clear(SA.GL.COLOR_BUFFER_BIT | SA.GL.DEPTH_BUFFER_BIT);
      var program = SA.imageProgram;
      gl.useProgram(program);
      gl.clearColor(1.0, 1.0, 1.0, 1.0);
      gl.disable(gl.DEPTH_TEST);
      gl.enable(gl.BLEND);
      // gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
    }

    return this.DrawTiles();
  };

  // I want only the annotation to create a mask image.
  // Note: Tile in the list may not be loaded yet.
  // Returns true if all the tiles to render were available.
  // False implies that the user shoudl render again.
  TileView.prototype.DrawTiles = function () {
    // Download view is not visible, but still needs to render tiles.
    // This causes black/blank download images
    // if ( ! this.Parent.is(':visible') ) {
    //    return;
    // }
    // console.time("  ViewDraw");
    if (this.gl) {
      return this.Section.Draw(this);
    } else {
      this.ClearPending = true;
      // Clear the canvas to start drawing.
      // this.Context2d.fillStyle = '#ffffff';
      // this.Context2d.fillRect(0, 0, this.Viewport[2], this.Viewport[3]);
      this.Context2d.resetTransform();
      this.Context2d.clearRect(0, 0, this.Canvas[0].width, this.Canvas[0].height);
      return this.Section.Draw(this);
    }
  };

  SA.TileView = TileView;
})();

// ==============================================================================
// The magic code to add show/hide custom event triggers
(function ($) {
  $.each(['show', 'hide'], function (i, ev) {
    var el = $.fn[ev];
    $.fn[ev] = function () {
      this.trigger(ev);
      return el.apply(this, arguments);
    };
  });
})(jQuery);

(function () {
  'use strict';

  // TODO: Fix
  // Add stack option to Save large image GUI.
  // SaveStackImages.

  // I think this can go away now that we have hover mode in text.

  // States for when the viewer consumes events.
  var SAVING_IMAGE = false;
  var INTERACTION_NONE = 0;
  var INTERACTION_DRAG = 1;
  var INTERACTION_ROTATE = 2;
  var INTERACTION_ZOOM = 3;
  var INTERACTION_OVERVIEW = 4;
  var INTERACTION_OVERVIEW_DRAG = 5;
  var INTERACTION_OVERVIEW_WHEEL = 6;

  // TODO: Can we get rid of args parameter now that we have ProcessArguments method?
  // See the top of the file for description of args.
  function Viewer (parent) {
    var self = this;

    this.Parent = parent;
    parent.addClass('sa-viewer');

    // Debugging
    SA.VIEWER = this;

    // For debugging event propagation.
    // this.SetupTestDivs(parent);
    // return;

    // This div is bound to all the events that propagate to the layers and widgets.
    this.Div = $('<div>')
      .appendTo(this.Parent)
      .css({
        'position': 'relative',
        'border-width': '0px',
        'width': '100%',
        'height': '100%',
        'box-sizing': 'border-box',
        'z-index': '49'
      })
      .addClass('sa-resize');
    this.Div.saOnResize(
            function () {
              self.UpdateSize();
            });
    this.Div.addClass('ViewerDiv');
    // So we can programatically set the keyboard focus
    this.Div.attr('tabindex', '1');

    // I am moving the eventually render feature into viewers.
    this.Drawing = false;
    this.RenderPending = false;
    this.Rotatable = true;

    this.HistoryFlag = false;
    this.MinPixelSize = 0.25;

    // Need this to avoid calling interaction on multiple times.
    this.InteractionEnabled = false;

    // Interaction state:
    // What to do for mouse move or mouse up.
    this.InteractionState = INTERACTION_NONE;
    // External callbacks
    this.InteractionListeners = [];

    this.AnimateLast = null;
    this.AnimateDuration = 0.0;
    this.TranslateTarget = [0.0, 0.0];

    this.MainView = new SA.TileView(this.Div, false);
    // webgl for main view.
    this.MainView.OutlineColor = [0, 0, 0];
    this.MainView.Camera.ZRange = [0, 1];
    this.MainView.Camera.ComputeMatrix();
    // necesary to respond to keyevents.
    this.MainView.Parent.attr('tabindex', '1');

    this.Layers = [];

    if (!SAM.detectMobile() || SAM.MOBILE_DEVICE === 'iPad') {
      this.OverViewVisibility = true;
      this.OverViewScale = 0.02; // Experimenting with scroll
      this.OverViewport = [80, 20, 180, 180];
      this.OverViewDiv = $('<div>')
                .appendTo(this.Div);

      this.OverView = new SA.TileView(this.OverViewDiv);
      this.OverView.Camera.ZRange = [-1, 0];
      this.OverView.Camera.SetWorldFocalPoint([13000.0, 11000.0]);
      this.OverView.Camera.SetHeight(22000.0);
      this.OverView.Camera.ComputeMatrix();

      // One must be true for the icon to be active (opaque).
      this.RotateIconHover = false;
      // I am not making this part of the InteractionState because
      // I want to make the overview its own widget.
      this.RotateIconDrag = false;

      this.RotateIcon =
                $('<img>')
                .appendTo(this.OverView.Parent)
                .attr('src', SA.ImagePathUrl + 'rotate.png')
                .addClass('sa-view-rotate')
                .mouseenter(function (e) { return self.RollEnter(e); })
                .mouseleave(function (e) { return self.RollLeave(e); })
                .mousedown(function (e) { return self.RollDown(e); })
                .attr('draggable', 'false')
                .on('dragstart', function () {
                  return false;
                });
      // Try to make the overview be on top of the rotate icon
      // It should receive events before the rotate icon.
      this.OverViewDiv.css({'z-index': '49'});
    }
    this.ZoomTarget = this.MainView.Camera.GetHeight();
    this.RollTarget = this.MainView.Camera.GetWorldRoll();

    this.DoubleClickX = 0;
    this.DoubleClickY = 0;

    // For stack correlations.
    this.StackCorrelations = undefined;
    // This is only for drawing correlations.
    this.RecordIndex = 0; // Only used for drawing correlations.

    this.InteractionOn();

    this.CopyrightWrapper = $('<div>')
            .appendTo(this.MainView.Parent)
            .addClass('sa-view-copyright');
    if (SA.Session && SA.Session.sessid === '560b5127a7a1412195d13685') {
      this.Icon = $('<img>')
                .appendTo(this.MainView.Parent)
                .attr('src', 'http://static1.squarespace.com/static/5126bbb4e4b08c2e6d1cb6e4/t/54e66f05e4b0440df79a5729/1424387847915/')
                .prop('title', 'UC Davis')
                .css({'position': 'absolute',
                  'bottom': '80px',
                  'left': '7px',
                  'width': '128px',
                  'z-index': '4'});
    }
    if (SA.Session && SA.Session.sessid === '57504ba7a7a1411310dd2637') {
      this.Icon = $('<img>')
                .appendTo(this.MainView.Parent)
                .attr('src', 'https://slide-atlas.org/api/v2/sessions/53d9230fdd98b54fd71e8ed7/attachments/57518ce4a7a14113156b8166')
                .prop('title', 'Philips')
                .css({'position': 'absolute',
                  'bottom': '90px',
                  'left': '7px',
                  'width': '100px',
                  'z-index': '4'});
    }

    // For accelerating mouse wheel zooming.  I should probably merg this with drag accerlation ...
    this.WheelSensitivity = 0.0;     // (0.1) + Sensitivity: fraction zoom with no acceleration
    this.WheelAcceleration = 0.025;   // Each wheel event increases sensitivty by this size.
    this.WheelTimeConstant = 1000.0; // Time constant for sensitivty to decay back to default value.
  }

  Viewer.prototype.GetParentDiv = function () {
    return this.Div;
  };

  Viewer.prototype.GetParent = function () {
    return this.Parent;
  };

  Viewer.prototype.ScaleOn = function () {
    if (!this.ScaleWidget) {
      this.ScaleWidget = new SAM.ScaleWidget();
    }
  };

  // I need to turn the bindins on and off, to make children 'contentEditable'.
  Viewer.prototype.InteractionOn = function () {
    // Keep from adding multiple bindings for events.
    if (this.InteractionEnabled) {
      return;
    }
    this.InteractionEnabled = true;

    var self = this;
    // var can = this.MainView.Parent;
    var can = this.Div;
    can.on(
      'mousedown.viewer',
      function (event) {
        // SA.FirefoxWhich(event);
        self.FirefoxWhich = event.which;
        return self.HandleMouseDown(event);
      });
    can.on(
      'mousemove.viewer',
      function (event) {
        // So key events go the the right viewer.
        this.focus();
        if (event.which === undefined) {
          event.which = self.FirefoxWhich;
        }
        // Firefox does not define offsetX ...?
        // SA.FirefoxWhich(event);
        // Firefox does not set which for mouse move events.
        if (event.which === undefined) {
          event.which = self.FirefoxWhich;
        }
        return self.HandleMouseMove(event);
      });
    // We need to detect the mouse up even if it happens outside the canvas,
    $(document.body).on(
      'mouseup.viewer',
      function (event) {
        // SA.FirefoxWhich(event);
        self.FirefoxWhich = 0;
        if (event.which === undefined) {
          event.which = 0;
        }
        self.HandleMouseUp(event);
        return true;
      });
    can.on(
      'wheel.viewer',
      function (event) {
        return self.HandleMouseWheel(event.originalEvent);
      });

    // I am delaying getting event manager out of receiving touch events.
    // It has too many helper functions.
    can.on(
      'touchstart.viewer',
      function (event) {
        return self.HandleTouchStart(event.originalEvent);
      });
    can.on(
      'touchmove.viewer',
      function (event) {
        if (event.which === undefined) {
          event.which = 0;
        }
        event.which = self.FirefoxWhich;
        return self.HandleTouchMove(event.originalEvent);
      });
    can.on(
      'touchend.viewer',
      function (event) {
        self.HandleTouchEnd(event.originalEvent);
        return true;
      });

    can.on(
      'keydown.viewer',
      function (event) {
        // alert('keydown');
        return self.HandleKeyDown(event);
      });
    can.on(
      'keyup.viewer',
      function (event) {
        return self.HandleKeyUp(event);
      });

    if (this.OverView) {
      // can = this.OverView.Parent;
      can = this.OverViewDiv;
      can.on(
        'mousedown.viewer',
        function (event) {
          SA.FirefoxWhich(event);
          self.FirefoxWhich = event.which;
          return self.HandleOverViewMouseDown(event);
        });

      can.on(
        'mouseup.viewer',
        function (event) {
          self.FirefoxWhich = 0;
          self.FirefoxWhich = 0;
          if (event.which === undefined) {
            event.which = 0;
          }
          return self.HandleOverViewMouseUp(event);
        });
      can.on(
        'mousemove.viewer',
        function (event) {
          // SA.FirefoxWhich(event);
          if (event.which === undefined) {
            event.which = self.FirefoxWhich;
          }
          return self.HandleOverViewMouseMove(event);
        });
      can.on(
        'mousewheel.viewer',
        function (event) {
          return self.HandleOverViewMouseWheel(event.originalEvent);
        });
    }
  };

  // I need to turn the bindins on and off, to make children 'contentEditable'.
  Viewer.prototype.InteractionOff = function () {
    this.InteractionEnabled = false;

    // Options:
    // 1: Just use off to get rid of all bindings. This will remove outside bindings too.
    // 2: Remove them 1 by 1.
    // Lets be verbose but safe.
    // var can = this.MainView.Parent;
    var can = this.Div;
    can.off('mousedown.viewer');
    can.off('mousemove.viewer');
    $(document.body).off('mouseup.viewer');
    can.off('wheel.viewer');
    can.off('touchstart.viewer');
    can.off('touchmove.viewer');
    can.off('touchend.viewer');
    can.off('keydown.viewer');
    can.off('keyup.viewer');

    if (this.OverView) {
      // can = this.OverView.Parent;
      can = this.OverViewDiv;
      can.off('mousedown.viewer');
      can.off('mouseup.viewer');
      can.off('mousemove.viewer');
      can.off('mousewheel.viewer');
    }
  };

  // Allow the viewer to receive keyboard events.
  Viewer.prototype.Focus = function () {
    var can = this.MainView.Parent;
    can.focus();
  };

  Viewer.prototype.SetRotatable = function (flag) {
    this.Rotatable = flag;
    if (flag) {
      this.RotateIcon.show();
    } else {
      this.RotateIcon.hide();
    }
  };

  // Try to remove all global references to this viewer.
  Viewer.prototype.Delete = function () {
    /*
    this.Div.remove();
    // Remove circular references too?
    // This will probably affect all viewers.
    $(document.body).off('mouseup.viewer');
    this.MainView.Delete();
    if (this.OverView) {
      this.OverView.Delete();
      delete this.OverView;
    }
    delete this.MainView;
    delete this.Parent;
    delete this.Div;
    delete this.InteractionListeners;
    delete this.RotateIcon;
    delete this.StackCorrelations;
    delete this.CopyrightWrapper;
    */
  };

  // Layers have a Draw(masterView) method.
  Viewer.prototype.AddLayer = function (layer) {
    this.Layers.push(layer);
  };

  // Abstracting saViewer  for viewer and dualViewWidget.
  // Save viewer state in a note.
  Viewer.prototype.Record = function (note, viewIdx) {
    viewIdx = viewIdx || 0;
    note.ViewerRecords[viewIdx].CopyViewer(this);
  };

  // TODO: Make the annotation layer optional.
  // I am moving some of the saViewer code into this viewer object because
  // I am trying to abstract the single viewer used for the HTML presentation
  // note and the full dual view / stack note.
  // TODO: Make an alternative path that does not require a note.
  Viewer.prototype.ProcessArguments = function (args) {
    if (args.overview !== undefined) {
      this.SetOverViewVisibility(args.overview);
    }
    if (args.zoomWidget !== undefined) {
      this.SetZoomWidgetVisibility(args.zoomWidget);
    }
    if (args.rotatable !== undefined) {
      this.SetRotatable(args.rotatable);
    }

    // The way I handle the viewer edit menu is messy.
    // TODO: Find a more elegant way to add tabs.
    // Maybe the way we handle the anntation tab shouodl be our pattern.
    if (args.menu !== undefined) {
      if (!this.Menu) {
        this.Menu = new SA.ViewEditMenu(this, null);
      }
      this.Menu.SetVisibility(args.menu);
    }

    if (args.tileSource) {
      args.note = SA.TileSourceToNote(args.tileSource);
    }

    if (args.note) {
      this.saNote = args.note;
      var index = this.saViewerIndex = args.viewerIndex || 0;
      this.SetViewerRecord(args.note.ViewerRecords[index]);

      this.Parent.attr('sa-note-id', args.note.Id || args.note.TempId);
      this.Parent.attr('sa-viewer-index', this.saViewerIndex);
    }
    if (args.hideCopyright !== undefined) {
      this.SetCopyrightVisibility(!args.hideCopyright);
    }
    if (args.interaction !== undefined) {
      this.SetInteractionEnabled(args.interaction);
    }
    this.UpdateSize();
  };

  // Which is better calling Note.Apply, or viewer.SetNote?  I think this
  // will  win.  The layer needs to have a load callback for vigilant threshold.
  Viewer.prototype.SetViewerRecord = function (viewerRecord, lockCamera) {
    // If a widget is active, then just inactivate it.
    // It would be nice to undo pencil strokes in the middle, but this feature will have to wait.
    if (this.ActiveWidget) {
      // Hackish way to deactivate.
      this.ActiveWidget.SetActive(false);
    }

    if (!lockCamera) {
      this.Reset();
    }

    var cache = this.GetCache();
    if (!cache || viewerRecord.Image._id !== cache.Image._id) {
      var newCache = SA.FindCache(viewerRecord.Image);
      this.SetCache(newCache);
    }

    if (!lockCamera) {
      this.SetOverViewBounds(viewerRecord.OverViewBounds);

      if (viewerRecord.Camera !== undefined && viewerRecord.Transform === undefined) {
        var cameraRecord = viewerRecord.Camera;
        this.GetCamera().Load(cameraRecord);
        if (this.OverView) {
          this.OverView.Camera.SetWorldRoll(cameraRecord.Roll);
          this.OverView.Camera.ComputeMatrix();
        }
        this.UpdateZoomGui();
        this.UpdateCamera();
      }
    }

    // TODO: Get rid of this hack.
    if (this.AnnotationWidget && viewerRecord.AnnotationVisibility !== undefined) {
      this.AnnotationWidget.SetVisibility(viewerRecord.AnnotationVisibility);
    }

    // fit the canvas to the div size.
    this.UpdateSize();
  };

  Viewer.prototype.SetNote = function (note, viewIdx, lockCamera) {
    if (!note || viewIdx < 0 || viewIdx >= note.ViewerRecords.length) {
      console.log('Cannot set viewer record of note');
      return;
    }
    this.SetViewerRecord(note.ViewerRecords[viewIdx], lockCamera);
    this.saNote = note;
    this.saViewerIndex = viewIdx;
  };
  Viewer.prototype.SetNoteFromId = function (noteId, viewIdx) {
    var self = this;
    var note = SA.GetNoteFromId(noteId);
    if (!note) {
      note = new SA.Note();
      note.LoadViewId(
                noteId,
                function () {
                  self.SetNote(note, viewIdx);
                });
      return note;
    }
    this.SetNote(note, viewIdx);
    return note;
  };

  Viewer.prototype.SetOverViewVisibility = function (visible) {
    this.OverViewVisibility = visible;
    if (!this.OverViewDiv) { return; }
    if (visible) {
      this.OverViewDiv.show();
    } else {
      this.OverViewDiv.hide();
    }
  };

  Viewer.prototype.GetOverViewVisibility = function () {
    return this.OverViewVisibility;
  };

  Viewer.prototype.Hide = function () {
    this.MainView.Parent.hide();
    if (this.OverView) {
      this.OverView.Parent.hide();
    }
  };

  Viewer.prototype.Show = function () {
    this.MainView.Parent.show();
    if (this.OverView && this.OverViewVisibility) {
      this.OverView.Parent.show();
    }
  };

  // The interaction boolean argument will supress interaction events if false.
  Viewer.prototype.EventuallyRender = function (interaction) {
    if (!this.RenderPending) {
      this.RenderPending = true;
      var self = this;
      window.requestAnimationFrame(
                function () {
                  self.RenderPending = false;
                  self.Draw();
                  if (interaction) {
                    // Easiest place to make sure interaction events are triggered.
                    self.TriggerInteraction();
                  }
                });
    }
  };

  // These should be in an overview widget class.
  Viewer.prototype.RollEnter = function (e) {
    if (!this.Rotatable) { return; }
    this.RotateIconHover = true;
    this.RotateIcon.addClass('sa-active');
  };
  Viewer.prototype.RollLeave = function (e) {
    if (this.RotateIconDrag) { return; }
    this.RotateIconHover = false;
    if (!this.RotateIconDrag) {
      this.RotateIcon.removeClass('sa-active');
    }
  };
  Viewer.prototype.RollDown = function (e) {
    if (!this.OverView) { return; }
    if (!this.Rotatable) { return; }
    this.FirefoxWhich = e.which;
    this.RotateIconDrag = true;
    // Find the center of the overview window.
    var cx = this.OverViewport[0] + (0.5 * this.OverViewport[2]);
    var cy = this.OverViewport[1] + (0.5 * this.OverViewport[3]);
    var offset = this.MainView.Parent.offset();
    var x = e.pageX - offset.left - cx;
    var y = e.pageY - offset.top - cy;

    // Normalize
    var m = Math.sqrt((x * x) + (y * y));
    this.RotateIconX = x / m;
    this.RotateIconY = y / m;

    // Move event is in the viewer or overview.
    // It has a sanity check of which button was pressed.
    // It looks like the icon consumes the down event so
    // the viewer never has a chance to set this
    SA.FirefoxWhich(event);
    this.FirefoxWhich = event.which;

    return false;
  };

  Viewer.prototype.RollMove = function (e) {
    if (!this.OverView) { return; }
    if (!this.RotateIconDrag) { return; }
    if (!this.Rotatable) { return; }
    if (e.which !== 1) {
      // We must have missed the mouse up event.
      this.RotateIconDrag = false;
      return;
    }

    // Find the center of the overview window.
    // Relative to mainview?
    var cx = this.OverViewport[0] + (0.5 * this.OverViewport[2]);
    var cy = this.OverViewport[1] + (0.5 * this.OverViewport[3]);

    var offset = this.MainView.Parent.offset();
    var x = e.pageX - offset.left - cx;
    var y = e.pageY - offset.top - cy;

    // Normalize
    var m = Math.sqrt((x * x) + (y * y));
    x = x / m;
    y = y / m;

    // Cross product gives angle*m^2
    var dAngle = x * this.RotateIconY - y * this.RotateIconX;

    var roll = this.MainView.Camera.GetWorldRoll() - dAngle;
    this.MainView.Camera.SetWorldRoll(roll);
    this.UpdateCamera();
    this.EventuallyRender(true);

    this.RotateIconX = x;
    this.RotateIconY = y;

    return false;
  };

  // onresize callback.  Canvas width and height and the camera need
  // to be synchronized with the canvas div.
  Viewer.prototype.UpdateSize = function () {
    if (!this.MainView) {
      return;
    }
    if (this.MainView.UpdateCanvasSize()) {
      this.EventuallyRender();
    }

    for (var i = 0; i < this.Layers.length; ++i) {
      var layer = this.Layers[i];
      if (layer && layer.UpdateSize) {
        layer.UpdateSize();
      }
    }

    // I do not know the way the viewport is used to place
    // this overview.  It should be like other widgets
    // and be placed relative to the parent.
    if (this.OverView) {
      var width = this.MainView.GetWidth();
      var height = this.MainView.GetHeight();
      var area = width * height;
      var bounds = this.GetOverViewBounds();
      var aspect = (bounds[1] - bounds[0]) / (bounds[3] - bounds[2]);
      // size of overview
      var h = Math.sqrt(area * this.OverViewScale / aspect);
      var w = h * aspect;
      // Limit size
      if (h > height / 2) {
        h = height / 2;
        w = h * aspect;
        this.OverViewScale = w * h / area;
      }
      // center of overview
      var radius = Math.sqrt(h * h + w * w) / 2;
      // Construct the viewport.  Hack: got rid of viewport[0]
      // TODO: I really need to get rid of the viewport stuff
      this.OverViewport = [width - radius - w / 2,
        radius - h / 2,
        w, h];
      this.OverViewDiv.css({
        'left': this.OverViewport[0] + 'px',
        'width': this.OverViewport[2] + 'px',
        'top': this.OverViewport[1] + 'px',
        'height': this.OverViewport[3] + 'px'
      });
      this.OverView.UpdateCanvasSize();
    }
  };

  // TODO: Events are a pain because most are handled by parent.
  // Time to make the overview a real widget?
  Viewer.prototype.RollUp = function (e) {
    this.RotateIconDrag = false;
    if (!this.RotateIconHover) {
      this.RotateIcon.addClass('sa-active');
    }

    return false;
  };

  Viewer.prototype.GetMainCanvas = function () {
    return this.MainView.Canvas;
  };

  // A way to have a method called every time the camera changes.
  // Will be used for synchronizing viewers for stacks.
  Viewer.prototype.OnInteraction = function (callback) {
    // How should we remove listners?
    // Global clear for now.
    if (!callback) {
      this.InteractionListeners = [];
    } else {
      this.InteractionListeners.push(callback);
    }
  };

  Viewer.prototype.TriggerInteraction = function () {
    for (var i = 0; i < this.InteractionListeners.length; ++i) {
      var callback = this.InteractionListeners[i];
      callback();
    }
  };

  Viewer.prototype.GetDiv = function () {
    return this.MainView.Parent;
  };

  Viewer.prototype.InitializeZoomGui = function () {
    // Links: URL for the current view, and url to a highres cutout.
    this.ShareTab = new SA.Tab(this.GetDiv(),
                               SA.ImagePathUrl + 'share.png',
                               'shareTab');
    this.ShareTab.Div
      .css({
        'box-sizing': 'border-box',
        'position': 'absolute',
        'bottom': '0px',
        'right': '47px',
        'z-index': '49'});
    this.ShareTab.Panel
      .css({
        'box-sizing': 'border-box',
        'left': '-400px',
        'width': '480px',
        'z-index': '500',
        // 'height': '45px',
        'padding': '0 2px'});
    var self = this;
    this.ShareDisplay = $('<div>')
      .appendTo(this.ShareTab.Panel)
      .addClass('sa-view-share-text')
      .html('')
      .attr('contenteditable', 'true')
      .css({
        'tabindex': '1',
        'z-index': '501',
        'width': '100%',
        '-webkit-user-select': 'all',
        'user-select': 'all'});

    // TODO: Separate the share update from EndInteraction.
    this.ShareTab.Panel.on('show', function () {
      self.TriggerEndInteraction();
      self.ShareDisplay.focus();
    });
    // Gymnastics to let the textarea get events.
    // Allow copy of text.
    this.ShareDisplay.on('mouseenter', function () {
      self.InteractionOff();
      self.ShareDisplay.focus();
    });
    this.ShareDisplay.on('mouseleave', function () {
      self.InteractionOn();
      self.ShareDisplay.blur();
    });

    // Put the zoom bottons in a tab.
    this.ZoomTab = new SA.Tab(this.GetDiv(),
                               SA.ImagePathUrl + 'mag.png',
                               'zoomTab');
    this.ZoomTab.Div
      .css({
        'box-sizing': 'border-box',
        'position': 'absolute',
        'bottom': '0px',
        'right': '7px',
        'z-index': '49'});
    // .prop('title', 'Zoom scroll');
    this.ZoomTab.Panel
      .addClass('sa-view-zoom-panel');
    // Put the magnification factor inside the magnify glass icon.
    this.ZoomDisplay = $('<div>')
      .appendTo(this.ZoomTab.Div)
      .addClass('sa-view-zoom-text')
      .html('');

    // Place the zoom in / out buttons.
    // Todo: Make the button become more opaque when pressed.
    // Associate with viewer (How???).
    // Place properly (div per viewer?) (viewer.SetViewport also places buttons).

    this.ZoomDiv = $('<div>')
      .appendTo(this.ZoomTab.Panel)
      .addClass('sa-view-zoom-panel-div');
    this.ZoomInButton = $('<img>')
      .appendTo(this.ZoomDiv)
      .addClass('sa-view-zoom-button sa-zoom-in')
      .attr('type', 'image')
      .attr('src', SA.ImagePathUrl + 'zoomin2.png')
      .on('click touchstart', function () { self.AnimateZoom(0.5); })
      .attr('draggable', 'false')
      .on('dragstart', function () {
        return false;
      });

    this.ZoomOutButton = $('<img>').appendTo(this.ZoomDiv)
      .addClass('sa-view-zoom-button sa-zoom-out')
      .attr('type', 'image')
      .attr('src', SA.ImagePathUrl + 'zoomout2.png')
      .on('click touchstart', function () { self.AnimateZoom(2.0); })
      .attr('draggable', 'false')
      .on('dragstart', function () {
        return false;
      });

    this.ZoomInButton.addClass('sa-active');
    this.ZoomOutButton.addClass('sa-active');
  };

  Viewer.prototype.UpdateZoomGui = function () {
    if (!this.ZoomDisplay) { return; }
    var camHeight = this.GetCamera().GetHeight();
    var windowHeight = this.GetViewport()[3];
    // Assume image scanned at 40x
    var zoomValue = 40.0 * windowHeight / camHeight;
    // 2.5 and 1.25 are standard in the geometric series.
    if (zoomValue < 2) {
      zoomValue = zoomValue.toFixed(2);
    } else if (zoomValue < 4) {
      zoomValue = zoomValue.toFixed(1);
    } else {
      zoomValue = Math.round(zoomValue);
    }
    this.ZoomDisplay.html('x' + zoomValue);

    // I am looking for the best place to update this value.
    // Trying to fix a bug: Large scroll when wheel event occurs
    // first.
    this.ZoomTarget = camHeight;
  };

  Viewer.prototype.SaveImage = function (fileName) {
    this.MainView.Canvas[0].toBlob(function (blob) { saveAs(blob, fileName); }, 'image/png');
  };

  // Cancel the large image request before it finishes.
  Viewer.prototype.CancelLargeImage = function () {
    // This will abort the save blob that occurs after rendering.
    SA.ClearFinishedLoadingCallbacks();
    // We also need to stop the request for pending tiles.
    SA.ClearQueue();
    // Incase some of the queued tiles were for normal rendering.
    this.EventuallyRender(false);
  };

  // NOTE: Consider option for annotation layer to share a canvas with the
  // tile view.
  // Create a virtual viewer to save a very large image.
  Viewer.prototype.SaveLargeImage = function (fileName, width, height, stack,
                                               finishedCallback) {
    var self = this;
    var cache = this.GetCache();
    var cam = this.GetCamera();

    // Clone the main view.
    var view = new SA.TileView();
    view.SetCache(cache);
    view.Canvas.attr('width', width);
    view.Canvas.attr('height', height);
    view.SetViewport([0, 0, width, height]);
    var newCam = view.Camera;

    newCam.SetWorldFocalPoint(cam.GetWorldFocalPoint());
    newCam.SetWorldRoll(cam.GetWorldRoll());
    newCam.Height = cam.GetHeight();
    newCam.Width = cam.GetWidth();
    newCam.ViewportWidth = width;
    newCam.ViewportHeight = height;
    newCam.ComputeMatrix();

    // Load only the tiles we need.
    var tiles = cache.ChooseTiles(newCam, 0, []);
    for (var i = 0; i < tiles.length; ++i) {
      SA.LoadQueueAddTile(tiles[i]);
    }
    SA.LoadQueueUpdate();

    // this.CancelLargeImage = false;
    SA.AddFinishedLoadingCallback(
      function () {
        self.SaveLargeImage2(view, fileName,
                             width, height, stack,
                             finishedCallback);
      }
    );
  };

  Viewer.prototype.SaveLargeImage2 = function (view, fileName,
                                               width, height, stack,
                                               finishedCallback) {
    var sectionFileName = fileName;
    var note;
    if (stack) {
      note = SA.display.GetNote();
      var idx = fileName.indexOf('.');
      if (idx < 0) {
        sectionFileName = fileName + SA.ZERO_PAD(note.StartIndex, 4) + '.png';
      } else {
        sectionFileName = fileName.substring(0, idx) +
          SA.ZERO_PAD(note.StartIndex, 4) +
          fileName.substring(idx, fileName.length);
      }
    }
    console.log(sectionFileName + ' ' + SA.LoadQueue.length + ' ' + SA.LoadingCount);

    if (!view.Draw()) {
      console.log('Sanity check failed. Not all tiles were available.');
    }
    this.MainView.DrawShapes();

    for (var i = 0; i < this.Layers.length; ++i) {
      if (this.Layers[i].Draw) {
        this.Layers[i].Draw(view);
      }
    }

    console.log(JSON.stringify(this.GetCamera().Serialize()));

    view.Canvas[0].toBlob(function (blob) { saveAs(blob, sectionFileName); }, 'image/png');
    if (stack) {
      note = SA.display.GetNote();
      if (note.StartIndex < note.ViewerRecords.length - 1) {
        SA.display.NavigationWidget.NextNote();
        var self = this;
        setTimeout(function () {
          self.SaveLargeImage(fileName, width, height, stack,
                              finishedCallback);
        }, 1000);
        return;
      }
    }

    finishedCallback();
  };

  // This method waits until all tiles are loaded before saving.
  Viewer.prototype.EventuallySaveImage = function (fileName, finishedCallback) {
    var self = this;
    SA.AddFinishedLoadingCallback(
      function () {
        self.SaveImage(fileName);
        if (finishedCallback) {
          finishedCallback();
        }
      }
    );
    this.EventuallyRender(false);
  };

  // Not used anymore.  Incorpoarated in SaveLargeImage
  // delete these.
  // Save a bunch of stack images ----
  Viewer.prototype.SaveStackImages = function (fileNameRoot) {
    var self = this;
    SA.AddFinishedLoadingCallback(
      function () {
        self.SaveStackImage(fileNameRoot);
      }
    );
    this.EventuallyRender(false);
  };

  Viewer.prototype.SaveStackImage = function (fileNameRoot) {
    var self = this;
    var note = SA.display.GetNote();
    var fileName = fileNameRoot + SA.ZERO_PAD(note.StartIndex, 4);
    console.log(JSON.stringify(this.GetCamera().Serialize()));
    this.SaveImage(fileName);
    if (note.StartIndex < note.ViewerRecords.length - 1) {
      SA.display.NavigationWidget.NextNote();
      SA.AddFinishedLoadingCallback(
        function () {
          self.SaveStackImage(fileNameRoot);
        }
      );
      this.EventuallyRender(false);
    }
  };
  // -----

  Viewer.prototype.SetOverViewBounds = function (bounds) {
    this.OverViewBounds = bounds;
    if (this.OverView) {
      // With the rotating overview, the overview camera
      // never changes. Maybe this should be set in
      // 'UpdateCamera'.
      this.OverView.Camera.SetHeight(bounds[3] - bounds[2]);
      this.OverView.Camera.SetWorldFocalPoint([
        0.5 * (bounds[0] + bounds[1]),
        0.5 * (bounds[2] + bounds[3])]);
      this.OverView.Camera.ComputeMatrix();
    }
  };

  Viewer.prototype.GetOverViewBounds = function () {
    if (this.OverViewBounds) {
      return this.OverViewBounds;
    }
    var cache = this.GetCache();
    if (cache && cache.Image) {
      if (cache.Image.bounds) {
        return cache.Image.bounds;
      }
      if (cache.Image.dimensions) {
        var dims = cache.Image.dimensions;
        return [0, dims[0], 0, dims[1]];
      }
    }
    // Depreciated code.
    if (this.OverView) {
      var cam = this.OverView.Camera;
      var halfHeight = cam.GetHeight() / 2;
      var halfWidth = cam.GetWidth() / 2;
      var fp = cam.GetWorldFocalPoint();
      this.OverViewBounds = [
        fp[0] - halfWidth, fp[0] + halfWidth,
        fp[1] - halfHeight, fp[1] + halfHeight];
      return this.OverViewBounds;
    }
    // This method is called once too soon.  There is no image, and mobile devices have no overview.
    return [0, 10000, 0, 10000];
  };

  Viewer.prototype.SetSection = function (section) {
    if (section === null) {
      return;
    }

    if (section.Bounds) {
      this.SetOverViewBounds(section.Bounds);
    }
    if (section.Caches.length > 0) {
      this.CopyrightWrapper
        .html(section.Caches[0].Image.copyright);
    }

    this.MainView.SetSection(section);

    if (this.OverView) {
      this.OverView.SetSection(section);
      var bds = section.Bounds;
      if (bds) {
        this.OverView.Camera.SetWorldFocalPoint([
          (bds[0] + bds[1]) / 2,
          (bds[2] + bds[3]) / 2]);
        var height = (bds[3] - bds[2]);
        // See if the view is constrained by the width.
        var height2 = (bds[1] - bds[0]) * this.OverView.Viewport[3] / this.OverView.Viewport[2];
        if (height2 > height) {
          height = height2;
        }
        this.OverView.Camera.SetHeight(height);
        this.OverView.Camera.ComputeMatrix();
      }
    }
    // Change the overview to fit the new image dimensions.
    this.UpdateSize();
  };

  // Change the source / cache after a viewer has been created.
  // TODO: clean this up. Should probably call set section.
  // OverView bounds appear to be handled twice.
  // Handle copyright for sections. (multple caches?)
  Viewer.prototype.SetCache = function (cache) {
    if (cache && cache.Image) {
      if (cache.Image.bounds) {
        this.SetOverViewBounds(cache.Image.bounds);
      }

      this.CopyrightWrapper
        .html(cache.Image.copyright);
    }

    this.MainView.SetCache(cache);
    if (this.OverView) {
      this.OverView.SetCache(cache);
      if (cache) {
        var bds = cache.GetBounds();
        if (bds) {
          this.OverView.Camera.SetWorldFocalPoint([
            (bds[0] + bds[1]) / 2,
            (bds[2] + bds[3]) / 2]);
          var height = (bds[3] - bds[2]);
          // See if the view is constrained by the width.
          var height2 = (bds[1] - bds[0]) * this.OverView.Viewport[3] / this.OverView.Viewport[2];
          if (height2 > height) {
            height = height2;
          }
          this.OverView.Camera.SetHeight(height);
          this.OverView.Camera.ComputeMatrix();
        }
      }
    }
    // Change the overview to fit the new image dimensions.
    this.UpdateSize();
  };

  Viewer.prototype.GetCache = function () {
    return this.MainView.GetCache();
  };

  // ORIGIN SEEMS TO BE BOTTOM LEFT !!!
  // I intend this method to get called when the window resizes.
  // TODO: Redo all this overview viewport junk.
  // viewport: [left, top, width, height]
  // When I remove this function, move the logic to UpdateSize().
  Viewer.prototype.SetViewport = function (viewport) {
    // TODO: Get rid of this positioning hack.
    // Caller should be positioning the parent.
    // The whole 'viewport' concept needs to be eliminated.
    // this.MainView.SetViewport(viewport, this.Parent);
    // this.MainView.Camera.ComputeMatrix();

    // I do not know the way the viewport is used to place
    // this overview.  It should be like other widgets
    // and be placed relative to the parent.
    if (this.OverView) {
      var area = viewport[2] * viewport[3];
      var bounds = this.GetOverViewBounds();
      var aspect = (bounds[1] - bounds[0]) / (bounds[3] - bounds[2]);
      // size of overview
      var h = Math.sqrt(area * this.OverViewScale / aspect);
      var w = h * aspect;
      // Limit size
      if (h > viewport[3] / 2) {
        h = viewport[3] / 2;
        w = h * aspect;
        this.OverViewScale = w * h / area;
      }
      // center of overview
      var radius = Math.sqrt(h * h + w * w) / 2;
      // Construct the viewport.  Hack: got rid of viewport[0]
      // TODO: I really need to get rid of the viewport stuff
      this.OverViewport = [viewport[2] - radius - w / 2,
        viewport[1] + radius - h / 2,
        w, h];

      this.OverViewDiv.css({
        'left': this.OverViewport[0] + 'px',
        'width': this.OverViewport[2] + 'px',
        'top': this.OverViewport[1] + 'px',
        'height': this.OverViewport[3] + 'px'
      });
      this.OverView.UpdateCanvasSize();
    }
  };

  Viewer.prototype.GetViewport = function () {
    return this.MainView.Viewport;
  };

  // To fix a bug in the perk and elmer uploader.
  Viewer.prototype.ToggleMirror = function () {
    this.MainView.Camera.Mirror = !this.MainView.Camera.Mirror;
    if (this.OverView) {
      this.OverView.Camera.Mirror = !this.OverView.Camera.Mirror;
    }
  };

  // Same as set camera but use animation
  Viewer.prototype.AnimateCamera = function (center, rotation, height) {
    this.ZoomTarget = height;
    // Compute traslate target to keep position in the same place.
    this.TranslateTarget[0] = center[0];
    this.TranslateTarget[1] = center[1];
    this.RollTarget = rotation;

    this.AnimateLast = new Date().getTime();
    this.AnimateDuration = 200.0; // hard code 200 milliseconds
    this.EventuallyRender(true);
  };

  // This sets the overview camera from the main view camera.
  // The user can change the mainview camera and then call this method.
  Viewer.prototype.UpdateCamera = function () {
    var cam = this.MainView.Camera;
    this.ZoomTarget = cam.Height;

    var fp = cam.GetWorldFocalPoint();
    this.TranslateTarget[0] = fp[0];
    this.TranslateTarget[1] = fp[1];
    this.RollTarget = cam.GetWorldRoll();
    if (this.OverView) {
      this.OverView.Parent.css({'transform': 'rotate(' + this.RollTarget + 'rad'});
      this.OverView.Camera.SetWorldRoll(0);
      this.OverView.Camera.ComputeMatrix();
    }

    this.MainView.Camera.ComputeMatrix();
    this.UpdateZoomGui();
  };

    // This is used to set the default camera so the complexities
    // of the target and overview are hidden.
  Viewer.prototype.SetCamera = function (center, rotation, height) {
    this.MainView.Camera.SetHeight(height);
    this.MainView.Camera.SetWorldFocalPoint([center[0], center[1]]);
    this.MainView.Camera.SetWorldRoll(rotation * 3.14159265359 / 180.0);

    this.ZoomTarget = height;
    this.TranslateTarget[0] = center[0];
    this.TranslateTarget[1] = center[1];
    this.RollTarget = rotation;

    this.UpdateCamera();
    this.EventuallyRender(true);
  };

  Viewer.prototype.GetCamera = function () {
    return this.MainView.Camera;
  };

  // I could merge zoom methods if position defaulted to focal point.
  Viewer.prototype.AnimateZoomTo = function (factor, position) {
    if (this.AnimateDuration > 0.0) {
      // Odd effect with multiple fast zoom clicks.  Center shifted.
      return;
    }

    SA.StackCursorFlag = false;

    this.ZoomTarget = this.MainView.Camera.GetHeight() * factor;
    if (this.ZoomTarget < 0.9 / (1 << 5)) {
      this.ZoomTarget = 0.9 / (1 << 5);
    }

    // Lets restrict discrete zoom values to be standard values.
    var windowHeight = this.GetViewport()[3];
    var tmp = Math.round(Math.log(32.0 * windowHeight / this.ZoomTarget) /
                             Math.log(2));
    this.ZoomTarget = 32.0 * windowHeight / Math.pow(2, tmp);

    factor = this.ZoomTarget / this.MainView.Camera.GetHeight(); // Actual factor after limit.

    // Compute translate target to keep position in the same place.
    var fp = this.MainView.Camera.GetWorldFocalPoint();
    this.TranslateTarget[0] = position[0] - factor * (position[0] - fp[0]);
    this.TranslateTarget[1] = position[1] - factor * (position[1] - fp[1]);

    this.RollTarget = this.MainView.Camera.GetWorldRoll();

    this.AnimateLast = new Date().getTime();
    this.AnimateDuration = 200.0; // hard code 200 milliseconds
    this.EventuallyRender(true);
  };

  Viewer.prototype.AnimateZoom = function (factor) {
    // I cannot get the canvas from processing this event too.
    // Issue with double click. Hack to stop double click from firing.
    this.MouseUpTime -= 1000.0;

    if (this.AnimateDuration > 0.0) {
      return;
    }

    var focalPoint = this.GetCamera().GetWorldFocalPoint();
    this.AnimateZoomTo(factor, focalPoint);
  };

  Viewer.prototype.AnimateTranslate = function (dx, dy) {
    var fp = this.MainView.Camera.WorldFocalPoint();
    this.TranslateTarget[0] = fp[0] + dx;
    this.TranslateTarget[1] = fp[1] + dy;

    this.ZoomTarget = this.MainView.Camera.GetHeight();
    this.RollTarget = this.MainView.Camera.GetWorldRoll();

    this.AnimateLast = new Date().getTime();
    this.AnimateDuration = 200.0; // hard code 200 milliseconds
    this.EventuallyRender(true);
  };

  Viewer.prototype.AnimateRoll = function (dRoll) {
    dRoll *= Math.PI / 180.0;
    this.RollTarget = this.MainView.Camera.GetWorldRoll() + dRoll;

    this.ZoomTarget = this.MainView.Camera.GetHeight();
    var fp = this.MainView.Camera.GetWorldFocalPoint();
    this.TranslateTarget[0] = fp[0];
    this.TranslateTarget[1] = fp[1];

    this.AnimateLast = new Date().getTime();
    this.AnimateDuration = 200.0; // hard code 200 milliseconds
    this.EventuallyRender(true);
  };

  Viewer.prototype.AnimateTransform = function (dx, dy, dRoll) {
    var fp = this.MainView.Camera.GetWorldFocalPoint();
    this.TranslateTarget[0] = fp[0] + dx;
    this.TranslateTarget[1] = fp[1] + dy;

    this.RollTarget = this.MainView.Camera.GetWorldRoll() + dRoll;

    this.ZoomTarget = this.MainView.Camera.GetHeight();

    this.AnimateLast = new Date().getTime();
    this.AnimateDuration = 200.0; // hard code 200 milliseconds
    this.EventuallyRender(true);
  };

  Viewer.prototype.DegToRad = function (degrees) {
    return degrees * Math.PI / 180;
  };

  Viewer.prototype.Draw = function () {
    if (SA && SA.RootNote && SA.RootNote.WaterMark) {
      SA.WaterMark = true;
    } else {
      SA.WaterMark = false;
    }

    // I do not think this is actually necessary.
    // I was worried about threads, but javascript does not work that way.
    if (this.Drawing) { return; }
    this.Drawing = true;

    // This just changes the camera based on the current time.
    this.Animate();

    // console.time('ViewerDraw');

    // connectome
    if (!this.MainView || !this.MainView.Section) {
      return;
    }

    // Should the camera have the viewport in them?
    // The do not currently hav a viewport.

    // If we are still waiting for tiles to load, schedule another render.
    // This works fine, but results in many renders while waiting.
    // TODO: Consider having the tile load callback scheduling the next render.
    if (!this.MainView.Draw()) {
      this.EventuallyRender();
    }

    for (var i = 0; i < this.Layers.length; ++i) {
      if (this.Layers[i].Draw) {
        this.Layers[i].Draw(this.MainView);
      }
    }

    // This is not used anymore
    // However, I am thinking of resurecting it.  With many widgets,
    // drawing becomes slow.
    this.MainView.DrawShapes();
    if (this.OverView) {
      this.OverView.Draw();
      this.OverView.DrawOutline(true);
    }

    // Draw a rectangle in the overview representing the camera's view.
    if (this.OverView) {
      this.MainView.Camera.Draw(this.OverView);
      if (this.HistoryFlag) {
        this.OverView.DrawHistory(this.MainView.Viewport[3]);
      }
    }

    if (this.ScaleWidget) {
      // Girder is not setting spacing correct.
      // But we still need the scale widget for the grid widget.
      this.ScaleWidget.Draw(this.MainView);
    }

    // TODO: Drawing correlations should not be embedded in a single
    // viewer. Maybe dualViewWidget or a new stack object should handle it.

    // I am using shift for stack interaction.
    // Turn on the focal point when shift is pressed.
    if (SA.StackCursorFlag && SA.Edit) {
      this.MainView.DrawFocalPoint();
      if (this.StackCorrelations) {
        this.MainView.DrawCorrelations(this.StackCorrelations, this.RecordIndex);
      }
    }

    // Here to trigger SA.FinishedLoadingCallbacks
    SA.LoadQueueUpdate();
    // console.timeEnd('ViewerDraw');
    this.Drawing = false;
  };

  // Makes the viewer clean to setup a new slide...
  Viewer.prototype.Reset = function () {
    this.MomentumX = 0.0;
    this.MomentumY = 0.0;
    this.MomentumRoll = 0.0;
    this.MomentumScale = 0.0;
    if (this.MomentumTimerId) {
      window.cancelAnimationFrame(this.MomentumTimerId);
      this.MomentumTimerId = 0;
    }

    // Keep further touch moves from having any impact.
    this.StartTouchTime = 0;

    this.SetCache(null);
    this.MainView.ShapeList = [];

    for (var i = 0; i < this.Layers.length; ++i) {
      if (this.Layers[i].Reset) {
        this.Layers[i].Reset();
      }
      if (this.Layers[i].Remove) {
        this.Layers[i].Remove();
      }
    }
    this.Layers = [];
  };

  // A list of shapes to render in the viewer
  Viewer.prototype.AddShape = function (shape) {
    this.MainView.AddShape(shape);
  };

  Viewer.prototype.Animate = function () {
    var roll;
    if (this.AnimateDuration <= 0.0) {
      return;
    }
    var timeNow = new Date().getTime();
    if (timeNow >= (this.AnimateLast + this.AnimateDuration)) {
      this.AnimateDuration = 0;
      // We have past the target. Just set the target values.
      this.MainView.Camera.SetHeight(this.ZoomTarget);
      this.MainView.Camera.SetWorldRoll(this.RollTarget);
      this.MainView.Camera.SetWorldFocalPoint([this.TranslateTarget[0],
        this.TranslateTarget[1]]);
      this.ConstrainCamera();
      if (this.OverView) {
        roll = this.RollTarget;
        this.OverView.Parent.css({'transform': 'rotate(' + roll + 'rad'});
        this.OverView.Camera.SetWorldRoll(0);
        this.OverView.Camera.ComputeMatrix();
      }
      this.TriggerEndInteraction();
    } else {
      // Interpolate
      var currentHeight = this.MainView.Camera.GetHeight();
      var currentCenter = this.MainView.Camera.GetWorldFocalPoint();
      var currentRoll = this.MainView.Camera.GetWorldRoll();

      this.MainView.Camera.SetHeight(
        currentHeight + (this.ZoomTarget - currentHeight) *
          (timeNow - this.AnimateLast) / this.AnimateDuration);
      this.MainView.Camera.SetWorldRoll(
        currentRoll + (this.RollTarget - currentRoll) *
          (timeNow - this.AnimateLast) / this.AnimateDuration);
      this.MainView.Camera.SetWorldFocalPoint(
        [currentCenter[0] + (this.TranslateTarget[0] - currentCenter[0]) *
         (timeNow - this.AnimateLast) / this.AnimateDuration,
          currentCenter[1] + (this.TranslateTarget[1] - currentCenter[1]) *
         (timeNow - this.AnimateLast) / this.AnimateDuration]);
      this.ConstrainCamera();
      if (this.OverView) {
        roll = this.MainView.Camera.GetWorldRoll();
        this.OverView.Parent.css({'transform': 'rotate(' + roll + 'rad'});
        this.OverView.Camera.SetWorldRoll(0);
        this.OverView.Camera.ComputeMatrix();
      }
      this.AnimateDuration -= (timeNow - this.AnimateLast);
      // We are not finished yet.
      // Schedule another render
      this.EventuallyRender(true);
    }
    this.MainView.Camera.ComputeMatrix();
    if (this.OverView) {
      this.OverView.Camera.ComputeMatrix();
    }
    this.AnimateLast = timeNow;
    // Synchronize cameras is necessary
  };

  Viewer.prototype.OverViewPlaceCameraPt = function (x, y) {
    if (!this.OverView) {
      return;
    }
    // Compute focal point from inverse overview camera.
    x = x / this.OverView.Viewport[2];
    y = y / this.OverView.Viewport[3];
    var m = this.OverView.Camera.GetWorldMatrix();
    x = (x * 2.0 - 1.0) * m[15];
    y = (1.0 - y * 2.0) * m[15];
    var det = m[0] * m[5] - m[1] * m[4];
    var xNew = (x * m[5] - y * m[4] + m[4] * m[13] - m[5] * m[12]) / det;
    var yNew = (y * m[0] - x * m[1] - m[0] * m[13] + m[1] * m[12]) / det;

    // Animate to get rid of jerky panning (overview to low resolution).
    this.TranslateTarget[0] = xNew;
    this.TranslateTarget[1] = yNew;
    this.AnimateLast = new Date().getTime();
    this.AnimateDuration = 100.0;
    this.EventuallyRender(true);
  };

  // TODO: I think these are legacy and need to be removed.
  Viewer.prototype.SetInteractionEnabled = function (enabled) {
    console.log('Get rid of this');
    this.InteractionEnabled = enabled;
  };
  Viewer.prototype.EnableInteraction = function () {
    console.log('Get rid of this');
    this.InteractionEnabled = true;
  };
  Viewer.prototype.DisableInteraction = function () {
    console.log('Get rid of this');
    this.InteractionEnabled = false;
  };

  // Used to be in EventManager.
  // TODO: Evaluate and cleanup.
  Viewer.prototype.RecordMouseDown = function (event) {
    // Evaluate where LastMouseX / Y are used.
    this.LastMouseX = this.MouseX || 0;
    this.LastMouseY = this.MouseY || 0;
    this.LastMouseTime = this.MouseTime || 0;
    if (!this.SetMousePositionFromEvent(event)) { return false; }

    // TODO:  Formalize a call back to make GUI disappear when
    // navigation starts.  I think I did this already but have not
    // converted this code yet.
    // Get rid of the favorites and the link divs if they are visible
    // if (SA.LinkDiv && SA.LinkDiv.is(':visible')) {
    //  SA.LinkDiv.fadeOut();
    // }
    // if (typeof SA.FAVORITES_WIDGET !== 'undefined' &&
    //       SA.FAVORITES_WIDGET.hidden === false) {
    //  SA.FAVORITES_WIDGET.ShowHideFavorites();
    // }

    var date = new Date();
    this.MouseDownTime = date.getTime();
    // Double click gets stuck on.  We do not really need it.
    // var dTime = date.getTime() - this.MouseUpTime;
    // if (dTime < 200.0) { // 200 milliseconds
    //  this.DoubleClick = true;
    // }

    // this.TriggerStartInteraction();
  };
  // Used to be in EventManager.
  // TODO: Evaluate and cleanup.
  Viewer.prototype.SetMousePositionFromEvent = function (event) {
    var pt = this.GetMousePosition(event);
    if (pt === undefined) {
      return false;
    }
    this.MouseX = pt[0];
    this.MouseY = pt[1];
    // For annotation
    event.MouseX = pt[0];
    event.MouseY = pt[1];
    this.MouseTime = (new Date()).getTime();
    return true;
  };
  Viewer.prototype.RecordMouseMove = function (event) {
    this.LastMouseX = this.MouseX;
    this.LastMouseY = this.MouseY;
    this.LastMouseTime = this.MouseTime;
    if (!this.SetMousePositionFromEvent(event)) { return false; }
    this.MouseDeltaX = this.MouseX - this.LastMouseX;
    this.MouseDeltaY = this.MouseY - this.LastMouseY;
    this.MouseDeltaTime = this.MouseTime - this.LastMouseTime;
    return this.MouseDeltaX !== 0 || this.MouseDeltaY !== 0;
  };
  Viewer.prototype.RecordMouseUp = function (event) {
    if (!this.SetMousePositionFromEvent(event)) { return false; }
    this.MouseDown = false;

    // Record time so we can detect double click.
    var date = new Date();
    this.MouseUpTime = date.getTime();
    this.DoubleClick = false;
  };

  // Save the previous touches and record the new
  // touch locations in viewport coordinates.
  Viewer.prototype.HandleTouch = function (e, startFlag) {
    var date = new Date();
    var t = date.getTime();
    // I have had trouble on the iPad with 0 delta times.
    // Lets see how it behaves with fewer events.
    // It was a bug in iPad4 Javascript.
    // This throttle is not necessary.
    if (t - this.Time < 20 && !startFlag) { return false; }

    this.LastTime = this.Time;
    this.Time = t;

    if (!e) {
      e = event;
    }

    // Still used on mobile devices?
    this.LastTouches = this.Touches;
    this.Touches = [];
    for (var i = 0; i < e.targetTouches.length; ++i) {
      var offset = this.MainView.Canvas.offset();
      var x = e.targetTouches[i].pageX - offset.left;
      var y = e.targetTouches[i].pageY - offset.top;
      this.Touches.push([x, y]);
    }

    this.LastMouseX = this.MouseX;
    this.LastMouseY = this.MouseY;

    // Compute the touch average.
    var numTouches = this.Touches.length;
    this.MouseX = this.MouseY = 0.0;
    for (i = 0; i < numTouches; ++i) {
      this.MouseX += this.Touches[i][0];
      this.MouseY += this.Touches[i][1];
    }
    this.MouseX = this.MouseX / numTouches;
    this.MouseY = this.MouseY / numTouches;

    // Hack because we are moving away from using the event manager
    // Mouse interaction are already independent...
    this.offsetX = this.MouseX;
    this.offsetY = this.MouseY;

    return true;
  };

  Viewer.prototype.HandleTouchStart = function (event) {
    if (!this.InteractionEnabled) { return true; }

    // Stuff from event manager
    this.HandleTouch(event, true);
    this.StartTouchTime = this.Time;

    // Let the annotation layers have first dibs on processing the event.
    for (var i = 0; i < this.Layers.length; ++i) {
      var layer = this.Layers[i];
      if (layer.HandleTouchStart && !layer.HandleTouchStart(event)) {
        return false;
      }
    }

    SA.TriggerStartInteraction();

    this.MomentumX = 0.0;
    this.MomentumY = 0.0;
    this.MomentumRoll = 0.0;
    this.MomentumScale = 0.0;
    if (this.MomentumTimerId) {
      window.cancelAnimationFrame(this.MomentumTimerId);
      this.MomentumTimerId = 0;
    }

    // Four finger grab resets the view.
    if (this.Touches.length >= 4) {
      var cam = this.GetCamera();
      var bds = this.MainView.Section.GetBounds();
      cam.SetWorldFocalPoint([(bds[0] + bds[1]) * 0.5, (bds[2] + bds[3]) * 0.5]);
      cam.SetWorldRoll(0.0);
      cam.SetHeight(bds[3] - bds[2]);
      cam.ComputeMatrix();
      this.EventuallyRender();
      // Return value hides navigation widget
      return true;
    }

    return false;
  };

  Viewer.prototype.HandleTouchMove = function (e) {
    // Case where sweep caused nextNote.
    // Short circuit interaction.
    if (this.StartTouchTime === 0) { return false; }

    // Put a throttle on events
    if (!this.HandleTouch(e, false)) { return; }

    /* the display global is no longer set.
    if (SA.display && SA.display.NavigationWidget &&
        SA.display.NavigationWidget.Visibility) {
      // No slide interaction with the interface up.
      // I had bad interaction with events going to browser.
      SA.display.NavigationWidget.ToggleVisibility();
    }

    if (typeof (SA.MOBILE_ANNOTATION_WIDGET) !== 'undefined' &&
            SA.MOBILE_ANNOTATION_WIDGET.Visibility) {
      // No slide interaction with the interface up.
      // I had bad interaction with events going to browser.
      SA.MOBILE_ANNOTATION_WIDGET.ToggleVisibility();
    }
    */

    // Let the annotation layers have first dibs on processing the event.
    for (var i = 0; i < this.Layers.length; ++i) {
      var layer = this.Layers[i];
      if (layer.HandleTouchMove && !layer.HandleTouchMove(event)) {
        return false;
      }
    }

    // detect sweep
    // Cross the screen in 1/2 second.
    var viewerWidth = this.MainView.Parent.width();
    var dxdt = 1000 * (this.MouseX - this.LastMouseX) / ((this.Time - this.LastTime) * viewerWidth);
    if (SA.display && SA.display.NavigationWidget) {
      if (dxdt > 4.0) {
        SA.display.NavigationWidget.PreviousNote();
        return false;
      }
      if (dxdt < -4.0) {
        SA.display.NavigationWidget.NextNote();
        return false;
      }
    }

    if (this.Touches.length === 1) {
      this.HandleTouchPan(this);
    } else if (this.Touches.length === 2) {
      this.HandleTouchPinch(this);
    } else if (this.Rotatable && this.Touches.length === 3) {
      this.HandleTouchRotate(this);
    }
  };

  // Only one touch
  Viewer.prototype.HandleTouchPan = function (event) {
    if (!this.InteractionEnabled) { return true; }
    if (this.Touches.length !== 1 || this.LastTouches.length !== 1) {
      // Sanity check.
      return;
    }

    // Let the annotation layers have first dibs on processing the event.
    // TODO Either forward primary or secondary events.
    for (var i = 0; i < this.Layers.length; ++i) {
      var layer = this.Layers[i];
      if (layer.HandleTouchPan && !layer.HandleTouchPan(event)) {
        return false;
      }
    }

    // I see an odd intermittent camera matrix problem
    // on the iPad that looks like a thread safety issue.
    if (this.MomentumTimerId) {
      window.cancelAnimationFrame(this.MomentumTimerId);
      this.MomentumTimerId = 0;
    }

    // Convert to world by inverting the camera matrix.
    // I could simplify and just process the vector.
    var w0 = this.ConvertPointViewerToWorld(this.LastMouseX, this.LastMouseY);
    var w1 = this.ConvertPointViewerToWorld(this.MouseX, this.MouseY);

    // This is the new focal point.
    var dx = w1[0] - w0[0];
    var dy = w1[1] - w0[1];
    var dt = event.Time - this.LastTime;

    // Remember the last motion to implement momentum.
    var momentumX = dx / dt;
    var momentumY = dy / dt;

    // Integrate momentum over a time period to avoid a fast event
    // dominating behavior.
    var k = Math.min(this.Time - this.LastTime, 250) / 250;
    this.MomentumX += (momentumX - this.MomentumX) * k;
    this.MomentumY += (momentumY - this.MomentumY) * k;
    this.MomentumRoll = 0.0;
    this.MomentumScale = 0.0;

    var cam = this.GetCamera();
    cam.Translate(-dx, -dy, 0);
    cam.ComputeMatrix();
    this.EventuallyRender(true);
  };

  Viewer.prototype.HandleTouchRotate = function (event) {
    if (!this.InteractionEnabled) { return true; }
    if (!this.Rotatable) { return true; }
    var numTouches = this.Touches.length;
    if (this.LastTouches.length !== numTouches || numTouches !== 3) {
      // Sanity check.
      return;
    }

    // I see an odd intermittent camera matrix problem
    // on the iPad that looks like a thread safety issue.
    if (this.MomentumTimerId) {
      window.cancelAnimationFrame(this.MomentumTimerId);
      this.MomentumTimerId = 0;
    }

    var w0 = this.ConvertPointViewerToWorld(this.LastMouseX, this.LastMouseY);
    var w1 = this.ConvertPointViewerToWorld(this.MouseX, this.MouseY);
    var dt = event.Time - this.LastTime;

    // Compute rotation.
    // Consider weighting rotation by vector length to avoid over contribution of short vectors.
    // We could also take the maximum.
    var x;
    var y;
    var a = 0;
    for (var i = 0; i < numTouches; ++i) {
      x = this.LastTouches[i][0] - this.LastMouseX;
      y = this.LastTouches[i][1] - this.LastMouseY;
      var a1 = Math.atan2(y, x);
      x = this.Touches[i][0] - this.MouseX;
      y = this.Touches[i][1] - this.MouseY;
      a1 = a1 - Math.atan2(y, x);
      if (a1 > Math.PI) { a1 = a1 - (2 * Math.PI); }
      if (a1 < -Math.PI) { a1 = a1 + (2 * Math.PI); }
      a += a1;
    }
    a = a / numTouches;

    // rotation and scale are around the mid point .....
    // we need to compute focal point height and roll (not just a matrix).
    // Focal point is the only difficult item.
    var cam = this.GetCamera();
    var fp = cam.GetWorldFocalPoint();
    w0[0] = fp[0] - w1[0];
    w0[1] = fp[1] - w1[1];
    var c = Math.cos(a);
    var s = Math.sin(a);
    // This is the new focal point.
    x = w1[0] + (w0[0] * c - w0[1] * s);
    y = w1[1] + (w0[0] * s + w0[1] * c);

    // Remember the last motion to implement momentum.
    var momentumRoll = a / dt;

    this.MomentumX = 0.0;
    this.MomentumY = 0.0;
    this.MomentumRoll = (this.MomentumRoll + momentumRoll) * 0.5;
    this.MomentumScale = 0.0;

    cam.SetWorldRoll(cam.GetWorldRoll() - a);
    cam.ComputeMatrix();
    if (this.OverView) {
      var cam2 = this.OverView.Camera;
      cam2.SetWorldRoll(cam.GetWorldRoll());
      cam2.ComputeMatrix();
    }
    this.EventuallyRender(true);
  };

  // I want pinch to be able to zoom and translate.
  Viewer.prototype.HandleTouchPinch = function (event) {
    if (!this.InteractionEnabled) { return true; }
    var numTouches = this.Touches.length;
    if (this.LastTouches.length !== numTouches || numTouches !== 2) {
      // Sanity check.
      return;
    }

    // I see an odd intermittent camera matrix problem
    // on the iPad that looks like a thread safety issue.
    if (this.MomentumTimerId) {
      window.cancelAnimationFrame(this.MomentumTimerId);
      this.MomentumTimerId = 0;
    }

    var w0 = this.ConvertPointViewerToWorld(this.LastMouseX, this.LastMouseY);
    var w1 = this.ConvertPointViewerToWorld(this.MouseX, this.MouseY);
    var dx = w1[0] - w0[0];
    var dy = w1[1] - w0[1];
    var dt = event.Time - this.LastTime;
    // iPad / iPhone must have low precision time
    if (dt === 0) {
      return;
    }

    // Compute scale.
    // Consider weighting rotation by vector length to avoid over contribution of short vectors.
    // We could also take max.
    // This should rarely be an issue and could only happen with 3 or more touches.
    var scale = 1;
    var s0 = 0;
    var s1 = 0;
    var x, y;
    for (var i = 0; i < numTouches; ++i) {
      x = this.LastTouches[i][0] - this.LastMouseX;
      y = this.LastTouches[i][1] - this.LastMouseY;
      s0 += Math.sqrt(x * x + y * y);
      x = this.Touches[i][0] - this.MouseX;
      y = this.Touches[i][1] - this.MouseY;
      s1 += Math.sqrt(x * x + y * y);
    }
    // This should not happen, but I am having trouble with NaN camera parameters.
    if (s0 < 2 || s1 < 2) {
      return;
    }
    scale = s1 / s0;

    // scale is around the mid point .....
    // we need to compute focal point height and roll (not just a matrix).
    // Focal point is the only difficult item.
    var cam = this.GetCamera();
    var fp = cam.GetWorldFocalPoint();
    w0[0] = fp[0] - w1[0] - dx;
    w0[1] = fp[1] - w1[1] - dy;
    // This is the new focal point.
    x = w1[0] + w0[0] / scale;
    y = w1[1] + w0[1] / scale;

    // Remember the last motion to implement momentum.
    var momentumScale = (scale - 1) / dt;

    this.MomentumX = dx / dt;
    this.MomentumY = dy / dt;
    this.MomentumRoll = 0.0;
    this.MomentumScale = (this.MomentumScale + momentumScale) * 0.5;

    cam.SetWorldFocalPoint([x, y]);
    cam.SetHeight(cam.GetHeight() / scale);
    //  cam.Translate(-dx, -dy, 0);
    cam.ComputeMatrix();
    this.EventuallyRender(true);
  };

  Viewer.prototype.HandleTouchEnd = function (event) {
    if (!this.InteractionEnabled) { return true; }

    var date = new Date();
    var dTime = date.getTime() - this.StartTouchTime;
    if (dTime < 200.0) { // 200 milliseconds
      // The mouse down sets the state to drag.
      // Change it back.  We are not going to drag, only a click.
      this.InteractionState = INTERACTION_NONE;
      return this.HandleMouseClick(event);
    }

    // Let the annotation layers have first dibs on processing the event.
    for (var i = 0; i < this.Layers.length; ++i) {
      var layer = this.Layers[i];
      if (layer.HandleTouchEnd && !layer.HandleTouchEnd(event)) {
        return false;
      }
    }

    // Code from a conflict
    var t = new Date().getTime();
    this.LastTime = this.Time;
    this.Time = t;

    var k = Math.min(this.Time - this.LastTime, 250) / 250;

    this.MomentumX = this.MomentumX * (1 - k);
    this.MomentumY = this.MomentumY * (1 - k);
    this.MomentumRoll = this.MomentumRoll * (1 - k);
    this.MomentumScale = this.MomentumScale * (1 - k);

    t = t - this.StartTouchTime;
    if (event.targetTouches.length === 0 && SAM.MOBILE_DEVICE) {
      this.StartTouchTime = 0;
      if (t < 90) {
        // We should not have a navigation widget on mobile
        // devices. (maybe iPad?).
        if (SA.display && SA.display.NavigationWidget) {
          SA.display.NavigationWidget.ToggleVisibility();
        }
        if (typeof (SA.MOBILE_ANNOTATION_WIDGET) !== 'undefined') {
          SA.MOBILE_ANNOTATION_WIDGET.ToggleVisibility();
        }
        return;
      }
      if (this.ActiveWidget !== undefined) {
        this.ActiveWidget.HandleTouchEnd(event);
        return;
      }
      // this.UpdateZoomGui();
      this.HandleMomentum();
    }
    // end conflict

    // this.UpdateZoomGui();
    this.HandleMomentum(event);

    // Use this as a flag to indicate ongoing interation (sweep, next
    // note .
    this.StartTouchTime = 0;
  };

  Viewer.prototype.HandleMomentum = function () {
    var self = this;
    // I see an odd intermittent camera matrix problem
    // on the iPad that looks like a thread safety issue.
    if (this.MomentumTimerId) {
      window.cancelAnimationFrame(this.MomentumTimerId);
      this.MomentumTimerId = 0;
    }

    var t = new Date().getTime();
    if (t - this.LastTime < 50) {
      this.MomentumTimerId = window.requestAnimationFrame(function () { self.HandleMomentum(); });
      return;
    }

    // Integrate the momentum.
    this.LastTime = this.Time;
    this.Time = t;
    var dt = this.Time - this.LastTime;

    var k = 200.0;
    var decay = Math.exp(-dt / k);
    var integ = (-k * decay + k);

    var cam = this.MainView.Camera;
    cam.Translate(-(this.MomentumX * integ), -(this.MomentumY * integ), 0);
    cam.SetHeight(cam.Height / ((this.MomentumScale * integ) + 1));
    cam.SetWorldRoll(cam.GetWorldRoll() - (this.MomentumRoll * integ));
    cam.ComputeMatrix();
    if (this.OverView) {
      var cam2 = this.OverView.Camera;
      cam2.SetWorldRoll(cam.GetWorldRoll());
      cam2.ComputeMatrix();
    }
    // I think the problem with the ipad is thie asynchronous render.
    // Maybe two renders occur at the same time.
    // this.EventuallyRender();
    this.Draw();

    // Decay the momentum.
    this.MomentumX *= decay;
    this.MomentumY *= decay;
    this.MomentumScale *= decay;
    this.MomentumRoll *= decay;

    if (Math.abs(this.MomentumX) < 0.01 && Math.abs(this.MomentumY) < 0.01 &&
            Math.abs(this.MomentumRoll) < 0.0002 && Math.abs(this.MomentumScale) < 0.00005) {
      // Change is small. Stop the motion.
      this.MomentumTimerId = 0;
      if (this.InteractionState !== INTERACTION_NONE) {
        this.InteractionState = INTERACTION_NONE;
        this.TriggerEndInteraction();
      }
    } else {
      this.MomentumTimerId = window.requestAnimationFrame(function () { self.HandleMomentum(); });
    }
  };

  Viewer.prototype.ConstrainCamera = function () {
    var bounds = this.GetOverViewBounds();
    if (!bounds) {
      // Cache has not been set.
      return;
    }
    var spacing = this.MainView.GetLeafSpacing();
    var viewport = this.MainView.GetViewport();
    var cam = this.MainView.Camera;

    var modified = false;
    var fp = cam.GetWorldFocalPoint();
    if (fp[0] < bounds[0]) {
      cam.SetWorldFocalPoint([bounds[0], fp[1]]);
      modified = true;
    }
    if (fp[0] > bounds[1]) {
      cam.SetWorldFocalPoint([bounds[1], fp[1]]);
      modified = true;
    }
    if (fp[1] < bounds[2]) {
      cam.SetWorldFocalPoint([fp[0], bounds[2]]);
      modified = true;
    }
    if (fp[1] > bounds[3]) {
      cam.SetWorldFocalPoint([fp[0], bounds[3]]);
      modified = true;
    }
    var heightMax = 2 * (bounds[3] - bounds[2]);
    if (cam.GetHeight() > heightMax) {
      cam.SetHeight(heightMax);
      // this.ZoomTarget = heightMax;
      modified = true;
    }
    var heightMin = viewport[3] * spacing * this.MinPixelSize;
    if (cam.GetHeight() < heightMin) {
      cam.SetHeight(heightMin);
      // this.ZoomTarget = heightMin;
      modified = true;
    }
    if (modified) {
      cam.ComputeMatrix();
    }
  };

  Viewer.prototype.HandleMouseClick = function (event) {
    if (!this.InteractionEnabled) { return true; }

    // Let the annotation layers have first dibs on processing the event.
    for (var i = 0; i < this.Layers.length; ++i) {
      var layer = this.Layers[i];
      if (layer.HandleMouseClick && !layer.HandleMouseClick(event)) {
        return false;
      }
    }
    return true;
  };

  Viewer.prototype.HandleMouseDown = function (event) {
    this.Shift = event.shiftKey;
    // Hack.  I am getting multiple mouse down and mouse up for a single click.
    // This will make sure we only respond to one.
    this.MouseDownFlag = true;
    if (!this.InteractionEnabled) { return true; }

    this.FirefoxWhich = event.which;
    event.preventDefault(); // Keep browser from selecting images.
    this.RecordMouseDown(event);

    if (this.RotateIconDrag) {
      // Problem with leaving the browser with mouse down.
      // This is a mouse down outside the icon, so the mouse must
      // have been let up and we did not get the event.
      this.RotateIconDrag = false;
    }

    if (this.DoubleClick) {
      // Without this, double click selects sub elementes.
      event.preventDefault();
      return this.HandleDoubleClick(event);
    }

    // Let the annotation layers have first dibs on processing the event.
    for (var i = 0; i < this.Layers.length; ++i) {
      var layer = this.Layers[i];
      if (layer.HandleMouseDown && !layer.HandleMouseDown(event)) {
        return false;
      }
    }

    // Choose what interaction will be performed.
    if (event.which === 1) {
      if (event.ctrlKey) {
        if (this.Rotatable) { this.InteractionState = INTERACTION_ROTATE; }
      } else if (event.altKey) {
        this.InteractionState = INTERACTION_ZOOM;
      } else {
        this.InteractionState = INTERACTION_DRAG;
      }
      return false;
    }
    if (event.which === 2 && this.Rotatble) {
      this.InteractionState = INTERACTION_ROTATE;
      return false;
    }
    return true;
  };

  Viewer.prototype.HandleDoubleClick = function (event) {
    if (!this.InteractionEnabled) { return true; }

    // Let the annotation layers have first dibs on processing the event.
    for (var i = 0; i < this.Layers.length; ++i) {
      var layer = this.Layers[i];
      if (layer.HandleDoubleClick && !layer.HandleDoubleClick(event)) {
        return false;
      }
    }

    var mWorld = this.ConvertPointViewerToWorld(event.offsetX, event.offsetY);
    if (event.which === 1) {
      this.AnimateZoomTo(0.5, mWorld);
    } else if (event.which === 3) {
      this.AnimateZoomTo(2.0, mWorld);
    }
    return true;
  };

  Viewer.prototype.HandleMouseUp = function (event) {
    // Hack.  I am getting multiple mouse down and mouse up for a single click.
    // This will make sure we only respond to one.
    if (!this.MouseDownFlag) {
      return;
    }
    this.MouseDownFlag = false;
    if (!this.InteractionEnabled) { return true; }
    var date = new Date();
    this.MouseUpTime = date.getTime();

    var dTime = date.getTime() - this.MouseDownTime;
    if (dTime < 200.0) { // 200 milliseconds
      // The mouse down sets the state to drag.
      // Change it back.  We are not going to drag, only a click.
      this.InteractionState = INTERACTION_NONE;
      return this.HandleMouseClick(event);
    }

    this.FirefoxWhich = 0;
    this.RecordMouseUp(event);

    if (this.RotateIconDrag) {
      this.RollUp(event);
      return false;
    }

    // Let the annotation layers have first dibs on processing the event.
    for (var i = 0; i < this.Layers.length; ++i) {
      var layer = this.Layers[i];
      if (layer.HandleMouseUp && !layer.HandleMouseUp(event)) {
        this.InteractionState = INTERACTION_NONE;
        return false;
      }
    }

    if (this.InteractionState === INTERACTION_OVERVIEW ||
        this.InteractionState === INTERACTION_OVERVIEW_DRAG) {
      return this.HandleOverViewMouseUp(event);
    }

    if (this.InteractionState !== INTERACTION_NONE) {
      this.InteractionState = INTERACTION_NONE;
      this.TriggerEndInteraction();
    }

    return false; // trying to keep the browser from selecting images
  };

  // I forget why this is necesary. Firefox, MS Edge?
  Viewer.prototype.GetEventOffset = function (event) {
    if (event.offsetX && event.offsetY) {
      return [event.offsetX, event.offsetY];
    } else if (event.layerX && event.layerY) {
      return [event.layerX, event.layerY];
    }
    return undefined;
  };

  // Relative to the div receiving the event. I do not know why this is so hard.
  // The event has postiion relative to the local child, or top window.
  // I might consider adding a class to divs that are 'transparent' to events.
  Viewer.prototype.GetMousePosition = function (event) {
    // Possibly a child.
    var pt = this.GetEventOffset(event);
    if (pt === undefined) {
      return undefined;
    }
    var element = event.target;
    if (element === this.Div[0]) {
      return pt;
    }

    // look one parent up.
    pt[0] += element.offsetLeft;
    pt[1] += element.offsetTop;
    element = element.parentElement;
    if (element === this.Div[0]) {
      return pt;
    }

    // one more.
    pt[0] += element.offsetLeft;
    pt[1] += element.offsetTop;
    element = element.parentElement;
    if (element === this.Div[0]) {
      return pt;
    }

    return undefined;
  };

  Viewer.prototype.HandleMouseMove = function (event) {
    if (!this.InteractionEnabled) { return true; }

    var pt = this.GetMousePosition(event);
    if (pt === undefined) {
      return true;
    }

    if (!this.RecordMouseMove(event)) { return true; }

    // I think we need to deal with the move here because the mouse can
    // exit the icon and the events are lost.
    if (event.which === 1 && this.Rotatable && this.RotateIconDrag) {
      this.RollMove(event);
      return false;
    }

    // Let the annotation layers have first dibs on processing the event.
    for (var i = 0; i < this.Layers.length; ++i) {
      var layer = this.Layers[i];
      if (layer.HandleMouseMove && !layer.HandleMouseMove(event)) {
        return false;
      }
    }

    // Arrow now tracks the mouse when first created (and no button pressed).
    // We no longer have any action for moving the mouse when no button is pressed.
    if (event.which === 0) {
      this.InteractionState = INTERACTION_NONE;
      return true;
    }

    if (this.InteractionState === INTERACTION_OVERVIEW ||
        this.InteractionState === INTERACTION_OVERVIEW_DRAG) {
      return this.HandleOverViewMouseMove(event);
    }

    if (this.InteractionState === INTERACTION_NONE) {
      // Allow the ResizePanel drag to process the events.
      return true;
    }

    var x = pt[0];
    var y = pt[1];
    var dx;
    var dy;

    // Drag camera in main view.
    // Dragging is too slow.  I want to accelerate dragging the further
    // this mouse moves.  This is a moderate change, so I am
    // going to try to accelerate with speed.
    if (this.InteractionState === INTERACTION_ROTATE) {
      // Rotate
      // Origin in the center.
      // GLOBAL GL will use view's viewport instead.
      var cx = x - (this.MainView.Viewport[2] * 0.5);
      var cy = y - (this.MainView.Viewport[3] * 0.5);
      // GLOBAL views will go away when views handle this.
      this.MainView.Camera.HandleRoll(cx, cy,
                                      this.MouseDeltaX,
                                      this.MouseDeltaY);
      this.RollTarget = this.MainView.Camera.GetWorldRoll();
      this.UpdateCamera();
    } else if (this.InteractionState === INTERACTION_ZOOM) {
      dy = this.MouseDeltaY / this.MainView.Viewport[2];
      this.MainView.Camera.SetHeight(this.MainView.Camera.GetHeight() /
                                           (1.0 + (dy * 5.0)));
      this.ZoomTarget = this.MainView.Camera.GetHeight();
      this.UpdateCamera();
    } else if (this.InteractionState === INTERACTION_DRAG) {
      // Translate
      // Convert to view [-0.5,0.5] coordinate system.
      // Note: the origin gets subtracted out in delta above.
      dx = -this.MouseDeltaX / this.MainView.Viewport[2];
      dy = -this.MouseDeltaY / this.MainView.Viewport[2];
      // compute the speed of the movement.
      var speed = Math.sqrt(dx * dx + dy * dy) / this.MouseDeltaTime;
      speed = 1.0 + speed * 1000; // f(0) = 1 and increasing.
      // I am not sure I like the speed acceleration.
            // Lets try a limit.
      if (speed > 3.0) { speed = 3.0; }
      dx = dx * speed;
      dy = dy * speed;
      this.MainView.Camera.HandleTranslate(dx, dy, 0.0);
      this.ConstrainCamera();
    }
    // The only interaction that does not go through animate camera.
    this.TriggerInteraction();
    this.EventuallyRender(true);

    x = event.offsetX;
    y = event.offsetY;

    return false;
  };

  Viewer.prototype.HandleMouseWheel = function (event) {
    if (!this.InteractionEnabled) { return true; }

    // Decay computations.
    this.MouseTime = (new Date()).getTime();
    if (this.LastMouseTime) {
      var dt = this.MouseTime - this.LastMouseTime;
      this.WheelSensitivity *= Math.exp(-dt / this.WheelTimeConstant);
      // console.log(dt);
    }
    this.LastMouseTime = this.MouseTime;
    this.WheelSensitivity += this.WheelAcceleration;
    if (this.WheelSensitivity > 0.2) {
      this.WheelSensitivity = 0.2;
    }

    // console.log(this.WheelSensitivity);

    if (!event.offsetX) {
      // for firefox
      event.offsetX = event.layerX;
      event.offsetY = event.layerY;
    }

    // Let the annotation layers have first dibs on processing the event.
    for (var i = 0; i < this.Layers.length; ++i) {
      var layer = this.Layers[i];
      if (layer.HandleMouseWheel && !layer.HandleMouseWheel(event)) {
        return false;
      }
    }

    // We want to accumulate the target, but not the duration.
    var tmp = 0;
    if (event.deltaY) {
      tmp = event.deltaY;
    } else if (event.wheelDelta) {
      tmp = event.wheelDelta;
    }
    // Wheel event seems to be in increments of 3.
    // depreciated mousewheel had increments of 120....
    // Initial delta cause another bug.
    // Lets restrict to one zoom step per event.
    if (tmp > 0) {
      this.ZoomTarget *= (1.0 + this.WheelSensitivity);
    } else if (tmp < 0) {
      this.ZoomTarget /= (1.0 + this.WheelSensitivity);
    }

    // Compute translate target to keep position in the same place.
    var position = this.ConvertPointViewerToWorld(event.offsetX, event.offsetY);
    var factor = this.ZoomTarget / this.MainView.Camera.GetHeight();
    var fp = this.MainView.Camera.GetWorldFocalPoint();
    this.TranslateTarget[0] = position[0] -
            factor * (position[0] - fp[0]);
    this.TranslateTarget[1] = position[1] -
            factor * (position[1] - fp[1]);

    this.RollTarget = this.MainView.Camera.GetWorldRoll();

    this.AnimateLast = new Date().getTime();
    this.AnimateDuration = 200.0; // hard code 200 milliseconds
    this.EventuallyRender(true);
    return false;
  };

  // returns false if the event was 'consumed' (browser convention).
  // Returns true if nothing was done with the event.
  Viewer.prototype.HandleKeyDown = function (event) {
    SAM.ShiftKey = event.shiftKey;
    SAM.ControlKey = event.ctrlKey;

    if (!this.InteractionEnabled) { return true; }

    // Key events are not going first to layers like mouse events.
    // Give layers a change to process them.
    for (var i = 0; i < this.Layers.length; ++i) {
      if (this.Layers[i].HandleKeyDown && !this.Layers[i].HandleKeyDown(event)) {
        return false;
      }
    }

    if (event.keyCode === 83 && event.ctrlKey) { // control -s to save.
      if (!SAVING_IMAGE) {
        SAVING_IMAGE = new SAM.Dialog();
        SAVING_IMAGE.Title.text('Saving');
        SAVING_IMAGE.Body.css({'margin': '1em 2em'});
        SAVING_IMAGE.WaitingImage = $('<img>')
                    .appendTo(SAVING_IMAGE.Body)
                    .attr('src', SA.ImagePathUrl + 'circular.gif')
                    .attr('alt', 'waiting...')
                    .addClass('sa-view-save');
        SAVING_IMAGE.ApplyButton.hide();
        SAVING_IMAGE.SavingFlag = false;
        SAVING_IMAGE.Count = 0;
      }
      if (!SAVING_IMAGE.SavingFlag) {
        SAVING_IMAGE.SavingFlag = true;
        SAVING_IMAGE.Show(1);
        this.EventuallySaveImage(
          'slideAtlas' + SA.ZERO_PAD(SAVING_IMAGE.Count, 3),
           function () {
             SAVING_IMAGE.SavingFlag = false;
             SAVING_IMAGE.Count += 1;
             SAVING_IMAGE.Hide();
           }
         );
      }

      return false;
    }

    // Handle paste
    if (event.keyCode === 79) {
      // o to print out world mouse location for debugging.
      // var wPt = this.ConvertPointViewerToWorld(this.LastMouseX, this.LastMouseY);
    }

    if (String.fromCharCode(event.keyCode) === 'R') {
      // this.MainView.Camera.Reset();
      this.MainView.Camera.ComputeMatrix();
      this.ZoomTarget = this.MainView.Camera.GetHeight();
      this.EventuallyRender(true);
      return false;
    }

    var cam, idx;
    var dx, dy, rx, ry;
    cam = this.GetCamera();
    var roll = cam.GetWorldRoll();
    var fp = cam.GetWorldFocalPoint();
    var c = Math.cos(roll);
    var s = -Math.sin(roll);
    if (event.keyCode === 38) {
      // Up cursor key
      if (event.ctrlKey) {
        // Rotate to the next 90 degree lock.
        idx = (this.MainView.Camera.GetWorldRoll() / (Math.PI * 0.5)) - 0.01;
        idx = Math.floor(idx);
        this.RollTarget = idx * Math.PI * 0.5;
      } else {
        dx = 0.0;
        dy = -0.5 * cam.GetHeight();
        rx = dx * c - dy * s;
        ry = dx * s + dy * c;
        this.TranslateTarget[0] = fp[0] + rx;
        this.TranslateTarget[1] = fp[1] + ry;
      }
      this.AnimateLast = new Date().getTime();
      this.AnimateDuration = 200.0;
      this.EventuallyRender(true);
      return false;
    } else if (event.keyCode === 40) {
      // Down cursor key
      if (event.ctrlKey) {
        // Rotate to the next 90 degree lock.
        idx = (this.MainView.Camera.GetWorldRoll() / (Math.PI * 0.5)) + 0.01;
        idx = Math.ceil(idx);
        this.RollTarget = idx * Math.PI * 0.5;
      } else {
        dx = 0.0;
        dy = 0.5 * cam.GetHeight();
        rx = dx * c - dy * s;
        ry = dx * s + dy * c;
      }
      this.TranslateTarget[0] = fp[0] + rx;
      this.TranslateTarget[1] = fp[1] + ry;
      this.AnimateLast = new Date().getTime();
      this.AnimateDuration = 200.0;
      this.EventuallyRender(true);
      return false;
    } else if (event.keyCode === 37) {
      // Left cursor key
      if (event.ctrlKey) {
        // Rotate by 90 degrees.
        this.RollTarget = this.MainView.Camera.GetWorldRoll() -
          Math.PI / 2.0;
      } else {
        dx = -0.5 * cam.GetWidth();
        dy = 0.0;
        rx = dx * c - dy * s;
        ry = dx * s + dy * c;
        this.TranslateTarget[0] = fp[0] + rx;
        this.TranslateTarget[1] = fp[1] + ry;
      }
      this.AnimateLast = new Date().getTime();
      this.AnimateDuration = 200.0;
      this.EventuallyRender(true);
      return false;
    } else if (event.keyCode === 39) {
      // Right cursor key
      if (event.ctrlKey) {
        // Rotate by 90 degrees.
        this.RollTarget = this.MainView.Camera.GetWorldRoll() +
          Math.PI / 2.0;
      } else {
        dx = 0.5 * cam.GetWidth();
        dy = 0.0;
        rx = dx * c - dy * s;
        ry = dx * s + dy * c;
        this.TranslateTarget[0] = fp[0] + rx;
        this.TranslateTarget[1] = fp[1] + ry;
      }
      this.AnimateLast = new Date().getTime();
      this.AnimateDuration = 200.0;
      this.EventuallyRender(true);
      return false;
    }

    if (event.keyCode === 27 && this.EscapeCallback) {
      this.EscapeCallback();
    }

    return true;
  };

  // returns false if the event was 'consumed' (browser convention).
  // Returns true if nothing was done with the event.
  Viewer.prototype.HandleKeyUp = function (event) {
    SAM.ShiftKey = event.shiftKey;
    SAM.ControlKey = event.ctrlKey;

    if (!this.InteractionEnabled) { return true; }

    // Let the annotation layers have first dibs on processing the event.
    var i;
    for (i = 0; i < this.Layers.length; ++i) {
      var layer = this.Layers[i];
      if (layer.HandleKeyUp && !layer.HandleKeyUp(event)) {
        return false;
      }
    }

    // Copy paste error?
    // Key events are not going first to layers like mouse events.
    // Give layers a change to process them.
    // for (i = 0; i < this.Layers.length; ++i) {
    //  if (this.Layers[i].HandleKeyUp && !this.Layers[i].HandleKeyUp(event)) {
    //    return false;
    //  }
    // }
    return true;
  };

  // Get the current scale factor between pixels and world units.
  Viewer.prototype.GetPixelsPerUnit = function () {
    return this.MainView.GetPixelsPerUnit();
  };

  Viewer.prototype.GetMetersPerUnit = function () {
    return this.MainView.GetMetersPerUnit();
  };

  // Covert a point from world coordiante system to viewer coordinate system (units pixels).
  Viewer.prototype.ConvertPointWorldToViewer = function (x, y) {
    var cam = this.MainView.Camera;
    return cam.ConvertPointWorldToViewer(x, y);
  };

  Viewer.prototype.ConvertPointViewerToWorld = function (x, y) {
    var cam = this.MainView.Camera;
    return cam.ConvertPointViewerToWorld(x, y);
  };

  // ==============================================================================
  // OverView slide widget stuff.

  Viewer.prototype.OverViewCheckActive = function (event) {
    if (!this.OverView) {
      return false;
    }
    var x = event.offsetX;
    var y = event.offsetY;
    // Half height and width
    var hw = this.OverViewport[2] / 2;
    var hh = this.OverViewport[3] / 2;
    // Center of the overview.
    var cx = this.OverViewport[0] + hw;
    var cy = this.OverViewport[1] + hh;

    x = x - cx;
    y = y - cy;
    // Rotate into overview slide coordinates.
    var roll = this.MainView.Camera.GetWorldRoll();
    var c = Math.cos(roll);
    var s = Math.sin(roll);
    var nx = Math.abs(c * x + s * y);
    var ny = Math.abs(c * y - s * x);
    if ((Math.abs(hw - nx) < 5 && ny < hh) ||
            (Math.abs(hh - ny) < 5 && nx < hw)) {
      this.OverViewActive = true;
      this.OverView.Parent.addClass('sa-view-overview-canvas sa-active');
    } else {
      this.OverViewActive = false;
      this.OverView.Parent.removeClass('sa-view-overview-canvas sa-active');
    }
    // return this.OverViewActive;
  };

  // Interaction events that change the main camera.

  // Resize of overview window will be drag with left mouse.
  // Reposition camera with left click (no drag).
  // Removing drag camera in overview.

  // TODO: Make the overview slide a widget.
  Viewer.prototype.HandleOverViewMouseDown = function (event) {
    if (!this.InteractionEnabled) { return true; }
    if (this.RotateIconDrag) { return; }

    this.InteractionState = INTERACTION_OVERVIEW;

    // Delay actions until we see if it is a drag or click.
    this.OverViewEventX = event.pageX;
    this.OverViewEventY = event.pageY;

    // Now that I do not drag the overview window tosize it,
    // This is simple.  TODO: Clean up modes and other leftover code.
    this.OverViewPlaceCamera(event);

    return false;
  };

  Viewer.prototype.HandleOverViewMouseUp = function (event) {
    if (!this.InteractionEnabled) { return true; }
    if (this.RotateIconDrag) { return; }

    // This target for animation is not implemented cleanly.
    // This fixes a bug: OverView translated rotates camamera back to zero.
    this.RollTarget = this.MainView.Camera.GetWorldRoll();

    this.OverViewPlaceCamera(event);

    this.InteractionState = INTERACTION_NONE;

    return false;
  };

  Viewer.prototype.OverViewPlaceCamera = function (event) {
    if (event.which === 1) {
      var x = event.offsetX;
      var y = event.offsetY;
      if (x === undefined) { x = event.layerX; }
      if (y === undefined) { y = event.layerY; }
      // Transform to view's coordinate system.
      this.OverViewPlaceCameraPt(x, y);
    }
  };

  Viewer.prototype.HandleOverViewMouseWheel = function (event) {
    // This is needed to keep resizing the overview if the events
    // move tothe viewer proper.
    // event.wheelDelta;
    // return false;

    this.InteractionState = INTERACTION_OVERVIEW_WHEEL;

    var tmp = 0;
    if (event.deltaY) {
      tmp = event.deltaY;
    } else if (event.wheelDelta) {
      tmp = event.wheelDelta;
    }

    if (tmp > 0) {
      this.OverViewScale *= 1.2;
    } else if (tmp < 0) {
      this.OverViewScale /= 1.2;
    }

    // overview scale is the fraction of the area of
    // the window covered by the overview window.
    var width = this.MainView.GetWidth();
    var height = this.MainView.GetHeight();
    var area = width * height;
    var bounds = this.GetOverViewBounds();
    var aspect = (bounds[1] - bounds[0]) / (bounds[3] - bounds[2]);
    // size of overview
    var h = Math.sqrt(area * this.OverViewScale / aspect);
    var w = h * aspect;

    if (w < 60) {
      this.RotateIcon.hide();
    } else {
      if (this.Rotatable) { this.RotateIcon.show(); }
    }

    this.UpdateSize();

    return false;
  };

  Viewer.prototype.HandleOverViewMouseMove = function (event) {
    if (!this.InteractionEnabled) { return true; }
    if (event.which === 1 && this.RotateIconDrag) {
      this.RollMove(event);
      return false;
    }

    this.OverViewPlaceCamera(event);

    return false;
  };

  Viewer.prototype.SetZoomWidgetVisibility = function (vis) {
    if (vis) {
      if (!this.ZoomTab) {
        this.InitializeZoomGui();
      }
      this.ZoomTab.show();
    } else {
      if (this.ZoomTab) {
        this.ZoomTab.hide();
      }
    }
  };

  Viewer.prototype.SetCopyrightVisibility = function (vis) {
    if (vis) {
      this.CopyrightWrapper.show();
    } else {
      this.CopyrightWrapper.hide();
    }
  };

  // ------------------------------------------------------
  // Access methods for vigilant

  Viewer.prototype.GetNumberOfLayers = function () {
    return this.Layers.length;
  };
  Viewer.prototype.GetLayer = function (idx) {
    if (idx >= 0 && idx < this.Layers.length) {
      return this.Layers[idx];
    }
    return null;
  };
  Viewer.prototype.RemoveLayer = function (layer) {
    var idx = this.Layers.indexOf(layer);
    if (idx < 0) {
      return;
    }
    this.Layers.splice(idx, 1);
  };

  // TODO:
  // Get rid of this.
  Viewer.prototype.NewAnnotationLayer = function () {
    // Create an annotation layer by default.
    var annotationLayer = new SAM.AnnotationLayer(this.Div);
    // Only for the text widget (dialog).
    // It needs to turn off events to make the text input work.
    annotationLayer.SetViewer(this);
    // Lets just shallow copy the camera.
    annotationLayer.SetCamera(this.GetCamera());

    this.AddLayer(annotationLayer);
    // TODO: Get rid of this.  master view is passed to draw.
    // Hack so the scale widget can get the spacing.
    annotationLayer.ScaleWidget.View = this.MainView;
    // Hack only used for girder testing.
    annotationLayer.Viewer = this;
    annotationLayer.UpdateSize();

    return annotationLayer;
  };

  Viewer.prototype.NewViewLayer = function () {
    // Create an annotation layer by default.
    var viewLayer = new SA.TileView(this.Div, false);
    this.AddLayer(viewLayer);
    viewLayer.UpdateSize();

    return viewLayer;
  };

  Viewer.prototype.TriggerEndInteraction = function () {
    this.UpdateZoomGui();

    // Save the state when the animation is finished.
    if (SA.RECORDER_WIDGET) {
      SA.RECORDER_WIDGET.RecordState();
    }

    // Update the url to the current view.
    var cam = this.GetCamera();
    var fp = cam.GetWorldFocalPoint();
    var width = Math.round(cam.GetWidth());
    var height = Math.round(cam.GetHeight());
    var left = Math.round(fp[0] - width / 2);
    var top = Math.round(fp[1] - height / 2);
    var rot = Math.round(cam.GetWorldRotation());

    // TODO: Fix this
    // Image._id is just a random id.
    // var imageId = this.GetCache().Image._id;
    // Hack to get th real id from a tile url.
    var url = this.GetCache().TileSource.getTileUrl(0, 0, 0, 0);
    var imageId = url.split('/')[3];

    url = window.location.href;
    var end = url.indexOf('item/');
    url = url.substr(0, end + 4);
    url = url + '/' + imageId + '?bounds=' + left + ',' + top +
      ',' + (left + width) + ',' + (top + height);

    if (rot !== 0) {
      url += '&rotate=' + rot;
    }

    this.ShareDisplay.text(url);
  };

  // ------------------------------------------------------

  SA.Viewer = Viewer;
})();

(function () {
  'use strict';

  // ==============================================================================
  // A correlation is just a pair of matching points from two sections.
  // Abstract the correlation so we have an api for getting points.
  // Currently, stack has direct access to correlation ivars / points.
  // The api will make forward and back transformations use the same code.

  function PairCorrelation () {
    this.point0 = [0, 0];
    this.point1 = [0, 0];
    this.Roll = 0;
    this.Height = 0;
  }

  PairCorrelation.prototype.Serialize = function () {
    return {'point0': [this.point0[0], this.point0[1]],
      'point1': [this.point1[0], this.point1[1]],
      'roll': this.Roll,
      'height': this.Height};
  };

  PairCorrelation.prototype.Load = function (obj) {
    this.point0[0] = obj.point0[0];
    this.point0[1] = obj.point0[1];
    this.point1[0] = obj.point1[0];
    this.point1[1] = obj.point1[1];
    if (obj.roll) {
      this.Roll = obj.roll;
    }
    if (obj.height) {
      this.Height = obj.height;
    }
  };

    // Idx changes the ordedr of the points and sign of delta roll.
  PairCorrelation.prototype.GetRoll = function (idx) {
    if (idx !== undefined && idx === 0) {
      return -this.Roll;
    } else {
      return this.Roll;
    }
  };

  PairCorrelation.prototype.GetPoint = function (idx) {
    if (idx === 0) {
      return this.GetPoint0();
    } else if (idx === 1) {
      return this.GetPoint1();
    }
    alert('Bad correlation point index: ' + idx);
    return [0, 0];
  };

  PairCorrelation.prototype.GetPoint0 = function () {
    return [this.point0[0], this.point0[1]];
  };

  PairCorrelation.prototype.SetPoint0 = function (pt) {
    this.point0[0] = pt[0];
    this.point0[1] = pt[1];
  };

  PairCorrelation.prototype.GetPoint1 = function () {
    return [this.point1[0], this.point1[1]];
  };

  PairCorrelation.prototype.SetPoint1 = function (pt) {
    this.point1[0] = pt[0];
    this.point1[1] = pt[1];
  };

  PairCorrelation.prototype.SetRoll = function (roll) {
    this.Roll = roll;
  };

  PairCorrelation.prototype.SetHeight = function (height) {
    this.Height = height;
  };

    // ==============================================================================
    // This object abstract the warp transformation between a pair of sections.

  function PairTransformation () {
    this.Correlations = [];
  }

  PairTransformation.prototype.Serialize = function () {
    return JSON.parse(JSON.stringify(this));
  };

  PairTransformation.prototype.Load = function (obj) {
    for (var ivar in obj) {
      this[ivar] = obj[ivar];
    }
  };

  PairTransformation.prototype.AddCorrelation = function (pt0, pt1) {
    var index = this.Correlations.length;
    var corr = new SA.PairCorrelation();
    corr.SetPoint0(pt0);
    corr.SetPoint1(pt1);
    this.Correlations.push(corr);
    return index;
  };

  PairTransformation.prototype.Load = function (obj) {
        // Views are not used anymore for viewer record stacks.
    if (obj.View0) {
      this.View0 = obj.View0;
    }
    if (obj.View1) {
      this.View1 = obj.View1;
    }
    for (var i = 0; i < obj.Correlations.length; ++i) {
      var correlation = new SA.PairCorrelation();
      correlation.Load(obj.Correlations[i]);
      this.Correlations.push(correlation);
    }
  };

    // Weighted neighbor.
    // Until we implement a closed form solution:
    // Compute the weighted average of points as center of rotation and translation.
  PairTransformation.prototype.WeightedTransform = function (idx0, idx1, fpIn, sigma) {
    var fpOut = [fpIn[0], fpIn[1]];
    if (this.Correlations.length === 0) {
      return fpOut;
    }

    if (sigma === undefined) {
      sigma = 20000;
    }

    if (this.Correlations.length === 0) {
      fpOut[0] = fpIn[0];
      fpOut[1] = fpIn[1];
      this.DeltaRoll = 0;
      return fpOut;
    }

    var correlation;
    var c;
    var s;
    var pt0, pt1;
    if (this.Correlations.length <= 1) {
      correlation = this.Correlations[0];
      this.DeltaRoll = correlation.GetRoll(idx1);
      pt0 = correlation.GetPoint(idx0);
      var dx = fpIn[0] - pt0[0];
      var dy = fpIn[1] - pt0[1];
      c = Math.cos(this.DeltaRoll);
      s = Math.sin(this.DeltaRoll);
      pt1 = correlation.GetPoint(idx1);
      fpOut[0] = c * dx + s * dy + pt1[0];
      fpOut[1] = c * dy - s * dx + pt1[1];
      return fpOut;
    }

    // Compute the average weighted correlation point for each image.
    var x, y;
    var sigma2 = sigma * sigma;
    var sumGauss = 0.0;
    var sum0 = [0.0, 0.0];
    var sum1 = [0.0, 0.0];
    var gauss;
    for (var i = 0; i < this.Correlations.length; ++i) {
      correlation = this.Correlations[i];
      pt0 = correlation.GetPoint(idx0);
      pt1 = correlation.GetPoint(idx1);
            // Distance from the focal point being transformed (for weight)
      x = pt0[0] - fpIn[0];
      y = pt0[1] - fpIn[1];
      var dist2 = x * x + y * y;
            // Compute the gaussian (minimum for numerical stability)
      gauss = Math.max(Math.exp(-dist2 / sigma2), 0.0000001);

      sumGauss += gauss;
      sum0[0] += gauss * pt0[0];
      sum0[1] += gauss * pt0[1];
      sum1[0] += gauss * pt1[0];
      sum1[1] += gauss * pt1[1];
    }
    sum0[0] = sum0[0] / sumGauss;
    sum0[1] = sum0[1] / sumGauss;
    sum1[0] = sum1[0] / sumGauss;
    sum1[1] = sum1[1] / sumGauss;

    // Now compute orientation.
    this.DeltaRoll = 0;

    // For now lets ignore the roll in the correlation
    // and compute roll from multiple points.

    // Compute rotation
    var roll = 0;
    sumGauss = 0.0;
    var sumTheta = 0.0;
    for (i = 0; i < this.Correlations.length; ++i) {
      correlation = this.Correlations[i];
      pt0 = correlation.GetPoint(idx0);
      pt1 = correlation.GetPoint(idx1);
            // Distance from the focal point (for weight).
      x = pt0[0] - fpIn[0];
      y = pt0[1] - fpIn[1];
      var dist = x * x + y * y;
      gauss = Math.max(Math.exp(-dist / sigma2), 0.0000001);
            // Compute the two angles using the average centers.
            // angle 0:
      x = pt0[0] - sum0[0];
      y = pt0[1] - sum0[1];
      var angle0 = Math.atan2(x, y);
            // Compute distance for small angle consideration.
      var dist0 = x * x + y * y;
            // Angle 1:
      x = pt1[0] - sum1[0];
      y = pt1[1] - sum1[1];
      var angle1 = Math.atan2(x, y);
            // Compute distance for small angle consideration.
      var dist1 = x * x + y * y;

            // Now combine weights.
      gauss = gauss * Math.sqrt(Math.min(dist0, dist1));

            // Averaging angles is tricky because of cycles.
            // Assume all angles are small.
      var dAngle = (angle1 - angle0);
      var twoPi = Math.PI * 2;
      while (dAngle > Math.PI) { dAngle -= twoPi; }
      while (dAngle < -Math.PI) { dAngle += twoPi; }

      sumTheta += dAngle * gauss;
      sumGauss += gauss;
    }
    if (sumGauss > 0) {
      roll = (sumTheta / sumGauss);
    }
        // Silly converting this to degrees, but set camera takes degrees.
        // This is the second return value.
    this.DeltaRoll = (sumTheta / sumGauss);

        // Since focal points are not at center of rotation (sum0 and sum1).
        // We need to translate center to origin, rotate, then translate back.
    fpOut[0] -= sum0[0];
    fpOut[1] -= sum0[1];
    c = Math.cos(roll);
    s = Math.sin(roll);
        // Left handed pixel coordinate system messes the rotation.
    x = c * fpOut[0] + s * fpOut[1];
    y = c * fpOut[1] - s * fpOut[0];

    fpOut[0] = x + sum1[0];
    fpOut[1] = y + sum1[1];

    return fpOut;
  };

    // Nearest neighbor.
  PairTransformation.prototype.ForwardTransform = function (pt0, sigma) {
    this.DeltaRoll = 0;
    if (this.Correlations.length === 0) {
      return pt0;
    }

    return this.WeightedTransform(0, 1, pt0, sigma);
  };

    // Nearest neighbor.
  PairTransformation.prototype.ReverseTransform = function (pt1, sigma) {
    this.DeltaRoll = 0;
    if (this.Correlations.length === 0) {
      return pt1;
    }

    return this.WeightedTransform(1, 0, pt1, sigma);
  };

  PairTransformation.prototype.ForwardTransformCamera = function (camIn, camOut) {
    camOut.SetWorldFocalPoint(this.ForwardTransform(camIn.GetWorldFocalPoint(),
                                                    camIn.Height / 2));
    camOut.SetWorldRoll(camIn.GetWorldRoll() + this.DeltaRoll);
    camOut.SetHeight(camIn.GetHeight());
    // This should be computed from the viewport
    // camOut.Width = camIn.Width;
    camOut.SetWidth(camOut.GetHeight() * camOut.GetViewportWidth() / camOut.GetViewportHeight());
  };

  // TODO: Fix this (image camera coordinate system) or get rid of pairTransform
  PairTransformation.prototype.ReverseTransformCamera = function (camIn, camOut) {
    camOut.FocalPoint = this.ReverseTransform(camIn.FocalPoint, camIn.Height / 2);
    camOut.Roll = camIn.Roll + this.DeltaRoll;
    camOut.Height = camIn.Height;
    // TODO: Camera should do this internally.
    camOut.SetWidth(camOut.GetHeight() * camOut.GetViewportWidth() / camOut.GetViewportHeight());
  };

  SA.PairCorrelation = PairCorrelation;
  SA.PairTransformation = PairTransformation;
})();

// ==============================================================================
// Initially a contour found for each section in a stack.
// Each section gets on of these StackSectionWidgets.  I am extending this
// to include multiple contours fo sections that have multiple pieces,
// and internal contours / features.  Internal edges may not be closed
// loops.
// Initially, these widgets will have no interaction, so they might
// be better as shapes, but we will see.

// Eventually I will put a transformation in here.
// Also, I would like this to have its own instance variable in
// the viewerRecord.

(function () {
    // Depends on the CIRCLE widget
  'use strict';

  function StackSectionWidget (viewer) {
    this.Thumb = null; // default click. in stack creator.

    // Active is just to turn the section yellow temporarily.
    this.Active = false;
    this.Color = [0, 1, 0];
    this.Shapes = [];

    this.Bounds = null;
    if (viewer) {
      this.Viewer = viewer;
      this.Viewer.AddWidget(this);
    }
  }

  StackSectionWidget.prototype.IsEmpty = function () {
    return this.Shapes.length === 0;
  };

  // Add all the lines in the in section to this section.
  StackSectionWidget.prototype.Union = function (section) {
    for (var i = 0; i < section.Shapes.length; ++i) {
      this.Shapes.push(section.Shapes[i]);
    }
    this.Bounds = null;
  };

  // Bounds are in slide / world coordinates.
  // Returns 0 if is does not overlap at all.
  // Returns 1 if part of the section is in the bounds.
  // Returns 2 if all of the section is in the bounds.
  StackSectionWidget.prototype.ContainedInBounds = function (bds) {
    var sBds = this.GetBounds();
    if (sBds[0] > bds[0] && sBds[1] < bds[1] &&
            sBds[2] > bds[2] && sBds[3] < bds[3]) {
      // section is fully contained in the bounds.
      return 2;
    }
    if (sBds[1] < bds[0] || sBds[0] > bds[1] ||
            sBds[3] < bds[2] || sBds[2] > bds[3]) {
      // No overlap of bounds.
      return 0;
    }

    // Bounds partially overlap.  Look closer.
    var pointsIn = false;
    var pointsOut = false;
    for (var i = 0; i < this.Shapes.length; ++i) {
      var contained = this.Shapes[i].ContainedInBounds(bds);
      if (contained === 1) {
        return 1;
      }
      if (contained === 0) {
        pointsOut = true;
      }
      if (contained === 2) {
        pointsIn = true;
      }
      if (pointsIn && pointsOut) {
        return 1;
      }
    }

    if (pointsIn) {
      return 2;
    }
    return 0;
  };

    // Returns the center of the bounds in view coordinates.
  StackSectionWidget.prototype.GetViewCenter = function (view) {
    var bds = this.GetBounds();
    return view.Camera.ConvertPointWorldToViewer((bds[0] + bds[1]) * 0.5,
                                                     (bds[2] + bds[3]) * 0.5);
  };

  // We need bounds in view coordinates for sorting.
  // Do not bother caching the value.
  StackSectionWidget.prototype.GetViewBounds = function (view) {
    if (this.Shapes.length === 0) {
      return [0, 0, 0, 0];
    }
    var c = this.GetViewCenter(view);
    var bds = [c[0], c[0], c[1], c[1]];
    for (var i = 0; i < this.Shapes.length; ++i) {
      var shape = this.Shapes[i];
      for (var j = 0; j < shape.Points.length; ++j) {
        var pt = shape.Points[j];
        pt = view.Camera.ConvertPointWorldToViewer(pt[0], pt[1]);
        if (pt[0] < bds[0]) { bds[0] = pt[0]; }
        if (pt[0] > bds[1]) { bds[1] = pt[0]; }
        if (pt[1] < bds[2]) { bds[2] = pt[1]; }
        if (pt[1] > bds[3]) { bds[3] = pt[1]; }
      }
    }
    return bds;
  };

  StackSectionWidget.prototype.ComputeViewUpperRight = function (view) {
    // Compute the upper right corner in view coordinates.
    // This is used by the SectionsWidget holds this section.
    var bds = this.GetBounds();
    var p0 = view.Camera.ConvertPointWorldToViewer(bds[0], bds[2]);
    var p1 = view.Camera.ConvertPointWorldToViewer(bds[0], bds[3]);
    var p2 = view.Camera.ConvertPointWorldToViewer(bds[1], bds[3]);
    var p3 = view.Camera.ConvertPointWorldToViewer(bds[1], bds[2]);
        // Pick the furthest upper right corner.
    this.ViewUpperRight = p0;
    var best = p0[0] - p0[1];
    var tmp = p1[0] - p1[1];
    if (tmp > best) {
      best = tmp;
      this.ViewUpperRight = p1;
    }
    tmp = p2[0] - p2[1];
    if (tmp > best) {
      best = tmp;
      this.ViewUpperRight = p2;
    }
    tmp = p3[0] - p3[1];
    if (tmp > best) {
      best = tmp;
      this.ViewUpperRight = p3;
    }
  };

  StackSectionWidget.prototype.Draw = function (view) {
    this.ComputeViewUpperRight(view);
    for (var i = 0; i < this.Shapes.length; ++i) {
      if (this.Active) {
        this.Shapes[i].OutlineColor = [1, 1, 0];
      } else {
        this.Shapes[i].OutlineColor = this.Color;
      }
      this.Shapes[i].Draw(view);
    }
  };

  StackSectionWidget.prototype.Serialize = function () {
        // Backing away from 'every section has a contour'.
    if (this.Thumb) {
      return null;
    }
    var obj = {};
    obj.type = 'stack_section';
    obj.color = this.Color;
    obj.shapes = [];
    for (var i = 0; i < this.Shapes.length; ++i) {
      var shape = this.Shapes[i];
            // Is is a pain that polyline does not serialize.
      var polyLineObj = {
        closedloop: shape.Closed,
        points: []};
      for (var j = 0; j < shape.Points.length; ++j) {
        polyLineObj.points.push([shape.Points[j][0], shape.Points[j][1]]);
      }
      obj.shapes.push(polyLineObj);
    }
    return obj;
  };

    // Load a widget from a json object (origin MongoDB).
  StackSectionWidget.prototype.Load = function (obj) {
    if (obj.color) {
      this.Color[0] = parseFloat(obj.color[0]);
      this.Color[1] = parseFloat(obj.color[1]);
      this.Color[2] = parseFloat(obj.color[2]);
    }
    if (!obj.shapes) {
      return;
    }
    for (var n = 0; n < obj.shapes.length; n++) {
      var polylineObj = obj.shapes[n];
      if (polylineObj.points) {
        var points = polylineObj.points;
        var shape = new SAM.Polyline();
        shape.OutlineColor = this.Color;
        shape.FixedSize = false;
        shape.LineWidth = 0;
        if (polylineObj.closedloop) {
          shape.Closed = polylineObj.closedloop;
        }
        this.Shapes.push(shape);
        for (var m = 0; m < points.length; ++m) {
          shape.Points[m] = [points[m][0], points[m][1]];
        }
                // NewStack page uses this and does not have a "layer".
                // Annotations do not need webgl anyway.
                // TODO:Remove this uncessary argument altogether.
                // shape.UpdateBuffers(this.Layer.AnnotationView);
        shape.UpdateBuffers();
      }
    }
  };

    // We could recompute the bounds from the
  StackSectionWidget.prototype.GetCenter = function () {
    var bds = this.GetBounds();
    return [(bds[0] + bds[1]) * 0.5, (bds[2] + bds[3]) * 0.5];
  };

    // We could recompute the bounds from the
  StackSectionWidget.prototype.GetBounds = function () {
        // Special case for simple thumb selection.
    if (this.Thumb) {
      var rad = this.Thumb.Height * this.Thumb.ScreenPixelSpacing / 4.0;
      var cx = this.ThumbX;
      var cy = this.ThumbY;
      return [cx - rad, cx + rad, cy - rad, cy + rad];
    }

    if (this.Shapes.length === 0) {
      return this.Bounds;
    }
    if (!this.Bounds) {
      this.Bounds = this.Shapes[0].GetBounds();
      for (var i = 1; i < this.Shapes.length; ++i) {
        var bds = this.Shapes[i].GetBounds();
        if (bds[0] < this.Bounds[0]) {
          this.Bounds[0] = bds[0];
        }
        if (bds[1] > this.Bounds[1]) {
          this.Bounds[1] = bds[1];
        }
        if (bds[2] < this.Bounds[2]) {
          this.Bounds[2] = bds[2];
        }
        if (bds[3] > this.Bounds[3]) {
          this.Bounds[3] = bds[3];
        }
      }
    }
    return this.Bounds.slice(0);
  };

  StackSectionWidget.prototype.Deactivate = function () {
    this.Viewer.DeactivateWidget(this);
    for (var i = 0; i < this.Shapes.length; ++i) {
      this.Shapes[i].Active = false;
    }
    this.Viewer.EventuallyRender();
  };

  StackSectionWidget.prototype.HandleKeyPress = function (keyCode, shift) {
    return true;
  };

  StackSectionWidget.prototype.HandleMouseDown = function (event) {
    return true;
  };

  StackSectionWidget.prototype.HandleMouseUp = function (event) {
    return true;
  };

  StackSectionWidget.prototype.HandleDoubleClick = function (event) {
    return true;
  };

  StackSectionWidget.prototype.HandleMouseMove = function (event) {
    return true;
  };

  StackSectionWidget.prototype.CheckActive = function (event) {
    return false;
  };

  StackSectionWidget.prototype.GetActive = function () {
    return false;
  };

    // Setting to active always puts state into "active".
    // It can move to other states and stay active.
  StackSectionWidget.prototype.SetActive = function (flag) {
    if (flag) {
      this.Viewer.ActivateWidget(this);
      for (var i = 0; i < this.Shapes.length; ++i) {
        this.Shapes[i].Active = true;
      }

      this.Viewer.EventuallyRender();
    } else {
      this.Deactivate();
      this.Viewer.DeactivateWidget(this);
    }
  };

  StackSectionWidget.prototype.RemoveFromViewer = function () {
    if (this.Viewer) {
      this.Viewer.RemoveWidget(this);
    }
  };

    // ==============================================================================
    // These features might better belong in a separate object of edges.

    // Modifies this section's points to match argument section
    // Also returns the translation and rotation.
  StackSectionWidget.prototype.RigidAlign = function (section, trans) {
    var center1 = this.GetCenter();
    var center2 = section.GetCenter();
        // Translate so that the centers are the same.
        // this.Translate([(center2[0]-center1[0]),
        //                (center2[1]-center2[1])]);

        // Lets use a transformation instead.  It will be easier for the stack
        // editor.
    trans[0] = (center2[0] - center1[0]);
    trans[1] = (center2[1] - center1[1]);

    if (this.Thumb || section.Thumb) {
      trans[2] = 0;
      return;
    }

        // Get the bounds of both contours.
    var bds1 = this.GetBounds();
    bds1[0] += trans[0]; bds1[1] += trans[0];
    bds1[2] += trans[1]; bds1[3] += trans[1];
    var bds2 = section.GetBounds();

        // Combine them (union).
    bds2[0] = Math.min(bds1[0], bds2[0]);
    bds2[1] = Math.max(bds1[1], bds2[1]);
    bds2[2] = Math.min(bds1[2], bds2[2]);
    bds2[3] = Math.max(bds1[3], bds2[3]);
    // Expand the contour by 10%
    var xMid = (bds2[0] + bds2[1]) * 0.5;
    var yMid = (bds2[2] + bds2[3]) * 0.5;
    bds2[0] = xMid + 1.1 * (bds1[0] - xMid);
    bds2[1] = xMid + 1.1 * (bds1[1] - xMid);
    bds2[2] = yMid + 1.1 * (bds1[2] - yMid);
    bds2[3] = yMid + 1.1 * (bds1[3] - yMid);

    // choose a spacing.
    // about 160,000 kPixels (400x400);
    var spacing = Math.sqrt((bds2[1] - bds2[0]) * (bds2[3] - bds2[2]) / 160000);
    // Note. gradient decent messes up with spacing too small.

    var distMap = new SA.DistanceMap(bds2, spacing);
    for (var i = 0; i < section.Shapes.length; ++i) {
      // ignore origin.
      distMap.AddPolyline(section.Shapes[i]);
    }
    distMap.Update();

    this.ViewerEventuallyRender();
    // Coordinate system has changed.
    this.RigidAlignWithMap(distMap, trans);
  };

  // Perform gradient descent on the transform....
  // Do not apply to the points.
  // trans is the starting position as well as the return value.
  StackSectionWidget.prototype.RigidAlignWithMap = function (distMap, trans) {
    // Compute center of rotation
    var center = this.GetCenter();

    // shiftX, shiftY, roll
    var tmpTrans = [0, 0, 0];

    // Try several rotations to see which is the best.
    var bestTrans = null;
    var bestDist = -1;
    var i;
    for (var a = -180; a < 180; a += 30) {
      tmpTrans = [trans[0], trans[1], Math.PI * a / 180];
      var dist;
      for (i = 0; i < 5; ++i) {
        dist = this.RigidDecentStep(tmpTrans, center, distMap, 200000);
      }
      // For symmetrical cases, give no rotation a slight advantage.
      dist = dist * (1.0 + Math.abs(a / 180));
      if (bestDist < 0 || dist < bestDist) {
        bestDist = dist;
        bestTrans = tmpTrans.slice(0);
      }
    }

    // Now the real gradient decent.
    tmpTrans = bestTrans;
    // Slowing discount outliers.
    var aveDist = 200000;
    for (i = 0; i < 100; ++i) {
      aveDist = this.RigidDecentStep(tmpTrans, center, distMap, aveDist);
    }
    // caller can do this if they want.
    // this.Transform([trans[0],trans[1]], center, trans[2]);
    // Just return the transformation parameters.
    // The center is als part of the transform, but it can be gotten with GetCenter.
    trans[0] = tmpTrans[0];
    trans[1] = tmpTrans[1];
    trans[2] = tmpTrans[2];
  };

  // Returns the average distance as the error.
  // trans is the starting transform (dx,dy, dRoll). This state is modified
  // by this method.
  // Center: center of rotation.
  // distMap is the array of distances.
  // Threshold sets large distances to a constant. It should be reduced to
  // minimize the contribution of outliers. Thresh is in units of map pixels.
  StackSectionWidget.prototype.RigidDecentStep = function (trans, center,
                                                             distMap, thresh) {
    var vx, vy, rx, ry;
    var s = Math.sin(trans[2]);
    var c = Math.cos(trans[2]);
    var sumx = 0;
    var sumy = 0;
    var totalDist = 0;
    var sumr = 0;
    var numContributingPoints = 0;
    for (var j = 0; j < this.Shapes.length; ++j) {
      var shape = this.Shapes[j];
      // var debugScalars = new Array(shape.Points.length);
      // shape.DebugScalars = debugScalars;
      for (var k = 0; k < shape.Points.length; ++k) {
        var pt = shape.Points[k];
        var x = pt[0];
        var y = pt[1];

        // transform the point.
        vx = (x - center[0]);
        vy = (y - center[1]);
        rx = c * vx + s * vy;
        ry = -s * vx + c * vy;
        x = x + (rx - vx) + trans[0];
        y = y + (ry - vy) + trans[1];

        // Get the distance for this point.
        var dist = distMap.GetDistance(x, y) * distMap.Spacing;
        totalDist += dist;
        // Use threshold to minimize effect of outliers.
        // debugScalars[k] = (thresh)/(thresh + dist);
        // dist = (thresh*dist)/(thresh + dist);

        // debugScalars[k] = (dist < thresh) ? 1:0;
        // if (dist > thresh) {dist = 0;}
        // debugScalars[k] = Math.exp(-0.69*(dist*dist)/(thresh*thresh));
        var gs = 1;
        if (thresh > 0) { gs = Math.exp(-0.69 * (dist * dist) / (thresh * thresh)); }
        dist = dist * gs;

        // Scale the negative gradient by thresholded distance.
        var grad = distMap.GetGradient(x, y);
        var mag = Math.sqrt(grad[0] * grad[0] + grad[1] * grad[1]);

        if (mag > 0) {
          ++numContributingPoints;

          // Keep a total for translation
          grad[0] = -grad[0] * dist / mag;
          grad[1] = -grad[1] * dist / mag;
          sumx += grad[0];
          sumy += grad[1];

          // For rotation
          var cross = ry * grad[0] - rx * grad[1];
          sumr += cross / (rx * rx + ry * ry);
        } else {
          // skip
        }
      }
    }

    var aveDist = totalDist / numContributingPoints;
        // Trying to be intelligent about the step size
    trans[0] += sumx / numContributingPoints;
    trans[1] += sumy / numContributingPoints;
    trans[2] += sumr / numContributingPoints;

        // for debugging (the rest is in shape.js
        // t = {cx: center[0], cy: center[1],
        //     c: Math.cos(trans[2]), s: Math.sin(trans[2]),
        //     sx: trans[0], sy: trans[1]};
        // for (var i = 0; i < this.Shapes.length; ++i) {
        //    this.Shapes[i].Trans = t;
        // }
        // VIEWER1.Draw();

    return aveDist;
  };

  StackSectionWidget.prototype.Transform = function (shift, center, roll) {
    this.Bounds = null;
    for (var i = 0; i < this.Shapes.length; ++i) {
      var shape = this.Shapes[i];
      shape.Trans = null;
      for (var j = 0; j < shape.Points.length; ++j) {
        var pt = shape.Points[j];
        var x = pt[0];
        var y = pt[1];
        var vx = x - center[0];
        var vy = y - center[1];
        var s = Math.sin(roll);
        var c = Math.cos(roll);
        var rx = c * vx + s * vy;
        var ry = -s * vx + c * vy;
        pt[0] = x + (rx - vx) + shift[0];
        pt[1] = y + (ry - vy) + shift[1];
      }
      shape.UpdateBuffers(this.Layer.AnnotationView);
    }
  };

    // shift is [x,y]
  StackSectionWidget.prototype.Translate = function (shift) {
    this.Bounds = null;
    for (var i = 0; i < this.Shapes.length; ++i) {
      var shape = this.Shapes[i];
      for (var j = 0; j < shape.Points.length; ++j) {
        var pt = shape.Points[j];
        pt[0] += shift[0];
        pt[1] += shift[1];
      }
      shape.UpdateBuffers(this.Layer.AnnotationView);
    }
  };

    // I could also implement a resample to get uniform spacing.
  StackSectionWidget.prototype.RemoveDuplicatePoints = function (epsilon) {
    if (epsilon === undefined) {
      epsilon = 0;
    }
    for (var i = 0; i < this.Shapes.length; ++i) {
      var shape = this.Shapes[i];
      var p0 = shape.Points[shape.Points.length - 1];
      var idx = 0;
      while (idx < shape.Points.length) {
        var p1 = shape.Points[idx];
        var dx = p1[0] - p0[0];
        var dy = p1[1] - p0[1];
        if (Math.sqrt(dx * dx + dy * dy) <= epsilon) {
          shape.Points.splice(idx, 1);
        } else {
          ++idx;
          p0 = p1;
        }
      }
      shape.UpdateBuffers(this.Layer.AnnotationView);
    }
  };

  StackSectionWidget.prototype.Decimate = function () {
    var bds = this.GetBounds();
    var spacing = (bds[1] - bds[0] + bds[3] - bds[2]) / 400;
    for (var i = 0; i < this.Shapes.length; ++i) {
      this.Shapes[i].Decimate(spacing);
    }
  };

  SA.StackSectionWidget = StackSectionWidget;
})();

// ==============================================================================
// A gui for that controls layers in multiple viewers.

(function () {
  'use strict';

  function LayerView (parent, label) {
    this.Layers = [];
    this.Label = label;
    this.Color = [Math.random(), Math.random(), Math.random()];

    this.Initialize(parent, label);
    this.SetSizeScale(1.0);

    this.Changeflag = false;
  }

  LayerView.prototype.AddLayer = function (layer) {
    var self = this;
    // For the stack viewer.  The layer gets loaded with another view,
    // We hve to apply the color and threshold.
    layer.LoadCallbacks.push(function () {
      self.UpdateLayer(layer);
    });

    this.Layers.push(layer);
    if (this.VisibilityCheckBox && this.Slider) {
      this.UpdateLayer(layer);
    }
  };

  // Initialize the gui / dom
  LayerView.prototype.Initialize = function (parent, label) {
    var self = this;

    // The wrapper div that controls a single layer.
    var layerControl = $('<div>')
      .appendTo(parent)
      .css({'border': '1px solid #CCC', 'width': '100%'});

    var leftWrapper = $('<div>')
      .appendTo(layerControl)
      .css({
        'width': '80%',
        'border-right': '1px solid #CCC',
        'height': '100%',
        'display': 'inline-block'});
    // the sub-div that holds the direct toggle and the label.
    var toggleWrapper = $('<div>')
      .appendTo(leftWrapper)
      .css({
        'border-bottom': '1px solid #CCC',
        'width': '100%',
        'float': 'top' });

    this.VisibilityCheckBox = $('<input type="checkbox">')
      .appendTo(toggleWrapper)
      .css({'display': 'inline-block'})
      .on('change',
          function () {
            self.VisibilityCheckCallback();
          })
      .prop('checked', true);

    $('<div>')
      .appendTo(toggleWrapper)
      .css({
        'display': 'inline-block',
        'margin-left': '1em'})
      .html(label);

    this.ChangeCheckBox = $('<input type="checkbox">')
      .appendTo(toggleWrapper)
      .css({
        'display': 'inline-block',
        'float': 'right'})
      .on('change',
          function () {
            self.ChangeCheckCallback();
          })
      .prop('checked', false);

    // Wrapper for the confidence slider.
    var confWrapper = $('<div>')
      .appendTo(leftWrapper)
      .css({'width': '100%'});

    this.Slider = $('<input type="range" min="0" max="100">')
      .appendTo(confWrapper)
      .on('input',
          function () {
            self.SliderCallback();
          });

    $('<div>')
      .appendTo(confWrapper)
      .html('0%')
      .css({ 'float': 'left' });

    $('<div>')
      .appendTo(confWrapper)
      .html('100%')
      .css({ 'float': 'right' });

    var colorWrapper = $('<div>')
      .appendTo(layerControl)
      .css({
        'padding': '5px',
        'height': '100%',
        'width': '20%',
        'display': 'inline-block'});
    this.ColorInput = $('<input type="color">')
      .appendTo(colorWrapper)
      .css({'width': '100%'})
      .val(SAM.ConvertColorToHex(this.Color))
      .change(function () {
        self.ColorCallback();
      });

    this.SizeScaleInput = $('<input type="number">').appendTo(colorWrapper)
      .css({'width': '100%'})
      .prop('title', 'Change the size of the detections')
      .on('change', function () { self.SizeScaleCallback(); });
  };

  LayerView.prototype.SetSizeScale = function (sizeScale) {
    this.SizeScaleInput.val((Math.round(sizeScale * 100)).toString());
    // not used this.RectSizeScale = sizeScale;
    // This might not be necessary. Change event might trigger it for us.
    this.SizeScaleCallback();
  };

  LayerView.prototype.SizeScaleCallback = function () {
    this.Color = SAM.ConvertColor(this.ColorInput.val());
    this.UpdateLayers();
  };

  LayerView.prototype.ColorCallback = function () {
    this.Color = SAM.ConvertColor(this.ColorInput.val());
    this.UpdateLayers();
  };

  LayerView.prototype.VisibilityCheckCallback = function () {
    // var checked = this.VisibilityCheckBox.prop('checked');
    // for (var i = 0; i < this.Layers.length; ++i) {
    //   this.Layers[i].SetVisibility(checked);
    //   this.Layers[i].EventuallyDraw();
    // }
    this.UpdateLayers();
  };

  LayerView.prototype.ChangeCheckCallback = function () {
    this.ChangeFlag = this.ChangeCheckBox.prop('checked');
    this.UpdateLayers();
    if (this.ChangeFlag) {
      var set1 = this.Layers[0].WidgetList[0].Shape;
      var set2 = this.Layers[1].WidgetList[0].Shape;
      set1.ChangeDetectionVisibilities(set1, set2);
      set1.SetOutlineColor('#FF0000');
      set2.SetOutlineColor('#0000FF');
    }
  };

  LayerView.prototype.SliderCallback = function () {
    this.UpdateLayers();
  };

  LayerView.prototype.UpdateLayer = function (layer) {
    var visibility = this.VisibilityCheckBox.prop('checked');
    var sizeScale = parseInt(this.SizeScaleInput.val() / 100);
    var visValue = parseInt(this.Slider.val()) / 100.0;
    for (var wIndex = 0; wIndex < layer.WidgetList.length; wIndex++) {
      var widget = layer.WidgetList[wIndex];
      if (widget.Label === undefined || widget.Label === this.Label) {
        widget.Visibility = visibility;
        widget.SetThreshold(visValue);
        widget.Shape.SetOutlineColor(this.Color);
        widget.Shape.SetScale(sizeScale);
        widget.ComputeVisibilities();
      }
    }
    layer.EventuallyDraw();
  };

  LayerView.prototype.UpdateLayers = function () {
    for (var i = 0; i < this.Layers.length; ++i) {
      var layer = this.Layers[i];
      this.UpdateLayer(layer);
    }
  };

  SA.LayerView = LayerView;
})();

(function () {
  'use strict';

  function HeatMap (parent) {
    this.HeatMapDiv = $('<div>')
            .appendTo(parent)
            .css({'position': 'absolute',
              'left': '0px',
              'top': '0px',
              'border-width': '0px',
              'width': '100%',
              'height': '100%',
              'box-sizing': 'border-box',
              'z-index': '150'})
            .addClass('sa-resize');

    this.View = new SA.TileView(this.HeatMapDiv, true);
    var gl = this.View.gl;
    this.Color = [0.0, 0.4, 0.0];
    this.Window = 1.0;
    this.Level = 0.5;
    this.Gamma = 1.0;

    var self = this;
    this.HeatMapDiv.saOnResize(
            function () {
              self.View.UpdateCanvasSize();
                // Rendering will be a slave to the view because it needs the
                // view's camera anyway.
            });

        // Test red->alpha, constant color set externally
    var heatMapFragmentShaderString =
            'precision highp float;' +
            'varying vec2 vTextureCoord;' +
            'uniform sampler2D uSampler;' +
            'uniform vec3 uColor;' +
            'uniform vec2 uWindowLevel;' +
            'uniform float uGamma;' +
            'void main(void) {' +
            '  vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t)).rgba;' +
            '  float alpha = textureColor[0];' +
            '  if (uWindowLevel[0] !== 1.0 || uWindowLevel[1] !== 0.5) {' +
            '    alpha = ((alpha-0.5)/uWindowLevel[0]) + uWindowLevel[1];' +
            '  }' +
            '  if (uGamma !== 1.0) {' +
            '    if (uGamma < 0.0) {' +
            '      alpha = pow((1.0-alpha), -uGamma);' +
            '    } else {' +
            '      alpha = pow(alpha, uGamma);' +
            '    }' +
            '  }' +
            '  textureColor = vec4(uColor, alpha);' +
            '  gl_FragColor = textureColor;' +
            '}';
    var vertexShaderString =
            'attribute vec3 aVertexPosition;' +
            'attribute vec2 aTextureCoord;' +
            'uniform mat4 uMVMatrix;' +
            'uniform mat4 uPMatrix;' +
            'uniform mat3 uNMatrix;' +
            'varying vec2 vTextureCoord;' +
            'void main(void) {' +
            '  gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition,1.0);' +
            '  vTextureCoord = aTextureCoord;' +
            '}';

    var shaderProgram = SA.createWebGlProgram(heatMapFragmentShaderString, vertexShaderString, gl);
        // Setup the shader program to render heatmaps.
    shaderProgram.textureCoordAttribute =
            gl.getAttribLocation(shaderProgram, 'aTextureCoord');
    gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
    shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, 'uSampler');
    shaderProgram.colorUniform = gl.getUniformLocation(shaderProgram, 'uColor');
    shaderProgram.gamaUniform = gl.getUniformLocation(shaderProgram, 'uGamma');
    shaderProgram.windowLevelUniform = gl.getUniformLocation(shaderProgram, 'uWindowLevel');
    this.View.ShaderProgram = shaderProgram;
  }

  HeatMap.prototype.SetCache = function (cache) {
    this.View.SetCache(cache);
    var imageObj = cache.GetImageData();
    if (!imageObj.spacing) {
      imageObj.spacing = [1, 1, 1];
    }
    if (!imageObj.origin) {
      imageObj.origin = [0, 0, 0];
    }
    var width = imageObj.dimensions[0] * imageObj.spacing[0];
    var height = imageObj.dimensions[1] * imageObj.spacing[1];
    this.View.Camera.Load(
      {FocalPoint: [width / 2, height / 2],
        Roll: 0,
        Height: height});
    this.View.Camera.ComputeMatrix();
    this.View.UpdateCanvasSize();
  };

    // Only works for images served by slide atlas.
  HeatMap.prototype.SetImageData = function (imageObj) {
    imageObj.spacing = imageObj.spacing || [1.0, 1.0, 1.0];
    imageObj.origin = imageObj.origin || [0.0, 0.0, 0.0];

    var heatMapSource = new SA.SlideAtlasSource();
    heatMapSource.Prefix = imageObj.prefix;
    var heatMapCache = new SA.Cache();
    heatMapCache.TileSource = heatMapSource;
    heatMapCache.SetImageData(imageObj);
    this.View.SetCache(heatMapCache);
  };

  HeatMap.prototype.Draw = function (masterView, inCam) {
    inCam = inCam || masterView.Camera;

    if (inCam) {
      if (this.Transform) {
        this.Transform.ForwardTransformCamera(inCam, this.View.GetCamera());
      } else {
                // Use spacing and origin for a transformation.
        var outCam = this.View.Camera;
        var imageObj = this.View.GetCache().Image;
        outCam.DeepCopy(inCam);
        var fp = outCam.GetWorldFocalPoint();
        outCam.SetWorldFocalPoint([
          (fp[0] - imageObj.origin[0]) / imageObj.spacing[0],
          (fp[1] - imageObj.origin[1]) / imageObj.spacing[1]]);
        outCam.SetWidth(outCam.GetWidth() / imageObj.spacing[0]);
        outCam.SetHeight(outCam.GetHeight() / imageObj.spacing[0]);
        outCam.ComputeMatrix();
        this.Camera.DeepCopy(outCam);
      }
    }

    if (this.View.gl) {
      var gl = this.View.gl;
      var program = this.View.ShaderProgram;
      gl.useProgram(program);
      gl.clearColor(1.0, 1.0, 1.0, 1.0);
      gl.disable(gl.DEPTH_TEST);
      gl.enable(gl.BLEND);
            // The blending in funky because there is no destination.
            // It is blending with data from canvas behind the webGl canvas.
      gl.blendFunc(gl.SRC_ALPHA, gl.ZERO);
      gl.uniform3f(program.colorUniform, this.Color[0], this.Color[1], this.Color[2]);
      gl.uniform1f(program.gamaUniform, this.Gamma);
      gl.uniform2f(program.windowLevelUniform, this.Window, this.Level);
    }

    this.View.DrawTiles();
  };

    // Clear the canvas for another render.
  HeatMap.prototype.Reset = function () {
  };

  SA.HeatMap = HeatMap;
})();

// A Renderer - layer tints an image and adds opacity.  Maybe lens in the future.
(function () {
  'use strict';

  function OverlayView (parent) {
    this.OverlayViewDiv = $('<div>')
            .appendTo(parent)
            .css({'position': 'absolute',
              'left': '0px',
              'top': '0px',
              'border-width': '0px',
              'width': '100%',
              'height': '100%',
              'box-sizing': 'border-box',
              'z-index': '150'})
            .addClass('sa-resize');

    this.View = new SA.TileView(this.OverlayViewDiv, true);
    var gl = this.View.gl;
    this.Color = [1.0, 0.0, 1.0];
    this.Center = [500, 500];
    this.Radius = 0;
    this.Opacity = 1.0;

    var self = this;
    this.OverlayViewDiv.saOnResize(
            function () {
              self.View.UpdateCanvasSize();
                // Rendering will be a slave to the view because it needs the
                // view's camera anyway.
            });

        // Test red->alpha, constant color set externally
    var heatMapFragmentShaderString =
            'precision highp float;' +
            'varying vec2 vTextureCoord;' +
            'uniform sampler2D uSampler;' +
            'uniform vec3 uColor;' +
            'uniform vec2 uCenter;' +
            'uniform float uOpacity;' +
            'void main(void) {' +
            '  float alpha = uOpacity;' +
            '  float dx = gl_FragCoord.x - uCenter.x;' +
            '  float dy = gl_FragCoord.y - uCenter.y;' +
            '  if ((dx * dx) + (dy * dy) < 40000.0) { alpha = 0.0;}' +
            '  vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t)).rgba;' +
            '  float intensity = textureColor[0];' +
            '  textureColor[0] = intensity * uColor[0];' +
            '  textureColor[1] = intensity * uColor[1];' +
            '  textureColor[2] = intensity * uColor[2];' +
            '  textureColor[3] = alpha;' +
            '  gl_FragColor = textureColor;' +
            // "  gl_FragColor = vec4(gl_FragCoord.x / 1000.0, gl_FragCoord.y / 1000.0, 0, alpha);" +
            '}';
    var vertexShaderString =
            'attribute vec3 aVertexPosition;' +
            'attribute vec2 aTextureCoord;' +
            'uniform mat4 uMVMatrix;' +
            'uniform mat4 uPMatrix;' +
            'uniform mat3 uNMatrix;' +
            'varying vec2 vTextureCoord;' +
            'varying vec4 vPos;' +
            'void main(void) {' +
            '  gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition,1.0);' +
            '  vTextureCoord = aTextureCoord;' +
            '}';

    var shaderProgram = SA.createWebGlProgram(heatMapFragmentShaderString, vertexShaderString, gl);
        // Setup the shader program to render heatmaps.
    shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, 'aTextureCoord');
    gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
    shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, 'uSampler');
    shaderProgram.colorUniform = gl.getUniformLocation(shaderProgram, 'uColor');
    shaderProgram.opacityUniform = gl.getUniformLocation(shaderProgram, 'uOpacity');
    shaderProgram.centerUniform = gl.getUniformLocation(shaderProgram, 'uCenter');
    this.View.ShaderProgram = shaderProgram;

    // this.View.Canvas
    this.OverlayViewDiv.on(
      'mousemove.overlay',
      function (event) {
        self.Center[0] = event.offsetX;
        self.Center[1] = self.OverlayViewDiv.height() - event.offsetY;
        self.EventuallyDraw();
        return true;
      });
  }

  // To compress draw events.
  OverlayView.prototype.EventuallyDraw = function () {
    if (!this.RenderPending) {
      this.RenderPending = true;
      var self = this;
      window.requestAnimationFrame(
                function () {
                  self.RenderPending = false;
                  self.Draw();
                });
    }
  };

  OverlayView.prototype.SetCache = function (cache) {
    this.View.SetCache(cache);
    var imageObj = cache.GetImageData();
    if (!imageObj.spacing) {
      imageObj.spacing = [1, 1, 1];
    }
    if (!imageObj.origin) {
      imageObj.origin = [0, 0, 0];
    }
    var width = imageObj.dimensions[0] * imageObj.spacing[0];
    var height = imageObj.dimensions[1] * imageObj.spacing[1];
    this.View.Camera.Load(
      {FocalPoint: [width / 2, height / 2],
        Roll: 0,
        Height: height});
    this.View.Camera.ComputeMatrix();
    this.View.UpdateCanvasSize();
  };

    // Only works for images served by slide atlas.
  OverlayView.prototype.SetImageData = function (imageObj) {
    imageObj.spacing = imageObj.spacing || [1.0, 1.0, 1.0];
    imageObj.origin = imageObj.origin || [0.0, 0.0, 0.0];

    var heatMapSource = new SA.SlideAtlasSource();
    heatMapSource.Prefix = imageObj.prefix;
    var heatMapCache = new SA.Cache();
    heatMapCache.TileSource = heatMapSource;
    heatMapCache.SetImageData(imageObj);
    this.View.SetCache(heatMapCache);
  };

  OverlayView.prototype.Draw = function (masterView, inCam) {
    // TODO: Clear any pending renders.
    if (masterView) {
      inCam = inCam || masterView.Camera;
    }

    if (inCam) {
      if (this.Transform) {
        this.Transform.ForwardTransformCamera(inCam, this.View.GetCamera());
      } else {
        // Use spacing and origin for a transformation.
        var outCam = this.View.Camera;
        var imageObj = this.View.GetCache().Image;
        outCam.DeepCopy(inCam);
        var fp = outCam.GetWorldFocalPoint();
        outCam.SetWorldFocalPoint([
          (fp[0] - imageObj.origin[0]) / imageObj.spacing[0],
          (fp[1] - imageObj.origin[1]) / imageObj.spacing[1]]);
        outCam.SetWidth(outCam.GetWidth() / imageObj.spacing[0]);
        outCam.SetHeight(outCam.GetHeight() / imageObj.spacing[0]);
        outCam.ComputeMatrix();
        this.Camera.DeepCopy(outCam);
      }
    }

    if (this.View.gl) {
      var gl = this.View.gl;
      var program = this.View.ShaderProgram;
      gl.useProgram(program);
      gl.clearColor(1.0, 1.0, 1.0, 1.0);
      gl.disable(gl.DEPTH_TEST);
      gl.enable(gl.BLEND);
            // The blending in funky because there is no destination.
            // It is bleniding with data from canvas behind the webGl canvas.
      gl.blendFunc(gl.SRC_ALPHA, gl.ZERO);
      gl.uniform3f(program.colorUniform, this.Color[0], this.Color[1], this.Color[2]);
      gl.uniform1f(program.opacityUniform, this.Opacity);
      gl.uniform2f(program.centerUniform, this.Center[0], this.Center[1]);
    }

    this.View.DrawTiles();
  };

    // Clear the canvas for another render.
  OverlayView.prototype.Reset = function () {
  };

  SA.OverlayView = OverlayView;
})();
//# sourceURL=sa-all.max.js
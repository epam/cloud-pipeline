// Active is used for a single widget when we are drawing or editing.
// Selected can be multiple widgets.

// -Separating annotations from the viewer. They have their own canvas / layer now.
// -This is more like a view than a viewer.
// -Viewer still handles stack correlations crosses.
// -This object does not bind events, but does have handle methods called by
//  the viewer.  We could change this if the annotationsLayer received
//  events before the viewer.
// -Leave the copyright stuff in the viewer too.  It is not rendered in the canvas.
// -AnnotationWidget (the panel for choosing an annotation to add) is
//  separate from this class.
// -I will need to fix saving images from the canvas.  Saving large imag
//  should still work. Use this for everything.
// -This class does not handle annotation visibility (part of annotationWidget).

(function () {
  'use strict';

  window.SAM = window.SAM || {};
  window.SAM.ImagePathUrl = 'not set';
  window.SAM.MOBILE_DEVICE = false;

  // Widget factory.  Return a widget from its serialized metadata.
  SAM.ConstructWidget = function (obj, layer) {
    var widget;
    switch (obj.type) {
      case 'lasso':
        widget = new SAM.LassoWidget(layer);
        break;
      case 'pencil':
        widget = new SAM.PencilWidget(layer);
        break;
      case 'text':
        widget = new SAM.TextWidget(layer);
        break;
      case 'arrow':
        widget = new SAM.ArrowWidget(layer);
        break;
      case 'circle':
        widget = new SAM.CircleWidget(layer);
        break;
      case 'polyline':
        widget = new SAM.PolylineWidget(layer);
        break;
      case 'rectangle':
        widget = new SAM.RectWidget(layer);
        break;
      case 'rect_set':
        widget = new SAM.RectSetWidget(layer);
        break;
      case 'grid':
        widget = new SAM.GridWidget(layer);
        break;
    }
    widget.Load(obj);
    // TODO: Get rid of this hack.
    // This is the messy way of detecting widgets that did not load
    // properly.
    if (widget.Type === 'sections' && widget.IsEmpty()) {
      // delete widget;
      return undefined;
    }
    return widget;
  };

  SAM.detectMobile = function () {
    if (SAM.MOBILE_DEVICE) {
      return SAM.MOBILE_DEVICE;
    }
    SAM.MOBILE_DEVICE = false;
    if (navigator.userAgent.match(/Android/i)) {
      SAM.MOBILE_DEVICE = 'Andriod';
    }
    if (navigator.userAgent.match(/webOS/i)) {
      SAM.MOBILE_DEVICE = 'webOS';
    }
    if (navigator.userAgent.match(/iPhone/i)) {
      SAM.MOBILE_DEVICE = 'iPhone';
    }
    if (navigator.userAgent.match(/iPad/i)) {
      SAM.MOBILE_DEVICE = 'iPad';
    }
    if (navigator.userAgent.match(/iPod/i)) {
      SAM.MOBILE_DEVICE = 'iPod';
    }
    if (navigator.userAgent.match(/BlackBerry/i)) {
      SAM.MOBILE_DEVICE = 'BlackBerry';
    }
    if (navigator.userAgent.match(/Windows Phone/i)) {
      SAM.MOBILE_DEVICE = 'Windows Phone';
    }
    return SAM.MOBILE_DEVICE;
  };

  // Debugging ... not called in normal operation.
  // Report the area for each polyline in the sequence.
  SAM.areaSequence = function (r, g, b) {
    var pl = new SAM.Polyline();
    var vr = SA.RootNote.ViewerRecords;
    var areaSequence = [];
    for (var i = 0; i < vr.length; ++i) {
      var area = 0;
      var as = vr[i].Annotations;
      for (var j = 0; j < as.length; ++j) {
        var an = as[j];
        if (an.type === 'polyline' &&
                    Math.round(an.outlinecolor[0] * 255) === r &&
                    Math.round(an.outlinecolor[1] * 255) === g &&
                    Math.round(an.outlinecolor[2] * 255) === b) {
          if (area !== 0) { console.log('Found more than one in a section'); }
          pl.Points = an.points;
          area += pl.ComputeArea() * 0.25 * 0.25;
          area = Math.round(area * 100) / 100.0;
        }
      }
      areaSequence.push(area);
    }
    // console.log(JSON.stringify(areaSequence));
    return areaSequence;
  };

  // Convert any color to an array [r,g,b] values 0->1
  SAM.ConvertColor = function (color) {
    if (typeof (color) === 'string' && color[0] !== '#') {
      if (color.slice(0, 5) === 'rgba(') {
        color = color.slice(5, -1).split(',');
        color[0] = color[0] / 255;
        color[1] = color[1] / 255;
        color[2] = color[1] / 255;
        return color;
      }

      // Deal with color names.
      var colors = {
        'aliceblue': '#f0f8ff',
        'antiquewhite': '#faebd7',
        'aqua': '#00ffff',
        'aquamarine': '#7fffd4',
        'azure': '#f0ffff',
        'beige': '#f5f5dc',
        'bisque': '#ffe4c4',
        'black': '#000000',
        'blanchedalmond': '#ffebcd',
        'blue': '#0000ff',
        'blueviolet': '#8a2be2',
        'brown': '#a52a2a',
        'burlywood': '#deb887',
        'cadetblue': '#5f9ea0',
        'chartreuse': '#7fff00',
        'chocolate': '#d2691e',
        'coral': '#ff7f50',
        'cornflowerblue': '#6495ed',
        'cornsilk': '#fff8dc',
        'crimson': '#dc143c',
        'cyan': '#00ffff',
        'darkblue': '#00008b',
        'darkcyan': '#008b8b',
        'darkgoldenrod': '#b8860b',
        'darkgray': '#a9a9a9',
        'darkgreen': '#006400',
        'darkkhaki': '#bdb76b',
        'darkmagenta': '#8b008b',
        'darkolivegreen': '#556b2f',
        'darkorange': '#ff8c00',
        'darkorchid': '#9932cc',
        'darkred': '#8b0000',
        'darksalmon': '#e9967a',
        'darkseagreen': '#8fbc8f',
        'darkslateblue': '#483d8b',
        'darkslategray': '#2f4f4f',
        'darkturquoise': '#00ced1',
        'darkviolet': '#9400d3',
        'deeppink': '#ff1493',
        'deepskyblue': '#00bfff',
        'dimgray': '#696969',
        'dodgerblue': '#1e90ff',
        'firebrick': '#b22222',
        'floralwhite': '#fffaf0',
        'forestgreen': '#228b22',
        'fuchsia': '#ff00ff',
        'gainsboro': '#dcdcdc',
        'ghostwhite': '#f8f8ff',
        'gold': '#ffd700',
        'goldenrod': '#daa520',
        'gray': '#808080',
        'green': '#008000',
        'greenyellow': '#adff2f',
        'honeydew': '#f0fff0',
        'hotpink': '#ff69b4',
        'indianred ': '#cd5c5c',
        'indigo ': '#4b0082',
        'ivory': '#fffff0',
        'khaki': '#f0e68c',
        'lavender': '#e6e6fa',
        'lavenderblush': '#fff0f5',
        'lawngreen': '#7cfc00',
        'lemonchiffon': '#fffacd',
        'lightblue': '#add8e6',
        'lightcoral': '#f08080',
        'lightcyan': '#e0ffff',
        'lightgoldenrodyellow': '#fafad2',
        'lightgrey': '#d3d3d3',
        'lightgreen': '#90ee90',
        'lightpink': '#ffb6c1',
        'lightsalmon': '#ffa07a',
        'lightseagreen': '#20b2aa',
        'lightskyblue': '#87cefa',
        'lightslategray': '#778899',
        'lightsteelblue': '#b0c4de',
        'lightyellow': '#ffffe0',
        'lime': '#00ff00',
        'limegreen': '#32cd32',
        'linen': '#faf0e6',
        'magenta': '#ff00ff',
        'maroon': '#800000',
        'mediumaquamarine': '#66cdaa',
        'mediumblue': '#0000cd',
        'mediumorchid': '#ba55d3',
        'mediumpurple': '#9370d8',
        'mediumseagreen': '#3cb371',
        'mediumslateblue': '#7b68ee',
        'mediumspringgreen': '#00fa9a',
        'mediumturquoise': '#48d1cc',
        'mediumvioletred': '#c71585',
        'midnightblue': '#191970',
        'mintcream': '#f5fffa',
        'mistyrose': '#ffe4e1',
        'moccasin': '#ffe4b5',
        'navajowhite': '#ffdead',
        'navy': '#000080',
        'oldlace': '#fdf5e6',
        'olive': '#808000',
        'olivedrab': '#6b8e23',
        'orange': '#ffa500',
        'orangered': '#ff4500',
        'orchid': '#da70d6',
        'palegoldenrod': '#eee8aa',
        'palegreen': '#98fb98',
        'paleturquoise': '#afeeee',
        'palevioletred': '#d87093',
        'papayawhip': '#ffefd5',
        'peachpuff': '#ffdab9',
        'peru': '#cd853f',
        'pink': '#ffc0cb',
        'plum': '#dda0dd',
        'powderblue': '#b0e0e6',
        'purple': '#800080',
        'red': '#ff0000',
        'rosybrown': '#bc8f8f',
        'royalblue': '#4169e1',
        'saddlebrown': '#8b4513',
        'salmon': '#fa8072',
        'sandybrown': '#f4a460',
        'seagreen': '#2e8b57',
        'seashell': '#fff5ee',
        'sienna': '#a0522d',
        'silver': '#c0c0c0',
        'skyblue': '#87ceeb',
        'slateblue': '#6a5acd',
        'slategray': '#708090',
        'snow': '#fffafa',
        'springgreen': '#00ff7f',
        'steelblue': '#4682b4',
        'tan': '#d2b48c',
        'teal': '#008080',
        'thistle': '#d8bfd8',
        'tomato': '#ff6347',
        'turquoise': '#40e0d0',
        'violet': '#ee82ee',
        'wheat': '#f5deb3',
        'white': '#ffffff',
        'whitesmoke': '#f5f5f5',
        'yellow': '#ffff00',
        'yellowgreen': '#9acd32'
      };
      if (typeof colors[color.toLowerCase()] !== 'undefined') {
        color = colors[color.toLowerCase()];
      } else {
        alert('Unknown color ' + color);
      }
    }

    // Deal with color in hex format i.e. #0000ff
    if (typeof (color) === 'string' && color.length === 7 && color[0] === '#') {
      var floatColor = [];
      var idx = 1;
      for (var i = 0; i < 3; ++i) {
        var val = ((16.0 * SAM.HexDigitToInt(color[idx++])) + SAM.HexDigitToInt(color[idx++])) / 255.0;
        floatColor.push(val);
      }
      return floatColor;
    }
    if (typeof (color) === 'string') {
      // No other formats for now.
      console.error('Cannot decode color ' + color);
      var colorArray = new Array(3);
      colorArray.fill(0);
      return colorArray;
    }
    // Fall through arrays.
    return color.slice();
  };

  // RGB [Float, Float, Float] to #RRGGBB string
  SAM.ConvertColorToHex = function (color) {
    if (typeof (color) === 'string') {
      if (color.slice(0, 5) === 'rgba(') {
        return color;
      }
      color = SAM.ConvertColorNameToHex(color);
      if (color.substring(0, 1) === '#') {
        return color;
      } else if (color.substring(0, 3) === 'rgb') {
        var temp = color.substring(4, color.length - 1).split(',');
        color = [parseInt(temp[0]) / 255,
          parseInt(temp[1]) / 255,
          parseInt(temp[2]) / 255];
      }
    }
    var hexDigits = '0123456789abcdef';
    var str = '#';
    for (var i = 0; i < 3; ++i) {
      var tmp = color[i];
      for (var j = 0; j < 2; ++j) {
        tmp *= 16.0;
        var digit = Math.floor(tmp);
        if (digit < 0) { digit = 0; }
        if (digit > 15) { digit = 15; }
        tmp = tmp - digit;
        str += hexDigits.charAt(digit);
      }
    }
    return str;
  };

  // 0-f hex digit to int
  SAM.HexDigitToInt = function (hex) {
    if (hex === '1') {
      return 1.0;
    } else if (hex === '2') {
      return 2.0;
    } else if (hex === '3') {
      return 3.0;
    } else if (hex === '4') {
      return 4.0;
    } else if (hex === '5') {
      return 5.0;
    } else if (hex === '6') {
      return 6.0;
    } else if (hex === '7') {
      return 7.0;
    } else if (hex === '8') {
      return 8.0;
    } else if (hex === '9') {
      return 9.0;
    } else if (hex === 'a' || hex === 'A') {
      return 10.0;
    } else if (hex === 'b' || hex === 'B') {
      return 11.0;
    } else if (hex === 'c' || hex === 'C') {
      return 12.0;
    } else if (hex === 'd' || hex === 'D') {
      return 13.0;
    } else if (hex === 'e' || hex === 'E') {
      return 14.0;
    } else if (hex === 'f' || hex === 'F') {
      return 15.0;
    }
    return 0.0;
  };

  SAM.ConvertColorNameToHex = function (color) {
    // Deal with color names.
    if (typeof (color) === 'string' && color[0] !== '#') {
      var colors = {
        'aliceblue': '#f0f8ff',
        'antiquewhite': '#faebd7',
        'aqua': '#00ffff',
        'aquamarine': '#7fffd4',
        'azure': '#f0ffff',
        'beige': '#f5f5dc',
        'bisque': '#ffe4c4',
        'black': '#000000',
        'blanchedalmond': '#ffebcd',
        'blue': '#0000ff',
        'blueviolet': '#8a2be2',
        'brown': '#a52a2a',
        'burlywood': '#deb887',
        'cadetblue': '#5f9ea0',
        'chartreuse': '#7fff00',
        'chocolate': '#d2691e',
        'coral': '#ff7f50',
        'cornflowerblue': '#6495ed',
        'cornsilk': '#fff8dc',
        'crimson': '#dc143c',
        'cyan': '#00ffff',
        'darkblue': '#00008b',
        'darkcyan': '#008b8b',
        'darkgoldenrod': '#b8860b',
        'darkgray': '#a9a9a9',
        'darkgreen': '#006400',
        'darkkhaki': '#bdb76b',
        'darkmagenta': '#8b008b',
        'darkolivegreen': '#556b2f',
        'darkorange': '#ff8c00',
        'darkorchid': '#9932cc',
        'darkred': '#8b0000',
        'darksalmon': '#e9967a',
        'darkseagreen': '#8fbc8f',
        'darkslateblue': '#483d8b',
        'darkslategray': '#2f4f4f',
        'darkturquoise': '#00ced1',
        'darkviolet': '#9400d3',
        'deeppink': '#ff1493',
        'deepskyblue': '#00bfff',
        'dimgray': '#696969',
        'dodgerblue': '#1e90ff',
        'firebrick': '#b22222',
        'floralwhite': '#fffaf0',
        'forestgreen': '#228b22',
        'fuchsia': '#ff00ff',
        'gainsboro': '#dcdcdc',
        'ghostwhite': '#f8f8ff',
        'gold': '#ffd700',
        'goldenrod': '#daa520',
        'gray': '#808080',
        'green': '#008000',
        'greenyellow': '#adff2f',
        'honeydew': '#f0fff0',
        'hotpink': '#ff69b4',
        'indianred': '#cd5c5c',
        'indigo ': '#4b0082',
        'ivory': '#fffff0',
        'khaki': '#f0e68c',
        'lavender': '#e6e6fa',
        'lavenderblush': '#fff0f5',
        'lawngreen': '#7cfc00',
        'lemonchiffon': '#fffacd',
        'lightblue': '#add8e6',
        'lightcoral': '#f08080',
        'lightcyan': '#e0ffff',
        'lightgoldenrodyellow': '#fafad2',
        'lightgrey': '#d3d3d3',
        'lightgreen': '#90ee90',
        'lightpink': '#ffb6c1',
        'lightsalmon': '#ffa07a',
        'lightseagreen': '#20b2aa',
        'lightskyblue': '#87cefa',
        'lightslategray': '#778899',
        'lightsteelblue': '#b0c4de',
        'lightyellow': '#ffffe0',
        'lime': '#00ff00',
        'limegreen': '#32cd32',
        'linen': '#faf0e6',
        'magenta': '#ff00ff',
        'maroon': '#800000',
        'mediumaquamarine': '#66cdaa',
        'mediumblue': '#0000cd',
        'mediumorchid': '#ba55d3',
        'mediumpurple': '#9370d8',
        'mediumseagreen': '#3cb371',
        'mediumslateblue': '#7b68ee',
        'mediumspringgreen': '#00fa9a',
        'mediumturquoise': '#48d1cc',
        'mediumvioletred': '#c71585',
        'midnightblue': '#191970',
        'mintcream': '#f5fffa',
        'mistyrose': '#ffe4e1',
        'moccasin': '#ffe4b5',
        'navajowhite': '#ffdead',
        'navy': '#000080',
        'oldlace': '#fdf5e6',
        'olive': '#808000',
        'olivedrab': '#6b8e23',
        'orange': '#ffa500',
        'orangered': '#ff4500',
        'orchid': '#da70d6',
        'palegoldenrod': '#eee8aa',
        'palegreen': '#98fb98',
        'paleturquoise': '#afeeee',
        'palevioletred': '#d87093',
        'papayawhip': '#ffefd5',
        'peachpuff': '#ffdab9',
        'peru': '#cd853f',
        'pink': '#ffc0cb',
        'plum': '#dda0dd',
        'powderblue': '#b0e0e6',
        'purple': '#800080',
        'red': '#ff0000',
        'rosybrown': '#bc8f8f',
        'royalblue': '#4169e1',
        'saddlebrown': '#8b4513',
        'salmon': '#fa8072',
        'sandybrown': '#f4a460',
        'seagreen': '#2e8b57',
        'seashell': '#fff5ee',
        'sienna': '#a0522d',
        'silver': '#c0c0c0',
        'skyblue': '#87ceeb',
        'slateblue': '#6a5acd',
        'slategray': '#708090',
        'snow': '#fffafa',
        'springgreen': '#00ff7f',
        'steelblue': '#4682b4',
        'tan': '#d2b48c',
        'teal': '#008080',
        'thistle': '#d8bfd8',
        'tomato': '#ff6347',
        'turquoise': '#40e0d0',
        'violet': '#ee82ee',
        'wheat': '#f5deb3',
        'white': '#ffffff',
        'whitesmoke': '#f5f5f5',
        'yellow': '#ffff00',
        'yellowgreen': '#9acd32'
      };
      color = color.toLowerCase();
      if (typeof colors[color] !== 'undefined') {
        color = colors[color];
      }
    }
    return color;
  };

  // length units = meters
  window.SAM.DistanceToString = function (length) {
    var lengthStr = '';
    if (length < 0.001) {
      // Latin-1 00B5 is micro sign
      lengthStr += (length * 1e6).toFixed(2) + ' \xB5m';
    } else if (length < 0.01) {
      lengthStr += (length * 1e3).toFixed(2) + ' mm';
    } else if (length < 1.0) {
      lengthStr += (length * 1e2).toFixed(2) + ' cm';
    } else if (length < 1000) {
      lengthStr += (length).toFixed(2) + ' m';
    } else {
      lengthStr += (length).toFixed(2) + ' km';
    }
    return lengthStr;
  };

  window.SAM.StringToDistance = function (lengthStr) {
    var length = 0;
    lengthStr = lengthStr.trim(); // remove leading and trailing spaces.
    var len = lengthStr.length;
    // Convert to microns
    if (lengthStr.substring(len - 2, len) === '\xB5m') {
      length = parseFloat(lengthStr.substring(0, len - 2)) / 1e6;
    } else if (lengthStr.substring(len - 2, len) === 'mm') {
      length = parseFloat(lengthStr.substring(0, len - 2)) / 1e3;
    } else if (lengthStr.substring(len - 2, len) === 'cm') {
      length = parseFloat(lengthStr.substring(0, len - 2)) / 1e2;
    } else if (lengthStr.substring(len - 2, len) === ' m') {
      length = parseFloat(lengthStr.substring(0, len - 2));
    } else if (lengthStr.substring(len - 2, len) === 'km') {
      length = parseFloat(lengthStr.substring(0, len - 2)) * 1e3;
    }

    return length;
  };

  // ConvertToMeters.
  window.SAM.ConvertToMeters = function (distObj) {
    if (!distObj.units || distObj.units === 'Units') {
      return distObj.value;
    }

    if (distObj.units.toLowerCase() === 'nm') {
      distObj.units = 'm';
      distObj.value *= 1e-9;
      return distObj.value;
    }
    if (distObj.units.toLowerCase() === '\xB5m') {
      distObj.units = 'm';
      distObj.value *= 1e-6;
      return distObj.value;
    }
    if (distObj.units.toLowerCase() === 'mm') {
      distObj.units = 'm';
      distObj.value *= 1e-3;
      return distObj.value;
    }
    if (distObj.units.toLowerCase() === 'cm') {
      distObj.units = 'm';
      distObj.value *= 1e-2;
      return distObj.value;
    }
    if (distObj.units.toLowerCase() === 'dm') {
      distObj.units = 'm';
      distObj.value *= 1e-1;
      return distObj.value;
    }
    if (distObj.units.toLowerCase() === 'm') {
      distObj.units = 'm';
      return distObj.value;
    }
    if (distObj.units.toLowerCase() === 'km') {
      distObj.units = 'm';
      distObj.value *= 1e3;
      return distObj.value;
    }
    console.log('Unknown units: ' + distObj.units);
    return distObj.value;
  };

  window.SAM.ConvertForGui = function (distObj) {
    if (!distObj.units) {
      distObj.units = 'Units';
      return;
    }
    SAM.ConvertToMeters(distObj);
    if (distObj.value > 1000) {
      distObj.value = distObj.value / 1000;
      distObj.units = 'km';
      return;
    }
    if (distObj.value > 1) {
      distObj.value = distObj.value;
      distObj.units = 'm';
      return;
    }
    if (distObj.value > 0.01) {
      distObj.value = distObj.value * 100;
      distObj.units = 'cm';
      return;
    }
    if (distObj.value > 0.001) {
      distObj.value = distObj.value * 1000;
      distObj.units = 'mm';
      return;
    }
    if (distObj.value > 0.0000001) {
      distObj.value = distObj.value * 1000000;
      distObj.units = '\xB5m';
      return;
    }
    distObj.value = distObj.value * 1000000000;
    distObj.units = 'nm';
  };

  // Pass in the viewer div.
  // TODO: Pass the camera into the draw method.  It is shared here.
  function AnnotationLayer (parent) {
    var self = this;

    // For stack.  Z = 0 is default for single images.
    // Annotations use this to decide whether to draw or not.
    // It is changed when the GirderStackWidget changes frame.
    this.ZTime = 0;

    // This will be called when a widget is selected by the user.
    // So the panel can put the layer into edit mode.
    this.ActivatedCallback = undefined;
    this.SelectionChangeCallback = undefined;
    this.ModifiedCallback = undefined;

    // Equivalent to editing.  Only one should be editing at a time.
    this.Active = false;

    this.Visibility = true;
    // TODO: Get rid of this.  The layer should not enforce
    // a single active widget.
    this.ActiveWidget = null;

    this.Parent = parent;
    this.LoadCallbacks = [];
    this.LayerDiv = $('<div>')
      .appendTo(parent)
      .css({
        'position': 'absolute',
        'left': '0px',
        'top': '0px',
        'border-width': '0px',
        'width': '100%',
        'height': '100%',
        'z-index': '1',
        'box-sizing': 'border-box'
      })
            .addClass('sa-resize');

    // I do not like modifying the parent.
    this.LayerDiv.saOnResize(
            function () {
              self.UpdateSize();
            });

    // Hack for debugging
    SAM.DebugLayer = this;

    // TODO: Abstract the view to a layer somehow.
    this.AnnotationView = new SAM.View(this.LayerDiv);

    this.AnnotationView.Canvas
      .saOnResize(function () { self.UpdateCanvasSize(); });

    this.WidgetList = [];
    // TODO:
    // I want to move away from having each shape have its own interaction (dialog).
    // Instead, I want to keep the shapes, and then have helper objects for interaction.
    // Right now this is used for non interactive annotation.
    // In the future I will add interaction helper object to manipulate shapes..
    // this.ShapeList = []; // Not needed quite yet.

    // Scale widget is unique. Deal with it separately so it is not
    // saved with the notes.
    this.ScaleWidget = new SAM.ScaleWidget(this);
  }

  // Like jquery remove.  Remove elements and events.
  AnnotationLayer.prototype.Remove = function () {
    this.LayerDiv.remove();
    this.Parent = undefined;
  };

  // This gets called when a click causes as single widget in this layer
  // to be selected. The annotation panel, uses it to turn editing on for this layer.
  AnnotationLayer.prototype.SetActivatedCallback = function (callback) {
    this.ActivatedCallback = callback;
  };
  AnnotationLayer.prototype.SetActive = function (flag) {
    if (flag === this.Active) {
      return;
    }
    this.Active = flag;
    if (flag && this.ActivatedCallback) {
      (this.ActivatedCallback)(this);
    }
  };

  // This will be called anytime one of the widgets in this layer gets modified.
  // This layer is apssed as an argument (rethink this.  It is not necessary).
  AnnotationLayer.prototype.SetModifiedCallback = function (callback) {
    this.ModifiedCallback = callback;
  };

  AnnotationLayer.prototype.Modified = function () {
    if (this.ModifiedCallback) {
      (this.ModifiedCallback)(this);
    }
  };

  // TODO: Not really select: Remove this (or change its name)
  // This will be called when a widget is selected by the user.
  // I am not sure about the usefulness of this method.
  AnnotationLayer.prototype.SetSelectionChangeCallback = function (callback) {
    this.SelectionChangeCallback = callback;
  };

  // Applies to all widgets in the layer.
  // Returns true if something changed.
  AnnotationLayer.prototype.SetSelected = function (flag) {
    var changed = false;
    for (var idx = 0; idx < this.WidgetList.length; ++idx) {
      var widget = this.WidgetList[idx];
      if (widget.SetSelected && widget.SetSelected(flag)) {
        changed = true;
      }
    }
    if (changed && this.SelectionChangeCallback) {
      (this.SelectionChangeCallback)(this);
    }
    return changed;
  };

  // Returns true if the annotation layer is completely empty.
  AnnotationLayer.prototype.IsEmpty = function () {
    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (!widget.IsEmpty()) {
        return false;
      }
    }
    return true;
  };

  AnnotationLayer.prototype.InactivateAll = function () {
    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.SetActive(false)) {
        widget.SetActive(false);
      }
    }
    return true;
  };

  AnnotationLayer.prototype.UnselectAll = function () {
    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.SetSelected) {
        widget.SetSelected(false);
      }
    }
  };

  // Returns true if any widget was deleted.
  // This Also prunes empty widgets.
  AnnotationLayer.prototype.DeleteSelected = function () {
    var modified = false;
    var keepers = [];
    // Let every widget delete its selected components.
    for (var idx = 0; idx < this.WidgetList.length; ++idx) {
      var widget = this.WidgetList[idx];
      // Only deletes the selected widgets / shapes.
      if (widget.DeleteSelected()) {
        modified = true;
        if (!widget.IsEmpty()) {
          keepers.push(widget);
        }
      } else {
        keepers.push(widget);
      }
    }
    if (this.WidgetList.length !== keepers.length) {
      this.WidgetList = keepers;
    }

    return modified;
  };

  AnnotationLayer.prototype.GetVisibility = function () {
    return this.Visibility;
  };
  AnnotationLayer.prototype.SetVisibility = function (vis) {
    if (vis === this.Visibility) {
      return;
    }
    this.Visibility = vis;
    // Since KeyDown (V) can change visibility, this resets it.
    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.SetVisibility) {
        widget.SetVisibility(vis);
      }
    }
    this.EventuallyDraw();
  };

  AnnotationLayer.prototype.GetCamera = function () {
    return this.AnnotationView.GetCamera();
  };
  AnnotationLayer.prototype.SetCamera = function (cam) {
    return this.AnnotationView.SetCamera(cam);
  };
  AnnotationLayer.prototype.GetViewport = function () {
    return this.AnnotationView.Viewport;
  };
  AnnotationLayer.prototype.UpdateCanvasSize = function () {
    this.AnnotationView.UpdateCanvasSize();
  };
  AnnotationLayer.prototype.Clear = function () {
    this.AnnotationView.Clear();
  };
  // This is the same as LayerDiv.
  // Get the div of the layer (main div).
  // It is used to append DOM GUI children.
  AnnotationLayer.prototype.GetParent = function () {
    // return this.AnnotationView.Parent;
    return this.Parent;
  };
  // Get the current scale factor between pixels and world units.
  AnnotationLayer.prototype.GetPixelsPerUnit = function () {
    return this.AnnotationView.GetPixelsPerUnit();
  };

  AnnotationLayer.prototype.GetMetersPerUnit = function () {
    return this.AnnotationView.GetMetersPerUnit();
  };

  /*
  AnnotationLayer.prototype.TestDrawingOnImage = function () {
    if (false && !this.TestImageLoading) {
      // Load the test image
      var self = this;
      var test = new Image();
      test.onload = function () {
        self.TestImage = test;
        var width = 1024;
        var height = 512;
        var canvas = $('<canvas>')
          .attr('width', width.toString())
          .attr('height', height.toString())
          .hide();
        var ctx = canvas[0].getContext('2d');
        // ----- Image canvas.
        ctx.drawImage(self.TestImage,0,0);
        // self.TestImage.style.display = 'none';
        // ----- Canvas to data
        var imageData = ctx.getImageData(0, 0, width, height);
        var data = imageData.data;
        for (var y = 0; y < height; y += 1) {
          for (var x = 512; x < width; x += 1) {
            var idx = 4*(x + y * width);
            data[idx]     = 255 - data[idx];     // red
            // data[idx + 1] = 255 - data[idx + 1]; // green
            data[idx + 2] = 255 - data[idx + 2]; // blue
            data[idx + 3] = 255 - data[idx + 3]; // alpha
          }
        }
        // ----- data back to canvas.
        ctx.putImageData(imageData, 0, 0);
        // ----- canvas to image.
        self.TestImage2 = new Image();
        SA.GirderView.uploadImage(canvas[0].toDataURL('image/png'), '5990fc973f24e54cbd1469b9');
        self.TestImage2.src = canvas[0].toDataURL('image/png');

      };
      test.src = SA.ImagePathUrl + 'imageTest.png';
      test.src = 'http://lemon/api/v1/file/5ad3eb243f24e55361fb4fd9/download?contentDisposition=inline';
      this.TestImageLoading = true;
    }

    if (this.TestImage2) {
      var ctx=this.AnnotationView.Context2d;
      ctx.drawImage(this.TestImage2, 10, 10);
    }
  };
  */

  // the view arg is necessary for rendering into a separate canvas for
  // saving large images.
  AnnotationLayer.prototype.Draw = function () {
    this.AnnotationView.Clear();
    // this.TestDrawingOnImage();

    if (!this.Visibility) { return; }

    for (var i = 0; i < this.WidgetList.length; ++i) {
      this.WidgetList[i].Draw(this);
    }
    // if (this.ScaleWidget) {
      // Girder is not setting spacing correct.
      // But we still need the scale widget for the grid widget.
      // this.ScaleWidget.Draw(this.AnnotationView);
    // }
  };

  AnnotationLayer.prototype.GetView = function () {
    return this.AnnotationView;
  };

  // To compress draw events.
  AnnotationLayer.prototype.EventuallyDraw = function () {
    if (!this.RenderPending) {
      this.RenderPending = true;
      var self = this;
      window.requestAnimationFrame(
                function () {
                  self.RenderPending = false;
                  self.Draw();
                });
    }
  };

  // Allow the layer to receive keyboard events.
  // TODO: If we have not bound out own events, forward focus to the viewer.
  AnnotationLayer.prototype.Focus = function () {
    // This looks like an error LayerDiv is a jquery pointer
    // It was probably can = this.AnnotationView.Parent
    // which is the same thing as LayerDiv (unless AnnotationView was created without a parent arg)
    // var can = this.LayerDiv.Parent;
    var can = this.LayerDiv;
    can.focus();
  };

  // Some widgets need access to the viewer.
  AnnotationLayer.prototype.GetViewer = function () {
    return this.Viewer;
  };

  // I hate to do this, but .....
  // The viewer bindings keeps any children divs from editing text.
  // A second Solution is to make the text dialog a sibling of the viewer.
  // Then full screen would have to be on their parent.
  // TODO: Get rid of this reference.
  AnnotationLayer.prototype.SetViewer = function (viewer) {
    this.Viewer = viewer;
  };

  // Load an array of anntoations into this layer.
  // It does not clear previous annotations. Call reset to do that.
  // Called by Viewer.SetViewerRecord()
  // This is neede to give a callback to an app that needs to update the
  // visibility of annotations based on a threshold.
  AnnotationLayer.prototype.LoadAnnotations = function (annotations) {
    // TODO: Fix this.  Keep actual widgets in the records / notes.
    // For now lets just do the easy thing and recreate all the
    // annotations.
    for (var i = 0; i < annotations.length; ++i) {
      var widget = this.LoadWidget(annotations[i]);
      // This a bad hack. Modifying that array passed in.
      // It is not really needed.  It was a fix for a schema mistake.
      if (!widget) {
        // Get rid of corrupt widgets that do not load properly
        annotations.splice(i, 1);
        --i;
      }
    }

    // This is used by the vigilant plugnin to update which annotations
    // are visible based on a confidence threshold.
    if (this.LoadCallback) {
      (this.LoadCallback)();
    }
    if (this.LoadCallbacks) {
      for (i = 0; i < this.LoadCallbacks.length; ++i) {
        (this.LoadCallbacks[i])();
      }
    }
  };

  // Load a widget from a json object (origin MongoDB).
  // Returns the widget if there was not an error.
  AnnotationLayer.prototype.LoadWidget = function (obj) {
    var widget = SAM.ConstructWidget(obj, this);
    if (widget) {
      this.AddWidget(widget);
    }
    return widget;
  };

  // Return to initial state.
  AnnotationLayer.prototype.Reset = function () {
    this.Clear();
    this.WidgetList = [];
  };

  AnnotationLayer.prototype.GetMouseWorld = function () {
    return this.MouseWorld;
  };

  AnnotationLayer.prototype.ComputeMouseWorld = function (event) {
    this.MouseWorld = this.GetCamera().ConvertPointViewerToWorld(event.offsetX, event.offsetY);
    // Put this extra ivar in the even object.
    event.worldX = this.MouseWorld[0];
    event.worldY = this.MouseWorld[1];
    return this.MouseWorld;
  };

  // TODO: share this code with viewer.
  // I think MouseX,Y and, offestX,Y are both
  // Save the previous touches and record the new
  // touch locations in viewport coordinates.
  AnnotationLayer.prototype.InitializeTouch = function (event, startFlag) {
    this.OriginalEvent = event;
    var date = new Date();
    var t = date.getTime();
    // I have had trouble on the iPad with 0 delta times.
    // Lets see how it behaves with fewer events.
    // It was a bug in iPad4 Javascript.
    // This throttle is not necessary.
    if (t - this.Time < 20 && !startFlag) { return false; }

    this.LastTime = this.Time;
    this.Time = t;

    // Still used on mobile devices?
    this.LastTouches = this.Touches;
    this.Touches = [];
    for (var i = 0; i < event.targetTouches.length; ++i) {
      var offset = this.AnnotationView.Canvas.offset();
      var x = event.targetTouches[i].pageX - offset.left;
      var y = event.targetTouches[i].pageY - offset.top;
      this.Touches.push([x, y]);
    }

    this.LastMouseX = this.MouseX;
    this.LastMouseY = this.MouseY;

    // Compute the touch average.
    var numTouches = this.Touches.length;
    this.MouseX = this.MouseY = 0.0;
    for (i = 0; i < numTouches; ++i) {
      this.MouseX += this.Touches[i][0];
      this.MouseY += this.Touches[i][1];
    }
    this.MouseX = this.MouseX / numTouches;
    this.MouseY = this.MouseY / numTouches;

    // Hack because we are moving away from using the event manager
    // Mouse interaction are already independant...
    this.offsetX = this.MouseX;
    this.offsetY = this.MouseY;

    return true;
  };

  // TODO: Try to get rid of the viewer argument.
  AnnotationLayer.prototype.HandleTouchStart = function (event) {
    if (!this.GetVisibility()) {
      return true;
    }

    this.Event = event;
    this.InitializeTouch(event, true);

    if (event.pencil) {
      console.log('ipad pencil start');
      var pencil = this.GetIPadPencilWidget();
      pencil.SetStateToDrawing();
      pencil.HandleTouchStart(this);
      return false;
    }

    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.HandleTouchStart && !widget.HandleTouchStart(this)) {
        return false;
      }
    }
  };

  AnnotationLayer.prototype.HandleTouchMove = function (e) {
    if (!this.GetVisibility()) {
      return true;
    }
    // Put a throttle on events
    if (!this.InitializeTouch(e, false)) { return; }

    if (event.pencil) {
      console.log('ipad pencil move');
      var pencil = this.GetIPadPencilWidget();
      pencil.HandleTouchMove(this);
      return false;
    }

    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.HandleTouchMove && !widget.HandleTouchMove(this)) {
        return false;
      }
    }

    // More complex touch interactions.
    if (this.Touches.length === 1) {
      return this.HandleTouchPan(this);
    }
    if (this.Touches.length === 2) {
      return this.HandleTouchPinch(this);
    }
  };

  AnnotationLayer.prototype.HandleTouchPan = function (event) {
    if (!this.GetVisibility()) {
      return true;
    }
    if (this.ActiveWidget && this.ActiveWidget.HandleTouchPan) {
      this.Event = event;
      return this.ActiveWidget.HandleTouchPan(this);
    }
    return true;
  };

  AnnotationLayer.prototype.HandleTouchPinch = function (event) {
    if (!this.GetVisibility()) {
      return true;
    }
    this.Event = event;
    if (this.ActiveWidget && this.ActiveWidget.HandleTouchPinch) {
      return this.ActiveWidget.HandleTouchPinch(this);
    }
    return true;
  };

  AnnotationLayer.prototype.HandleTouchEnd = function (event) {
    if (!this.GetVisibility()) {
      return true;
    }
    this.Event = event;

    // It seems that end events do not have a force (to indicate iPad pencil).
    if (this.Pencil && this.Pencil.IsStateDrawingDown()) {
      event.pencil = true;
    }

    if (event.pencil) {
      var pencil = this.GetIPadPencilWidget();
      pencil.HandleTouchEnd(this);
      pencil.SetActive(false);
      this.Modified();
      // Tell the panel that this layer selection has changed.
      if (this.SelectionChangedCallback) {
        (this.SelectionChangedCallback)(this);
      }
      return false;
    }

    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.HandleTouchEnd && !widget.HandleTouchEnd(this)) {
        return false;
      }
    }
    return true;
  };

  AnnotationLayer.prototype.SetMousePositionFromEvent = function (event) {
    if (event.MouseX && event.MouseY) {
      this.MouseX = event.MouseX;
      this.MouseY = event.MouseY;
    } else if (event.offsetX && event.offsetY) {
      this.MouseX = event.offsetX;
      this.MouseY = event.offsetY;
    } else if (event.layerX && event.layerY) {
      this.MouseX = event.layerX;
      this.MouseY = event.layerY;
      event.offsetX = event.layerX;
      event.offsetY = event.layerY;
    }
    this.MouseTime = new Date().getTime();
  };

  // Is any part of the layer selected.
  AnnotationLayer.prototype.IsSelected = function () {
    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.IsSelected()) {
        return true;
      }
    }
  };

  // Click will only select one widget.
  // returns the widget selected or undefined.
  AnnotationLayer.prototype.HandleSelect = function (event) {
    if (!this.GetVisibility()) {
      return;
    }
    this.Event = event;
    this.SetMousePositionFromEvent(event);

    // Not the same as modified.
    var modified = false;
    // This is to limit selection to a single widget, unless shift is held.
    var selectedWidgets = [];

    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      var selectedOld = widget.IsSelected();
      // Skip calling select if widget is already selected and we allow multiple selections.
      if (!(event.shiftKey && selectedOld)) {
        if (widget.HandleSelect && widget.HandleSelect(this)) {
          selectedWidgets.push(widget);
        }
      }

      if (selectedOld !== widget.IsSelected()) {
        modified = true;
      }
      // widget "handleSelect should do this.
      // pencil can have multiple shapes.  I do not wnat them all selected.
      // widget.SetSelected(pick);
    }

    if (selectedWidgets.length > 0 && !this.Active) {
      // Active means editing, since a selected widget will respond to events
      // and change, the layer has to be active.
      this.SetActive(true);
    }

    // This does not work when previously selected
    if (modified) {
      if (this.SelectionChangeCallback) {
        (this.SelectionChangeCallback)(this);
      }
      this.EventuallyDraw();
    }
    return selectedWidgets;
  };

  AnnotationLayer.prototype.HasSelections = function () {
    if (this.GetASelectedWidget()) {
      return true;
    }
    return false;
  };

  // Widget type is the objects type string instance variable.
  // If undefined, it will match any type.
  AnnotationLayer.prototype.GetASelectedWidget = function (widgetType) {
    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.IsSelected && widget.IsSelected()) {
        if (widgetType === undefined || widgetType === widget.Type) {
          return this.WidgetList[i];
        }
      }
    }
    return undefined;
  };

  AnnotationLayer.prototype.HandleMouseDown = function (event) {
    if (!this.GetVisibility()) {
      return true;
    }
    this.Event = event;
    this.LastMouseDownTime = this.MouseDownTime || 1;
    this.SetMousePositionFromEvent(event);
    this.ComputeMouseWorld(event);

    // Trying to detect click
    // TODO: How to skip clicks when doubleclick occur.
    // this.MouseClick = true;
    this.MouseDownX = this.MouseX;
    this.MouseDownY = this.MouseY;
    this.MouseDownTime = this.MouseTime;

    if (this.LastMouseDownTime) {
      if (this.MouseDownTime - this.LastMouseDownTime < 200) {
        delete this.LastMouseDownTime;
        return this.HandleDoubleClick(this);
      }
    }

    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.HandleMouseDown && !widget.HandleMouseDown(this)) {
        return false;
      }
    }
    return true;
  };

  AnnotationLayer.prototype.HandleDoubleClick = function (event) {
    if (!this.GetVisibility()) {
      return true;
    }
    if (this.ActiveWidget && this.ActiveWidget.HandleDoubleClick) {
      this.Event = event;
      return this.ActiveWidget.HandleDoubleClick(this);
    }
    return true;
  };

  AnnotationLayer.prototype.HandleMouseClick = function (event) {
    if (!this.GetVisibility()) {
      return true;
    }
    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.HandleMouseClick && !widget.HandleMouseClick(this)) {
        return false;
      }
    }

    return true;
  };

  AnnotationLayer.prototype.HandleMouseUp = function (event) {
    if (!this.GetVisibility()) {
      return true;
    }

    // if (this.MouseClick) {
    //  this.MouseClick = false;
    //  return this.HandleClick(event);
    // }

    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.HandleMouseUp && !widget.HandleMouseUp(this)) {
        return false;
      }
    }

    return true;
  };

  AnnotationLayer.prototype.HandleMouseMove = function (event) {
    if (!this.GetVisibility()) {
      return true;
    }

    this.Event = event;
    this.SetMousePositionFromEvent(event);

    // The event position is relative to the target which can be a tab on
    // top of the canvas.  Just skip these events.
    // if ($(event.target).width() !== $(event.currentTarget).width()) {
      // console.log('child event ' + event.MouseY);
    // }

    this.ComputeMouseWorld(event);

    // Firefox does not set "which" for move events.
    event.which = event.buttons;
    if (event.which === 2) {
      event.which = 3;
    } else if (event.which === 3) {
      event.which = 2;
    }

    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.HandleMouseMove && !widget.HandleMouseMove(this)) {
        return false;
      }
    }

    // An active widget should stop propagation even if it does not
    // respond to the event.
    return true;
  };

  AnnotationLayer.prototype.HandleMouseWheel = function (event) {
    if (!this.GetVisibility()) {
      return true;
    }
    if (this.ActiveWidget && this.ActiveWidget.HandleMouseWheel) {
      this.Event = event;
      return this.ActiveWidget.HandleMouseWheel(this);
    }
    return true;
  };

  AnnotationLayer.prototype.HandleKeyDown = function (event) {
    if (!this.GetVisibility()) {
      return true;
    }

    if (event.keyCode === 77) {
      // Hack to merge tracks for timelapse
      var strokes = [];
      for (var i = 0; i < this.WidgetList.length; ++i) {
        var w = this.WidgetList[i];
        if (w.IsSelected()) {
          strokes.push(w);
        }
      }
      if (strokes.length > 1) {
        var s0 = strokes[0].Shapes.Shapes[0];
        var s1 = strokes[1].Shapes.Shapes[0];
        // This only works for single strokes.
        // TODO: Get rid of "Shapes".  The correct way to do this is to
        // Just keep polylines (not widgets).
        // A widget drawing can still keep its list of polylines, but the layer
        // does not (has only polylines).  This is a significant change, but not huge.
        // Connect the closest ends.
        var pt0 = s0.Points[s0.Points.length - 1];
        var pt1 = s1.Points[0];
        var dx = pt1[0] - pt0[0];
        var dy = pt1[1] - pt0[1];
        var dist01 = Math.sqrt(dx * dx + dy * dy);
        pt0 = s0.Points[0];
        pt1 = s1.Points[s1.Points.length - 1];
        dx = pt1[0] - pt0[0];
        dy = pt1[1] - pt0[1];
        var dist10 = Math.sqrt(dx * dx + dy * dy);
        if (dist01 < dist10) {
          s0.Points = s0.Points.concat(s1.Points);
        } else {
          s0.Points = s1.Points.concat(s0.Points);
        }
        s0.UpdateBuffers(this.AnnotationView);
        this.RemoveWidget(strokes[1]);
        this.EventuallyDraw();
        return false;
      }
    }

    this.Event = event;

    for (i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.HandleKeyDown && !widget.HandleKeyDown(this)) {
        return false;
      }
    }

    return true;
  };

  AnnotationLayer.prototype.HandleKeyUp = function (event) {
    if (!this.GetVisibility()) {
      return true;
    }

    if (event.keyCode === 46) { // delete key
      // Some browser (safari?) was navigating when the delete key was pressed.
      // (Even though we returned false here. Maybe it was triggered on the keyup.
      event.preventDefault();
      return false;
    }

    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.HandleKeyDown && !widget.HandleKeyDown(this)) {
        return false;
      }
    }
    return true;
  };

  AnnotationLayer.prototype.GetNumberOfWidgets = function () {
    return this.WidgetList.length;
  };

  AnnotationLayer.prototype.GetWidget = function (i) {
    return this.WidgetList[i];
  };

  // Legacy
  AnnotationLayer.prototype.GetWidgets = function () {
    return this.WidgetList;
  };

  AnnotationLayer.prototype.AddWidget = function (widget) {
    var self = this;
    this.WidgetList.push(widget);
    if (widget.SetModifiedCallback) {
      widget.SetModifiedCallback(
        function (w) { self.WidgetModifiedCallback(w); });
    }

    if (widget.UpdateBuffers) { widget.UpdateBuffers(this); }
  };

  // Callback being used for to generally.
  AnnotationLayer.prototype.WidgetModifiedCallback = function (widget) {
    // Just forward the message on.
    this.Modified();
  };

  // Hmmmm.  Try to remove this.  It would be nice not to keep a pointer to an active widget.
  AnnotationLayer.prototype.ActivateWidget = function (widget) {
    if (widget !== this.ActiveWidget) {
      this.LayerDiv.focus();
      this.ActiveWidget = widget;
      // Tell the panel that this layer selection has changed.
      if (this.SelectionChangedCallback) {
        (this.SelectionChangedCallback)(this);
      }
    }
  };

  // TODO: Get rid of this depreciated methods.
  // A widget cannot call this if another widget is active.
  // The widget deals with its own activation and deactivation.
  AnnotationLayer.prototype.DeactivateWidget = function (widget) {
    if (this.ActiveWidget !== widget || widget === null) {
      // Do nothing if the widget is not active.
      return;
    }
    // Incase the widget changed the cursor.  Change it back.
    this.LayerDiv.css({'cursor': ''});
    // The cursor does not change immediatly.  Try to flush.
    this.EventuallyDraw();
    this.ActiveWidget = null;
    widget.SetActive(false);
  };
  // Deactivate all widgets (should the layer have an active state?)
  AnnotationLayer.prototype.Deactivate = function () {
    for (var idx = 0; idx < this.WidgetList.length; ++idx) {
      this.WidgetList[idx].SetActive(false);
    }
  };

  AnnotationLayer.prototype.GetActiveWidget = function () {
    return this.ActiveWidget;
  };

  AnnotationLayer.prototype.RemoveWidget = function (widget) {
    if (widget.Layer === null) {
      return;
    }
    if (this.ActiveWidget === widget) {
      this.ActiveWidget = undefined;
    }
    widget.Layer = null;
    var idx = this.WidgetList.indexOf(widget);
    if (idx !== -1) {
      this.WidgetList.splice(idx, 1);
      this.Modified();
    }
  };

  AnnotationLayer.prototype.LoadGirderItem = function (id) {
    var itemId = '564e42fe3f24e538e9a20eb9';
    var data = {'itemId': itemId,
      'limit': 50,
      'offset': 0,
      'sort': 'lowerName',
      'sortdir': 1};

    // This gives an array of {_id:"....",annotation:{name:"...."},itemId:"...."}
    girder.rest.restRequest({
      type: 'get',
      url: 'annotation',
      data: JSON.stringify(data),
      success: function (data, status) {
        console.log('success');
      },
      error: function () {
        alert('AJAX - error() : annotation get');
      }
    });

    var annotationId = '572be29d3f24e53573aa8e91';
    girder.rest.restRequest({
      url: 'annotation/' + annotationId,    // note that you don't need
      // api/v1
      method: 'GET',                          // data will be put in the
      // body of a POST
      contentType: 'application/json'        // this tells jQuery that we
      // are passing JSON in the body
    }).done(function (data) {
      console.log('done');
    });
  };

  AnnotationLayer.prototype.SaveGirderItem = function (id) {
    // Create a new annotation.
    var annotId = '572be29d3f24e53573aa8e91';
    var data = {'name': 'Test3',
      'elements': [{'type': 'circle',
        'lineColor': '#FFFF00',
        'lineWidth': 20,
        'center': [5000, 5000, 0],
        'radius': 2000}]
    };
    girder.rest.restRequest({
      type: 'post',
      url: 'annotation',
      data: JSON.stringify(data),
      success: function (data, status) {
        console.log('success');
      },
      error: function () {
        alert('AJAX - error() : annotation get');
      }
    });

    // Change an existing annotation
    data = {'name': 'Test',
      'elements': [{'type': 'polyline',
        'points': [[6500, 6600, 0], [3300, 5600, 0], [10600, 500, 6]],
        'closed': true,
        'fillColor': 'rgba(0, 255, 0, 1)'} ]
    };
    girder.rest.restRequest({
      type: 'put',
      url: 'annotation/' + annotId,
      data: JSON.stringify(data),
      success: function (data, status) {
        console.log('success2');
      },
      error: function () {
        alert('AJAX - error() : annotation get');
      }
    });
  };

  AnnotationLayer.prototype.UpdateSize = function () {
    if (!this.AnnotationView) {
      return false;
    }
    if (this.AnnotationView.UpdateCanvasSize()) {
      this.EventuallyDraw();
      return true;
    }
    return false;
  };

  AnnotationLayer.prototype.Test = function () {
    for (var i = 0; i < this.WidgetList.length; ++i) {
      var w = this.WidgetList[i];
      if (w.Type === 'polyline') {
        w.ColorByHandedness();
      }
      this.EventuallyDraw();
    }
  };

  // Order of preference: 1: a selected widget, 2: IVar "Pencil", 3: Stylus only.
  // 4: a new constructed pencil  Widget.
  AnnotationLayer.prototype.GetIPadPencilWidget = function () {
    // For efficiency.
    if (this.Pencil && this.Pencil.IsSelected()) {
      return this.Pencil;
    }

    // Look for a selected.
    for (var i = 0; i < this.WidgetList.length; ++i) {
      var widget = this.WidgetList[i];
      if (widget.StylusOnly) {
        this.Pencil = widget;
      }
      if (widget.Type === 'pencil' && widget.IsSelected()) {
        this.Pencil = widget;
        return widget;
      }
    }

    if (this.Pencil) {
      return this.Pencil;
    }

    // Code to make a new pencil
    // Make a new widget (and make it active).
    this.Pencil = new SAM.PencilWidget(this, false);
    // I want this widget to only respond to pencil/stylus events
    this.Pencil.StylusOnly = true;
    this.WidgetList.push(this.Pencil);
    return this.Pencil;
  };

  SAM.AnnotationLayer = AnnotationLayer;
})();

// here temporarily
// transformation that user camera models
(function () {
  'use strict';

  // ==============================================================================
  // A correlation is just a pair of matching points from two sections.
  // Abstract the correlation so we have an api for getting points.
  // Currently, stack has direct access to correlation ivars / points.
  // The api will make forward and back transformations use the same code.

  // Pass in world to image transformation (3x3) for each image.
  function MatrixTransformation () {
    this.WorldToImage1 = mat3.create();
    this.Image1ToWorld = mat3.create();
    this.WorldToImage2 = mat3.create();
    this.Image2ToWorld = mat3.create();
  }

  MatrixTransformation.prototype.M2Invert = function (m1) {
    var d = m1[0] * m1[3] - m1[1] * m1[2];
    return [ m1[3] / d, -m1[1] / d,
      -m1[2] / d, m1[0] / d];
  };
  MatrixTransformation.prototype.M2Multiply = function (m1, m2) {
    return [m1[0] * m2[0] + m1[1] * m2[2], m1[0] * m2[1] + m1[1] * m2[3],
      m1[2] * m2[0] + m1[3] * m2[2], m1[2] * m2[1] + m1[3] * m2[3]];
  };

  // Initialize with 3 corresponding points.
  MatrixTransformation.prototype.InitializeWithPoints = function (p1a, p2a, p1b, p2b, p1c, p2c) {
    var m1 = mat3.create();
    var m2 = mat3.create();
    mat3.identity(m1);
    mat3.identity(m2);
    // Take the first point as the origin.
    m1[2] = p1a[0]; m1[5] = p1a[1];
    m2[2] = p2a[0]; m2[5] = p2a[1];
    // Assume that the image1 coordinates (minus origin) are world.
    // Matrix to transform i,j to new basis b,c
    var A1 = [p1b[0] - p1a[0], p1c[0] - p1a[0],
      p1b[1] - p1a[1], p1c[1] - p1a[1]];
    var A2 = [p2b[0] - p2a[0], p2c[0] - p2a[0],
      p2b[1] - p2a[1], p2c[1] - p2a[1]];
    var M = this.M2Multiply(A2, this.M2Invert(A1));
    // Use the 2x2 in the 3x3
    m2[0] = M[0]; m2[1] = M[1];
    m2[3] = M[2]; m2[4] = M[3];

    this.Initialize(m1, m2);
  };

  // Pass in two matrixes (World to image)
  MatrixTransformation.prototype.Initialize = function (m1, m2) {
    // Now invert these matrixes.
    mat3.set(m1, this.WorldToImage1);
    mat3.set(m2, this.WorldToImage2);

    // A lot of hastle to get the inverse for a 3x3.
    // It is not that hard to compute.
    var m4a = mat4.create();
    var m4b = mat4.create();
    mat3.toMat4(this.WorldToImage1, m4a);
    mat4.inverse(m4a, m4b);
    mat4.toMat3(m4b, this.Image1ToWorld);

    mat3.toMat4(this.WorldToImage2, m4a);
    mat4.inverse(m4a, m4b);
    mat4.toMat3(m4b, this.Image2ToWorld);
  };

  // 1->2
  // This is confusing because for slides I consider image as world.
  // World here is geo location.
  MatrixTransformation.prototype.ForwardTransformPoint = function (ptIn) {
    var m = this.Image1ToWorld;
    var x = ptIn[0] * m[0] + ptIn[1] * m[1] + m[2];
    var y = ptIn[0] * m[3] + ptIn[1] * m[4] + m[5];
    var h = ptIn[0] * m[6] + ptIn[1] * m[7] + m[8];
    m = this.WorldToImage2;
    var x2 = x * m[0] + y * m[1] + h * m[2];
    var y2 = x * m[3] + y * m[4] + h * m[5];
    var h2 = x * m[6] + y * m[7] + h * m[8];
    return [x2 / h2, y2 / h2];
  };
  // 2->1
  MatrixTransformation.prototype.ReverseTransformPoint = function (ptIn) {
    var m = this.Image2ToWorld;
    var x = ptIn[0] * m[0] + ptIn[1] * m[1] + m[2];
    var y = ptIn[0] * m[3] + ptIn[1] * m[4] + m[5];
    var h = ptIn[0] * m[6] + ptIn[1] * m[7] + m[8];
    m = this.WorldToImage1;
    var x2 = x * m[0] + y * m[1] + h * m[2];
    var y2 = x * m[3] + y * m[4] + h * m[5];
    var h2 = x * m[6] + y * m[7] + h * m[8];
    return [x2 / h2, y2 / h2];
  };

  // 1->2
  MatrixTransformation.prototype.ForwardTransformCamera = function (camIn, camOut) {
    var fpIn = camIn.GetWorldFocalPoint();
    var fpOut = camOut.GetWorldFocalPoint();
    var upIn = [fpIn[0] + 1, fpIn[1]];

    var pt = this.ForwardTransformPoint(fpIn);
    fpOut[0] = pt[0]; fpOut[1] = pt[1];
    var upOut = this.ForwardTransformPoint(upIn);
    upOut[0] -= fpOut[0];
    upOut[1] -= fpOut[1];
    var scale = Math.sqrt(upOut[0] * upOut[0] + upOut[1] * upOut[1]);
    // compute the height.
    camOut.SetHeight(camIn.GetHeight() * scale);
    camOut.SetWorldRoll(camIn.GetWorldRoll());
    camOut.ComputeMatrix();
  };

  // 2->1
  MatrixTransformation.prototype.ReverseTransformCamera = function (camIn, camOut) {
    var fpIn = camIn.GetWorldFocalPoint();
    var fpOut = camOut.GetWorldFocalPoint();
    var upIn = [fpIn[0] + 1, fpIn[1]];

    var pt = this.ReverseTransformPoint(fpIn);
    fpOut[0] = pt[0]; fpOut[1] = pt[1];
    var upOut = this.ReverseTransformPoint(upIn);
    upOut[0] -= fpOut[0];
    upOut[1] -= fpOut[1];
    var scale = Math.sqrt(upOut[0] * upOut[0] + upOut[1] * upOut[1]);
    // compute the height.
    camOut.SetHeight(camIn.GetHeight() * scale);
    camOut.SetWorldRoll(camIn.GetWorldRoll());
    camOut.ComputeMatrix();
  };

  SAM.MatrixTransformation = MatrixTransformation;
})();

// TODO:
// Cleanup API for choosing coordinate systems.
// Position (currently Origin) is in slide.
//   I want to extend this to Viewer.
//   Relative to corners or center and
//   possibly relative to left, right of shape ... like css
// Currently we use FixedSize to choose width and height units.

// For the sort term I need an option to have position relative to upper
// left of the viewer.

(function () {
  'use strict';

  function Shape () {
    this.Orientation = 0.0; // in degrees, counter clockwise, 0 is left
    this.PositionCoordinateSystem = Shape.SLIDE;
    // This is the position of the shape origin in the containing
    // coordinate system. Probably better called position.
    this.Origin = new Array(2);
    this.Origin.fill(10000); // Anchor in world coordinates.
    // FixedSize => PointBuffer units in viewer pixels.
    // otherwise
    this.FixedSize = false;
    this.FixedOrientation = false;
    this.LineWidth = 0; // Line width has to be in same coordinates as points.
    this.Visibility = true; // An easy way to turn off a shape (with removing it from the shapeList).
    this.Selected = false;
    this.SelectedColor = [1.0, 1.0, 0.0];
    // Playing around with layering.  The anchor is being obscured by the text.
    this.ZOffset = 0.1;

    // Grouping shapes.
    // TODO: Change widgets to interactors (that can deal with multiple shapes).
    this.Children = {};
  }

  Shape.prototype.GetLineWidth = function () {
    return this.LineWidth;
  };

  Shape.prototype.GetOrigin = function () {
    return this.Origin;
  };

  // in degrees
  Shape.prototype.GetOrientation = function () {
    return this.Orientation;
  };

  // in radians
  Shape.prototype.GetRotation = function () {
    return this.Orientation * Math.PI / 180.0;
  };

  Shape.prototype.Modified = function () {
    this.Matrix = undefined;
  };

  Shape.prototype.DeleteSelected = function () {
    for (var name in this.Children) {
      if (this.Children[name].DeleteSelected()) {
        delete this.Children[name];
      }
    }
    if (this.IsSelected()) {
      this.PointBuffer = undefined;
      return true;
    }
    return false;
  };

  Shape.prototype.IsEmpty = function () {
    return this.PointBuffer === undefined;
  };

  // Coordinate Systems
  Shape.SLIDE = 0; // Pixel of highest resolution level.
  Shape.VIEWER = 1; // Pixel of viewer canvas.

  Shape.prototype.destructor = function () {
    // Get rid of the buffers?
  };

  // Returns true if the selected state changed.
  Shape.prototype.SetSelected = function (f) {
    if (f === this.Selected) { return false; }
    this.Selected = f;
    // When a parent is selected, the children are highligted too.
    for (var childKey in this.Children) {
      var child = this.Children[childKey];
      child.SetSelected(f);
    }

    return true;
  };

  Shape.prototype.IsSelected = function () {
    return this.Selected;
  };

  Shape.prototype.Draw = function (view) {
    if (!this.Visibility) {
      return;
    }
    if (this.Matrix === undefined) {
      this.UpdateBuffers(view);
    }

    if (this.IsEmpty()) {
      return;
    }

    var theta;
    var m;
    var x;
    var y;
    if (view.gl) {
      // Lets use the camera to change coordinate system to pixels.
      // TODO: Put this camera in the view or viewer to avoid creating one each render.
      var camMatrix = mat4.create();
      mat4.identity(camMatrix);
      if (this.FixedSize) {
        var viewFrontZ = view.Camera.ZRange[0] + 0.01;
        // This camera matrix changes pixel/ screen coordinate system to
        // view [-1,1],[-1,1],z
        camMatrix[0] = 2.0 / view.Viewport[2];
        camMatrix[12] = -1.0;
        camMatrix[5] = -2.0 / view.Viewport[3];
        camMatrix[13] = 1.0;
        camMatrix[14] = viewFrontZ; // In front of tiles in this view
      }

      // The actor matrix that rotates to orientation and shift (0,0) to origin.
      // Rotate based on ivar orientation.
      theta = this.Orientation * 3.1415926536 / 180.0;
      this.Matrix[0] = Math.cos(theta);
      this.Matrix[1] = -Math.sin(theta);
      this.Matrix[4] = Math.sin(theta);
      this.Matrix[5] = Math.cos(theta);
      // Place the origin of the shape.
      x = this.Origin[0];
      y = this.Origin[1];
      if (this.FixedSize) {
        // For fixed size, translation must be in view/pixel coordinates.
        // First transform the world to view.
        m = view.Camera.Matrix;
        x = (this.Origin[0] * m[0] + this.Origin[1] * m[4] + m[12]) / m[15];
        y = (this.Origin[0] * m[1] + this.Origin[1] * m[5] + m[13]) / m[15];
        // convert view to pixels (view coordinate system).
        x = view.Viewport[2] * (0.5 * (1.0 + x));
        y = view.Viewport[3] * (0.5 * (1.0 - y));
      }
      // Translate to place the origin.
      this.Matrix[12] = x;
      this.Matrix[13] = y;
      this.Matrix[14] = this.ZOffset;

      var program = SA.polyProgram;

      view.gl.useProgram(program);
      view.gl.disable(view.gl.BLEND);
      view.gl.enable(view.gl.DEPTH_TEST);

      // This does not work.
      // I will need to make thick lines with polygons.
      // view.gl.lineWidth(5);

      // These are the same for every tile.
      // Vertex points (shifted by tiles matrix)
      view.gl.bindBuffer(view.gl.ARRAY_BUFFER, this.VertexPositionBuffer);
      // Needed for outline ??? For some reason, DrawOutline did not work
      // without this call first.
      view.gl.vertexAttribPointer(program.vertexPositionAttribute,
                                   this.VertexPositionBuffer.itemSize,
                                   view.gl.FLOAT, false, 0, 0);     // Texture coordinates
      // Local view.
      view.gl.viewport(view.Viewport[0], view.Viewport[1],
                        view.Viewport[2], view.Viewport[3]);

      view.gl.uniformMatrix4fv(program.mvMatrixUniform, false, this.Matrix);
      if (this.FixedSize) {
        view.gl.uniformMatrix4fv(program.pMatrixUniform, false, camMatrix);
      } else {
        // Use main views camera to convert world to view.
        view.gl.uniformMatrix4fv(program.pMatrixUniform, false, view.Camera.GetImageMatrix());
      }

      // Fill color
      if (this.FillColor !== undefined) {
        if (this.Selected) {
          view.gl.uniform3f(program.colorUniform, this.SelectedColor[0],
                                 this.SelectedColor[1], this.SelectedColor[2]);
        } else {
          view.gl.uniform3f(program.colorUniform, this.FillColor[0],
                                 this.FillColor[1], this.FillColor[2]);
        }
        // Cell Connectivity
        view.gl.bindBuffer(view.gl.ELEMENT_ARRAY_BUFFER, this.CellBuffer);

        view.gl.drawElements(view.gl.TRIANGLES, this.CellBuffer.numItems,
                                view.gl.UNSIGNED_SHORT, 0);
      }

      if (this.OutlineColor !== undefined) {
        if (this.Selected) {
          view.gl.uniform3f(program.colorUniform, this.SelectedColor[0],
                                 this.SelectedColor[1], this.SelectedColor[2]);
        } else {
          view.gl.uniform3f(program.colorUniform, this.OutlineColor[0],
                                 this.OutlineColor[1], this.OutlineColor[2]);
        }

        if (this.LineWidth === 0) {
          if (this.WireFrame) {
            view.gl.bindBuffer(view.gl.ELEMENT_ARRAY_BUFFER, this.CellBuffer);
            view.gl.drawElements(view.gl.LINE_LOOP, this.CellBuffer.numItems,
                                        view.gl.UNSIGNED_SHORT, 0);
          } else {
            // Outline. This only works for polylines
            view.gl.drawArrays(view.gl.LINE_STRIP, 0, this.VertexPositionBuffer.numItems);
          }
        } else {
          // Cell Connectivity
          view.gl.bindBuffer(view.gl.ELEMENT_ARRAY_BUFFER, this.LineCellBuffer);
          view.gl.drawElements(view.gl.TRIANGLES, this.LineCellBuffer.numItems,
                                    view.gl.UNSIGNED_SHORT, 0);
        }
      }
    } else { // 2d Canvas -----------------------------------------------
      view.Context2d.save();
      // Identity.
      view.Context2d.setTransform(1, 0, 0, 1, 0, 0);

      var scale;
      if (this.PositionCoordinateSystem === Shape.SLIDE) {
        theta = (this.Orientation * 3.1415926536 / 180.0);
        if (!this.FixedSize) {
          theta -= view.Camera.GetImageRoll();
        }
        this.Matrix[0] = Math.cos(theta);
        this.Matrix[1] = -Math.sin(theta);
        this.Matrix[4] = Math.sin(theta);
        this.Matrix[5] = Math.cos(theta);
        // Place the origin of the shape.
        x = this.Origin[0];
        y = this.Origin[1];
        scale = 1.0;
        if (!this.FixedSize) {
          // World need to be drawn in view coordinate system so the
          scale = view.Viewport[3] / view.Camera.GetHeight();
        }
        // First transform the origin-world to view.
        m = view.Camera.GetImageMatrix();
        x = (this.Origin[0] * m[0] + this.Origin[1] * m[4] + m[12]) / m[15];
        y = (this.Origin[0] * m[1] + this.Origin[1] * m[5] + m[13]) / m[15];

        // convert origin-view to pixels (view coordinate system).
        x = view.Viewport[2] * (0.5 * (1.0 + x));
        y = view.Viewport[3] * (0.5 * (1.0 - y));
        view.Context2d.transform(this.Matrix[0], this.Matrix[1], this.Matrix[4], this.Matrix[5], x, y);
      } else if (this.PositionCoordinateSystem === Shape.VIEWER) {
        theta = (this.Orientation * 3.1415926536 / 180.0);
        this.Matrix[0] = Math.cos(theta);
        this.Matrix[1] = -Math.sin(theta);
        this.Matrix[4] = Math.sin(theta);
        this.Matrix[5] = Math.cos(theta);
        // Place the origin of the shape.
        x = this.Origin[0];
        y = this.Origin[1];
        scale = 1.0;

        view.Context2d.transform(this.Matrix[0], this.Matrix[1], this.Matrix[4], this.Matrix[5], x, y);
      }

      // Right now this is specific to a rectangle.
      // It is here because I need the transformation.  It could be generalized...
      if (this.Image && this.Image.complete && this.Width && this.Height) {
        view.Context2d.save();
        // Scale the image to match the rectangle
        var a = this.Width * scale / this.Image.width;
        var d = this.Height * scale / this.Image.height;
        // move the origin to the corner of the image.
        var e = -this.Width * scale / 2.0;
        var f = -this.Height * scale / 2.0;
        // a c e
        // b d f
        view.Context2d.transform(a, 0, 0, d, e, f);
        view.Context2d.drawImage(this.Image, 0, 0);
        view.Context2d.restore();
      }

      // for debugging section alignment.
      var x0 = this.PointBuffer[0];
      var y0 = this.PointBuffer[1];
      // For debugging gradient decent aligning contours.
      // This could be put into the canvas transform, but it is only for debugging.
      // if (this.Trans) {
      //      var vx = x0-this.Trans.cx;
      //      var vy = y0-this.Trans.cy;
      //      var rx =  this.Trans.c*vx + this.Trans.s*vy;
      //      var ry = -this.Trans.s*vx + this.Trans.c*vy;
      //      x0 = x0 + (rx-vx) + this.Trans.sx;
      //      y0 = y0 + (ry-vy) + this.Trans.sy;
      // }

      // This gets remove when the debug code is uncommented.
      view.Context2d.beginPath();
      view.Context2d.moveTo(x0 * scale, y0 * scale);

      var i = 3;
      while (i < this.PointBuffer.length) {
        var x1 = this.PointBuffer[i];
        var y1 = this.PointBuffer[i + 1];
        // For debugging.  Apply a transformation and color by scalars.
        // if (this.Trans) {
        //    var vx = x1-this.Trans.cx;
        //    var vy = y1-this.Trans.cy;
        //    var rx =  this.Trans.c*vx + this.Trans.s*vy;
        //    var ry = -this.Trans.s*vx + this.Trans.c*vy;
        //    x1 = x1 + (rx-vx) + this.Trans.sx;
        //    y1 = y1 + (ry-vy) + this.Trans.sy;
        // }
        // view.Context2d.beginPath();
        // view.Context2d.moveTo(x0*scale,y0*scale);
        // Also for debugging
        // if (this.DebugScalars) {
        //    view.Context2d.strokeStyle=SAM.ConvertColorToHex([1,this.DebugScalars[i/3], 0]);
        // } else {
        //    view.Context2d.strokeStyle=SAM.ConvertColorToHex(this.OutlineColor);
        // }
        // view.Context2d.stroke();
        // x0 = x1;
        // y0 = y1;

        // This gets remove when the debug code is uncommented.
        view.Context2d.lineTo(x1 * scale, y1 * scale);

        i += 3;
      }

      if (this.OutlineColor !== undefined) {
        var width = this.LineWidth * scale;
        if (width === 0) {
          width = 1;
        }
        view.Context2d.lineWidth = width;
        if (this.Selected) {
          view.Context2d.strokeStyle = SAM.ConvertColorToHex(this.SelectedColor);
        } else {
          view.Context2d.strokeStyle = SAM.ConvertColorToHex(this.OutlineColor);
        }
        // This gets remove when the debug code is uncommented.
        view.Context2d.stroke();
      }

      if (this.FillColor !== undefined) {
        if (this.Selected) {
          view.Context2d.fillStyle = SAM.ConvertColorToHex(this.SelectedColor);
        } else {
          view.Context2d.fillStyle = SAM.ConvertColorToHex(this.FillColor);
        }
        view.Context2d.fill();
      }

      view.Context2d.restore();
    }
    for (var name in this.Children) {
      if (this.Children[name] && this.Children[name].Draw) {
        this.Children[name].Draw(view);
      }
    }
  };

  // Invert the fill color.
  Shape.prototype.ChooseOutlineColor = function () {
    if (this.FillColor) {
      this.OutlineColor = [1.0 - this.FillColor[0],
        1.0 - this.FillColor[1],
        1.0 - this.FillColor[2]];
    }
  };

  Shape.prototype.SetOrigin = function (o) {
    this.Origin = o.slice();
  };

  Shape.prototype.SetOutlineColor = function (c) {
    this.OutlineColor = SAM.ConvertColor(c);
  };

  Shape.prototype.GetOutlineColor = function (c) {
    return this.OutlineColor;
  };

  Shape.prototype.SetFillColor = function (c) {
    this.FillColor = SAM.ConvertColor(c);
  };

  Shape.prototype.HandleMouseMove = function (event, dx, dy) {
    // superclass does nothing
    return false;
  };

  // Shape.prototype.UpdateBuffers = function(view) {
  //    // The superclass does not implement this method.
  // }

  // Returns undefined if the point is not on the segment.
  // Returns the interpolation index if it is touching the edge.
  // NOTE: Confusion between undefined and 0. I could return -1 ...???...
  // However -1 could mean extrapolation ....
  Shape.prototype.IntersectPointLine = function (pt, end0, end1, dist) {
    // make end0 the origin.
    var x = pt[0] - end0[0];
    var y = pt[1] - end0[1];
    var vx = end1[0] - end0[0];
    var vy = end1[1] - end0[1];

    // Rotate so the edge lies on the x axis.
    var length = Math.sqrt(vx * vx + vy * vy); // Avoid atan2 ... by rotating with complex numbers
    if (length === 0) {
      return undefined;
    }

    // Get the edge normal direction.
    vx = vx / length;
    vy = -vy / length;
    // Rotate the coordinate system to put the edge on the x axis.
    var newX = (x * vx - y * vy);
    var newY = (x * vy + y * vx);

    if (Math.abs(newY) > dist ||
            newX < 0 || newX > length) {
      return undefined;
    }
    return newX / length;
  };

  SAM.Shape = Shape;
})();

// Originally to hold a set of polylines for the pencil widget.

(function () {
  // Depends on the CIRCLE widget
  'use strict';

  function ShapeGroup () {
    this.Shapes = [];
    this.Bounds = [0, -1, 0, -1];
  }

  ShapeGroup.prototype.UpdateBuffers = function (view) {
    for (var i = 1; i < this.Shapes.length; ++i) {
      var shape = this.Shapes[i];
      if (shape.UpdateBuffers) {
        shape.UpdateBuffers(view);
      }
    }
  };

  ShapeGroup.prototype.GetBounds = function () {
    return this.Bounds;
  };

  // Returns 0 if is does not overlap at all.
  // Returns 1 if part of the section is in the bounds.
  // Returns 2 if all of the section is in the bounds.
  ShapeGroup.prototype.ContainedInBounds = function (bds) {
    if (this.Shapes.length === 0) { return 0; }
    var retVal = this.Shapes[0].ContainedInBounds(bds);
    for (var i = 1; i < this.Shapes.length; ++i) {
      if (retVal === 1) {
                // Both inside and outside. Nothing more to check.
        return retVal;
      }
      var shapeVal = this.Shapes[i].ContainedInBounds(bds);
      if (retVal === 0 && shapeVal !== 0) {
        retVal = 1;
      }
      if (retVal === 2 && shapeVal !== 2) {
        retVal = 1;
      }
    }
    return retVal;
  };

  // Returns the selecteded shape (or undefined).
  ShapeGroup.prototype.HandleSelect = function (pt, dist) {
    var found;
    for (var idx = 0; idx < this.Shapes.length; ++idx) {
      var shape = this.Shapes[idx];
      if (found || !shape.PointOnShape(pt, dist)) {
        // A shape was already selected. Just unselect the rest.
        if (!SAM.ShiftKey) {
          shape.SetSelected(false);
        }
      } else {
        shape.SetSelected(true);
        found = shape;
      }
    }
    return found;
  };

  // Legacy?
  // Returns the index of the shape selected,  -1 if None.
  ShapeGroup.prototype.PointOnShape = function (pt, dist) {
    for (var i = 0; i < this.Shapes.length; ++i) {
      if (this.Shapes[i].PointOnShape(pt, dist)) {
        return i;
      }
    }
    return -1;
  };

  ShapeGroup.prototype.Modified = function () {
    for (var i = 0; i < this.Shapes.length; ++i) {
      this.Shapes.Modified();
    }
  };

  // Return true if any shape was deleted.
  ShapeGroup.prototype.DeleteSelected = function () {
    var modified = false;
    var keepers = [];
    for (var idx = 0; idx < this.Shapes.length; ++idx) {
      var shape = this.Shapes[idx];
      if (this.Shapes[idx].DeleteSelected()) {
        // Something was deleted.
        modified = true;
      }
      if (!shape.IsEmpty()) {
        keepers.push(this.Shapes[idx]);
      }
    }
    if (keepers.length < this.Shapes.length) {
      this.Shapes = keepers;
    }
    return modified;
  };

  ShapeGroup.prototype.IsEmpty = function () {
    for (var idx = 0; idx < this.Shapes.length; ++idx) {
      if (!this.Shapes[idx].IsEmpty()) {
        return false;
      }
    }
    return true;
  };

  // Depreciates: TODO:  Remove this method.
  // I decided I hate popups.  They are visual noise and
  // when there are many annotations, you cannot get the one you want.
  // They always got orphaned for some reason.  Not worth fixing.
  // Find a world location of a popup point given a camera.
  ShapeGroup.prototype.FindPopupPoint = function (cam) {
    if (this.Shapes.length === 0) { return; }
    var roll = cam.GetWorldRoll();
    var s = Math.sin(roll + (Math.PI * 0.25));
    var c = Math.cos(roll + (Math.PI * 0.25));
    var bestPt = this.Shapes[0].FindPopupPoint(cam);
    var bestProjection = (c * bestPt[0]) - (s * bestPt[1]);
    for (var i = 1; i < this.Shapes.length; ++i) {
      var pt = this.Shapes[i].FindPopupPoint(cam);
      var projection = (c * pt[0]) - (s * pt[1]);
      if (projection > bestProjection) {
        bestProjection = projection;
        bestPt = pt;
      }
    }
    return bestPt;
  };

  ShapeGroup.prototype.Draw = function (view) {
    for (var i = 0; i < this.Shapes.length; ++i) {
      this.Shapes[i].Draw(view);
    }
  };

  ShapeGroup.prototype.AddShape = function (shape) {
    this.Shapes.push(shape);
  };

  ShapeGroup.prototype.GetNumberOfShapes = function () {
    return this.Shapes.length;
  };

  ShapeGroup.prototype.GetShape = function (index) {
    return this.Shapes[index];
  };

  ShapeGroup.prototype.PopShape = function () {
    return this.Shapes.pop();
  };

  // Should be called remove child
  ShapeGroup.prototype.DeleteChild = function (idx) {
    return this.Shapes.splice(idx, 1);
  };

  // Set the all to the same selected state.
  // Returns true if any selection changed.
  ShapeGroup.prototype.SetSelected = function (flag) {
    var changed = false;
    for (var i = 0; i < this.Shapes.length; ++i) {
      if (this.Shapes[i].SetSelected(flag)) {
        changed = true;
      }
    }
    return changed;
  };

  // Set only one child selected state
  ShapeGroup.prototype.SetSelectedChild = function (idx, flag) {
    this.Shapes[idx].SetSelected(flag);
  };

  // Returns true if any shapes are selected.
  ShapeGroup.prototype.IsSelected = function () {
    for (var i = 0; i < this.Shapes.length; ++i) {
      if (this.Shapes[i].IsSelected()) {
        return true;
      }
    }
    return false;
  };

  ShapeGroup.prototype.SetLineWidth = function (lineWidth) {
    for (var i = 0; i < this.Shapes.length; ++i) {
      this.Shapes[i].LineWidth = lineWidth;
    }
  };

  // Just returns the first.
  ShapeGroup.prototype.GetLineWidth = function () {
    if (this.Shapes.length !== 0) {
      return this.Shapes[0].GetLineWidth();
    }
    return 0;
  };

  ShapeGroup.prototype.SetOutlineColor = function (color) {
    for (var i = 0; i < this.Shapes.length; ++i) {
      this.Shapes[i].OutlineColor = color;
    }
  };

  // Just returns the first.
  ShapeGroup.prototype.GetOutlineColor = function () {
    if (this.Shapes.length !== 0) {
      return this.Shapes[0].OutlineColor;
    }
    return [0, 0, 0];
  };

  ShapeGroup.prototype.SetOrigin = function (origin) {
    for (var i = 0; i < this.Shapes.length; ++i) {
      // Makes a copy of the array.
      this.Shapes[i].SetOrigin(origin);
    }
  };

  // Adds origin to points and sets origin to 0.
  ShapeGroup.prototype.ResetOrigin = function () {
    for (var i = 0; i < this.Shapes.length; ++i) {
      this.Shapes[i].ResetOrigin();
    }
  };

  // Just returns the first.
  ShapeGroup.prototype.GetOrigin = function () {
    if (this.Shapes.length !== 0) {
      return this.Shapes[0].Origin;
    }
    return [0, 0, 0];
  };

  SAM.ShapeGroup = ShapeGroup;
})();

// ==============================================================================
// Feedback for the image that will be downloaded with the cutout service.
// Todo:
// - Key events and tooltips for buttons.
//   This is difficult because the widget would have to be active all the time.
//   Hold off on this.

(function () {
  'use strict';

  function CutoutWidget (parent, viewer) {
    this.Viewer = viewer;
    // this.Layer = viewer.GetAnnotationLayer();
    var cam = this.Layer.GetCamera();
    var fp = cam.GetWorldFocalPoint();

    var rad = cam.Height / 4;
    this.Bounds = [fp[0] - rad, fp[0] + rad, fp[1] - rad, fp[1] + rad];
    this.DragBounds = [fp[0] - rad, fp[0] + rad, fp[1] - rad, fp[1] + rad];

    this.Layer.AddWidget(this);
    this.Viewer.EventuallyRender();

        // Bits that indicate which edges are active.
    this.Active = 0;

    var self = this;
    this.Div = $('<div>')
            .appendTo(parent)
            .addClass('sa-view-cutout-div');
    $('<button>')
            .appendTo(this.Div)
            .text('Cancel')
            .addClass('sa-view-cutout-button')
            .click(function () { self.Cancel(); });
    $('<button>')
            .appendTo(this.Div)
            .text('Download')
            .addClass('sa-view-cutout-button')
            .click(function () { self.Accept(); });

    this.Select = $('<select>')
            .appendTo(this.Div);
    $('<option>').appendTo(this.Select)
            .attr('value', 0)
            .text('tif');
    $('<option>').appendTo(this.Select)
            .attr('value', 1)
            .text('jpeg');
    $('<option>').appendTo(this.Select)
            .attr('value', 2)
            .text('png');
    $('<option>').appendTo(this.Select)
            .attr('value', 3)
            .text('svs');

    this.Label = $('<div>')
            .addClass('sa-view-cutout-label')
            .appendTo(this.Div);
    this.UpdateBounds();
    this.HandleMouseUp();
  }

  CutoutWidget.prototype.Accept = function () {
    this.Deactivate();
    var types = ['tif', 'jpeg', 'png', 'svs'];
    var imageSource = this.Viewer.GetCache().Image;
        // var bounds = [];
        // for (var i=0; i <this.Bounds.length; i++) {
        //  bounds[i] = this.Bounds[i] -1;
        // }

    window.location = '/cutout/' + imageSource.database + '/' +
            imageSource._id + '/image.' + types[this.Select.val()] + '?bounds=' + JSON.stringify(this.Bounds);
  };

  CutoutWidget.prototype.Cancel = function () {
    this.Deactivate();
  };

  CutoutWidget.prototype.Serialize = function () {
    return false;
  };

  CutoutWidget.prototype.Draw = function (view) {
    var center = [(this.DragBounds[0] + this.DragBounds[1]) * 0.5,
      (this.DragBounds[2] + this.DragBounds[3]) * 0.5];
    var cam = view.Camera;

    if (view.gl) {
      alert('webGL cutout not supported');
    } else {
      // The 2d canvas was left in world coordinates.
      var ctx = view.Context2d;
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      this.DrawRectangle(ctx, this.Bounds, cam, '#00A', 1, 0);
      this.DrawRectangle(ctx, this.DragBounds, cam, '#000', 2, this.Active);
      this.DrawCenter(ctx, center, cam, '#000');
      ctx.restore();
    }
  };

  CutoutWidget.prototype.DrawRectangle = function (ctx, bds, cam, color,
                                                    lineWidth, active) {
        // Convert the for corners to view.
    var pt0 = cam.ConvertPointWorldToViewer(bds[0], bds[2]);
    var pt1 = cam.ConvertPointWorldToViewer(bds[1], bds[2]);
    var pt2 = cam.ConvertPointWorldToViewer(bds[1], bds[3]);
    var pt3 = cam.ConvertPointWorldToViewer(bds[0], bds[3]);

    ctx.lineWidth = lineWidth;

    ctx.beginPath();
    ctx.strokeStyle = (active & 4) ? '#FF0' : color;
    ctx.moveTo(pt0[0], pt0[1]);
    ctx.lineTo(pt1[0], pt1[1]);
    ctx.stroke();

    ctx.beginPath();
    ctx.strokeStyle = (active & 2) ? '#FF0' : color;
    ctx.moveTo(pt1[0], pt1[1]);
    ctx.lineTo(pt2[0], pt2[1]);
    ctx.stroke();

    ctx.beginPath();
    ctx.strokeStyle = (active & 8) ? '#FF0' : color;
    ctx.moveTo(pt2[0], pt2[1]);
    ctx.lineTo(pt3[0], pt3[1]);
    ctx.stroke();

    ctx.beginPath();
    ctx.strokeStyle = (active & 1) ? '#FF0' : color;
    ctx.moveTo(pt3[0], pt3[1]);
    ctx.lineTo(pt0[0], pt0[1]);
    ctx.stroke();
  };

  CutoutWidget.prototype.DrawCenter = function (ctx, pt, cam, color) {
        // Convert the for corners to view.
    var pt0 = cam.ConvertPointWorldToViewer(pt[0], pt[1]);

    ctx.strokeStyle = (this.Active & 16) ? '#FF0' : color;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(pt0[0] - 5, pt0[1]);
    ctx.lineTo(pt0[0] + 5, pt0[1]);
    ctx.moveTo(pt0[0], pt0[1] - 5);
    ctx.lineTo(pt0[0], pt0[1] + 5);
    ctx.stroke();
  };

  CutoutWidget.prototype.HandleKeyPress = function (keyCode, shift) {
        // Return is the same as except.
    if (event.keyCode === 67) {
      alert('Accept');
    }
        // esc or delete: cancel
    if (event.keyCode === 67) {
      alert('Cancel');
    }

    return true;
  };

  CutoutWidget.prototype.HandleDoubleClick = function (event) {
    return true;
  };

  CutoutWidget.prototype.HandleMouseDown = function (event) {
    if (event.which !== 1) {
      return false;
    }
    return true;
  };

    // returns false when it is finished doing its work.
  CutoutWidget.prototype.HandleMouseUp = function () {
    var tmp;
    if (this.Bounds[0] > this.Bounds[1]) {
      tmp = this.Bounds[0];
      this.Bounds[0] = this.Bounds[1];
      this.Bounds[1] = tmp;
    }
    if (this.Bounds[2] > this.Bounds[3]) {
      tmp = this.Bounds[2];
      this.Bounds[2] = this.Bounds[3];
      this.Bounds[3] = tmp;
    }

    this.DragBounds = this.Bounds.slice(0);
    this.Viewer.EventuallyRender();
  };

  CutoutWidget.prototype.HandleMouseMove = function (event) {
    if (event.which === 0) {
      this.CheckActive(event);
      return;
    }

    if (this.Active) {
      var cam = this.Layer.GetCamera();
      var pt = cam.ConvertPointViewerToWorld(event.offsetX, event.offsetY);
      if (this.Active & 1) {
        this.DragBounds[0] = pt[0];
      }
      if (this.Active & 2) {
        this.DragBounds[1] = pt[0];
      }
      if (this.Active & 4) {
        this.DragBounds[2] = pt[1];
      }
      if (this.Active & 8) {
        this.DragBounds[3] = pt[1];
      }
      if (this.Active & 16) {
        var dx = pt[0] - 0.5 * (this.DragBounds[0] + this.DragBounds[1]);
        var dy = pt[1] - 0.5 * (this.DragBounds[2] + this.DragBounds[3]);
        this.DragBounds[0] += dx;
        this.DragBounds[1] += dx;
        this.DragBounds[2] += dy;
        this.DragBounds[3] += dy;
      }
      this.UpdateBounds();
      this.Viewer.EventuallyRender();
      return true;
    }
    return false;
  };

    // Bounds follow drag bounds, but snap to the tile grid.
    // Maybe we should not force Bounds to contain DragBounds.
    // Bounds Grow when dragging the center. Maybe
    // round rather the use floor and ceil.
  CutoutWidget.prototype.UpdateBounds = function (event) {
    var cache = this.Viewer.GetCache();
    var tileWidth = cache.Image.TileWidth;
    var tileHeight = cache.Image.TileHeight;

    var bds = [0, 0, 0, 0];
    bds[0] = Math.round(this.DragBounds[0] / tileWidth) * tileWidth;
    bds[1] = Math.round(this.DragBounds[1] / tileWidth) * tileWidth;
    bds[2] = Math.round(this.DragBounds[2] / tileHeight) * tileHeight;
    bds[3] = Math.round(this.DragBounds[3] / tileHeight) * tileHeight;

    // Keep the bounds in the image.
    // min and max could be inverted.
    // I am not sure the image bounds have to be on the tile boundaries.
    var imgBds = cache.Image.bounds;
    if (bds[0] < imgBds[0]) {
      bds[0] = imgBds[0];
    }
    if (bds[1] < imgBds[0]) {
      bds[1] = imgBds[0];
    }
    if (bds[2] < imgBds[2]) {
      bds[2] = imgBds[2];
    }
    if (bds[3] < imgBds[2]) {
      bds[3] = imgBds[2];
    }

    if (bds[0] > imgBds[1]) {
      bds[0] = imgBds[1];
    }
    if (bds[1] > imgBds[1]) {
      bds[1] = imgBds[1];
    }
    if (bds[2] > imgBds[3]) {
      bds[2] = imgBds[3];
    }
    if (bds[3] > imgBds[3]) {
      bds[3] = imgBds[3];
    }

    // Do not the bounds go to zero area.
    if (bds[0] !== bds[1]) {
      this.Bounds[0] = bds[0];
      this.Bounds[1] = bds[1];
    }
    if (bds[2] !== bds[3]) {
      this.Bounds[2] = bds[2];
      this.Bounds[3] = bds[3];
    }

        // Update the label.
    var dim = [this.Bounds[1] - this.Bounds[0], this.Bounds[3] - this.Bounds[2]];
    this.Label.text(dim[0] + ' x ' + dim[1] +
                        ' = ' + this.FormatPixels(dim[0] * dim[1]) + 'pixels');
  };

  CutoutWidget.prototype.FormatPixels = function (num) {
    if (num > 1000000000) {
      return Math.round(num / 1000000000) + 'G';
    }
    if (num > 1000000) {
      return Math.round(num / 1000000) + 'M';
    }
    if (num > 1000) {
      return Math.round(num / 1000) + 'k';
    }
    return num;
  };

  CutoutWidget.prototype.HandleTouchPan = function (event) {
  };

  CutoutWidget.prototype.HandleTouchPinch = function (event) {
  };

  CutoutWidget.prototype.HandleTouchEnd = function (event) {
  };

  CutoutWidget.prototype.CheckActive = function (event) {
    var cam = this.Layer.GetCamera();
        // it is easier to make the comparison in slide coordinates,
        // but we need a tolerance in pixels.
    var tolerance = cam.Height / 200;
    var pt = cam.ConvertPointViewerToWorld(event.offsetX, event.offsetY);
    var active = 0;

    var inX = (this.DragBounds[0] - tolerance < pt[0] && pt[0] < this.DragBounds[1] + tolerance);
    var inY = (this.DragBounds[2] - tolerance < pt[1] && pt[1] < this.DragBounds[3] + tolerance);
    if (inY && Math.abs(pt[0] - this.DragBounds[0]) < tolerance) {
      active = active | 1;
    }
    if (inY && Math.abs(pt[0] - this.DragBounds[1]) < tolerance) {
      active = active | 2;
    }
    if (inX && Math.abs(pt[1] - this.DragBounds[2]) < tolerance) {
      active = active | 4;
    }
    if (inX && Math.abs(pt[1] - this.DragBounds[3]) < tolerance) {
      active = active | 8;
    }

    var center = [(this.DragBounds[0] + this.DragBounds[1]) * 0.5,
      (this.DragBounds[2] + this.DragBounds[3]) * 0.5];
    tolerance *= 2;
    if (Math.abs(pt[0] - center[0]) < tolerance &&
            Math.abs(pt[1] - center[1]) < tolerance) {
      active = active | 16;
    }

    if (active !== this.Active) {
      this.SetActive(active);
      this.Viewewr.EventuallyRender();
    }

    return false;
  };

    // Multiple active states. Active state is a bit confusing.
  CutoutWidget.prototype.GetActive = function () {
    return this.Active;
  };

  CutoutWidget.prototype.Deactivate = function () {
    this.Div.remove();
    if (this.Layer === null) {
      return;
    }
    this.Layer.DeactivateWidget(this);
    this.Layer.RemoveWidget(this);

    this.Viewer.EventuallyRender();
  };

    // Setting to active always puts state into "active".
    // It can move to other states and stay active.
  CutoutWidget.prototype.SetActive = function (active) {
    if (this.Active === active) {
      return;
    }
    this.Active = active;

    if (active !== 0) {
      this.Layer.ActivateWidget(this);
    } else {
      this.Layer.DeactivateWidget(this);
    }
    this.Viewer.EventuallyRender();
  };

  SAM.CutoutWidget = CutoutWidget;
})();

// TODO:
// Fix the webGL attributes not initialized properly warning.
// Multiple text object should share the same texture.
// Add symbols -=+[]{},.<>'";: .....

(function () {
  'use strict';

  var LINE_SPACING = 1.3;

    // I need an array to map ascii to my letter index.
    // a = 97
  var ASCII_LOOKUP =
    [[0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 0
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 5
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 10
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 15
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 20
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 25
         [0, 413, 50, 98], [0, 413, 50, 98], [900, 17, 30, 98], [791, 119, 28, 95], [0, 413, 50, 98], // 30 32 = ' ' 33="!"
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 35
         [260, 18, 32, 97], [292, 18, 32, 97], [0, 413, 50, 98], [0, 413, 50, 98], [635, 120, 25, 36], // 40 40="(" 41=")" 44=','
         [783, 17, 37, 57], [662, 121, 25, 34], [687, 121, 46, 96], [822, 214, 58, 98], [881, 214, 50, 98], // 45 45="-" 46="." 47="/" 48 = 01
         [932, 214, 56, 98], [0, 114, 53, 98], [54, 114, 54, 98], [109, 114, 54, 98], [164, 114, 57, 98], // 50 = 23456
         [222, 114, 49, 98], [272, 114, 57, 98], [330, 114, 56, 98], [554, 18, 25, 76], [579, 121, 28, 73], // 55 = 789 (387 ') 58=":" 59=";"
         [0, 413, 50, 98], [412, 120, 62, 69], [0, 413, 50, 98], [733, 10, 53, 106], [0, 413, 50, 98], // 60 61 = "=" 63="?"
         [263, 314, 67, 98], [331, 314, 55, 98], [387, 314, 59, 98], [447, 314, 66, 98], [514, 314, 52, 98], // 65 = ABCDE
         [566, 314, 49, 98], [616, 314, 67, 98], [684, 314, 67, 98], [752, 314, 24, 98], [777, 314, 36, 98], // 70 = FGHIJ
         [814, 314, 58, 98], [873, 314, 45, 98], [919, 314, 88, 98], [0, 214, 66, 98], [69, 214, 72, 98], // 75 = KLMNO
         [142, 214, 54, 98], [197, 214, 76, 98], [274, 214, 53, 98], [328, 214, 49, 98], [378, 214, 55, 98], // 80 = PQRST
         [434, 214, 66, 98], [501, 214, 63, 98], [565, 214, 96, 98], [662, 214, 55, 98], [718, 214, 53, 98], // 85 = UVWXY
         [772, 214, 49, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 90 = Z
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [51, 413, 56, 98], [108, 413, 50, 98], // 95 97 = abc
         [154, 413, 50, 98], [210, 413, 50, 98], [263, 413, 39, 98], [301, 413, 50, 98], [350, 413, 54, 98], // 100 = defgh
         [406, 413, 22, 98], [427, 413, 34, 98], [458, 413, 50, 98], [508, 413, 24, 98], [532, 413, 88, 98], // 105 = ijklm
         [619, 413, 57, 98], [675, 413, 60, 98], [734, 413, 57, 98], [790, 413, 57, 98], [847, 413, 40, 98], // 110 = nopqr
         [886, 413, 42, 98], [925, 413, 41, 98], [966, 413, 56, 98], [0, 314, 49, 98], [50, 314, 77, 98], // 115 = stuvw
         [127, 314, 48, 98], [173, 314, 52, 98], [224, 314, 42, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 120 = xyz
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 125
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 130
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 135
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 140
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 145
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 150
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 155
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 160
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 165
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 170
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 175
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 180
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 185
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 198
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 195
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 200
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 205
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 210
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 215
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 220
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 225
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 230
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 235
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 240
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 245
         [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], [0, 413, 50, 98], // 250
         [0, 413, 50, 98]];

  // All text object use the same texture map.

  function Text () {
    this.Color = [0.0, 0.1, 0.5];
    this.FontSize = 12; // Height in pixels

    // Position of the anchor in the world coordinate system.
    this.Position = [100, 100];
    this.Orientation = 0.0; // in degrees, counter clockwise, 0 is left

    // The anchor point and position are the same point.
    // Position is in world coordinates.
    // Offset is in pixel coordinates of text (buffers).
    // In pixel(text) coordinate system
    // It is the position of the upper left corner relative to the postion / anchor.
    this.Offset = [0, 0];
    this.Selected = false;

    // this.String = "Hello World";
    // this.String = "0123456789";
    this.String = '';

    // Pixel bounds are in text box coordiante system.
    this.PixelBounds = [0, 0, 0, 0];

    this.BackgroundFlag = false;
  }

  Text.prototype.DeleteSelected = function () {
    if (this.IsSelected()) {
      this.SetString('');
      return true;
    }
  };

  Text.prototype.IsEmpty = function () {
    return this.String === undefined || this.String === '';
  };

  Text.prototype.SetString = function (str) {
    this.String = str;
  };

  Text.prototype.GetString = function () {
    return this.String;
  };

  Text.prototype.Draw = function (view) {
    // Place the anchor of the text.
    // First transform the world anchor to view.
    var x = this.Position[0];
    var y = this.Position[1];
    if (this.PositionCoordinateSystem !== SAM.Shape.VIEWER) {
      var m = view.Camera.GetImageMatrix();
      x = (this.Position[0] * m[0] + this.Position[1] * m[4] + m[12]) / m[15];
      y = (this.Position[0] * m[1] + this.Position[1] * m[5] + m[13]) / m[15];
      // convert view to pixels (view coordinate system).
      x = view.Viewport[2] * (0.5 * (1.0 + x));
      y = view.Viewport[3] * (0.5 * (1.0 - y));
    }

    // Hacky attempt to mitigate the bug that randomly sends the Offset values into the tens of thousands.
    if (Math.abs(this.Offset[0]) > 1000 || Math.abs(this.Offset[1]) > 1000) {
      this.Offset = [-50, 0];
    }

    // (x,y) is the screen position of the text.
    // Canvas text location is lower left of first letter.
    var strArray = this.String.split('\n');
    // Move (x,y) from tip of the arrow to the upper left of the text box.
    var ctx = view.Context2d;
    ctx.save();
    var radians = this.Orientation * Math.PI / 180;
    var s = Math.sin(radians);
    var c = Math.cos(radians);
    ctx.setTransform(c, -s, s, c, x, y);
    x = -this.Offset[0];
    y = -this.Offset[1];

    ctx.font = this.FontSize + 'pt Calibri';
    var width = this.PixelBounds[1];
    var height = this.PixelBounds[3];
    // Draw the background text box.
    if (this.BackgroundFlag) {
      // ctx.fillStyle = '#fff';
      // ctx.strokeStyle = '#000';
      // ctx.fillRect(x - 2, y - 2, this.PixelBounds[1] + 4, (this.PixelBounds[3] + this.FontSize/3)*1.4);
      var radius = this.FontSize / 4;
      roundRect(ctx, x - radius, y - radius,
                width + 2 * radius, height + 2 * radius,
                radius, true, false);
    }

    // Choose the color for the text.
    if (this.Selected) {
      ctx.fillStyle = '#FF0';
    } else {
      ctx.fillStyle = SAM.ConvertColorToHex(this.Color);
    }

    // Convert (x,y) from upper left of textbox to lower left of first character.
    y = y + this.FontSize;
    // Draw the lines of the text.
    for (var i = 0; i < strArray.length; ++i) {
      ctx.fillText(strArray[i], x, y);
      // Move to the lower left of the next line.
      y = y + this.FontSize * LINE_SPACING;
    }

    // ctx.stroke();
    ctx.restore();
  };

  function roundRect (ctx, x, y, width, height, radius) {
    if (typeof radius === 'undefined') {
      radius = 2;
    }
    ctx.fillStyle = '#fff';
    // ctx.strokeStyle = '#666';
    ctx.fillRect(x, y, width, height);

    /*
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
    */
    // ctx.stroke();
    // ctx.fill();
  }

  Text.prototype.UpdateBuffers = function (view) {
    var i;
    if (!view.gl) {
      // Canvas.  Compute pixel bounds.
      var strArray = this.String.split('\n');
      var height = this.FontSize * LINE_SPACING * strArray.length;
      var width = 0;
      // Hack: use a global viewer because I do not have the viewer.
      // Maybe it should be passed in as an argument, or store the context
      // as an instance variable.
      var ctx = view.Context2d;
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.font = this.FontSize + 'pt Calibri';
      // Compute the width of the text box.
      for (i = 0; i < strArray.length; ++i) {
        var lineWidth = ctx.measureText(strArray[i]).width;
        if (lineWidth > width) { width = lineWidth; }
      }
      this.PixelBounds = [0, width, 0, height];
      ctx.restore();
      return;
    }
    // Create a textured quad for each letter.
    var vertexPositionData = [];
    var textureCoordData = [];
    var cellData = [];
        // 128 for power of 2, but 98 to top of characters.
    var charLeft = 0;
    var charTop = 0;
    var ptId = 0;
    this.PixelBounds = [0, 0, 0, this.FontSize];

    for (i = 0; i < this.String.length; ++i) {
      var idx = this.String.charCodeAt(i);
      if (idx === 10 || idx === 13) { // newline
        charLeft = 0;
        charTop += this.FontSize;
      } else {
        var port = ASCII_LOOKUP[idx];
        // Convert to texture coordinate values.
        var tLeft = port[0] / 1024.0;
        var tRight = (port[0] + port[2]) / 1024.0;
        var tBottom = port[1] / 512.0;
        var tTop = (port[1] + port[3]) / 512.0;
        // To place vertices
        var charRight = charLeft + port[2] * this.FontSize / 98.0;
        var charBottom = charTop + port[3] * this.FontSize / 98.0;

        // Accumulate bounds;
        if (this.PixelBounds[0] > charLeft) { this.PixelBounds[0] = charLeft; }
        if (this.PixelBounds[1] < charRight) { this.PixelBounds[1] = charRight; }
        if (this.PixelBounds[2] > charTop) { this.PixelBounds[2] = charTop; }
        if (this.PixelBounds[3] < charBottom) { this.PixelBounds[3] = charBottom; }

        // Make 4 points, We could share points.
        textureCoordData.push(tLeft);
        textureCoordData.push(tBottom);
        vertexPositionData.push(charLeft);
        vertexPositionData.push(charBottom);
        vertexPositionData.push(0.0);

        textureCoordData.push(tRight);
        textureCoordData.push(tBottom);
        vertexPositionData.push(charRight);
        vertexPositionData.push(charBottom);
        vertexPositionData.push(0.0);

        textureCoordData.push(tLeft);
        textureCoordData.push(tTop);
        vertexPositionData.push(charLeft);
        vertexPositionData.push(charTop);
        vertexPositionData.push(0.0);

        textureCoordData.push(tRight);
        textureCoordData.push(tTop);
        vertexPositionData.push(charRight);
        vertexPositionData.push(charTop);
        vertexPositionData.push(0.0);

        charLeft = charRight;

        // Now create the cell.
        cellData.push(0 + ptId);
        cellData.push(1 + ptId);
        cellData.push(2 + ptId);

        cellData.push(2 + ptId);
        cellData.push(1 + ptId);
        cellData.push(3 + ptId);
        ptId += 4;
      }
    }

    this.VertexTextureCoordBuffer = view.gl.createBuffer();
    view.gl.bindBuffer(view.gl.ARRAY_BUFFER, this.VertexTextureCoordBuffer);
    view.gl.bufferData(view.gl.ARRAY_BUFFER, new Float32Array(textureCoordData), view.gl.STATIC_DRAW);
    this.VertexTextureCoordBuffer.itemSize = 2;
    this.VertexTextureCoordBuffer.numItems = textureCoordData.length / 2;

    this.VertexPositionBuffer = view.gl.createBuffer();
    view.gl.bindBuffer(view.gl.ARRAY_BUFFER, this.VertexPositionBuffer);
    view.gl.bufferData(view.gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), view.gl.STATIC_DRAW);
    this.VertexPositionBuffer.itemSize = 3;
    this.VertexPositionBuffer.numItems = vertexPositionData.length / 3;

    this.CellBuffer = view.gl.createBuffer();
    view.gl.bindBuffer(view.gl.ELEMENT_ARRAY_BUFFER, this.CellBuffer);
    view.gl.bufferData(view.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cellData), view.gl.STATIC_DRAW);
    this.CellBuffer.itemSize = 1;
    this.CellBuffer.numItems = cellData.length;
  };

  // Point in text coordinates is over the text.
  Text.prototype.PointInText = function (xMouse, yMouse) {
    if (!this.Visibility) { return false; }

    var bds = this.PixelBounds.slice(0);
    if (this.BackgroundFlag) {
      var radius = this.FontSize / 4;
      bds[0] -= radius;
      bds[1] += radius;
      bds[2] -= radius;
      bds[3] += radius;
    }
    if (xMouse > bds[0] && xMouse < bds[1] &&
        yMouse > bds[2] && yMouse < bds[3]) {
      return true;
    }
    return false;
  };

  Text.prototype.SetColor = function (c) {
    this.Color = SAM.ConvertColor(c);
  };
  Text.prototype.GetColor = function () {
    return this.Color;
  };

  Text.prototype.SetFontSize = function (s) {
    this.FontSize = s;
  };
  Text.prototype.GetFontSize = function () {
    return this.FontSize;
  };

  Text.prototype.SetBackgroundFlag = function (f) {
    this.BackgroundFlag = f;
  };
  Text.prototype.GetBackgroundFlag = function () {
    return this.BackgroundFlag;
  };

  Text.prototype.IsSelected = function () {
    return this.Selected;
  };

  // Returns true if the selected state changed.
  Text.prototype.SetSelected = function (f) {
    if (f === this.Selected) { return false; }
    this.Selected = f;
    return true;
  };

  SAM.Text = Text;
})();

// ==============================================================================

(function () {
    // Depends on the CIRCLE widget
  'use strict';

  // Not receiving events
  var INACTIVE = 0;
  // Receiving events but not clickable
  var ACTIVE = 1;
  // Mouse over widget and clickable
  var HOVER = 2;
  // Dialog window is up.
  var DIALOG = 3;
  // Dragging the text but not the arrow point
  var DRAG_TEXT = 4;
  // Draggind the text and arrow.
  var DRAG = 5;

  var TEXT_ONLY = 0;
  var ARROW_HOVER = 1;
  var TEXT_ARROW = 2;

  // TODO: Get rid of this layer in the constructor.
  function TextWidget (layer) {
    this.Layer = layer;

    this.Type = 'text';

    this.Text = new SAM.Text();
    this.Text.BackgroundFlag = true;
    this.Arrow = new SAM.Arrow();
    this.ArrowModified = true;
    this.State = INACTIVE;

    this.VisibilityMode = TEXT_ONLY;

    // This method gets called if anything is added, deleted or moved.
    this.ModifiedCallback = undefined;
    // This method gets called if the active state of this widget turns on or off.
    // This is used to turn off the pencil button in the Panel.
    this.StateChangeCallback = undefined;
    // This is used by the annotationPanel to transfer draing mode to a new selected widget.
    this.SelectedCallback = undefined;

    // Hack because I do not have the layer here.  Net toset the initial position.
    this.Uninitialized = true;
  }

  TextWidget.prototype.SetModifiedCallback = function (callback) {
    this.ModifiedCallback = callback;
  };

  TextWidget.prototype.SetSelectedCallback = function (callback) {
    this.SelectedCallback = callback;
  };

  // Selects the widget if the text is fuly contained in the selection rectangle.
  TextWidget.prototype.ApplySelect = function (selection) {
    var bds = this.Text.PixelBounds;
    var cam = this.Layer.GetCamera();
    var p = cam.ConvertPointWorldToViewer(this.Text.Position[0], this.Text.Position[1]);

    if (selection.ViewerPointInSelection(p[0] + bds[0], p[1] + bds[2]) &&
        selection.ViewerPointInSelection(p[0] + bds[0], p[1] + bds[3]) &&
        selection.ViewerPointInSelection(p[0] + bds[1], p[1] + bds[2]) &&
        selection.ViewerPointInSelection(p[0] + bds[1], p[1] + bds[3])) {
      this.Text.SetSelected(true);
      this.Arrow.SetSelected(true);
      return true;
    }
    this.Text.SetSelected(false);
    this.Arrow.SetSelected(false);
    return false;
  };

  TextWidget.prototype.SetCreationCamera = function (cam) {
    // Lets save the zoom level (sort of).
    // Load will overwrite this for existing annotations.
    // This will allow us to expand annotations into notes.
    this.CreationCamera = cam.Serialize();
  };

  // This callback gets called when ever the active state changes,
  // even if caused by an external call. This widget is passed as a argument.
  // This is used to turn off the pencil button in the Panel.
  TextWidget.prototype.SetStateChangeCallback = function (callback) {
    this.StateChangeCallback = callback;
  };

  // Called when the state changes.
  TextWidget.prototype.StateChanged = function () {
    if (this.StateChangeCallback) {
      this.StateChangeCallback(this);
    }
  };

  // Called when widget is modified.
  TextWidget.prototype.Modified = function () {
    if (this.ModifiedCallback) {
      this.ModifiedCallback(this);
    }
  };

  TextWidget.prototype.SetActive = function (flag) {
    if (flag && this.State !== ACTIVE) {
      this.State = HOVER;
      this.StateChanged();
    }
    if (!flag && this.State !== INACTIVE) {
      this.State = INACTIVE;
      this.StateChanged();
      // I should just let te caller do this.
      this.Text.SetSelected(false);
      this.Arrow.SetSelected(false);
    }
    // And this.
    this.Layer.EventuallyDraw();
  };

  // I am not sure if this is used.  We have multiple selected states.
  // Default to the whole widget selected.
  TextWidget.prototype.SetSelected = function (flag) {
    this.Text.SetSelected(flag);
    this.Arrow.SetSelected(flag);

    if (flag && this.SelectedCallback) {
      (this.SelectedCallback)(this);
    }
    if (!flag) {
      // We can be selected without being active, but we cannot be
      // active without being selected.
      this.SetActive(false);
    }
  };

  TextWidget.prototype.SetStateToDialog = function () {
    if (this.State === DIALOG) {
      return;
    }
    if (!this.Dialog) {
      this.InitializeDialog();
    }
    this.State = DIALOG;
    this.WidgetPropertiesToDialog();
    this.StateChanged();
    this.ShowPropertiesDialog();
  };

  // Can we delete this?
  TextWidget.prototype.IsEmpty = function () {
    return this.Text.IsEmpty();
  };

  TextWidget.prototype.IsSelected = function () {
    return this.Text.IsSelected() || this.Arrow.IsSelected();
  };

  TextWidget.prototype.SetPositionToDefault = function () {
    var view = this.Layer.GetView();
    this.Text.UpdateBuffers(view); // Needed to get the bounds.
    // middle top(above)
    var offset = [
      (this.Text.PixelBounds[0] + this.Text.PixelBounds[1]) * 0.5,
      -this.Text.PixelBounds[3]];
    var middle = [
      0.5 * (this.Text.PixelBounds[0] + this.Text.PixelBounds[1]),
      0.5 * (this.Text.PixelBounds[2] + this.Text.PixelBounds[3])];
    if (this.VisibilityMode === TEXT_ONLY) {
      this.Text.Offset = middle;
      this.SavedTextOffset = offset;
    } else {
      this.Text.Offset = offset;
      this.SavedTextOffset = offset;
    }

    // I would like to setup the anchor in the middle of the screen,
    // And have the Anchor in the middle of the text.
    var cam = this.Layer.GetCamera();
    var fp = cam.GetWorldFocalPoint();
    this.Text.Position = [fp[0], fp[1], 0];
    this.ArrowModified = true;
    this.Uninitialized = false;
  };

  // Three state visibility so text can be hidden during calss questions.
  // The combined visibilities is confusing.
  // Global text visibility is passed in as argument.
  // Local visiblity mode is the hover state of this text. (0 text only, 1: hover, 2: both on).
  TextWidget.prototype.Draw = function () {
    if (this.State === DIALOG) {
      // So it does not draw until after the initial dialog is gone.
      return;
    }
    // Get the text bounds and initialize the postion anchor and offset.
    if (this.Uninitialized) {
      this.SetPositionToDefault();
    }
    var view = this.Layer.GetView();
    // TODO:  FIx this . it is hacky.
    // I think bounds are not computable until after the first render or something.
    if (this.Text.PixelBounds[1] === 0) {
      this.Text.UpdateBuffers(view);
      this.ArrowModified = true;
    }
    if (this.ArrowModified) {
      this.UpdateArrow();
    }

    if (this.VisibilityMode !== 0) {
      this.Arrow.Draw(view);
    }
    // if (this.VisibilityMode !== ARROW_HOVER || this.Arrow.IsSelected()) {
    this.Text.Draw(view);
    this.Text.Visibility = true;
    // } else {
    //  this.Text.Visibility = false;
    // }
  };

  TextWidget.prototype.PasteCallback = function (data, mouseWorldPt) {
    this.Load(data);
    // Place the tip of the arrow at the mose location.
    this.Text.Position[0] = mouseWorldPt[0];
    this.Text.Position[1] = mouseWorldPt[1];
    this.ArrowModified = true;
    this.Layer.EventuallyDraw();
    this.Modified();
  };

  TextWidget.prototype.Serialize = function () {
    if (this.Text === undefined) { return null; }
    var obj = {};
    obj.type = 'text';
    obj.user_note_flag = this.UserNoteFlag;
    obj.color = this.Text.Color;
    obj.size = this.Text.FontSize;
    obj.offset = [-this.Text.Offset[0], -this.Text.Offset[1]];
    obj.position = this.Text.Position;
    obj.string = this.Text.String;
    obj.visibility = this.VisibilityMode;
    obj.backgroundFlag = this.Text.BackgroundFlag;
    obj.creation_camera = this.CreationCamera;

    return obj;
  };

  // Load a widget from a json object (origin MongoDB).
  TextWidget.prototype.Load = function (obj) {
    this.UserNoteFlag = obj.user_note_flag;

    this.Text.String = obj.string;
    var rgb = [parseFloat(obj.color[0]),
      parseFloat(obj.color[1]),
      parseFloat(obj.color[2])];
    this.Text.SetColor(rgb);
    this.Text.SetFontSize(parseFloat(obj.size));
    if (obj.backgroundFlag !== undefined) {
      this.Text.BackgroundFlag = obj.backgroundFlag;
    }
    this.Text.Position = [parseFloat(obj.position[0]),
      parseFloat(obj.position[1]),
      parseFloat(obj.position[2])];

    // I added offest and I have to deal with entries that do not have it.
    if (obj.offset) { // how to try / catch in javascript?
      this.SetTextOffset(parseFloat(obj.offset[0]),
                         parseFloat(obj.offset[1]));
    }

    // How zoomed in was the view when the annotation was created.
    if (obj.creation_camera !== undefined) {
      this.CreationCamera = obj.creation_camera;
    }

    if (obj.visibility !== undefined) {
      this.VisibilityMode = obj.visibility;
    }

    this.Arrow.SetFillColor(rgb);
    this.Arrow.ChooseOutlineColor();
    this.ArrowModified = true;
    this.Uninitialized = false;
  };

  // When the arrow is visible, the text is offset from the position (tip of arrow).
  TextWidget.prototype.SetTextOffset = function (x, y) {
    this.SavedTextOffset = [-x, -y];
    this.Text.Offset = this.SavedTextOffset.slice(0);
    this.ArrowModified = true;
  };

  // When the arrow is visible, the text is offset from the position (tip of arrow).
  TextWidget.prototype.SetPosition = function (x, y) {
    this.Text.Position = [x, y, 0];
    this.ArrowModified = true;
  };

  // Offset is in the middle of the bounds when the shape is not visible.
  TextWidget.prototype.SetVisibilityMode = function (mode) {
    if (mode === this.VisibilityMode) {
      return;
    }
    // var modified = true;
    this.ArrowModified = true;
    if (mode === TEXT_ONLY) {
      this.SavedTextOffset = this.Text.Offset.slice(0);
      // Adjust the offset so the anchor is in the center of the text.
      this.Text.Offset = [
        (this.Text.PixelBounds[0] + this.Text.PixelBounds[1]) * 0.5,
        (this.Text.PixelBounds[2] + this.Text.PixelBounds[3]) * 0.5];
    }
    if (this.VisibilityMode === TEXT_ONLY) {
      if (this.SavedTextOffset) {
        this.Text.Offset = this.SavedTextOffset.slice(0);
      } else {
        // SHort arrow pointing to the left.
        this.Text.Offset = [
          (this.Text.PixelBounds[0] + this.Text.PixelBounds[1]) * 0.5,
          -this.Text.PixelBounds[3]];
      }
    }
    this.VisibilityMode = mode;
  };

  // Change orientation and length of arrow based on the anchor location.
  TextWidget.prototype.UpdateArrow = function () {
    if (this.Text.PixelBounds[3] === 0) {
      return;
    }
    this.Arrow.Origin = this.Text.Position;

    // Compute the middle of the text bounds.
    var xMid = 0.5 * (this.Text.PixelBounds[0] + this.Text.PixelBounds[1]);
    var yMid = 0.5 * (this.Text.PixelBounds[2] + this.Text.PixelBounds[3]);
    var xRad = 0.5 * (this.Text.PixelBounds[1] - this.Text.PixelBounds[0]);
    var yRad = 0.5 * (this.Text.PixelBounds[3] - this.Text.PixelBounds[2]);

    // Compute the angle of the arrow.
    var dx = this.Text.Offset[0] - xMid;
    var dy = this.Text.Offset[1] - yMid;
    this.Arrow.Orientation = -(180.0 + Math.atan2(dy, dx) * 180.0 / Math.PI);
    // Compute the length of the arrow.
    var length = Math.sqrt(dx * dx + dy * dy);
    // Find the intersection of the vector and the bounding box.
    var min = length;
    var d;
    if (dy !== 0) {
      d = Math.abs(length * yRad / dy);
      if (min > d) { min = d; }
    }
    if (dx !== 0) {
      d = Math.abs(length * xRad / dx);
      if (min > d) { min = d; }
    }
    length = length - min - 5;
    if (length < 5) { length = 5; }
    this.Arrow.Length = length;
    this.Arrow.UpdateBuffers(this.Layer.GetView());
    this.ArrowModified = false;
  };

  // Returns this widget if it is selected, undefined otherwise.
  TextWidget.prototype.HandleSelect = function () {
    if (this.State === DIALOG) {
      return;
    }
    var event = this.Layer.Event;
    var tMouse = this.ScreenPixelToTextPixelPoint(event.offsetX, event.offsetY);

    if (this.Text.PointInText(tMouse[0], tMouse[1])) {
      this.Text.SetSelected(true);
      this.Arrow.SetSelected(false);
      this.Layer.GetParent().css({'cursor': 'move'});
      this.State = HOVER;
      return this;
    }
    var anchor = this.Text.Offset;
    if (this.Arrow.PointInShape(tMouse[0] - anchor[0], tMouse[1] - anchor[1])) {
      this.Text.SetSelected(true);
      this.Arrow.SetSelected(true);
      this.Layer.GetParent().css({'cursor': 'move'});
      this.State = DRAG;
      return this;
    }
    // Not really necesary, but it cannot hurt.
    this.SetActive(false);
  };

  // Returns true if modified.
  TextWidget.prototype.DeleteSelected = function () {
    return this.Text.DeleteSelected();
  };

  TextWidget.prototype.HandleKeyDown = function () {
    // The dialog consumes all key events.
    if (this.State === DIALOG) {
      return false;
    }

    // Copy
    var event = this.Layer.Event;
    if (event.keyCode === 67 && event.ctrlKey) {
      // control-c for copy
      // The extra identifier is not needed for widgets, but will be
      // needed if we have some other object on the clipboard.
      var clip = {Type: 'TextWidget', Data: this.Serialize()};
      localStorage.ClipBoard = JSON.stringify(clip);
      return false;
    }

    return true;
  };

  TextWidget.prototype.HandleMouseDown = function () {
    if (this.State === INACTIVE) {
      return true;
    }

    var event = this.Layer.Event;
    if (event.which === 1) {
      var x = event.offsetX;
      var y = event.offsetY;
      this.LastMouse = [x, y];
      // var tMouse = this.ScreenPixelToTextPixelPoint(x, y);
      if (this.State === HOVER) {
        if (this.Arrow.IsSelected()) {
          this.State = DRAG;
        } else if (this.Text.IsSelected()) {
          if (this.VisibilityMode === TEXT_ONLY) {
            this.State = DRAG;
          } else {
            this.State = DRAG_TEXT;
          }
        }
      }
    }

    return this.State === ACTIVE;
  };

  // returns false when it is finished doing its work.
  TextWidget.prototype.HandleMouseUp = function () {
    if (this.State === INACTIVE) {
      return true;
    }
    if (this.State === DRAG_TEXT || this.State === DRAG) {
      this.SetActive(true);
      this.Modified();
    }
    return false;
  };

  // I need to convert mouse screen point to coordinates of text buffer
  // to see if the mouse position is in the bounds of the text.
  // Screen y vector point down (up is negative).
  // Text coordinate system will match canvas text: origin upper left, Y point down.
  TextWidget.prototype.ScreenPixelToTextPixelPoint = function (x, y) {
    // convert the world arrow tip to screen.
    var cam = this.Layer.GetCamera();
    var textOriginScreenPixelPosition =
            cam.ConvertPointWorldToViewer(this.Text.Position[0], this.Text.Position[1]);
    // Offset to the text)
    x = (x - textOriginScreenPixelPosition[0]) + this.Text.Offset[0];
    y = (y - textOriginScreenPixelPosition[1]) + this.Text.Offset[1];

    return [x, y];
  };

  TextWidget.prototype.HandleMouseMove = function () {
    if (this.State === INACTIVE) {
      return true;
    }

    // Handle the hovering feature.
    // Indicates that clicking will drag by changing the cursor.
    var event = this.Layer.Event;
    var x = event.offsetX;
    var y = event.offsetY;
    if (this.State === ACTIVE || this.State === HOVER) {
      var cursor = '';
      var tMouse = this.ScreenPixelToTextPixelPoint(x, y);
      var anchor = this.Text.Offset;
      if (this.Text.IsSelected() && this.Text.PointInText(tMouse[0], tMouse[1])) {
        cursor = 'move';
        this.State = HOVER;
      } else if (this.Arrow.IsSelected() && this.Arrow.PointInShape(tMouse[0] - anchor[0], tMouse[1] - anchor[1])) {
        cursor = 'move';
        this.State = HOVER;
      } else {
        this.State = ACTIVE;
      }
      this.Layer.GetParent().css({'cursor': cursor});
    }

    if ((this.VisibilityMode === 0 && this.State === DRAG_TEXT) ||
        this.State === DRAG) {
      var cam = this.Layer.GetCamera();
      var w0 = cam.ConvertPointViewerToWorld(this.LastMouse[0], this.LastMouse[1]);
      var w1 = cam.ConvertPointViewerToWorld(x, y);
      var wdx = w1[0] - w0[0];
      var wdy = w1[1] - w0[1];
      this.Text.Position[0] += wdx;
      this.Text.Position[1] += wdy;
      this.ArrowModified = true;
      this.Layer.EventuallyDraw();
      this.LastMouse = [x, y];
      return false;
    } else if (this.State === DRAG_TEXT) { // Just the text not the anchor glyph
      var dx = event.offsetX - this.LastMouse[0];
      var dy = event.offsetY - this.LastMouse[1];
      this.LastMouse = [event.offsetX, event.offsetY];
      // TODO: Get the Mouse Deltas out of the layer.
      this.Text.Offset[0] -= dx;
      this.Text.Offset[1] -= dy;
      this.ArrowModified = true;
      this.Layer.EventuallyDraw();
      return false;
    }
    return true;
  };

  TextWidget.prototype.HandleTouchPan = function () {
    // We should probably have a handle touch start too.
    if (this.State === INACTIVE) {
      return true;
    }

    this.Layer.MouseDeltaX = this.Layer.MouseX - this.Layer.LastMouseX;
    this.Layer.MouseDeltaY = this.Layer.MouseY - this.Layer.LastMouseY;
    this.HandleMouseMove();
    return false;
  };

  TextWidget.prototype.HandleTouchEnd = function () {
    if (this.State === INACTIVE) {
      return true;
    }
    this.Modified();
    return false;
  };

  TextWidget.prototype.GetActive = function () {
    if (this.State !== INACTIVE) {
      return true;
    }
    return false;
  };

  // This creates the dialog and sets all values to defaults (from local storage).
  TextWidget.prototype.InitializeDialog = function () {
    this.Dialog = new SAM.Dialog(this.Layer.GetParent().parent());
    this.Dialog.Title.text('Text Annotation Editor');
    this.Dialog.Body.css({'margin': '1em 2em'});

    this.Dialog.TextInput =
      $('<textarea>')
      .appendTo(this.Dialog.Body)
      .css({
        'width': '87%',
        'height': '8em'});

    this.Dialog.FontDiv = $('<div>')
      .appendTo(this.Dialog.Body)
      .css({'display': 'table-row'});
    this.Dialog.FontLabel = $('<div>')
      .appendTo(this.Dialog.FontDiv)
      .text('Font (px):')
      .css({
        'display': 'table-cell',
        'text-align': 'left'});
    this.Dialog.FontInput = $('<input type="number">')
      .appendTo(this.Dialog.FontDiv)
      .val('12')
      .css({'display': 'table-cell'});

    this.Dialog.ColorDiv = $('<div>')
      .appendTo(this.Dialog.Body)
      .css({'display': 'table-row'});
    this.Dialog.ColorLabel = $('<div>')
      .appendTo(this.Dialog.ColorDiv)
      .text('Color:')
      .css({
        'display': 'table-cell',
        'text-align': 'left'});
    this.Dialog.ColorInput = $('<input type="color">')
      .appendTo(this.Dialog.ColorDiv)
      .val('#30ff00')
            .css({'display': 'table-cell'});

    this.Dialog.VisibilityModeDiv = $('<div>')
      .appendTo(this.Dialog.Body)
      .css({'display': 'table-row'});
    this.Dialog.VisibilityModeLabel = $('<div>')
      .appendTo(this.Dialog.VisibilityModeDiv)
      .text('Visibility:')
      .css({
        'display': 'table-cell',
        'text-align': 'left'});
    this.Dialog.VisibilityModeInputButtons = $('<div>')
      .appendTo(this.Dialog.VisibilityModeDiv)
      .css({'display': 'table-cell'});
    this.Dialog.VisibilityModeInputs = [];
    this.Dialog.VisibilityModeInputs[TEXT_ONLY] =
      $('<input type="radio" name="visibilityoptions" value="0">Text only</input>')
      .appendTo(this.Dialog.VisibilityModeInputButtons);

    $('<br>').appendTo(this.Dialog.VisibilityModeInputButtons);

    this.Dialog.VisibilityModeInputs[ARROW_HOVER] =
      $('<input type="radio" name="visibilityoptions" value="1">Arrow only, text on hover</input>')
      .appendTo(this.Dialog.VisibilityModeInputButtons);

    $('<br>').appendTo(this.Dialog.VisibilityModeInputButtons);

    this.Dialog.VisibilityModeInputs[TEXT_ARROW] =
      $('<input type="radio" name="visibilityoptions" value="2">Arrow and text visible</input>')
      .appendTo(this.Dialog.VisibilityModeInputButtons);

    this.Dialog.VisibilityModeInputs[TEXT_ONLY].attr('checked', 'true');

    this.Dialog.BackgroundDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.BackgroundLabel =
            $('<div>')
            .appendTo(this.Dialog.BackgroundDiv)
            .text('Background:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.BackgroundInput =
            $('<input type="checkbox">')
            .appendTo(this.Dialog.BackgroundDiv)
            .css({'display': 'table-cell'});

    // Get default properties.
    this.VisibilityMode = TEXT_ONLY;
    this.Dialog.BackgroundInput.prop('checked', true);
    var hexcolor = SAM.ConvertColorToHex(this.Dialog.ColorInput.val());
    if (localStorage.TextWidgetDefaults) {
      var defaults = JSON.parse(localStorage.TextWidgetDefaults);
      if (defaults.Color) {
        hexcolor = SAM.ConvertColorToHex(defaults.Color);
        this.Text.SetColor(hexcolor);
        this.Arrow.SetFillColor(hexcolor);
      } else {
        this.Arrow.SetFillColor(this.Text.Color);
      }
      if (defaults.FontSize) {
        // font size was wrongly saved as a string.
        this.Text.SetFontSize(parseFloat(defaults.FontSize));
      }
      if (defaults.BackgroundFlag !== undefined) {
        this.Text.BackgroundFlag = defaults.BackgroundFlag;
      }
      if (defaults.VisibilityMode !== undefined) {
        this.VisibilityMode = defaults.VisibilityMode;
        this.Dialog.VisibilityModeInputs[this.VisibilityMode].attr('checked', 'true');
      }
    }
  };

  // Can we bind the dialog apply callback to an objects method?
  TextWidget.prototype.ShowPropertiesDialog = function () {
    var self = this;
    this.Dialog.SetApplyCallback(function () { self.DialogApplyCallback(); });
    this.Dialog.SetCloseCallback(function () { self.DialogCloseCallback(); });
    this.Dialog.Show(true);
    this.Dialog.TextInput.focus();
  };

  TextWidget.prototype.DialogApplyCallback = function () {
    // Transfer properties fromt he dialog GUI to the widget.
    this.DialogPropertiesToWidget();
    // View bindings kept the dialog text input from working.
    if (!this.Layer) {
      return;
    }
    this.SetActive(false);
    this.Layer.EventuallyDraw();
  };

  TextWidget.prototype.DialogCloseCallback = function () {
    // View bindings keep dialog text input from working.
    if (this.Uninitialized) {
      // This will triger the layer to get rid of the text widget.
      this.Text.SetString('');
    }
    // Why doen't the layer do this?
    if (this.IsEmpty()) {
      this.Layer.EventuallyDraw();
      this.Layer.RemoveWidget(this);
      // Trigger the changed callback  (should we have a delete callback?)
      this.StateChanged();
      return;
    }

    this.SetActive(false);
    this.Layer.EventuallyDraw();
  };

  // Fill the dialog values from the widget values.
  TextWidget.prototype.WidgetPropertiesToDialog = function () {
    this.Dialog.ColorInput.val(SAM.ConvertColorToHex(this.Text.Color));
    this.Dialog.FontInput.val(this.Text.GetFontSize().toFixed(0));
    this.Dialog.BackgroundInput.prop('checked', this.Text.BackgroundFlag);
    this.Dialog.TextInput.val(this.Text.String);
    // this.Dialog.VisibilityModeInputs[this.VisibilityMode].attr('checked', true);
  };

  // Copy the properties of the dialog into the widget
  TextWidget.prototype.DialogPropertiesToWidget = function () {
    var modified = false;

    // Get the string
    this.ApplyLineBreaks();
    var string = this.Dialog.TextInput.val();
    // remove any trailing white space.
    string = string.trim();
    if (string === '') {
      this.Layer.EventuallyDraw();
      this.Layer.RemoveWidget(this);
      // Trigger the changed callback  (should we have a delete callback?)
      this.StateChanged();
      return;
    }
    if (string !== this.Text.GetString()) { modified = true; }
    this.Text.SetString(string);

    // Get the color
    var hexcolor = SAM.ConvertColorToHex(this.Dialog.ColorInput.val());
    if (hexcolor !== this.Text.GetColor()) {
      modified = true;
      this.Text.SetColor(hexcolor);
      this.Arrow.SetFillColor(hexcolor);
      this.Arrow.ChooseOutlineColor();
      this.ArrowModified = true;
    }

    // Get the font size
    var fontSize = parseFloat(this.Dialog.FontInput.val());
    if (fontSize !== this.Text.GetFontSize()) { modified = true; }
    this.Text.SetFontSize(fontSize);

    // Get the visibility mode
    var mode = TEXT_ONLY;
    if (this.Dialog.VisibilityModeInputs[TEXT_ONLY].prop('checked')) {
      if (this.VisibilityMode !== TEXT_ONLY) { modified = true; }
      mode = TEXT_ONLY;
    } else if (this.Dialog.VisibilityModeInputs[ARROW_HOVER].prop('checked')) {
      if (this.VisibilityMode !== ARROW_HOVER) { modified = true; }
      mode = ARROW_HOVER;
    } else {
      if (this.VisibilityMode !== TEXT_ARROW) { modified = true; }
      mode = TEXT_ARROW;
    }
    if (this.VisibilityMode !== mode) {
      // This also changes the anchor if necessary.
      this.SetVisibilityMode(mode);
      modified = true;
    }

    // Background flag is not working for some reasop.
    var backgroundFlag = this.Dialog.BackgroundInput.prop('checked');
    if (backgroundFlag !== this.Text.GetBackgroundFlag()) {
      modified = true;
      this.Text.SetBackgroundFlag(backgroundFlag);
    }

    // Save values in local storage as defaults for next time.
    localStorage.TextWidgetDefaults = JSON.stringify({
      Color: hexcolor,
      FontSize: this.Text.GetFontSize(),
      VisibilityMode: this.VisibilityMode,
      BackgroundFlag: backgroundFlag});

    if (modified) {
      this.Modified();
    }
  };

  // Function to apply line breaks to textarea text.
  TextWidget.prototype.ApplyLineBreaks = function () {
    var oTextarea = this.Dialog.TextInput[0];

    oTextarea.setAttribute('wrap', 'off');
    var strRawValue = oTextarea.value;
    oTextarea.value = '';
    var nEmptyWidth = oTextarea.scrollWidth;
    var nLastWrappingIndex = -1;
    for (var i = 0; i < strRawValue.length; i++) {
      var curChar = strRawValue.charAt(i);
      if (curChar === ' ' || curChar === '-' || curChar === '+') {
        nLastWrappingIndex = i;
      }
      oTextarea.value += curChar;
      if (oTextarea.scrollWidth > nEmptyWidth) {
        var buffer = '';
        if (nLastWrappingIndex >= 0) {
          for (var j = nLastWrappingIndex + 1; j < i; j++) {
            buffer += strRawValue.charAt(j);
          }
          nLastWrappingIndex = -1;
        }
        buffer += curChar;
        oTextarea.value = oTextarea.value.substr(0, oTextarea.value.length - buffer.length);
        oTextarea.value += '\n' + buffer;
      }
    }
    oTextarea.setAttribute('wrap', '');
  };

  SAM.TextWidget = TextWidget;
})();

// Polyline. one line witn multiple segments.

(function () {
  'use strict';

  function Polyline () {
    SAM.Shape.call(this);
    this.Origin = [0.0, 0.0]; // Center in world coordinates.
    this.Points = [];
    this.Closed = false;
    this.Bounds = [0, -1, 0, -1];
  }
  Polyline.prototype = new SAM.Shape();

  // Polyline.prototype.destructor=function() {
  // Get rid of the buffers?
  // }

  // A single point is considered empty.
  Polyline.prototype.IsEmpty = function () {
    if (this.Points.length < 2) {
      return true;
    }
    return false;
  };

  Polyline.prototype.DeleteSelected = function () {
    if (this.IsSelected()) {
      this.Points = [];
      return true;
    }
    return false;
  };

  Polyline.prototype.SetLineWidth = function (lineWidth) {
    this.LineWidth = lineWidth;
  };

  Polyline.prototype.GetLineWidth = function () {
    return this.LineWidth;
  };

  Polyline.prototype.GetEdgeLength = function (edgeIdx) {
    if (edgeIdx < 0 || edgeIdx > this.Points.length - 2) {
      return 0;
    }
    var dx = this.Points[edgeIdx + 1][0] - this.Points[edgeIdx][0];
    var dy = this.Points[edgeIdx + 1][1] - this.Points[edgeIdx][1];

    return Math.sqrt(dx * dx + dy * dy);
  };

  Polyline.prototype.GetNumberOfPoints = function () {
    return this.Points.length;
  };

  // Internal bounds will ignore origin and orientation.
  Polyline.prototype.GetBounds = function () {
    var bounds = this.Bounds.slice(0);
    bounds[0] += this.Origin[0];
    bounds[1] += this.Origin[0];
    bounds[2] += this.Origin[1];
    bounds[3] += this.Origin[1];
    return bounds;
  };

  // Returns 0 if is does not overlap at all.
  // Returns 1 if part of the section is in the bounds.
  // Returns 2 if all of the section is in the bounds.
  Polyline.prototype.ContainedInBounds = function (bds) {
    // Need to get world bounds.
    var myBds = this.GetBounds();

    // Polyline does not cache bounds, so just look to the points.
    if (bds[1] < myBds[0] || bds[0] > myBds[1] ||
            bds[3] < myBds[2] || bds[2] > myBds[3]) {
      return 0;
    }
    if (bds[1] >= myBds[0] && bds[0] <= myBds[1] &&
            bds[3] >= myBds[2] && bds[2] <= myBds[3]) {
      return 2;
    }
    return 1;
  };

  Polyline.prototype.SetOrigin = function (origin) {
    this.Origin = origin.slice(0);
  };

  // Adds origin to points and sets origin to 0.
  Polyline.prototype.ResetOrigin = function (view) {
    for (var i = 0; i < this.Points.length; ++i) {
      var pt = this.Points[i];
      pt[0] += this.Origin[0];
      pt[1] += this.Origin[1];
    }
    this.Origin[0] = 0;
    this.Origin[1] = 0;
    this.UpdateBuffers(view);
  };

  // Returns -1 if the point is not on a vertex.
  // Returns the index of the vertex is the point is within dist of a the
  // vertex.
  Polyline.prototype.PointOnVertex = function (pt, dist) {
    dist = dist * dist;
    for (var i = 0; i < this.Points.length; ++i) {
      var dx = this.Points[i][0] - pt[0];
      var dy = this.Points[i][1] - pt[1];
      if (dx * dx + dy * dy < dist) {
        return i;
      }
    }
    return -1;
  };

  // Returns undefined if the point is not on the shape.
  // Otherwise returns the indexes of the segment touched [i0, i1, k].
  Polyline.prototype.PointOnShape = function (pt, dist) {
    // Make a copy of the point (array).
    pt = pt.slice(0);
    pt[0] -= this.Origin[0];
    pt[1] -= this.Origin[1];
    // NOTE: bounds already includes lineWidth
    if (pt[0] + dist < this.Bounds[0] || pt[0] - dist > this.Bounds[1] ||
            pt[1] + dist < this.Bounds[2] || pt[1] - dist > this.Bounds[3]) {
      return undefined;
    }
    // Check for mouse touching an edge.
    var k;
    for (var i = 1; i < this.Points.length; ++i) {
      k = this.IntersectPointLine(pt, this.Points[i - 1],
                                  this.Points[i], dist);
      if (k !== undefined) {
        return [i - 1, i, k];
      }
    }
    if (this.Closed) {
      k = this.IntersectPointLine(pt, this.Points[this.Points.length - 1],
                                  this.Points[0], dist);
      if (k !== undefined) {
        return [this.Points.length - 1, 0, k];
      }
    }
    return undefined;
  };

  // Find a world location of a popup point given a camera.
  Polyline.prototype.FindPopupPoint = function (cam) {
    if (this.Points.length === 0) { return; }
    var roll = cam.GetWorldRoll();
    var s = Math.sin(roll + (Math.PI * 0.25));
    var c = Math.cos(roll + (Math.PI * 0.25));
    var bestPt = this.Points[0];
    var bestProjection = (c * bestPt[0]) - (s * bestPt[1]);
    for (var i = 1; i < this.Points.length; ++i) {
      var pt = this.Points[i];
      var projection = (c * pt[0]) - (s * pt[1]);
      if (projection > bestProjection) {
        bestProjection = projection;
        bestPt = pt;
      }
    }
    bestPt[0] += this.Origin[0];
    bestPt[1] += this.Origin[1];
    return bestPt;
  };

  // Note, self intersection can cause unexpected areas.
  // i.e looping around a point twice ...
  Polyline.prototype.ComputeArea = function () {
    if (this.Points.length < 3) {
      return 0.0;
    }

    // Compute the center. It should be more numerically stable.
    // I could just choose the first point as the origin.
    var cx = 0;
    var cy = 0;
    for (var j = 0; j < this.Points.length; ++j) {
      cx += this.Points[j][0];
      cy += this.Points[j][1];
    }
    cx = cx / this.Points.length;
    cy = cy / this.Points.length;

    var area = 0.0;
    // Iterate over triangles adding the area of each
    var last = this.Points.length - 1;
    var vx1 = this.Points[last][0] - cx;
    var vy1 = this.Points[last][1] - cy;
    // First and last point form another triangle (they are not the same).
    for (j = 0; j < this.Points.length; ++j) {
      // Area of triangle is 1/2 magnitude of cross product.
      var vx2 = vx1;
      var vy2 = vy1;
      vx1 = this.Points[j][0] - cx;
      vy1 = this.Points[j][1] - cy;
      area += (vx1 * vy2) - (vx2 * vy1);
    }

    return area;
  };

  Polyline.prototype.MergePoints = function (thresh, view) {
    thresh = thresh * thresh;
    var modified = false;
    for (var i = 1; i < this.Points.length; ++i) {
      var dx = this.Points[i][0] - this.Points[i - 1][0];
      var dy = this.Points[i][1] - this.Points[i - 1][1];
      if (dx * dx + dy * dy < thresh) {
                // The two points are close. Remove the point.
        this.Points.splice(i, 1);
                // Removing elements from the array we are iterating over.
        --i;
        modified = true;
      }
    }
    if (modified) {
      this.UpdateBuffers(view);
    }
  };

  // The real problem is aliasing.  Line is jagged with high frequency sampling artifacts.
  // Pass in the spacing as a hint to get rid of aliasing.
  Polyline.prototype.Decimate = function (spacing, view) {
    // Keep looping over the line removing points until the line does not change.
    var modified = true;
    while (modified) {
      modified = false;
      var newPoints = [];
      newPoints.push(this.Points[0]);
      // Window of four points.
      var i = 3;
      while (i < this.Points.length) {
        var p0 = this.Points[i];
        var p1 = this.Points[i - 1];
        var p2 = this.Points[i - 2];
        var p3 = this.Points[i - 3];
        // Compute the average of the center two.
        var cx = (p1[0] + p2[0]) * 0.5;
        var cy = (p1[1] + p2[1]) * 0.5;
        // Find the perendicular normal.
        var nx = (p0[1] - p3[1]);
        var ny = -(p0[0] - p3[0]);
        var mag = Math.sqrt(nx * nx + ny * ny);
        nx = nx / mag;
        ny = ny / mag;
        mag = Math.abs(nx * (cx - this.Points[i - 3][0]) + ny * (cy - this.Points[i - 3][1]));
        // Mag metric does not distinguish between line and a stroke that double backs on itself.
        // Make sure the two point being merged are between the outer points 0 and 3.
        var dir1 = (p0[0] - p1[0]) * (p3[0] - p1[0]) + (p0[1] - p1[1]) * (p3[1] - p1[1]);
        var dir2 = (p0[0] - p2[0]) * (p3[0] - p2[0]) + (p0[1] - p2[1]) * (p3[1] - p2[1]);
        if (mag < spacing && dir1 < 0.0 && dir2 < 0.0) {
          // Replace the two points with their average.
          newPoints.push([cx, cy, 0]);
          modified = true;
          // Skip the next point the window will have one old merged point,
          // but that is ok because it is just used as reference and not altered.
          i += 2;
        } else {
          //  No modification.  Just move the window one.
          newPoints.push(this.Points[i - 2]);
          ++i;
        }
      }
      // Copy the remaing point / 2 points
      i = i - 2;
      while (i < this.Points.length) {
        newPoints.push(this.Points[i]);
        ++i;
      }
      this.Points = newPoints;
    }
    this.UpdateBuffers(view);
  };

  Polyline.prototype.AddPointToBounds = function (pt, radius) {
    if (pt[0] - radius < this.Bounds[0]) {
      this.Bounds[0] = pt[0] - radius;
    }
    if (pt[0] + radius > this.Bounds[1]) {
      this.Bounds[1] = pt[0] + radius;
    }

    if (pt[1] - radius < this.Bounds[2]) {
      this.Bounds[2] = pt[1] - radius;
    }
    if (pt[1] + radius > this.Bounds[3]) {
      this.Bounds[3] = pt[1] + radius;
    }
  };

  // NOTE: Line thickness is handled by style in canvas.
  // I think the GL version that uses triangles is broken.
  Polyline.prototype.UpdateBuffers = function (view) {
    // Hack: Annotations really do not need to worry about webgl
    // anymore. And the view is only used to get the webgl context.
    view = view || {};

    var points = this.Points.slice(0);
    if (this.Closed && points.length > 2) {
      points.push(points[0]);
    }
    this.PointBuffer = [];
    var cellData = [];
    var lineCellData = [];
    this.Matrix = mat4.create();
    mat4.identity(this.Matrix);

    if (this.Points.length === 0) { return; }
    // xMin,xMax, yMin,yMax
    this.Bounds = [points[0][0], points[0][0], points[0][1], points[0][1]];

    var i;
    if (this.LineWidth === 0 || !view.gl) {
      for (i = 0; i < points.length; ++i) {
        this.PointBuffer.push(points[i][0]);
        this.PointBuffer.push(points[i][1]);
        this.PointBuffer.push(0.0);
        this.AddPointToBounds(points[i], 0);
      }
      // Not used for line width === 0.
      for (i = 2; i < points.length; ++i) {
        cellData.push(0);
        cellData.push(i - 1);
        cellData.push(i);
      }
    } else {
      // Compute a list normals for middle points.
      var edgeNormals = [];
      var mag;
      var x;
      var y;
      var end = points.length - 1;
      // Compute the edge normals.
      for (i = 0; i < end; ++i) {
        x = points[i + 1][0] - points[i][0];
        y = points[i + 1][1] - points[i][1];
        mag = Math.sqrt(x * x + y * y);
        edgeNormals.push([-y / mag, x / mag]);
      }

      if (end > 0) {
        var half = this.LineWidth / 2.0;
        // 4 corners per point
        var dx = edgeNormals[0][0] * half;
        var dy = edgeNormals[0][1] * half;
        this.PointBuffer.push(points[0][0] - dx);
        this.PointBuffer.push(points[0][1] - dy);
        this.PointBuffer.push(0.0);
        this.PointBuffer.push(points[0][0] + dx);
        this.PointBuffer.push(points[0][1] + dy);
        this.PointBuffer.push(0.0);
        this.AddPointToBounds(points[i], half);
        for (i = 1; i < end; ++i) {
          this.PointBuffer.push(points[i][0] - dx);
          this.PointBuffer.push(points[i][1] - dy);
          this.PointBuffer.push(0.0);
          this.PointBuffer.push(points[i][0] + dx);
          this.PointBuffer.push(points[i][1] + dy);
          this.PointBuffer.push(0.0);
          dx = edgeNormals[i][0] * half;
          dy = edgeNormals[i][1] * half;
          this.PointBuffer.push(points[i][0] - dx);
          this.PointBuffer.push(points[i][1] - dy);
          this.PointBuffer.push(0.0);
          this.PointBuffer.push(points[i][0] + dx);
          this.PointBuffer.push(points[i][1] + dy);
          this.PointBuffer.push(0.0);
        }
        this.PointBuffer.push(points[end][0] - dx);
        this.PointBuffer.push(points[end][1] - dy);
        this.PointBuffer.push(0.0);
        this.PointBuffer.push(points[end][0] + dx);
        this.PointBuffer.push(points[end][1] + dy);
        this.PointBuffer.push(0.0);
      }
      // Generate the triangles for a thick line
      for (i = 0; i < end; ++i) {
        lineCellData.push(0 + 4 * i);
        lineCellData.push(1 + 4 * i);
        lineCellData.push(3 + 4 * i);
        lineCellData.push(0 + 4 * i);
        lineCellData.push(3 + 4 * i);
        lineCellData.push(2 + 4 * i);
      }

      // Not used.
      for (i = 2; i < points.length; ++i) {
        cellData.push(0);
        cellData.push((2 * i) - 1);
        cellData.push(2 * i);
      }
    }

    if (view.gl) {
      this.VertexPositionBuffer = view.gl.createBuffer();
      view.gl.bindBuffer(view.gl.ARRAY_BUFFER, this.VertexPositionBuffer);
      view.gl.bufferData(view.gl.ARRAY_BUFFER, new Float32Array(this.PointBuffer), view.gl.STATIC_DRAW);
      this.VertexPositionBuffer.itemSize = 3;
      this.VertexPositionBuffer.numItems = this.PointBuffer.length / 3;

      this.CellBuffer = view.gl.createBuffer();
      view.gl.bindBuffer(view.gl.ELEMENT_ARRAY_BUFFER, this.CellBuffer);
      view.gl.bufferData(view.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cellData), view.gl.STATIC_DRAW);
      this.CellBuffer.itemSize = 1;
      this.CellBuffer.numItems = cellData.length;

      if (this.LineWidth !== 0) {
        this.LineCellBuffer = view.gl.createBuffer();
        view.gl.bindBuffer(view.gl.ELEMENT_ARRAY_BUFFER, this.LineCellBuffer);
        view.gl.bufferData(view.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(lineCellData), view.gl.STATIC_DRAW);
        this.LineCellBuffer.itemSize = 1;
        this.LineCellBuffer.numItems = lineCellData.length;
      }
    }
  };

  // GLOBAL To Position the orientation of the edge.
  var EDGE_ANGLE = (2 * Math.PI) * 0 / 24;
  var EDGE_OFFSET = 0; // In screen pixels.
  var EDGE_ROOT = 'edge';
  var EDGE_DELAY = 200;
  // Saves images centered at spots on the edge.
  // Roll is set to put the edge horizontal.
  // Step is in screen pixel units
  // Count is the starting index for file name generation.
  Polyline.prototype.SampleEdge = function (viewer, dim, step, count, callback) {
    var cam = viewer.GetCamera();
    var scale = cam.GetHeight() / cam.ViewportHeight;
    // Convert the step from screen pixels to world.
    step *= scale;
    var cache = viewer.GetCache();
    var dimensions = [dim, dim];
    // Distance between edge p0 to next sample point.
    var remaining = step / 2;
    // Recursive to serialize asynchronous cutouts.
    this.RecursiveSampleEdge(this.Points.length - 1, 0, remaining, step, count,
                             cache, dimensions, scale, callback);
  };
  Polyline.prototype.RecursiveSampleEdge = function (i0, i1, remaining, step, count,
                                                      cache, dimensions, scale, callback) {
    var pt0 = this.Points[i0];
    var pt1 = this.Points[i1];
    // Compute the length of the edge.
    var dx = pt1[0] - pt0[0];
    var dy = pt1[1] - pt0[1];
    var length = Math.sqrt(dx * dx + dy * dy);
    // Take steps along the edge (size 'step')
    if (remaining > length) {
      // We passed over this edge. Move to the next edge.
      remaining = remaining - length;
      i0 = i1;
      i1 += 1;
      // Test for terminating condition.
      if (i1 < this.Points.length) {
        this.RecursiveSampleEdge(i0, i1, remaining, step, count,
                                         cache, dimensions, scale, callback);
      } else {
        (callback)();
      }
    } else {
      var self = this;
      // Compute the sample point and tangent on this edge.
      var edgeAngle = -Math.atan2(dy, dx) + EDGE_ANGLE;
      var k = remaining / length;
      var x = pt0[0] + k * (pt1[0] - pt0[0]);
      var y = pt0[1] + k * (pt1[1] - pt0[1]);
      // Normal (should be out if loop is clockwise).
      var nx = -dy;
      var ny = dx;
      var mag = Math.sqrt(nx * nx + ny * ny);
      nx = (nx / mag) * EDGE_OFFSET * scale;
      ny = (ny / mag) * EDGE_OFFSET * scale;

      // Save an image at this sample point.
      SA.GetCutoutImage(
        cache, dimensions, [x + nx, y + ny], scale,
        edgeAngle, EDGE_ROOT + count + '.png',
        function () {
          setTimeout(
            function () {
              ++count;
              remaining += step;
              self.RecursiveSampleEdge(
                i0, i1, remaining, step, count,
                cache, dimensions, scale, callback);
            },
            EDGE_DELAY);
        }
      );
    }
  };

  // Returns true if the selection changed.
  Polyline.prototype.SetSelected = function (flag) {
    if (this.Selected === flag) {
      return false;
    }
    this.Selected = flag;
    return true;
  };

  Polyline.prototype.IsSelected = function () {
    return this.Selected;
  };

  // Polyline.prototype.Draw = function (view) {
  //  SAM.Shape.prototype.Draw.call(this, view);
  // };

  SAM.Polyline = Polyline;
})();

// Two behaviors:
// 1: Single click and drag causes a vertex to follow the
// mouse. A new vertex is inserted if the click was on an edge.  If a
// vertex is dropped on top of its neighbor, the are merged.
// 2: WHen the widget is first created or double cliccked, it goes into
// drawing mode.  A vertex follows the cursor with no buttons pressed.
// A single click causes another vertex to be added.  Double click ends the
// draing state.

(function () {
  // Depends on the CIRCLE widget
  'use strict';

  var VERTEX_RADIUS = 8;
  var EDGE_RADIUS = 4;

  // These need to be cleaned up.
  // Drawing started with 0 points or drawing restarted.
  var DRAWING = 0;
  // Drawing mode: Mouse is up and the new point is following the mouse.
  var DRAWING_EDGE = 1;
  // Not active.
  var WAITING = 2;
  // Waiting but receiving events.  The circle handle is active.
  var ACTIVE = 5;
  // Dialog is active.
  var PROPERTIES_DIALOG = 6;

  function PolylineWidget (layer, newFlag) {
    if (layer === undefined) {
      return;
    }

    // Keep track of annotation created by students without edit
    // permission.
    this.UserNoteFlag = !SA.Edit;
    this.Type = 'polyline';

    // Circle is to show an active vertex.
    this.Circle = new SAM.Circle();
    this.Polyline = new SAM.Polyline();

    this.InitializeDialog(layer);

    // Get default properties.
    this.LineWidth = 10.0;
    this.Polyline.Closed = false;
    if (localStorage.PolylineWidgetDefaults) {
      var defaults = JSON.parse(localStorage.PolylineWidgetDefaults);
      if (defaults.Color) {
        this.Dialog.ColorInput.val(SAM.ConvertColorToHex(defaults.Color));
      }
      // Remebering closed flag seems arbitrary.  User can complete
      // the loop if they want it closed. Leaving it open allow
      // restart too.
      // if (defaults.ClosedLoop !== undefined) {
      //    this.Polyline.Closed = defaults.ClosedLoop;
      // }
      if (defaults.LineWidth) {
        this.LineWidth = defaults.LineWidth;
        this.Dialog.LineWidthInput.val(this.LineWidth);
      }
    }

    this.Circle.FillColor = [1.0, 1.0, 0.2];
    this.Circle.OutlineColor = [0.0, 0.0, 0.0];
    this.Circle.FixedSize = false;
    this.Circle.ZOffset = -0.05;

    this.Polyline.OutlineColor = [0.0, 0.0, 0.0];
    this.Polyline.SetOutlineColor(this.Dialog.ColorInput.val());
    this.Polyline.FixedSize = false;

    layer.AddWidget(this);

    // Set line thickness using layer. (5 pixels).
    // The Line width of the shape switches to 0 (single line)
    // when the actual line with is too thin.
    this.Polyline.LineWidth = this.LineWidth;
    this.Circle.Radius = this.LineWidth;
    this.Circle.UpdateBuffers(layer.AnnotationView);

    // ActiveVertex and Edge are for placing the circle handle.
    this.ActiveVertex = -1;
    this.ActiveEdge = undefined;
    // Which vertec is being dragged.
    this.DrawingVertex = -1;

    if (newFlag) {
      this.State = DRAWING;
      this.SetCursorToDrawing(layer);
      // this.Polyline.Active = true;
      layer.ActivateWidget(this);
    } else {
      this.State = WAITING;
      this.Circle.Visibility = false;
    }

    // Lets save the zoom level (sort of).
    // Load will overwrite this for existing annotations.
    // This will allow us to expand annotations into notes.
    this.CreationCamera = layer.GetCamera().Serialize();

    // Set to be the width of a pixel.
    this.MinLine = 1.0;

    layer.EventuallyDraw(false);
  }

  PolylineWidget.prototype.InitializeDialog = function (layer) {
    var self = this;
    this.Dialog = new SAM.Dialog(function () { self.DialogApplyCallback(layer); });
    // Customize dialog for a lasso.
    this.Dialog.Title.text('Lasso Annotation Editor');
    this.Dialog.Body.css({'margin': '1em 2em'});
    // Color
    this.Dialog.ColorDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.ColorLabel =
            $('<div>')
            .appendTo(this.Dialog.ColorDiv)
            .text('Color:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.ColorInput =
            $('<input type="color">')
            .appendTo(this.Dialog.ColorDiv)
            .val('#30ff00')
            .css({'display': 'table-cell'});

    // closed check
    this.Dialog.ClosedDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.ClosedLabel =
            $('<div>')
            .appendTo(this.Dialog.ClosedDiv)
            .text('Closed:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.ClosedInput =
            $('<input type="checkbox">')
            .appendTo(this.Dialog.ClosedDiv)
            .attr('checked', 'false')
            .css({'display': 'table-cell'});
    /*
      this.Dialog.ReverseButton =
            $('<button>')
            .appendTo(this.Dialog.ClosedDiv)
            .text('Reverse')
            .css({'display': 'table-cell'})
            .on('click touchstart',
                function () {
                  self.Polyline.Points.reverse();
                });
    */

    // Line Width
    this.Dialog.LineWidthDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.LineWidthLabel =
            $('<div>')
            .appendTo(this.Dialog.LineWidthDiv)
            .text('Line Width:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.LineWidthInput =
            $('<input type="number">')
            .appendTo(this.Dialog.LineWidthDiv)
            .css({'display': 'table-cell'})
            .keypress(function (event) { return event.keyCode !== 13; });

    // Length
    this.Dialog.LengthDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.LengthLabel =
            $('<div>')
            .appendTo(this.Dialog.LengthDiv)
            .text('Length:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.Length =
            $('<div>')
            .appendTo(this.Dialog.LengthDiv)
            .css({'display': 'table-cell'});

    // Area
    this.Dialog.AreaDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.AreaLabel =
            $('<div>')
            .appendTo(this.Dialog.AreaDiv)
            .text('Area:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.Area =
            $('<div>')
            .appendTo(this.Dialog.AreaDiv)
            .css({'display': 'table-cell'});
  };

  PolylineWidget.prototype.Draw = function (view) {
    // When the line is too thin, we can see nothing.
    // Change it to line drawing.
    var cam = view.GetCamera();
    this.MinLine = cam.GetSpacing();
    if (this.LineWidth < this.MinLine) {
      // Too thin. Use a single line.
      this.Polyline.LineWidth = 0;
    } else {
      this.Polyline.LineWidth = this.LineWidth;
    }

    this.Polyline.Draw(view);
    this.Circle.Draw(view);
    if (this.Text) {
      this.PositionText();
      this.Text.Draw(view);
    }
  };

  PolylineWidget.prototype.PasteCallback = function (data, layer, mouseWorldPt) {
    this.Load(data);
    // Place the widget over the mouse.
    // This is more difficult than the circle.  Compute the shift.
    var bounds = this.Polyline.GetBounds();
    if (!bounds) {
      console.log('Warining: Pasting empty polyline');
      return;
    }
    var xOffset = mouseWorldPt[0] - (bounds[0] + bounds[1]) / 2;
    var yOffset = mouseWorldPt[1] - (bounds[2] + bounds[3]) / 2;
    for (var i = 0; i < this.Polyline.GetNumberOfPoints(); ++i) {
      this.Polyline.Points[i][0] += xOffset;
      this.Polyline.Points[i][1] += yOffset;
    }
    this.Polyline.UpdateBuffers(layer.AnnotationView);
    if (SAM.NotesWidget && !this.UserNoteFlag) { SAM.NotesWidget.MarkAsModified(); } // Hack
    if (this.UserNoteFlag && SA.notesWidget) { SA.notesWidget.EventuallySaveUserNote(); }
    layer.EventuallyDraw(true);
  };

  PolylineWidget.prototype.Serialize = function () {
    if (this.Polyline === undefined) { return null; }
    var obj = {};
    obj.type = 'polyline';
    obj.user_note_flag = this.UserNoteFlag;
    obj.lineColor = SAM.ConvertColorToHex(this.Polyline.OutlineColor);
    obj.lineWidth = this.LineWidth;
    // Copy the points to avoid array reference bug.
    obj.points = [];
    for (var i = 0; i < this.Polyline.GetNumberOfPoints(); ++i) {
      obj.points.push([this.Polyline.Points[i][0], this.Polyline.Points[i][1]]);
    }

    obj.creation_camera = this.CreationCamera;
    obj.closedloop = this.Polyline.Closed;

    if (this.Text) {
      obj.text = this.Text.String;
    }

    return obj;
  };

  PolylineWidget.prototype.InitializeText = function (layer) {
    if (this.Text) { return; }
    this.Text = new SAM.Text();
    this.Text.String = 'Hello';
    this.Text.UpdateBuffers(layer.AnnotationView); // Needed to get the bounds.
    this.Text.Color = [0.0, 0.0, 1.0];
    // position the middle of the text string
    this.Text.Anchor = [0.5 * (this.Text.PixelBounds[0] + this.Text.PixelBounds[1]),
      0.5 * (this.Text.PixelBounds[2] + this.Text.PixelBounds[3])];
    this.Text.Position = [100, 100, 0];
    // no sign background
    this.Text.BackgroundFlag = false;
  };

  PolylineWidget.prototype.PositionText = function () {
    var bounds = this.Polyline.GetBounds();
    var x = (bounds[0] + bounds[1]) / 2;
    var y = bounds[2];
    this.Text.Position = [x, y - 40, 0];
  };

  // Load a widget from a json object (origin MongoDB).
  // Object already json decoded.
  PolylineWidget.prototype.Load = function (obj, layer) {
    if (obj.lineColor) {
      this.Polyline.OutlineColor = SAM.ConvertColor(obj.lineColor);
    }
    if (obj.lineWidth !== undefined) {
      this.LineWidth = parseFloat(obj.lineWidth);
      this.Polyline.LineWidth = this.LineWidth;
    }
    this.Polyline.Points = [];
    for (var n = 0; n < obj.points.length; n++) {
      this.Polyline.Points[n] = [parseFloat(obj.points[n][0]),
        parseFloat(obj.points[n][1])];
    }
    if (obj.closedloop !== undefined) {
      this.Polyline.Closed = obj.closedloop;
    }
    this.Polyline.UpdateBuffers(layer.AnnotationView);

    if (obj.text) {
      if (!this.Text) {
        this.InitializeText(layer);
      }
      this.Text.String = obj.text;
    }

    // How zoomed in was the view when the annotation was created.
    if (obj.view_height !== undefined) {
      this.CreationCamera = obj.creation_camera;
    }
  };

  PolylineWidget.prototype.CityBlockDistance = function (p0, p1) {
    return Math.abs(p1[0] - p0[0]) + Math.abs(p1[1] - p0[1]);
  };

  PolylineWidget.prototype.HandleKeyDown = function (layer) {
    // 'r' reverses loop (and colors: Blue clockwise, Red counter clockwise)
    var event = layer.Event;
    if (event.keyCode === 82) {
      this.Polyline.Points.reverse();
      this.ColorByHandedness(layer);
      layer.EventuallyDraw(true);
    }

    // Copy
    if (event.keyCode === 67 && event.ctrlKey) {
      // control-c for copy
      // The extra identifier is not needed for widgets, but will be
      // needed if we have some other object on the clipboard.
      var clip = {Type: 'PolylineWidget', Data: this.Serialize()};
      localStorage.ClipBoard = JSON.stringify(clip);
      return false;
    }

    // escape key (or space or enter) to turn off drawing
    if (event.keyCode === 27 || event.keyCode === 32 || event.keyCode === 13) {
      // Last resort.  ESC key always deactivates the widget.
      // Deactivate.
      layer.DeactivateWidget(this);
      if (SAM.NotesWidget && !this.UserNoteFlag) { SAM.NotesWidget.MarkAsModified(); } // Hack
      if (this.UserNoteFlag && SA.notesWidget) { SA.notesWidget.EventuallySaveUserNote(); }
      if (window.SA) { SA.RecordState(); }
      return false;
    }

    return true;
  };

  PolylineWidget.prototype.HandleDoubleClick = function (layer) {
    if (this.State === DRAWING || this.State === DRAWING_EDGE) {
      this.Polyline.MergePoints(this.Circle.Radius);
      layer.DeactivateWidget(this);
      return false;
    }
    // Handle: Restart drawing mode. Any point on the line can be used.
    var event = layer.Event;
    if (this.State === ACTIVE) {
      var x = event.offsetX;
      var y = event.offsetY;
      var pt = layer.GetCamera().ConvertPointViewerToWorld(x, y);
      // Active => Double click starts drawing again.
      if (this.ActiveVertex !== -1) {
        this.Polyline.Points[this.ActiveVertex] = pt;
        this.DrawingVertex = this.ActiveVertex;
        this.ActiveVertex = -1;
      } else if (this.ActiveEdge) {
        // Insert a new point in the edge.
        // mouse down gets called before this and does this.
        // TODO: Fix it so mouse down/up do not get called on
        // double click.
        this.Polyline.Points.splice(this.ActiveEdge[1], 0, pt);
        this.DrawingVertex = this.ActiveEdge[1];
        this.ActiveEdge = undefined;
      } else {
        // Sanity check:
        console.log('No vertex or edge is active.');
        return false;
      }
      this.Polyline.UpdateBuffers(layer.AnnotationView);
      this.SetCursorToDrawing(layer);
      // Transition to drawing edge when we know which way the user
      // is dragging.
      this.State = DRAWING;
      layer.EventuallyDraw(false);
      return false;
    }
  };

  // Because of double click:
  // Mouse should do nothing. Mouse move and mouse up should cause all
  // the changes.
  PolylineWidget.prototype.HandleMouseDown = function (layer) {
    var event = layer.Event;
    // Only chnage handle properties.  Nothing permanent changes with mousedown.
    if (event.which === 1 && this.State === ACTIVE) {
      // User has started dragging a point with the mouse down.
      // Change the circle color to the line color when dragging.
      this.Circle.FillColor = this.Polyline.OutlineColor;
      this.Circle.Active = false;
    }

    return false;
  };

  // Returns false when it is finished doing its work.
  PolylineWidget.prototype.HandleClick = function (layer) {
    var event = layer.Event;
    this.HandleMouseUp(event);
  };

  // Returns false when it is finished doing its work.
  PolylineWidget.prototype.HandleMouseUp = function (layer) {
    var event = layer.Event;
    // Shop dialog with right click.  I could have a menu appear.
    if (event.which === 3) {
      // Right mouse was pressed.
      // Pop up the properties dialog.
      this.State = PROPERTIES_DIALOG;
      this.ShowPropertiesDialog();
      return false;
    }

    if (event.which !== 1) {
      return false;
    }

    if (this.State === ACTIVE) {
      // Dragging a vertex just ended.
      // Handle merging points when user drags a vertex onto another.
      this.Polyline.MergePoints(this.Circle.Radius);
      // TODO: Manage modidfied more consistently.
      if (SAM.NotesWidget && !this.UserNoteFlag) { SAM.NotesWidget.MarkAsModified(); } // Hack
      if (window.SA) { SA.RecordState(); }
      if (this.UserNoteFlag && SA.notesWidget) { SA.notesWidget.EventuallySaveUserNote(); }
      return false;
    }

    var x = event.offsetX;
    var y = event.offsetY;
    var pt = layer.GetCamera().ConvertPointViewerToWorld(x, y);

    if (this.State === DRAWING) {
      // handle the case where we restarted drawing and clicked again
      // before moving the mouse. (triple click).  Do nothing.
      if (this.Polyline.GetNumberOfPoints() > 0) {
        return false;
      }
      // First point after creation. We delayed adding the first
      // point so add it now.
      this.Polyline.Points.push(pt);
      // Not really necessary because DRAWING_EDGE case resets it.
      this.DrawingVertex = this.Polyline.GetNumberOfPoints() - 1;
      this.State = DRAWING_EDGE;
    }
    if (this.State === DRAWING_EDGE) {
      // Check to see if the loop was closed.
      if (this.Polyline.GetNumberOfPoints() > 2 && this.ActiveVertex === 0) {
        // The user clicked on the first vertex. End the line.
        // Remove the temporary point at end used for drawing.
        this.Polyline.Points.pop();
        this.Polyline.Closed = true;
        layer.DeactivateWidget(this);
        if (window.SA) { SA.RecordState(); }
        return false;
      }
      // Insert another point to drag around.
      this.DrawingVertex += 1;
      this.Polyline.Points.splice(this.DrawingVertex, 0, pt);
      this.Polyline.UpdateBuffers(layer.AnnotationView);
      layer.EventuallyDraw(true);
      return false;
    }
    if (this.UserNoteFlag && SA.notesWidget) { SA.notesWidget.EventuallySaveUserNote(); }
    return false;
  };

  //  Preconditions: State === ACTIVE, Mouse 1 is down.
  // ActiveVertex !== 1 or ActiveEdge === [p0,p1,k]
  PolylineWidget.prototype.HandleDrag = function (pt, layer) {
    if (this.ActiveEdge) {
      // User is dragging an edge point that has not been
      // created yet.
      var pt0 = this.Polyline.Points[this.ActiveEdge[0]];
      var pt1 = this.Polyline.Points[this.ActiveEdge[1]];
      var x = pt0[0] + this.ActiveEdge[2] * (pt1[0] - pt0[0]);
      var y = pt0[1] + this.ActiveEdge[2] * (pt1[1] - pt0[1]);
      this.Polyline.Points.splice(this.ActiveEdge[1], 0, [x, y]);
      this.ActiveVertex = this.ActiveEdge[1];
      this.ActiveEdge = undefined;
      this.HighlightVertex(this.ActiveVertex, layer);
      // When dragging, circle is the same color as the line.
      this.Circle.Active = false;
    }
    if (this.ActiveVertex === -1) {
      // Sanity check.
      return false;
    }
    // If a vertex is dragged onto its neighbor, indicate that
    // the vertexes will be merged. Change the color of the
    // circle to active as an indicator.
    this.Circle.Active = false;
    this.Polyline.Points[this.ActiveVertex] = pt;
    if (this.ActiveVertex > 0 &&
            this.Polyline.GetEdgeLength(this.ActiveVertex - 1) < this.Circle.Radius) {
      this.Circle.Active = true;
      // Snap to the neighbor. Deep copy the point
      pt = this.Polyline.Points[this.ActiveVertex - 1].slice(0);
    }
    if (this.ActiveVertex < this.Polyline.GetNumberOfPoints() - 1 &&
            this.Polyline.GetEdgeLength(this.ActiveVertex) < this.Circle.Radius) {
      this.Circle.Active = true;
      // Snap to the neighbor. Deep copy the point
      pt = this.Polyline.Points[this.ActiveVertex + 1].slice(0);
    }
    // Move the vertex with the mouse.
    this.Polyline.Points[this.ActiveVertex] = pt;
    // Move the hightlight circle with the vertex.
    this.Circle.Origin = pt;
    this.Polyline.UpdateBuffers(layer.AnnotationView);

    // TODO: Fix this hack.
    if (SAM.NotesWidget && !this.UserNoteFlag) { SAM.NotesWidget.MarkAsModified(); } // Hack
    if (this.UserNoteFlag && SA.notesWidget) { SA.notesWidget.EventuallySaveUserNote(); }
    layer.EventuallyDraw(true);
  };

  // precondition : State === DRAWING
  // postcondition: State === DRAWING_EDGE
  // Handle a bunch of cases.  First created, restart at ends or middle.
  PolylineWidget.prototype.StartDrawing = function (pt) {
    // If the widget was just created do nothing.
    if (this.Polyline.GetNumberOfPoints() === 0) {
      return;
    }
    // If we are the begining, Reverse the points.
    if (this.DrawingVertex === 0) {
      this.Polyline.Points.reverse();
      this.DrawingVertex = this.Polyline.GetNumberOfPoints() - 1;
    }
    // If we are at the end.  Add a point.
    if (this.DrawingVertex === this.Polyline.GetNumberOfPoints() - 1) {
      this.Polyline.Points.push(pt);
      this.DrawingVertex += 1;
      this.State = DRAWING_EDGE;
      return;
    }
    // If we are in the middle. Choose between the two edges.
    var pt0 = this.Polyline.Points[this.DrawingVertex - 1];
    var pt1 = this.Polyline.Points[this.DrawingVertex];
    var pt2 = this.Polyline.Points[this.DrawingVertex + 1];
    // Movement vector
    var dx = pt[0] - pt1[0];
    var dy = pt[1] - pt1[1];
    // This is sort of a pain. Normalize the edges.
    var e0 = [pt0[0] - pt1[0], pt0[1] - pt1[1]];
    var dist0 = Math.sqrt(e0[0] * e0[0] + e0[1] * e0[1]);
    dist0 = (dx * e0[0] + dy * e0[1]) / dist0;
    var e1 = [pt2[0] - pt1[0], pt2[1] - pt1[1]];
    var dist1 = Math.sqrt(e1[0] * e1[0] + e1[1] * e1[1]);
    dist1 = (dx * e1[0] + dy * e1[1]) / dist0;
    // if the user is draggin backward, reverse the points.
    if (dist0 > dist1) {
      this.Polyline.Points.reverse();
      this.DrawingVertex = this.Polyline.GetNumberOfPoints() - this.DrawingVertex - 1;
    }
    // Insert a point to continue drawing.
    this.DrawingVertex += 1;
    this.Polyline.Points.splice(this.DrawingVertex, 0, pt);
    this.State = DRAWING_EDGE;
    return false;
  };

  PolylineWidget.prototype.HandleMouseMove = function (layer) {
    var event = layer.Event;
    var x = event.offsetX;
    var y = event.offsetY;
    var pt = layer.GetCamera().ConvertPointViewerToWorld(x, y);

    if (this.State === DRAWING) {
      this.StartDrawing(pt);
      return false;
    }
    if (this.State === DRAWING_EDGE) {
      // Move the active point to follor the cursor.
      this.Polyline.Points[this.DrawingVertex] = pt;
      this.Polyline.UpdateBuffers(layer.AnnotationView);

      // This higlights the first vertex when a loop is possible.
      var idx = this.Polyline.PointOnVertex(pt, this.Circle.Radius);
      if (this.DrawingVertex === this.Polyline.GetNumberOfPoints() - 1 && idx === 0) {
        // Highlight first vertex to indicate potential loop closure.
        this.HighlightVertex(0, layer);
      } else {
        this.HighlightVertex(-1, layer);
      }
      return false;
    }

    if (this.State === ACTIVE) {
      if (event.which === 0) {
        // Turn off the active vertex if the mouse moves away.
        // if (!this.CheckActive(layer)) {
        //  layer.DeactivateWidget(this);
        // } else {
        //  this.UpdateActiveCircle(layer);
        // }
        return false;
      }
      if (this.State === ACTIVE && event.which === 1) {
        // We are in the middle of dragging a vertex (not in
        // drawing mode). Leave the circle highlighted.
        // Use ActiveVertex instead of DrawingVertex which is used
        // for drawing mode.
        this.HandleDrag(pt, layer);
      }
    }
  };

  // Just returns true and false.  It saves either ActiveVertex or
  // ActiveEdge if true. Otherwise, it has no side effects.
  PolylineWidget.prototype.CheckActive = function (layer) {
    return false;
    /*
    var event = layer.Event;
    var x = event.offsetX;
    var y = event.offsetY;
    var pt = layer.GetCamera().ConvertPointViewerToWorld(x, y);
    var dist;

    this.ActiveEdge = undefined;

    // Check for mouse touching a vertex circle.
    dist = VERTEX_RADIUS / layer.GetPixelsPerUnit();
    dist = Math.max(dist, this.Polyline.GetLineWidth());
    this.ActiveVertex = this.Polyline.PointOnVertex(pt, dist);

    if (this.State === DRAWING_EDGE) {
      // TODO:  The same logic is in mouse move.  Decide which to remove.
      // Only allow the first vertex to be active (closing the loop).
      if (this.Polyline.GetNumberOfPoints() < 2 ||
          this.ActiveVertex !== 0) {
        this.ActiveVertex = -1;
        return false;
      }
      return true;
    }

    if (this.ActiveVertex === -1) {
      // Tolerance: 5 screen pixels.
      dist = EDGE_RADIUS / layer.GetPixelsPerUnit();
      dist = Math.max(dist, this.Polyline.GetLineWidth() / 2);
      this.ActiveEdge = this.Polyline.PointOnShape(pt, dist);
      if (!this.ActiveEdge) {
        return false;
      }
    }
    return true;
    */
  };

  // This does not handle the case where we want to highlight an edge
  // point that has not been created yet.
  PolylineWidget.prototype.HighlightVertex = function (vertexIdx, layer) {
    if (vertexIdx < 0 || vertexIdx >= this.Polyline.GetNumberOfPoints()) {
      this.Circle.Visibility = false;
    } else {
      this.Circle.Visibility = true;
      this.Circle.Active = true;
      this.Circle.Radius = VERTEX_RADIUS / layer.GetPixelsPerUnit();
      this.CircleRadius = Math.max(this.CircleRadius,
                                         this.Polyline.GetLineWidth() * 1.5);
      this.Circle.UpdateBuffers(layer.AnnotationView);
      this.Circle.Origin = this.Polyline.Points[vertexIdx];
    }
    this.ActiveVertex = vertexIdx;
    layer.EventuallyDraw(true);
  };

  // Use ActiveVertex and ActiveEdge iVars to place and size circle.
  PolylineWidget.prototype.UpdateActiveCircle = function (layer) {
    if (this.ActiveVertex !== -1) {
      this.HighlightVertex(this.ActiveVertex, layer);
      return;
    } else if (this.ActiveEdge) {
      this.Circle.Visibility = true;
      this.Circle.Active = true;
      this.Circle.Radius = EDGE_RADIUS / layer.GetPixelsPerUnit();
      this.CircleRadius = Math.max(this.CircleRadius,
                                         this.Polyline.GetLineWidth());
      // Find the exact point on the edge (projection of
      // cursor on the edge).
      var pt0 = this.Polyline.Points[this.ActiveEdge[0]];
      var pt1 = this.Polyline.Points[this.ActiveEdge[1]];
      var x = pt0[0] + this.ActiveEdge[2] * (pt1[0] - pt0[0]);
      var y = pt0[1] + this.ActiveEdge[2] * (pt1[1] - pt0[1]);
      this.Circle.Origin = [x, y, 0];
      this.Circle.UpdateBuffers(layer.AnnotationView);
    } else {
      // Not active.
      this.Circle.Visibility = false;
      // We never hightlight the whold polyline now.
      // this.Polyline.Active = false;
    }
    layer.EventuallyDraw(false);
  };

  // Multiple active states. Active state is a bit confusing.
  // Only one state (WAITING) does not receive events from the layer.
  PolylineWidget.prototype.GetActive = function () {
    if (this.State === WAITING) {
      return false;
    }
    return true;
  };

  // Active means that the widget is receiving events.  It is
  // "hot" and waiting to do something.
  // However, it is not active when in drawing mode.
  // This draws a circle at the active spot.
  // Vertexes are active for click and drag or double click into drawing
  // mode. Edges are active to insert a new vertex and drag or double
  // click to insert a new vertex and go into drawing mode.
  PolylineWidget.prototype.SetActive = function (flag, layer) {
    if (flag === this.GetActive()) {
      // Nothing has changed.  Do nothing.
      return;
    }

    if (flag) {
      this.State = ACTIVE;
      this.UpdateActiveCircle(layer);
    } else {
      this.State = WAITING;
      this.DrawingVertex = -1;
      this.ActiveVertex = -1;
      this.ActiveEdge = undefined;
      this.Circle.Visibility = false;
      if (this.DeactivateCallback) {
        this.DeactivateCallback();
      }
      // Remove invisible lines (with 0 or 1 points).
      if (this.Polyline.GetNumberOfPoints() < 2) {
        if (layer) {
          layer.RemoveWidget(this);
        }
      }
    }

    layer.EventuallyDraw(false);
  };

  PolylineWidget.prototype.SetCursorToDrawing = function (layer) {
    layer.GetParent().css(
            {'cursor': 'url(' + SAM.ImagePathUrl + 'dotCursor8.png) 4 4,crosshair'});
    layer.EventuallyDraw();
  };

  PolylineWidget.prototype.ShowPropertiesDialog = function () {
    this.Dialog.ColorInput.val(SAM.ConvertColorToHex(this.Polyline.OutlineColor));
    this.Dialog.ClosedInput.prop('checked', this.Polyline.Closed);
    this.Dialog.LineWidthInput.val((this.Polyline.LineWidth).toFixed(2));

    var length = this.ComputeLength() * 0.25; // microns per pixel.
    var lengthString = '';
    if (this.Polyline.FixedSize) {
      lengthString += length.toFixed(2);
      lengthString += ' px';
    } else {
      if (length > 1000) {
        lengthString += (length / 1000).toFixed(2) + ' mm';
      } else {
        // Latin-1 00B5 is micro sign
        lengthString += length.toFixed(2) + ' \xB5m';
      }
    }
    this.Dialog.Length.text(lengthString);

    if (this.Polyline.Closed) {
      this.Dialog.AreaDiv.show();
      var area = Math.abs(this.ComputeArea() * 0.25 * 0.25);
      var areaString = '';
      if (this.Polyline.FixedSize) {
        areaString += area.toFixed(2);
        areaString += ' pixels^2';
      } else {
        if (area > 1000000) {
          areaString += (area / 1000000).toFixed(2) + ' mm^2';
        } else {
          // Latin-1 00B5 is micro sign
          areaString += area.toFixed(2) + ' \xB5m^2';
        }
      }
      this.Dialog.Area.text(areaString);
    } else {
      this.Dialog.AreaDiv.hide();
    }
    this.Dialog.Show(true);
  };

  PolylineWidget.prototype.DialogApplyCallback = function (layer) {
    var hexcolor = this.Dialog.ColorInput.val();
    this.Polyline.SetOutlineColor(hexcolor);
    this.Polyline.Closed = this.Dialog.ClosedInput.prop('checked');

    // Cannot use the shap line width because it is set to zero (single pixel)
    // it the dialog value is too thin.
    this.LineWidth = parseFloat(this.Dialog.LineWidthInput.val());
    this.Polyline.UpdateBuffers(layer.AnnotationView);
    this.SetActive(false, layer);
    if (window.SA) { SA.RecordState(); }
    layer.EventuallyDraw(false);

    localStorage.PolylineWidgetDefaults = JSON.stringify(
      {Color: hexcolor,
        ClosedLoop: this.Polyline.Closed,
        LineWidth: this.LineWidth});
    if (SAM.NotesWidget && !this.UserNoteFlag) { SAM.NotesWidget.MarkAsModified(); } // Hack
    if (this.UserNoteFlag && SA.notesWidget) { SA.notesWidget.EventuallySaveUserNote(); }
  };

  // Note, self intersection can cause unexpected areas.
  // i.e looping around a point twice ...
  PolylineWidget.prototype.ComputeLength = function () {
    if (this.Polyline.GetNumberOfPoints() < 2) {
      return 0.0;
    }

    var length = 0;
    var x0 = this.Polyline.Points[0][0];
    var y0 = this.Polyline.Points[0][1];
    for (var j = 1; j < this.Polyline.GetNumberOfPoints(); ++j) {
      var x1 = this.Polyline.Points[j][0];
      var y1 = this.Polyline.Points[j][1];
      var dx = x1 - x0;
      var dy = y1 - y0;
      x0 = x1;
      y0 = y1;
      length += Math.sqrt(dx * dx + dy * dy);
    }

    return length;
  };

  // This differentiates the inside of the polygion from the outside.
  // It is used to sample points in a segmented region.
  // Not actively used (more for experimentation for now).
  PolylineWidget.prototype.PointInside = function (ox, oy) {
    if (this.Polyline.Closed === false) {
      return false;
    }
    var x;
    var max = this.Polyline.GetNumberOfPoints() - 1;
    var xPos = 0;
    var xNeg = 0;
    // var yCount = 0;
    var pt0 = this.Polyline.Points[max];
    pt0 = [pt0[0] - ox, pt0[1] - oy];
    for (var idx = 0; idx <= max; ++idx) {
      var pt1 = this.Polyline.Points[idx];
      pt1 = [pt1[0] - ox, pt1[1] - oy];
      var k;
      k = (pt1[1] - pt0[1]);
      if (k !== 0) {
        k = -pt0[1] / k;
        if (k > 0 && k <= 1) {
          // Edge crosses the axis.  Find the intersection.
          x = pt0[0] + k * (pt1[0] - pt0[0]);
          if (x > 0) { xPos += 1; }
          if (x < 0) { xNeg += 1; }
        }
      }
      pt0 = pt1;
    }

    if ((xPos % 2) && (xNeg % 2)) {
      return true;
    }
    return false;
  };

  // TODO: This will not work with Layer.  Move this to the viewer or a
  // helper object.
  // Save images with centers inside the polyline.
  PolylineWidget.prototype.Sample = function (dim, spacing, skip, root, count, layer) {
    var bds = this.Polyline.GetBounds();
    var ctx = layer.Context2d;
    for (var y = bds[2]; y < bds[3]; y += skip) {
      for (var x = bds[0]; x < bds[1]; x += skip) {
        if (this.PointInside(x, y)) {
          var ip = layer.GetCamera().ConvertPointWorldToViewer(x, y);
          ip[0] = Math.round(ip[0] - dim / 2);
          ip[1] = Math.round(ip[1] - dim / 2);
          var data = ctx.getImageData(ip[0], ip[1], dim, dim);
          SA.DownloadImageData(data, root + '_' + count + '.png');
          ++count;
        }
      }
    }
  };

  // Convert to right handed loop
  PolylineWidget.prototype.ColorByHandedness = function (layer) {
    var area = this.Polyline.ComputeArea();
    if (area > 0) {
      // right handed
      this.Polyline.OutlineColor = [1.0, 0.0, 0.0];
    } else {
      // left handed
      this.Polyline.OutlineColor = [0.0, 0.0, 1.0];
    }

    layer.EventuallyDraw(true);
  };

  /*
    // Saves images centered at spots on the edge.
    // Roll is set to put the edge horizontal.
    // Step is in screen pixel units
    PolylineWidget.prototype.SampleEdge = function(dim, step, count, callback, layer) {
    this.Polyline.SampleEdge(layer,dim,step,count,callback);
    }

    function DownloadTheano(widgetIdx, angleIdx) {
    EDGE_ANGLE = 2*Math.PI * angleIdx / 24;
    LAYERS[0].WidgetList[widgetIdx].SampleEdge(
    64,4,EDGE_COUNT,
    function () {
    setTimeout(function(){ DownloadTheano2(widgetIdx, angleIdx); }, 1000);
    },     layer
    );
    }

    function DownloadTheano2(widgetIdx, angleIdx) {
    ++angleIdx;
    if (angleIdx >= 24) {
    angleIdx = 0;
    ++widgetIdx;
    }
    if (widgetIdx < LAYERS[0].WidgetList.length) {
    DownloadTheano(widgetIdx, angleIdx);
    }
    }
    */

  SAM.PolylineWidget = PolylineWidget;
})();

// ==============================================================================
// Temporary drawing with a pencil.  It goes away as soon as the camera changes.
// pencil icon (image as html) follows the cursor.
// Middle mouse button (or properties menu item) drops pencil.
// maybe option in properties menu to save the drawing permanently.

// Merging lasso interactor style is with pencil.
// Differences. The previous stroke does not deselect when a new stroke is started/
// When a stroke ends,  A method is called to see if it can be merged with the selected stroke.

(function () {
  // Depends on the CIRCLE widget
  'use strict';

  // Not receiving events. Nothing selected. Just drawing.
  var INACTIVE = 0;

  // Various states for drawing.
  // Pencil up and pencil down.
  var DRAWING_UP = 2;
  var DRAWING_DOWN = 3;

  var OPEN = 0;
  var CLOSED = 1;

  function PencilWidget (layer) {
    this.Layer = layer;
    this.State = INACTIVE;

    // This method gets called if anything is added, deleted or moved.
    this.ModifiedCallback = undefined;
    // This method gets called if the active state of this widget turns on or off.
    // This is used to turn off the pencil button in the Panel.
    this.StateChangeCallback = undefined;
    // This is used by the annotationPanel to transfer draing mode to a new selected widget.
    this.SelectedCallback = undefined;

    this.Type = 'pencil';
    // True when this widget is dedicated to the apple pencil.
    this.StylusOnly = false;

    this.LineWidth = 0;
    this.Mode = OPEN;
    this.Color = '#00c';
    this.LoadDefaults();

    this.Shapes = new SAM.ShapeGroup();

    // Temporary way of showing time
    this.Circle = new SAM.Circle();
    this.Circle.Radius = 5;
    this.Circle.FixedSize = true;
    this.Circle.UpdateBuffers(layer.AnnotationView);
  }

  PencilWidget.prototype.LoadDefaults = function () {
    if (localStorage.PencilWidgetDefaults) {
      var defaults = JSON.parse(localStorage.PencilWidgetDefaults);
      if (defaults.Color) {
        this.Color = defaults.Color;
      }
      if (defaults.LineWidth !== undefined) {
        this.LineWidth = defaults.LineWidth;
      }
      if (defaults.Mode !== undefined) {
        if (defaults.Mode === 'open') {
          this.Mode = OPEN;
        } else {
          this.Mode = CLOSED;
        }
      }
    }
  };

  PencilWidget.prototype.InitializeDialog = function () {
    this.Dialog = new SAM.Dialog(this.Layer.GetParent().parent());
    var self = this;
    this.Dialog.SetApplyCallback(function () { self.DialogApplyCallback(); });
    // Customize dialog for a pencil.
    this.Dialog.Title.text('Pencil Annotation Editor');
    this.Dialog.Body.css({'margin': '1em 2em'});
    // Color
    this.Dialog.ColorDiv =
      $('<div>')
      .appendTo(this.Dialog.Body)
      .css({'display': 'table-row'});
    this.Dialog.ColorLabel =
      $('<div>')
      .appendTo(this.Dialog.ColorDiv)
      .text('Color:')
      .css({
        'display': 'table-cell',
        'text-align': 'left'});
    this.Dialog.ColorInput =
      $('<input type="color">')
      .appendTo(this.Dialog.ColorDiv)
      .val(this.Color)
      .css({'display': 'table-cell'});

    // Line Width
    this.Dialog.LineWidthDiv =
      $('<div>')
      .appendTo(this.Dialog.Body)
      .css({'display': 'table-row'});
    this.Dialog.LineWidthLabel =
      $('<div>')
      .appendTo(this.Dialog.LineWidthDiv)
      .text('Line Width:')
      .css({
        'display': 'table-cell',
        'text-align': 'left'});
    this.Dialog.LineWidthInput =
      $('<input type="number">')
      .appendTo(this.Dialog.LineWidthDiv)
      .val(this.LineWidth)
      .css({'display': 'table-cell'})
      .keypress(function (event) { return event.keyCode !== 13; });

    // closed check
    this.Dialog.ClosedDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.ClosedLabel =
            $('<div>')
            .appendTo(this.Dialog.ClosedDiv)
            .text('Closed:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.ClosedInput =
            $('<input type="checkbox">')
            .appendTo(this.Dialog.ClosedDiv)
            .attr('checked', 'false')
            .css({'display': 'table-cell'});
  };

  // This callback gets called when ever the active state changes,
  // even if caused by an external call. This widget is passed as a argument.
  // This is used to turn off the pencil button in the Panel.
  PencilWidget.prototype.SetStateChangeCallback = function (callback) {
    this.StateChangeCallback = callback;
  };

  PencilWidget.prototype.SetModifiedCallback = function (callback) {
    this.ModifiedCallback = callback;
  };

  PencilWidget.prototype.SetSelectedCallback = function (callback) {
    this.SelectedCallback = callback;
  };

  // Called when the state changes.
  PencilWidget.prototype.StateChanged = function () {
    if (this.StateChangeCallback) {
      this.StateChangeCallback(this);
    }
  };

  // Called when the state changes.
  PencilWidget.prototype.Modified = function () {
    if (this.ModifiedCallback) {
      (this.ModifiedCallback)(this);
    }
  };
  // PencilWidget.prototype.Modified = function () {
  //  this.Shapes.Modified();
  // };

  // Called when the state changes.
  PencilWidget.prototype.SelectionChanged = function () {
    if (this.SelectedCallback) {
      (this.SelectedCallback)(this);
    }
  };

  // Can we delete this?
  PencilWidget.prototype.IsEmpty = function () {
    return this.Shapes.IsEmpty();
  };

  // TODO: CLean this up.
  PencilWidget.prototype.SetModeToOpen = function () {
    // For new strokes
    this.Mode = OPEN;
    // For old selected strokes.
    for (var i = 0; i < this.Shapes.GetNumberOfShapes(); ++i) {
      var stroke = this.Shapes.GetShape(i);
      if (stroke.IsSelected()) {
        if (stroke.Closed === true) {
          this.Modified();
        }
        stroke.Closed = false;
        stroke.UpdateBuffers(this.Layer.AnnotationView);
        stroke.Modified();
      }
    }
    this.SaveDefaults();
  };
  PencilWidget.prototype.SetModeToClosed = function () {
    // Used for future strokes.
    this.Mode = CLOSED;
    // For old selected strokes.
    for (var i = 0; i < this.Shapes.GetNumberOfShapes(); ++i) {
      var stroke = this.Shapes.GetShape(i);
      if (stroke.IsSelected()) {
        if (stroke.Closed === false) {
          this.Modified();
        }
        stroke.Closed = true;
        stroke.UpdateBuffers(this.Layer.AnnotationView);
        stroke.Modified();
      }
    }
    this.SaveDefaults();
  };
  PencilWidget.prototype.IsModeClosed = function () {
    return this.Mode === CLOSED;
  };

  // Not used yet, but might be useful.
  PencilWidget.prototype.SetCreationCamera = function (cam) {
    // Lets save the zoom level (sort of).
    // Load will overwrite this for existing annotations.
    // This will allow us to expand annotations into notes.
    this.CreationCamera = cam.Serialize();
  };

  PencilWidget.prototype.GetActive = function () {
    return this.State !== INACTIVE;
  };

  PencilWidget.prototype.SetActive = function (flag) {
    if (flag && this.State === INACTIVE) {
      this.State = DRAWING_UP;
      this.StateChanged();
    }
    if (!flag && this.State !== INACTIVE) {
      this.State = INACTIVE;
      this.StateChanged();
    }
    // TODO: Fix: Single select must be setting the state to inactive without calling this method.
    // Cursor was not changing back.
    if (!flag) {
      this.Layer.GetParent().css({'cursor': ''});
    }
  };

  PencilWidget.prototype.IsStateDrawingDown = function () {
    return this.State === DRAWING_DOWN;
  };

  PencilWidget.prototype.SetStateToDrawing = function () {
    if (this.State === DRAWING_UP || this.State === DRAWING_DOWN) {
      return;
    }

    this.State = DRAWING_UP;
    this.StateChanged();

    if (!this.StylusOnly) {
      // Do not use the icon for the apple pencil
      this.Layer.GetParent().css(
        {'cursor': 'url(' + SAM.ImagePathUrl + 'Pencil-icon.png) 0 24,crosshair'});
    }
    this.Layer.EventuallyDraw();
  };

  PencilWidget.prototype.Draw = function () {
    var view = this.Layer.GetView();
    this.Shapes.Draw(view);
    this.Circle.FillColor = this.Color;
    if (this.Layer.ZTime !== undefined && this.Shapes.Shapes.length > 0) {
      // Find the time in the list of points
      var pts = this.Shapes.Shapes[0].Points;
      for (var i = 0; i < pts.length; ++i) {
        var pt = pts[i];
        if (pt.length === 3 && pt[2] === this.Layer.ZTime) {
          this.Circle.Origin = pt;
          // this.Circle.Draw(view);
          break;
        }
      }
    }
  };

  PencilWidget.prototype.Serialize = function () {
    var obj = {};
    obj.type = 'pencil';
    obj.shapes = [];
    // Hacky way to include closed flags.
    obj.closedFlags = [];
    for (var i = 0; i < this.Shapes.GetNumberOfShapes(); ++i) {
      // NOTE: Assumes shape is a Polyline.
      var shape = this.Shapes.GetShape(i);
      var points = shape.Points.slice(0);
      obj.shapes.push(points);
      obj.closedFlags.push(shape.Closed);
      obj.lineColor = SAM.ConvertColorToHex(shape.OutlineColor);
      obj.lineWidth = shape.LineWidth;
    }
    obj.creation_camera = this.CreationCamera;

    return obj;
  };

  // Load a widget from a json object (origin MongoDB).
  PencilWidget.prototype.Load = function (obj) {
    this.LineWidth = 0;
    if (obj.lineWidth !== undefined) {
      this.LineWidth = parseFloat(obj.lineWidth);
    }

    // Shapes use [1,1,1] instead of hex color. Really!!!

    var outlineColor = this.Color;
    if (obj.lineColor) {
      this.Color = obj.lineColor;
    }
    for (var n = 0; n < obj.shapes.length; n++) {
      var points = obj.shapes[n];
      var shape = new SAM.Polyline();
      if (obj.closedFlags) {
        shape.Closed = obj.closedFlags[n];
        if (shape.Closed) {
          this.Mode = CLOSED;
        } else {
          this.Mode = OPEN;
        }
      }
      shape.SetOutlineColor(outlineColor);
      shape.FixedSize = false;
      shape.LineWidth = this.LineWidth;
      if (this.Mode === CLOSED) {
        shape.Closed = true;
      }
      this.Shapes.AddShape(shape);
      // A copy of the points array is probably not necesary.
      shape.Points = points.slice(0);
      // Make sure they all have 3 coordinates
      for (var i = 0; i < shape.Points.length; ++i) {
        var pt = shape.Points[i];
        if (pt.length === 2) {
          shape.Points[i] = [pt[0], pt[1], 0.0];
        }
      }
    }

    // How zoomed in was the view when the annotation was created.
    if (obj.view_height !== undefined) {
      this.CreationCamera = obj.creation_camera;
    }
  };

  // Returns true if something was deleted.
  PencilWidget.prototype.DeleteSelected = function () {
    // Delete is handled by the caller.
    return this.Shapes.DeleteSelected();
  };

  PencilWidget.prototype.HandleKeyDown = function () {
    if (this.State === INACTIVE) {
      return true;
    }
    if (this.StylusOnly) {
      // I am not sure why the apple pencil needs this.
      return true;
    }
    if (this.State === DRAWING_UP || this.State === DRAWING_DOWN) {
      // escape key (or space or enter) to turn off drawing
      if (event.keyCode === 27 || event.keyCode === 32 || event.keyCode === 13) {
        this.SetActive(false);
        return false;
      }
    }
    return true;
  };

  /*
  PencilWidget.prototype.HandleDoubleClick = function () {
    if (this.State === DRAWING_UP || this.State === DRAWING_DOWN) {
      this.SetActive(false);
      return false;
    }
    if (this.State === SELECTED) {
      this.SetStateToDrawing();
      return false;
    }
    return true;
  };
  */

  PencilWidget.prototype.SetStateToDrawingDown = function (x, y) {
    if (this.State === DRAWING_DOWN) {
      return;
    }

    if (this.State !== DRAWING_UP) {
      // Consider DRAWIN_UP and DRAWING_DOWN as a single state.
      this.StateChanged();
    }

    this.State = DRAWING_DOWN;
    // Open: Unselect the last stroke.
    // Closed:  Keep the last selected because the two might be merged.
    if (this.Mode === OPEN) {
      var numStrokes = this.Shapes.GetNumberOfShapes();
      if (numStrokes > 0) {
        // Trying out cut feature
        // this.Shapes.SetSelectedChild(numStrokes - 1, false);
      }
    }
    // Start a new stroke
    var shape = new SAM.Polyline();
    // Select the current stroke.
    shape.SetSelected(true);
    // Leave the new stroke open unti we stop.
    if (!this.Dialog) {
      this.InitializeDialog();
    }
    shape.SetOutlineColor(this.Color);
    shape.FixedSize = false;
    shape.LineWidth = this.LineWidth;
    // Leave stroke open until it is finished.
    shape.Closed = false;
    this.Shapes.AddShape(shape);

    var pt = this.Layer.GetCamera().ConvertPointViewerToWorld(x, y);
    shape.Points.push([pt[0], pt[1], 0.0]); // avoid same reference.
  };

  // Returns the selected stroke or undefined.
  PencilWidget.prototype.HandleSelect = function () {
    // Check to see if a stroke was clicked.
    var x = this.Layer.MouseX;
    var y = this.Layer.MouseY;
    var pt = this.Layer.GetCamera().ConvertPointViewerToWorld(x, y);

    // Hack in click to add a point to the line.
    if (SAM.ControlKey) {
      if (this.IsSelected()) {
        var stroke = this.Shapes.Shapes[0];
        var p0 = stroke.Points[0];
        var p1 = stroke.Points[stroke.Points.length - 1];
        var dx = pt[0] - p0[0];
        var dy = pt[1] - p0[1];
        var dist0 = (dx * dx) + (dy * dy);
        dx = pt[0] - p1[0];
        dy = pt[1] - p1[1];
        var dist1 = (dx * dx) + (dy * dy);
        pt = [pt[0], pt[1], this.Layer.ZTime];
        console.log(pt.toString());
        if (dist1 < dist0) {
          // add point to the end.
          stroke.Points.push(pt);
        } else {
          // Add point to the beginning.
          stroke.Points = [pt].concat(stroke.Points);
        }
        this.Modified();
        stroke.UpdateBuffers(this.Layer.AnnotationView);
        this.Layer.EventuallyDraw();
        return this;
      } else {
        return false;
      }
    }

    var width = this.Shapes.GetLineWidth();
    // Tolerance: 5 screen pixels.
    var minWidth = 20.0 / this.Layer.GetPixelsPerUnit();
    if (width < minWidth) { width = minWidth; }

    var selectedShape = this.Shapes.HandleSelect(pt, width);
    if (selectedShape) {
      // Change the widget mode to match the selected stroke.
      if (selectedShape.Closed) {
        this.Mode = CLOSED;
      } else {
        this.Mode = OPEN;
      }
      // I do not this this is used anymore.
      this.SelectionChanged();
      return selectedShape;
    } else {
      this.SetActive(false);
      this.SelectionChanged();
    }
  };

  PencilWidget.prototype.HandleMouseDown = function () {
    if (this.State === INACTIVE) {
      return true;
    }
    if (this.StylusOnly) {
      // IPads do not have mice, so this is probably unecessary.
      return true;
    }

    var x = this.Layer.MouseX;
    var y = this.Layer.MouseY;

    // Anticipate dragging (might instead be a click or double click)
    var cam = this.Layer.GetCamera();
    this.LastMouse = cam.ConvertPointViewerToWorld(x, y);

    // if (event.which === 3) {
    //  // Right mouse was pressed.
    //  // Pop up the properties dialog.
    //  if (this.State === ACTIVE) {
    //    this.ShowPropertiesDialog();
    //  } else if (this.State === DRAWING_DOWN || this.State === DRAWING_UP) {
    //    // Undo a stroke
    //    if (this.Shapes.GetNumberOfShapes() > 1) {
    //      this.Shapes.PopShape();
    //      this.Layer.EventuallyDraw();
    //   }
    //  }
    //  return false;
    // }

    return false;
  };

  PencilWidget.prototype.HandleTouchStart = function () {
    if (this.State === INACTIVE) {
      return true;
    }
    if (this.StylusOnly && !this.Layer.Event.pencil) {
      // This allows viewer interaction with touches on the ipad pro..
      return true;
    }

    if (this.Layer.Touches.length !== 1) {
      // We pass one multiple touches
      return true;
    }

    if (this.State === DRAWING_UP) {
      var x = this.Layer.Touches[0][0];
      var y = this.Layer.Touches[0][1];
      this.SetStateToDrawingDown(x, y);
    }
    return false;
  };

  PencilWidget.prototype.HandleStop = function () {
    // A stroke has just been finished.
    var last = this.Shapes.GetNumberOfShapes() - 1;

    if (this.State === DRAWING_DOWN && last >= 0) {
      var spacing = this.Layer.GetCamera().GetSpacing();
      // NOTE: This assume that the shapes are polylines.
      var stroke = this.Shapes.GetShape(last);
      stroke.Decimate(spacing * 0.5);
      stroke.Closed = this.Mode === CLOSED;
      if (stroke.length <= 1) {
        stroke.Points.pop();
        return false;
      }
      this.Modified();
      // Do not trigger a state change event on drawing up/down transistions.
      this.State = DRAWING_UP;

      // When closed,  the interation is like a lasso.  The last
      // Can be merged with the selected stroke (if they overlap).
      if (this.Mode === CLOSED) {
        this.HandleLassoMerge();
      } else {
        // use intersecting stroke to cut a line.
        this.HandleOpenCut();
      }
    }
    return false;
  };

  PencilWidget.prototype.HandleMouseUp = function () {
    if (this.State === INACTIVE) {
      return true;
    }
    if (this.StylusOnly) {
      // IPads do not have mice, so this is probably unecessary.
      return true;
    }
    // Middle mouse deactivates the widget.
    var event = this.Layer.Event;
    if (event.which === 2) {
      // Middle mouse was pressed.
      this.SetActive(false);
      return false;
    }

    return this.HandleStop();
  };

  PencilWidget.prototype.HandleTouchEnd = function () {
    if (this.StylusOnly && !this.Layer.Event.pencil) {
      // The apple pencil needs to ignore viewer touch events.
      return true;
    }
    if (this.State !== DRAWING_DOWN) {
      return true;
    }
    return this.HandleStop();
  };

  PencilWidget.prototype.HandleMove = function (x, y) {
    if (this.State === DRAWING_UP) {
      this.SetStateToDrawingDown(x, y);
    }

    if (this.State === DRAWING_DOWN) {
      var last = this.Shapes.GetNumberOfShapes() - 1;
      var shape = this.Shapes.GetShape(last);
      var pt = this.Layer.GetCamera().ConvertPointViewerToWorld(x, y);
      shape.Points.push([pt[0], pt[1], 0.0]); // avoid same reference.
      shape.Modified();
      this.Layer.EventuallyDraw();
      return false;
    }

    return true;
  };

  PencilWidget.prototype.HandleMouseMove = function () {
    if (this.State === INACTIVE) {
      return true;
    }
    if (this.StylusOnly) {
      // IPads do not have mice, so this is probably unecessary.
      return true;
    }
    var event = this.Layer.Event;
    var x = this.Layer.MouseX;
    var y = this.Layer.MouseY;

    if (event.which === 1) {
      if (this.HandleMove(x, y) === false) {
        return false;
      }
    }

    return false;
  };

  PencilWidget.prototype.HandleTouchMove = function () {
    if (this.State === INACTIVE) {
      return true;
    }
    if (this.StylusOnly && !this.Layer.Event.pencil) {
      // The apple pencil needs to ignore viewer touch events.
      return true;
    }
    if (this.Layer.Touches.length !== 1) {
      return true;
    }

    var x = this.Layer.Touches[0][0];
    var y = this.Layer.Touches[0][1];

    this.HandleMove(x, y);
    return false;
  };

  // Selects or unselects all strokes.
  // Returns true if any selection changed.
  PencilWidget.prototype.SetSelected = function (flag) {
    var ret = this.Shapes.SetSelected(flag);

    if (flag) {
      this.SelectionChanged();
    }
    if (!flag) {
      // We can be selected without being active, but we cannot be
      // active without being selected.
      this.SetActive(false);
    }

    return ret;
  };

  // Returns true if any strokes are selected.
  PencilWidget.prototype.IsSelected = function () {
    return this.Shapes.IsSelected();
  };

  // Selects all strokes that match the selection
  // TODO: Check all the points in the stroke after the rough bounds check.
  PencilWidget.prototype.ApplySelect = function (selection) {
    var selected = false;
    for (var idx = 0; idx < this.Shapes.GetNumberOfShapes(); ++idx) {
      var shape = this.Shapes.GetShape(idx);
      // first check the bounds (xmin,xmax,ymin,ymax].
      var bds = shape.GetBounds();
      if (selection.WorldPointInSelection(bds[0], bds[2]) &&
          selection.WorldPointInSelection(bds[0], bds[3]) &&
          selection.WorldPointInSelection(bds[1], bds[2]) &&
          selection.WorldPointInSelection(bds[1], bds[3])) {
        // Good enough for now
        shape.SetSelected(true);
        selected = true;
      } else {
        shape.SetSelected(false);
      }
    }
    return selected;
  };

  // Can we bind the dialog apply callback to an objects method?
  PencilWidget.prototype.ShowPropertiesDialog = function () {
    if (!this.Dialog) {
      this.InitializeDialog();
    }
    this.Dialog.ColorInput.val(this.Color);
    this.Dialog.LineWidthInput.val(this.LineWidth.toFixed(2));
    this.Dialog.ClosedInput.prop('checked', this.Mode === CLOSED);

    this.Dialog.Show(true);
  };

  PencilWidget.prototype.DialogApplyCallback = function () {
    this.Color = this.Dialog.ColorInput.val();
    this.LineWidth = parseFloat(this.Dialog.LineWidthInput.val());
    if (this.Dialog.ClosedInput.prop('checked')) {
      this.SetModeToClosed();
    } else {
      this.SetModeToOpen();
    }

    this.Shapes.SetOutlineColor(this.Color);
    this.Shapes.SetLineWidth(parseFloat(this.Dialog.LineWidthInput.val()));
    this.Shapes.UpdateBuffers(this.Layer.AnnotationView);
    this.SetSelected(false);
    if (window.SA) { SA.RecordState(); }
    this.Layer.EventuallyDraw();
    this.Modified();
    this.SaveDefaults();
  };

  PencilWidget.prototype.SaveDefaults = function () {
    var hexcolor = this.Color;
    var mode = 'open';
    if (this.Mode === CLOSED) {
      mode = 'closed';
    }
    localStorage.PencilWidgetDefaults = JSON.stringify({
      Color: hexcolor,
      LineWidth: this.LineWidth,
      Mode: mode
    });
  };

  // ====================================================================
  // Lasso merge logic.

  // See if we can merge the last stroke with the selected stroke.
  PencilWidget.prototype.HandleLassoMerge = function () {
    var lastIdx = this.Shapes.GetNumberOfShapes() - 1;
    // This is the one just drawn.
    var stroke2 = this.Shapes.GetShape(lastIdx);
    // Find the selected stroke.
    var found = false;
    for (var stroke1Idx = 0; stroke1Idx < lastIdx; ++stroke1Idx) {
      var stroke1 = this.Shapes.GetShape(stroke1Idx);
      if (stroke1.IsSelected()) {
        found = true;
        break;
      }
    }
    if (!found) {
      // We could not find a second stroke.
      // Just close the last stroke and return.
      stroke2.Closed = true;
      stroke2.UpdateBuffers(this.Layer.AnnotationView);
      this.Layer.EventuallyDraw();
      console.log('first stroke not found');
      return;
    }

    // Now see if they overlap.
    if (this.CombineStrokes(stroke1, stroke2)) {
      console.log('stroke merged');
      // The last stroke has been merged.  Remove it.
      this.Shapes.DeleteChild(lastIdx);
      // Leave the other stroke selected.
      stroke1.UpdateBuffers(this.Layer.AnnotationView);
    } else {
      console.log('no intersection');
      // no intersection.  Keep them both, but leave the new one selected.
      stroke1.SetSelected(false);
      if (this.Mode === CLOSED) {
        stroke2.Closed = true;
      }
      stroke2.UpdateBuffers(this.Layer.AnnotationView);
    }
    this.Layer.EventuallyDraw();
  };

  // Loop is the old, stroke is the new.
  // returns true if merged, false if not.;
  PencilWidget.prototype.CombineStrokes = function (polyLineLoop, polyLineStroke) {
    var loop = polyLineLoop.Points;
    var stroke = polyLineStroke.Points;

    // This algorithm was desinged to have the first point be the same as the last point.
    // To generalize polylineWidgets and lassoWidgets, I changed this and put a closed
    // flag (which implicitely draws the last segment) in polyline.
    // It is easier to temporarily add the extra point and them remove it, than change the algorithm.
    loop.push(loop[0]);

    // Find the first and last intersection points between stroke and loop.
    var intersection0;
    var intersection1;
    for (var i = 1; i < stroke.length; ++i) {
      var pt0 = stroke[i - 1];
      var pt1 = stroke[i];
      var intersections = this.FindSegmentLoopIntersections(pt0, pt1, loop);
      // We are looking for the first and last interestions: so sort.
      intersections.sort(function (a, b) { return a.k - b.k; });
      for (var j = 0; j < intersections.length; ++j) {
        var intersection = intersections[j];
        if (intersections.length > 0) {
          if (intersection0 === undefined) {
            intersection0 = intersection;
            intersection0.StrokeIdx0 = i - 1;
            intersection0.StrokeIdx1 = i;
          } else {
            intersection1 = intersection;
            intersection1.StrokeIdx0 = i - 1;
            intersection1.StrokeIdx1 = i;
          }
        }
      }
    }

    // If we have two intersections, clip the loop with the stroke.
    if (intersection1 === undefined) {
      // Get rid of that extra duplicated point we added.
      loop.pop();
      return false;
    }

    // Crop the stroke and add the two new intersection points to the front and end.
    var croppedStroke = [intersection0.Point];
    croppedStroke = croppedStroke.concat(stroke.slice(intersection0.StrokeIdx1,
                                                      intersection1.StrokeIdx1));
    croppedStroke.push(intersection1.Point);

    // Do we need to reverse the cropped stroke?
    var reverseCroppedStroke = true;

    // Crop the loop into two parts.
    // Build both loops keeing track of their lengths.
    // Keep the longer part.
    var tmp;
    if (intersection1.LoopIdx1 < intersection0.LoopIdx1) {
      tmp = intersection0;
      intersection0 = intersection1;
      intersection1 = tmp;
      reverseCroppedStroke = !reverseCroppedStroke;
    }
    // The middle part.
    var croppedLoop = loop.slice(intersection0.LoopIdx1, intersection1.LoopIdx1);
    // The second part is the combination of the end and start pieces.
    tmp = loop.slice(intersection1.LoopIdx1);
    // Get rid of that extra duplicated point we added.
    tmp.pop();
    // Now add the start piece to the end piece. (it is a loop).
    tmp = tmp.concat(loop.slice(0, intersection0.LoopIdx1));
    if (this.ComputeStrokeLength(tmp) > this.ComputeStrokeLength(croppedLoop)) {
      // If we keep the second part because it is longer, we have to reverse the stroke.
      croppedLoop = tmp;
      reverseCroppedStroke = !reverseCroppedStroke;
    }
    if (reverseCroppedStroke) {
      croppedStroke.reverse();
    }
    polyLineLoop.Points = croppedLoop.concat(croppedStroke);

    return true;
  };

  PencilWidget.prototype.ComputeStrokeLength = function (stroke) {
    if (stroke.length === 0) {
      return 0;
    }
    var pt0 = stroke[0];
    var pt1, x, y;
    var length = 0;
    for (var i = 1; i < stroke.length; ++i) {
      pt1 = stroke[i];
      x = pt1[0] - pt0[0];
      y = pt1[1] - pt0[1];
      length += Math.sqrt(x * x + y * y);
    }
    return length;
  };

  // Returns all te points that a loop intersects with a single stroke segment.
  // transform all points so p0 is origin and p1 maps to (1,0)
  // Returns an empty array if no intersection,
  // It returns an array of intersections [{Point: newPt, LoopIndex: i}, ...] .
  // (sorted starting with the ones closest to p0).
  // It does not change the loop.
  PencilWidget.prototype.FindSegmentLoopIntersections = function (p0, p1, loop) {
    var intersections = [];
    var p = [(p1[0] - p0[0]), (p1[1] - p0[1])];
    var mag = Math.sqrt(p[0] * p[0] + p[1] * p[1]);
    if (mag <= 0.0) {
      return [];
    }
    p[0] = p[0] / mag;
    p[1] = p[1] / mag;

    var m0 = loop[0];
    var n0 = [(m0[0] - p0[0]) / mag, (m0[1] - p0[1]) / mag];
    var k0 = [(n0[0] * p[0] + n0[1] * p[1]), (n0[1] * p[0] - n0[0] * p[1])];

    for (var i = 1; i < loop.length; ++i) {
      var m1 = loop[i];
      // Avoid an infinite loop inserting points.
      if (p0 === m0 || p0 === m1) {
        continue;
      }
      var n1 = [(m1[0] - p0[0]) / mag, (m1[1] - p0[1]) / mag];
      var k1 = [(n1[0] * p[0] + n1[1] * p[1]), (n1[1] * p[0] - n1[0] * p[1])];
      if ((k1[1] >= 0.0 && k0[1] <= 0.0) || (k1[1] <= 0.0 && k0[1] >= 0.0)) {
        var k = k0[1] / (k0[1] - k1[1]);
        var x = k0[0] + k * (k1[0] - k0[0]);
        if (x > 0 && x <= 1) {
          var newPt = [(m0[0] + k * (m1[0] - m0[0])), (m0[1] + k * (m1[1] - m0[1])), 0.0];
          intersections.push({Point: newPt, LoopIdx0: i - 1, LoopIdx1: i, k: x});
        }
      }
      m0 = m1;
      n0 = n1;
      k0 = k1;
    }

    return intersections;
  };

  // This is not actually needed!  So it is not used.
  PencilWidget.prototype.IsPointInsideLoop = function (x, y, loop) {
    // Sum up angles.  Inside poitns will sum to 2pi, outside will sum to 0.
    var angle = 0.0;
    var pt0 = loop[loop.length - 1];
    for (var i = 0; i < loop.length; ++i) {
      var pt1 = loop[i];
      var v0 = [pt0[0] - x, pt0[1] - y];
      var v1 = [pt1[0] - x, pt1[1] - y];
      var mag0 = Math.sqrt(v0[0] * v0[0] + v0[1] * v0[1]);
      var mag1 = Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1]);
      angle += Math.arcsin((v0[0] * v1[1] - v0[1] * v1[0]) / (mag0 * mag1));
    }
    return (angle > 3.14 || angle < -3.14);
  };

  // --------------------------------------------------------------------------------
  // Stuff for eraser. Never finihsed.

  // Left turn.
  // Returns 'undefined' if zero length segment.
  PencilWidget.prototype.ComputeSegmentNormal = function (pt0, pt1) {
    var dx = pt1[0] - pt0[0];
    var dy = pt1[1] - pt0[1];
    var mag = Math.sqrt(dx * dx + dy * dy);
    if (mag === 0) {
      return;
    }
    return [-dy / mag, dx / mag];
  };

  // We need a fat line. Handle one segment at a time.
  // Output is an loop (array of points) around a thick line with rounded ends.
  // The first and last points are the same.
  PencilWidget.prototype.SegmentToLoop = function (pt1, pt2, radius) {
    var divisions = 8;
    var loop = [];
    // Compute a normal to the line segment.
    var n = this.ComputeSegmentNormal(pt1, pt2);
    if (!n) {
      n = [0, 1];
      loop.concat(this.EndCap(pt1, n, radius, divisions));
      // Do not duplicate the point in the middle of the circle.
      loop.pop();
      loop.concat(this.EndCap(pt1, n, -radius, divisions));
      return loop;
    }
    loop.concat(this.EndCap(pt1, n, radius, divisions));
    loop.concat(this.EndCap(pt2, n, -radius, divisions));
    return loop;
  };

  // I did not finish this method.
  /*
  // We need a fat line.
  // Output is an loop (array of points) around a thick line with rounded ends.
  // The first and last points of the output are the same.
  PencilWidget.prototype.StrokeToLoop = function (polyLineStroke, radius) {
    var stroke = polyLineStroke.Points;
    if (stroke.length === 0) {
      return;
    }

    // Compute normals for every segment in the loop.
    // (and get rid of 0 length segments).
    var normals = []; // One fewer normals than points.
    var pt0 = stroke[0];
    var points = [pt0]; // Only keep the non zero length segments.
    for (var i = 1; i < stroke.length; ++i) {
      var pt1 = points[i];
      n = this.ComputeSegmentNormal(pt0, pt1);
      if (n) {
        points.push(pt1);
        normals.push(n);
        pt0 = pt1;
      }
    }

    pt0 = points[0];
    // First the endcap.
    var loop = this.EndCap(points[0], nommals[0], radius, divisions);
    // Grow both ends of the loop as we add segments?  Maybe

    //  .... Just compute all points niavely and then check inside/ outside of circle box set.
    //  .... Will have to compute partial segments.
    pt1 = points[1];

    var divisions = 8;
    var dTheata = Math.PI / divisions;

    // Compute a normal to the line segment.
    var n = [pt2[0] - pt1[0], pt2[1] - pt1[1]];
    var mag = Math.sqrt(n[0] * n[0] + n[1] * n[1]);
    if (mag === 0.0) {
      n = [0,1];
      loop.concat(this.EndCap(pt1, n, radius, divisions));
      // Do not duplicate the point in the middle of the circle.
      loop.pop();
      loop.concat(this.EndCap(pt1, n, -radius, divisions));
      return loop;
    }
    loop.concat(this.EndCap(pt1, n, radius, divisions));
    loop.concat(this.EndCap(pt2, n, -radius, divisions));
    return loop;
  };
  */

  // Return half a circle.
  PencilWidget.prototype.EndCap = function (center, n, radius, divisions) {
    var points = [];
    for (var i = 0; i <= divisions; ++i) {
      var theta = Math.PI * i / divisions;
      var c = Math.cos(theta);
      var s = Math.sin(theta);
      // Rotate
      var x = center[0] + radius * (c * n[0] - s * n[1]);
      var y = center[1] + radius * (c * n[1] + s * n[0]);
      points.push([x, y]);
    }
    return points;
  };

  // Loop is the old, stroke is the new eraser stroke.
  // returns true if merged, false if not.;
  PencilWidget.prototype.CombineEraserStroke = function (polyLineLoop, polyLineStroke) {
    var loop = polyLineLoop.Points;
    var stroke = polyLineStroke.Points;

    // This algorithm was desinged to have the first point be the same as the last point.
    // To generalize polylineWidgets and lassoWidgets, I changed this and put a closed
    // flag (which implicitely draws the last segment) in polyline.
    // It is easier to temporarily add the extra point and them remove it, than change the algorithm.
    loop.push(loop[0]);

    // TODO: Fix this.  I got in an infinite loop.
    // Inserting points it the array we are iterating over.
    // Find the first and last intersection points between stroke and loop.
    var intersection0;
    var intersection1;
    for (var i = 1; i < stroke.length; ++i) {
      var pt0 = stroke[i - 1];
      var pt1 = stroke[i];
      var intersections = this.FindSegmentLoopIntersections(pt0, pt1, loop);
      // We are looking for the first and last interestions: so sort.
      intersections.sort(function (a, b) { return a.k - b.k; });
      if (intersections.length > 0) {
        if (intersection0 === undefined) {
          intersection0 = intersections[0];
          intersection0.StrokeIdx0 = i - 1;
          intersection0.StrokeIdx1 = i;
        } else {
          var last = intersections.length - 1;
          intersection1 = intersections[last];
          intersection1.StrokeIdx0 = i - 1;
          intersection1.StrokeIdx1 = i;
        }
      }
    }

    // If we have two intersections, clip the loop with the stroke.
    if (intersection1 === undefined) {
      // Get rid of that extra duplicated point we added.
      loop.pop();
      return false;
    }

    // Crop the stroke and add the two new intersection points to the front and end.
    var croppedStroke = [intersection0.Point];
    croppedStroke = croppedStroke.concat(stroke.slice(intersection0.StrokeIdx1,
                                                      intersection1.StrokeIdx1));
    croppedStroke.push(intersection1.Point);

    // Do we need to reverse the cropped stroke?
    var reverseCroppedStroke = true;

    // Crop the loop into two parts.
    // Build both loops keeing track of their lengths.
    // Keep the longer part.
    var tmp;
    if (intersection1.LoopIdx1 < intersection0.LoopIdx1) {
      tmp = intersection0;
      intersection0 = intersection1;
      intersection1 = tmp;
      reverseCroppedStroke = !reverseCroppedStroke;
    }
    // The middle part.
    var croppedLoop = loop.slice(intersection0.LoopIdx1, intersection1.LoopIdx1);
    // The second part is the combination of the end and start pieces.
    tmp = loop.slice(intersection1.LoopIdx1);
    // Get rid of that extra duplicated point we added.
    tmp.pop();
    // Now add the start piece to the end piece. (it is a loop).
    tmp = tmp.concat(loop.slice(0, intersection0.LoopIdx1));
    if (this.ComputeStrokeLength(tmp) > this.ComputeStrokeLength(croppedLoop)) {
      // If we keep the second part because it is longer, we have to reverse the stroke.
      croppedLoop = tmp;
      reverseCroppedStroke = !reverseCroppedStroke;
    }
    if (reverseCroppedStroke) {
      croppedStroke.reverse();
    }
    polyLineLoop.Points = croppedLoop.concat(croppedStroke);

    return true;
  };

  // ====================================================================
  // open cut logic

  //  If stroke crosses selected line, cut it.
  PencilWidget.prototype.HandleOpenCut = function () {
    var lastIdx = this.Shapes.GetNumberOfShapes() - 1;
    // This is the one just drawn.
    var stroke2 = this.Shapes.GetShape(lastIdx);
    // Find the selected stroke.
    var found = false;
    for (var stroke1Idx = 0; stroke1Idx < lastIdx; ++stroke1Idx) {
      var stroke1 = this.Shapes.GetShape(stroke1Idx);
      if (stroke1.IsSelected()) {
        found = true;
        break;
      }
    }
    if (!found) {
      // We could not find a second stroke.
      return;
    }

    // Now see if they overlap.
    for (var i = 1; i < stroke1.Points.length; ++i) {
      var pt0 = stroke1.Points[i - 1];
      var pt1 = stroke1.Points[i];
      var intersections = this.FindSegmentLoopIntersections(pt0, pt1, stroke2.Points);
      if (intersections.length > 0) {
        // Cut the line here.
        var part1 = stroke1.Points.slice(i);
        var part2 = stroke1.Points.slice(0, i);
        if (part1.length < 2) {
          part1 = part2;
          part2 = undefined;
        }
        stroke1.Points = part1;
        stroke1.UpdateBuffers(this.Layer.AnnotationView);
        // The last stroke either gets moved to a new widget or deleted.
        this.Shapes.DeleteChild(lastIdx);

        if (part2) {
          stroke2.Points = part2;
          stroke2.UpdateBuffers(this.Layer.AnnotationView);
          // Problems with multiple strokes in one widget.  Make a new widget.
          var widget2 = new PencilWidget(this.Layer);
          widget2.Shapes.AddShape(stroke2);
          widget2.Color = this.Color;
          this.Layer.AddWidget(widget2);
        }
        this.Layer.EventuallyDraw();
        this.SelectionChanged();
        return;
      }
    }
    stroke1.SetSelected(false);
    this.Layer.EventuallyDraw();
    this.SelectionChanged();
  };

  SAM.PencilWidget = PencilWidget;
})();

// ==============================================================================
// Segmentation / fill.  But should I change it into a contour at the end?

(function () {
  'use strict';

  var FILL_WIDGET_DRAWING = 0;
  var FILL_WIDGET_ACTIVE = 1;
  var FILL_WIDGET_WAITING = 2;

  function FillWidget (viewer, newFlag) {
    if (viewer === null) {
      return;
    }

        // I am not sure what to do for the fill because
        // I plan to change it to a contour.

    this.Dialog = new SAM.Dialog(this);
        // Customize dialog for a lasso.
    this.Dialog.Title.text('Fill Annotation Editor');
    this.Dialog.Body.css({'margin': '1em 2em'});
        // Color
    this.Dialog.ColorDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .addClass('sa-view-fill-div');
    this.Dialog.ColorLabel =
            $('<div>')
            .appendTo(this.Dialog.ColorDiv)
            .text('Color:')
            .addClass('sa-view-fill-label');
    this.Dialog.ColorInput =
            $('<input type="color">')
            .appendTo(this.Dialog.ColorDiv)
            .val('#30ff00')
            .addClass('sa-view-fill-input');

        // Line Width
    this.Dialog.LineWidthDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .addClass('sa-view-fill-div');
    this.Dialog.LineWidthLabel =
            $('<div>')
            .appendTo(this.Dialog.LineWidthDiv)
            .text('Line Width:')
            .addClass('sa-view-fill-label');
    this.Dialog.LineWidthInput =
            $('<input type="number">')
            .appendTo(this.Dialog.LineWidthDiv)
            .addClass('sa-view-fill-input')
            .keypress(function (event) { return event.keyCode !== 13; });

    this.Popup = new SAM.WidgetPopup(this);
    this.Viewer = viewer;
    this.Viewer.AddWidget(this);

    this.Cursor = $('<img>').appendTo('body')
            .addClass('sa-view-fill-cursor')
            .attr('type', 'image')
            .attr('src', SAM.ImagePathUrl + 'brush1.jpg');

    // I am trying to stop images from getting move events and displaying a circle/slash.
    // This did not work.  preventDefault did not either.
    // this.Cursor.mousedown(function (event) {self.HandleMouseDown(event);})
    // this.Cursor.mousemove(function (event) {self.HandleMouseMove(event);})
    // this.Cursor.mouseup(function (event) {self.HandleMouseUp(event);})
    // .preventDefault();

    this.ActiveCenter = [0, 0];

    this.State = FILL_WIDGET_DRAWING;
    if (!newFlag) {
      this.State = FILL_WIDGET_WAITING;
    }

    // Lets save the zoom level (sort of).
    // Load will overwrite this for existing annotations.
    // This will allow us to expand annotations into notes.
    this.CreationCamera = viewer.GetCamera().Serialize;
  }

  // This is expensive, so initialize explicitely outside the constructor.
  FillWidget.prototype.Initialize = function (view) {
    // Now for the segmentation initialization.
    this.Segmentation = new SA.Segmentation(this.Viewer);
  };

  FillWidget.prototype.Draw = function (view) {
    this.Segmentation.ImageAnnotation.Draw(view);
  };

  // I do not know what we are saving yet.
  FillWidget.prototype.Serialize = function () {
        /*
          var obj = new Object();
          obj.type = "pencil";
          obj.shapes = [];
          for (var i = 0; i < this.Shapes.length; ++i) {
          var shape = this.Shapes[i];
          var points = [];
          for (var j = 0; j < shape.Points.length; ++j) {
          points.push([shape.Points[j][0], shape.Points[j][1]]);
          }
          obj.shapes.push(points);
          }
          obj.creation_camera = this.CreationCamera;

          return obj;
        */
  };

    // Load a widget from a json object (origin MongoDB).
  FillWidget.prototype.Load = function (obj) {
        /*
          for(var n=0; n < obj.shapes.length; n++){
          var points = obj.shapes[n];
          var shape = new SAM.Polyline();
          shape.OutlineColor = [0.9, 1.0, 0.0];
          shape.FixedSize = false;
          shape.LineWidth = 0;
          this.Shapes.push(shape);
          for (var m = 0; m < points.length; ++m) {
          shape.Points[m] = [points[m][0], points[m][1]];
          }
          shape.UpdateBuffers(this.Viewer.AnnotationView);
          }

          // How zoomed in was the view when the annotation was created.
          if (obj.view_height !== undefined) {
          this.CreationCamera = obj.creation_camera;
          }
        */
  };

  FillWidget.prototype.HandleKeyPress = function (keyCode, shift) {
    return false;
  };

  FillWidget.prototype.Deactivate = function () {
    this.Popup.StartHideTimer();
    this.Viewer.DeactivateWidget(this);
    this.State = FILL_WIDGET_WAITING;
    if (this.DeactivateCallback) {
      this.DeactivateCallback();
    }
    this.Viewer.EventuallyRender();
  };

  FillWidget.prototype.HandleMouseDown = function (event) {
    var x = this.Viewer.MouseX;
    var y = this.Viewer.MouseY;

    var ptWorld;
    if (event.which === 1) {
      ptWorld = this.Viewer.ConvertPointViewerToWorld(x, y);
      this.Cursor.attr('src', SAM.ImagePathUrl + 'brush1.jpg');
      this.Cursor.show();
      this.Segmentation.AddPositive(ptWorld);
    }
    if (event.which === 3) {
      ptWorld = this.Viewer.ConvertPointViewerToWorld(x, y);
      this.Cursor.attr('src', SAM.ImagePathUrl + 'eraser1.jpg');
      this.Cursor.show();
      this.Segmentation.AddNegative(ptWorld);
    }
  };

  FillWidget.prototype.HandleMouseUp = function (event) {
    // Middle mouse deactivates the widget.
    if (event.which === 2) {
      // Middle mouse was pressed.
      this.Deactivate();
    }

    // A stroke has just been finished.
    if (event.which === 1 || event.which === 3) {
      this.Cursor.hide();
      this.Segmentation.Update();
      this.Segmentation.Draw();
      this.Viewer.EventuallyRender();
    }
  };

  FillWidget.prototype.HandleDoubleClick = function (event) {
  };

  FillWidget.prototype.HandleMouseMove = function (event) {
    var x = this.Viewer.MouseX;
    var y = this.Viewer.MouseY;

    // Move the paint bucket icon to follow the mouse.
    this.Cursor.css({'left': (x + 4), 'top': (y - 32)});

    if (this.Viewer.MouseDown === true && this.State === FILL_WIDGET_DRAWING) {
      var ptWorld;
      if (event.which === 1) {
        ptWorld = this.Viewer.ConvertPointViewerToWorld(x, y);
        this.Segmentation.AddPositive(ptWorld);
      }
      if (event.which === 3) {
        ptWorld = this.Viewer.ConvertPointViewerToWorld(x, y);
        this.Segmentation.AddNegative(ptWorld);
      }
    }
  };

  FillWidget.prototype.ComputeActiveCenter = function () {
        /*
          var count = 0;
          var sx = 0.0;
          var sy = 0.0;
          for (var i = 0; i < this.Shapes.length; ++i) {
          var shape = this.Shapes[i];
          var points = [];
          for (var j = 0; j < shape.Points.length; ++j) {
          sx += shape.Points[j][0];
          sy += shape.Points[j][1];
          }
          count += shape.Points.length;
          }

          this.ActiveCenter[0] = sx / count;
          this.ActiveCenter[1] = sy / count;
        */
  };

    // This also shows the popup if it is not visible already.
  FillWidget.prototype.PlacePopup = function () {
        /*
          var pt = this.Viewer.ConvertPointWorldToViewer(this.ActiveCenter[0],
          this.ActiveCenter[1]);
          pt[0] += 40;
          pt[1] -= 40;
          this.Popup.Show(pt[0],pt[1]);
        */
  };

  FillWidget.prototype.CheckActive = function (event) {
        /*
          if (this.State === FILL_WIDGET_DRAWING) { return; }

          var pt = this.Viewer.ConvertPointWorldToViewer(this.ActiveCenter[0],
          this.ActiveCenter[1]);

          var dx = this.Viewer.MouseX - pt[0];
          var dy = this.Viewer.MouseY - pt[1];
          var active = false;

          if (dx*dx + dy*dy < 1600) {
          active = true;
          }
          this.SetActive(active);
          return active;
        */
  };

  FillWidget.prototype.GetActive = function () {
    return false;
  };

    // Setting to active always puts state into "active".
    // It can move to other states and stay active.
  FillWidget.prototype.SetActive = function (flag) {
    if (flag) {
      this.Viewer.ActivateWidget(this);
      this.State = FILL_WIDGET_ACTIVE;
      for (var i = 0; i < this.Shapes.length; ++i) {
        this.Shapes[i].Active = true;
      }
      this.PlacePopup();
      this.Viewer.EventuallyRender();
    } else {
      this.Deactivate();
      this.Viewer.DeactivateWidget(this);
    }
  };

  FillWidget.prototype.RemoveFromViewer = function () {
    if (this.Viewer) {
      this.Viewer.RemoveWidget();
    }
  };

  // Can we bind the dialog apply callback to an objects method?
  FillWidget.prototype.ShowPropertiesDialog = function () {
    this.Dialog.ColorInput.val(SAM.ConvertColorToHex(this.Shapes[0].OutlineColor));
    this.Dialog.LineWidthInput.val((this.Shapes[0].LineWidth).toFixed(2));

    this.Dialog.Show(true);
  };

  FillWidget.prototype.DialogApplyCallback = function () {
    var hexcolor = this.Dialog.ColorInput.val();
    for (var i = 0; i < this.Shapes.length; ++i) {
      this.Shapes[i].SetOutlineColor(hexcolor);
      this.Shapes[i].LineWidth = parseFloat(this.Dialog.LineWidthInput.val());
      this.Shapes[i].UpdateBuffers(this.Viewer.AnnotationView);
    }
    this.SetActive(false);
    if (window.SA) { SA.RecordState(); }
    this.Viewer.EventuallyRender();
  };

  SAM.FillWidget = FillWidget;
})();

// ==============================================================================
// Variation of pencil
// Free form loop
// I plan to be abble to add or remove regions from the loop with multiple strokes.
// It will be a state, just like the pencil widget is a state.

(function () {
    // Depends on the CIRCLE widget
  'use strict';

  var DRAWING = 0;
  var ACTIVE = 1;
  var WAITING = 2;

  function LassoWidget (layer, newFlag) {
    if (layer === null) {
      return;
    }

        // Keep track of annotation created by students without edit
        // permission.
    this.UserNoteFlag = !SA.Edit;
    this.Type = 'lasso';

    var self = this;
    this.Dialog = new SAM.Dialog(function () { self.DialogApplyCallback(); });
        // Customize dialog for a lasso.
    this.Dialog.Title.text('Lasso Annotation Editor');
    this.Dialog.Body.css({'margin': '1em 2em'});
        // Color
    this.Dialog.ColorDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .addClass('sa-view-annotation-modal-div');
    this.Dialog.ColorLabel =
            $('<div>')
            .appendTo(this.Dialog.ColorDiv)
            .text('Color:')
            .addClass('sa-view-annotation-modal-input-label');
    this.Dialog.ColorInput =
            $('<input type="color">')
            .appendTo(this.Dialog.ColorDiv)
            .val('#30ff00')
            .addClass('sa-view-annotation-modal-input');

        // Line Width
    this.Dialog.LineWidthDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .addClass('sa-view-annotation-modal-div');
    this.Dialog.LineWidthLabel =
            $('<div>')
            .appendTo(this.Dialog.LineWidthDiv)
            .text('Line Width:')
            .addClass('sa-view-annotation-modal-input-label');
    this.Dialog.LineWidthInput =
            $('<input type="number">')
            .appendTo(this.Dialog.LineWidthDiv)
            .addClass('sa-view-annotation-modal-input')
            .keypress(function (event) { return event.keyCode !== 13; });

        // Area
    this.Dialog.AreaDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .addClass('sa-view-annotation-modal-div');
    this.Dialog.AreaLabel =
            $('<div>')
            .appendTo(this.Dialog.AreaDiv)
            .text('Area:')
            .addClass('sa-view-annotation-modal-input-label');
    this.Dialog.Area =
            $('<div>')
            .appendTo(this.Dialog.AreaDiv)
            .addClass('sa-view-annotation-modal-input');

        // Get default properties.
    if (localStorage.LassoWidgetDefaults) {
      var defaults = JSON.parse(localStorage.LassoWidgetDefaults);
      if (defaults.Color) {
        this.Dialog.ColorInput.val(SAM.ConvertColorToHex(defaults.Color));
      }
      if (defaults.LineWidth) {
        this.Dialog.LineWidthInput.val(defaults.LineWidth);
      }
    }

    this.Layer = layer;
    this.Popup = new SAM.WidgetPopup(this);
    this.Layer.AddWidget(this);

    this.Loop = new SAM.Polyline();
    this.Loop.OutlineColor = [0.0, 0.0, 0.0];
    this.Loop.SetOutlineColor(this.Dialog.ColorInput.val());
    this.Loop.FixedSize = false;
    this.Loop.LineWidth = 0;
    this.Loop.Closed = true;
    this.Stroke = false;

    this.ActiveCenter = [0, 0];

    if (newFlag) {
      this.SetStateToDrawing();
    } else {
      this.State = WAITING;
    }
  }

  LassoWidget.prototype.Draw = function (view) {
    this.Loop.Draw(view);
    if (this.Stroke) {
      this.Stroke.Draw(view);
    }
  };

  LassoWidget.prototype.Serialize = function () {
    var obj = {};
    obj.type = 'lasso';
    obj.user_note_flag = this.UserNoteFlag;
    obj.lineColor = SAM.ConvertColorToHex(this.Loop.OutlineColor);
    obj.lineWidth = this.Loop.GetLineWidth();
    obj.points = [];
    for (var j = 0; j < this.Loop.Points.length; ++j) {
      obj.points.push([this.Loop.Points[j][0], this.Loop.Points[j][1]]);
    }
    obj.closedloop = true;

    return obj;
  };

    // Load a widget from a json object (origin MongoDB).
  LassoWidget.prototype.Load = function (obj) {
    this.UserNoteFlag = obj.user_note_flag;
    if (obj.lineColor !== undefined) {
      this.Loop.OutlineColor = SAM.ConvertColor(obj.lineColor);
    }
    if (obj.lineWidth !== undefined) {
      this.Loop.LineWidth = obj.lineWidth;
    }
    var points = [];
    if (obj.points !== undefined) {
      points = obj.points;
    }
    if (obj.shape !== undefined) {
      points = obj.shapes[0];
    }

    for (var n = 0; n < points.length; n++) {
      this.Loop.Points[n] = [parseFloat(points[n][0]),
        parseFloat(points[n][1])];
    }
    this.ComputeActiveCenter();
    this.Loop.UpdateBuffers(this.Layer.AnnotationView);
  };

  LassoWidget.prototype.HandleMouseWheel = function (event) {
    if (this.State === DRAWING ||
             this.State === ACTIVE) {
      if (!this.Loop) { return true; }
      var tmp = 0;

      if (event.deltaY) {
        tmp = event.deltaY;
      } else if (event.wheelDelta) {
        tmp = event.wheelDelta;
      }

      var minWidth = 1.0 / this.Layer.GetPixelsPerUnit();

            // Wheel event seems to be in increments of 3.
            // depreciated mousewheel had increments of 120....
      var lineWidth = this.Loop.GetLineWidth();
      lineWidth = lineWidth || minWidth;
      if (tmp > 0) {
        lineWidth *= 1.1;
      } else if (tmp < 0) {
        lineWidth /= 1.1;
      }
      if (lineWidth <= minWidth) {
        lineWidth = 0.0;
      }
      this.Dialog.LineWidthInput.val(lineWidth);
      this.Loop.SetLineWidth(lineWidth);
      this.Loop.UpdateBuffers(this.Layer.AnnotationView);

      this.Layer.EventuallyDraw();
      return false;
    }
    return true;
  };

  LassoWidget.prototype.Deactivate = function () {
    this.Popup.StartHideTimer();
    this.Layer.DeactivateWidget(this);
    this.State = WAITING;
    this.Loop.SetActive(false);
    if (this.Stroke) {
      this.Stroke.SetActive(false);
    }
    if (this.DeactivateCallback) {
      this.DeactivateCallback();
    }
    this.Layer.EventuallyDraw();
  };

  LassoWidget.prototype.HandleKeyDown = function (event) {
    if (this.State === DRAWING) {
            // escape key (or space or enter) to turn off drawing
      if (event.keyCode === 27 || event.keyCode === 32 || event.keyCode === 13) {
        this.Deactivate();
        return false;
      }
    }
  };

  LassoWidget.prototype.HandleMouseDown = function (event) {
    var x = event.offsetX;
    var y = event.offsetY;

    if (event.which === 1) {
      // Start drawing.
      // Stroke is a temporary line for interaction.
      // When interaction stops, it is converted/merged with loop.
      this.Stroke = new SAM.Polyline();
      this.Stroke.OutlineColor = [0.0, 0.0, 0.0];
      this.Stroke.SetOutlineColor(this.Loop.OutlineColor);
      // this.Stroke.SetOutlineColor(this.Dialog.ColorInput.val());
      this.Stroke.FixedSize = false;
      this.Stroke.LineWidth = 0;

      var pt = this.Layer.GetCamera().ConvertPointViewerToWorld(x, y);
      this.Stroke.Points = [];
      this.Stroke.Points.push([pt[0], pt[1]]); // avoid same reference.
      return false;
    }
    return true;
  };

  LassoWidget.prototype.HandleMouseUp = function (event) {
        // Middle mouse deactivates the widget.
    if (event.which === 2) {
            // Middle mouse was pressed.
      this.Deactivate();
    }

        // A stroke has just been finished.
    if (event.which === 1 && this.State === DRAWING) {
      var spacing = this.Layer.GetCamera().GetSpacing();
            // this.Decimate(this.Stroke, spacing);
      this.Stroke.Decimate(spacing);
      if (this.Loop && this.Loop.Points.length > 0) {
        this.CombineStroke();
      } else {
        this.Stroke.Closed = true;
        this.Stroke.UpdateBuffers(this.Layer.AnnotationView);
        this.Loop = this.Stroke;
        this.Stroke = false;
      }
      this.ComputeActiveCenter();
      this.Layer.EventuallyDraw();

      if (this.UserNoteFlag && SA.notesWidget) { SA.notesWidget.EventuallySaveUserNote(); }
      if (window.SA) { SA.RecordState(); }
    }
    return false;
  };

  LassoWidget.prototype.HandleDoubleClick = function (event) {
    if (this.State === DRAWING) {
      this.Deactivate();
      return false;
    }
    if (this.State === ACTIVE) {
      this.SetStateToDrawing();
      return false;
    }
    return true;
  };

  LassoWidget.prototype.SetStateToDrawing = function () {
    this.State = DRAWING;
        // When drawing, the cursor is enough indication.
        // We keep the lines the normal color. Yellow is too hard to see.
    this.Loop.SetActive(false);
    this.Popup.Hide();
    this.Layer.GetParent().css(
            {'cursor': 'url(' + SAM.ImagePathUrl + 'select_lasso.png) 5 30,crosshair'});
    this.Layer.EventuallyDraw();
  };

  LassoWidget.prototype.HandleMouseMove = function (event) {
    var x = event.offsetX;
    var y = event.offsetY;

    if (event.which === 1 && this.State === DRAWING) {
      var shape = this.Stroke;
      var pt = this.Layer.GetCamera().ConvertPointViewerToWorld(x, y);
      shape.Points.push([pt[0], pt[1]]); // avoid same reference.
      shape.UpdateBuffers(this.Layer.AnnotationView);
      if (SA.notesWidget && !this.UserNoteFlag) { SA.notesWidget.MarkAsModified(); } // hack
      if (this.UserNoteFlag && SA.notesWidget) { SA.notesWidget.EventuallySaveUserNote(); }
      this.Layer.EventuallyDraw();
      return false;
    }

    if (this.State === ACTIVE &&
            event.which === 0) {
            // Deactivate
      this.SetActive(this.CheckActive(event));
      return false;
    }
    return true;
  };

  LassoWidget.prototype.ComputeActiveCenter = function () {
    var sx = 0.0;
    var sy = 0.0;
    var shape = this.Loop;
    for (var j = 0; j < shape.Points.length; ++j) {
      sx += shape.Points[j][0];
      sy += shape.Points[j][1];
    }

    this.ActiveCenter[0] = sx / shape.Points.length;
    this.ActiveCenter[1] = sy / shape.Points.length;
  };

    // This also shows the popup if it is not visible already.
  LassoWidget.prototype.PlacePopup = function () {
    var pt = this.Loop.FindPopupPoint(this.Layer.GetCamera());
    pt = this.Layer.GetCamera().ConvertPointWorldToViewer(pt[0], pt[1]);

    pt[0] += 20;
    pt[1] -= 10;

    this.Popup.Show(pt[0], pt[1]);
  };

    // Just returns whether the widget thinks it should be active.
    // Layer is responsible for seting it to active.
  LassoWidget.prototype.CheckActive = function (event) {
    if (this.State === DRAWING) { return; }

    var x = event.offsetX;
    var y = event.offsetY;
    var pt = this.Layer.GetCamera().ConvertPointViewerToWorld(x, y);

    var width = this.Loop.GetLineWidth() / 2;
        // Tolerance: 5 screen pixels.
    var minWidth = 10.0 / this.Layer.GetPixelsPerUnit();
    if (width < minWidth) { width = minWidth; }

    if (this.Loop.PointOnShape(pt, width)) {
      return true;
    } else {
      return false;
    }
  };

  LassoWidget.prototype.GetActive = function () {
    return this.State !== WAITING;
  };

    // Setting to active always puts state into "active".
    // It can move to other states and stay active.
  LassoWidget.prototype.SetActive = function (flag) {
    if (flag) {
      if (this.State === WAITING) {
        this.State = ACTIVE;
        this.Loop.SetActive(true);
        this.PlacePopup();
        this.Layer.EventuallyDraw();
      }
    } else {
      if (this.State !== WAITING) {
        this.Deactivate();
        this.Layer.DeactivateWidget(this);
      }
    }
    this.Layer.EventuallyDraw();
  };

    // It would be nice to put this as a superclass method, or call the
    // layer.RemoveWidget method instead.
  LassoWidget.prototype.RemoveFromLayer = function () {
    if (this.Layer) {
      this.RemoveWidget(this);
    }
  };

    // Can we bind the dialog apply callback to an objects method?
  LassoWidget.prototype.ShowPropertiesDialog = function () {
    this.Dialog.ColorInput.val(SAM.ConvertColorToHex(this.Loop.OutlineColor));
    this.Dialog.LineWidthInput.val((this.Loop.LineWidth).toFixed(2));

    var area = this.ComputeArea();
    var areaString = '' + area.toFixed(2);
    if (this.Loop.FixedSize) {
      areaString += ' pixels^2';
    } else {
      areaString += ' units^2';
    }
    this.Dialog.Area.text(areaString);
    this.Dialog.Show(true);
  };

  LassoWidget.prototype.DialogApplyCallback = function () {
    var hexcolor = this.Dialog.ColorInput.val();
    this.Loop.SetOutlineColor(hexcolor);
    this.Loop.LineWidth = parseFloat(this.Dialog.LineWidthInput.val());
    this.Loop.UpdateBuffers(this.Layer.AnnotationView);
    this.SetActive(false);
    if (window.SA) { SA.RecordState(); }
    this.Layer.EventuallyDraw();

    localStorage.LassoWidgetDefaults = JSON.stringify({Color: hexcolor, LineWidth: this.Loop.LineWidth});
    if (SAM.NotesWidget && !this.UserNoteFlag) { SAM.NotesWidget.MarkAsModified(); } // hack
    if (this.UserNoteFlag && SA.notesWidget) { SA.notesWidget.EventuallySaveUserNote(); }
  };

    /*
    // The real problem is aliasing.  Line is jagged with high frequency sampling artifacts.
    // Pass in the spacing as a hint to get rid of aliasing.
    LassoWidget.prototype.Decimate = function(shape, spacing) {
        // Keep looping over the line removing points until the line does not change.
        var modified = true;
        var sanityCheck = 0;
        while (modified) {
            modified = false;
            var newPoints = [];
            newPoints.push(shape.Points[0]);
            // Window of four points.
            var i = 3;
            while (i < shape.Points.length) {
                // Debugging a hang.  I do not think it occurs in decimate, but it might.
                if (++sanityCheck > 100000) {
                    alert("Decimate is takeing too long.");
                    return;
                }
                var p0 = shape.Points[i];
                var p1 = shape.Points[i-1];
                var p2 = shape.Points[i-2];
                var p3 = shape.Points[i-3];
                // Compute the average of the center two.
                var cx = (p1[0] + p2[0]) * 0.5;
                var cy = (p1[1] + p2[1]) * 0.5;
                // Find the perendicular normal.
                var nx = (p0[1] - p3[1]);
                var ny = -(p0[0] - p3[0]);
                var mag = Math.sqrt(nx*nx + ny*ny);
                nx = nx / mag;
                ny = ny / mag;
                mag = Math.abs(nx*(cx-shape.Points[i-3][0]) + ny*(cy-shape.Points[i-3][1]));
                // Mag metric does not distinguish between line and a stroke that double backs on itself.
                // Make sure the two point being merged are between the outer points 0 and 3.
                var dir1 = (p0[0]-p1[0])*(p3[0]-p1[0]) + (p0[1]-p1[1])*(p3[1]-p1[1]);
                var dir2 = (p0[0]-p2[0])*(p3[0]-p2[0]) + (p0[1]-p2[1])*(p3[1]-p2[1]);
                if (mag < spacing && dir1 < 0.0 && dir2 < 0.0) {
                    // Replace the two points with their average.
                    newPoints.push([cx, cy]);
                    modified = true;
                    // Skip the next point the window will have one old merged point,
                    // but that is ok because it is just used as reference and not altered.
                    i += 2;
                } else {
                    //  No modification.  Just move the window one.
                    newPoints.push(shape.Points[i-2]);
                    ++i;
                }
            }
            // Copy the remaing point / 2 points
            i = i-2;
            while (i < shape.Points.length) {
                newPoints.push(shape.Points[i]);
                ++i;
            }
            shape.Points = newPoints;
        }

        shape.UpdateBuffers(this.Layer.AnnotationView);
    }
    */
  LassoWidget.prototype.CombineStroke = function () {
        // This algorithm was desinged to have the first point be the same as the last point.
        // To generalize polylineWidgets and lassoWidgets, I changed this and put a closed
        // flag (which implicitely draws the last segment) in polyline.
        // It is easier to temporarily add the extra point and them remove it, than change the algorithm.
    this.Loop.Points.push(this.Loop.Points[0]);

        // Find the first and last intersection points between stroke and loop.
    var intersection0;
    var intersection1;
    for (var i = 1; i < this.Stroke.Points.length; ++i) {
      var pt0 = this.Stroke.Points[i - 1];
      var pt1 = this.Stroke.Points[i];
      var tmp = this.FindIntersection(pt0, pt1);
      if (tmp) {
                // I need to insert the intersection in the stroke so
                // one stroke segment does not intersect loop twice.
        this.Stroke.Points.splice(i, 0, tmp.Point);
        if (intersection0 === undefined) {
          intersection0 = tmp;
          intersection0.StrokeIndex = i;
        } else {
                    // If a point was added before first intersection,
                    // its index needs to be updated too.
          if (tmp.LoopIndex < intersection0.LoopIndex) {
            intersection0.LoopIndex += 1;
          }
          intersection1 = tmp;
          intersection1.StrokeIndex = i;
        }
      }
    }

    var sanityCheck = 0;

    // If we have two intersections, clip the loop with the stroke.
    if (intersection1 !== undefined) {
      // We will have two parts.
      // Build both loops keeing track of their lengths.
      // Keep the longer part.
      var points0 = [];
      var len0 = 0.0;
      var points1 = [];
      var len1 = 0.0;
      var dx;
      var dy;
      // Add the clipped stroke to both loops.
      for (i = intersection0.StrokeIndex; i < intersection1.StrokeIndex; ++i) {
        points0.push(this.Stroke.Points[i]);
        points1.push(this.Stroke.Points[i]);
      }
      // Now the two new loops take different directions around the original loop.
      // Decreasing
      i = intersection1.LoopIndex;
      while (i !== intersection0.LoopIndex) {
        if (++sanityCheck > 1000000) {
          alert('Combine loop 1 is taking too long.');
          return;
        }
        points0.push(this.Loop.Points[i]);
        dx = this.Loop.Points[i][0];
        dy = this.Loop.Points[i][1];
        // decrement around loop.  First and last loop points are the same.
        if (--i === 0) {
          i = this.Loop.Points.length - 1;
        }
        // Integrate distance.
        dx -= this.Loop.Points[i][0];
        dy -= this.Loop.Points[i][1];
        len0 += Math.sqrt(dx * dx + dy * dy);
      }
      // Duplicate the first point in the loop
      points0.push(intersection0.Point);

      // Increasing
      i = intersection1.LoopIndex;
      while (i !== intersection0.LoopIndex) {
        if (++sanityCheck > 1000000) {
          alert('Combine loop 2 is taking too long.');
          return;
        }
        points1.push(this.Loop.Points[i]);
        dx = this.Loop.Points[i][0];
        dy = this.Loop.Points[i][1];
        // increment around loop.  First and last loop points are the same.
        if (++i === this.Loop.Points.length - 1) {
          i = 0;
        }
        // Integrate distance.
        dx -= this.Loop.Points[i][0];
        dy -= this.Loop.Points[i][1];
        len1 += Math.sqrt(dx * dx + dy * dy);
      }
      // Duplicate the first point in the loop
      points1.push(intersection0.Point);

      if (len0 > len1) {
        this.Loop.Points = points0;
      } else {
        this.Loop.Points = points1;
      }

      if (window.SA) { SA.RecordState(); }
    }

    // Remove the extra point added at the begining of this method.
    this.Loop.Points.pop();
    this.Loop.UpdateBuffers(this.Layer.AnnotationView);
    this.ComputeActiveCenter();

    this.Stroke = false;
    this.Layer.EventuallyDraw();
  };

  // transform all points so p0 is origin and p1 maps to (1,0)
  // Returns false if no intersection,
  // If there is an intersection, it adds that point to the loop.
  // It returns {Point: newPt, LoopIndex: i} .
  LassoWidget.prototype.FindIntersection = function (p0, p1) {
    var best = false;
    var p = [(p1[0] - p0[0]), (p1[1] - p0[1])];
    var mag = Math.sqrt(p[0] * p[0] + p[1] * p[1]);
    if (mag < 0.0) {
      return false;
    }
    p[0] = p[0] / mag;
    p[1] = p[1] / mag;

    var m0 = this.Loop.Points[0];
    var n0 = [(m0[0] - p0[0]) / mag, (m0[1] - p0[1]) / mag];
    var k0 = [(n0[0] * p[0] + n0[1] * p[1]), (n0[1] * p[0] - n0[0] * p[1])];

    for (var i = 1; i < this.Loop.Points.length; ++i) {
      var m1 = this.Loop.Points[i];
      // Avoid an infinite loop inserting points.
      if (p0 === m0 || p0 === m1) {
        continue;
      }
      var n1 = [(m1[0] - p0[0]) / mag, (m1[1] - p0[1]) / mag];
      var k1 = [(n1[0] * p[0] + n1[1] * p[1]), (n1[1] * p[0] - n1[0] * p[1])];
      if ((k1[1] >= 0.0 && k0[1] <= 0.0) || (k1[1] <= 0.0 && k0[1] >= 0.0)) {
        var k = k0[1] / (k0[1] - k1[1]);
        var x = k0[0] + k * (k1[0] - k0[0]);
        if (x > 0 && x <= 1) {
          var newPt = [(m0[0] + k * (m1[0] - m0[0])), (m0[1] + k * (m1[1] - m0[1]))];
          if (!best || x < best.k) {
            best = {Point: newPt, LoopIndex: i, k: x};
          }
        }
      }
      m0 = m1;
      n0 = n1;
      k0 = k1;
    }
    if (best) {
      this.Loop.Points.splice(best.LoopIndex, 0, best.Point);
    }

    return best;
  };

  // This is not actually needed!  So it is not used.
  LassoWidget.prototype.IsPointInsideLoop = function (x, y) {
    // Sum up angles.  Inside poitns will sum to 2pi, outside will sum to 0.
    var angle = 0.0;
    var pt0 = this.Loop.Points[this.Loop.length - 1];
    for (var i = 0; i < this.Loop.length; ++i) {
      var pt1 = this.Loop.Points[i];
      var v0 = [pt0[0] - x, pt0[1] - y];
      var v1 = [pt1[0] - x, pt1[1] - y];
      var mag0 = Math.sqrt(v0[0] * v0[0] + v0[1] * v0[1]);
      var mag1 = Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1]);
      angle += Math.arcsin((v0[0] * v1[1] - v0[1] * v1[0]) / (mag0 * mag1));
    }

    return (angle > 3.14 || angle < -3.14);
  };

  LassoWidget.prototype.ComputeArea = function () {
    var area = 0.0;
    // Use the active center. It should be more numerical stable.
    // Iterate over triangles
    var vx1 = this.Loop.Points[0][0] - this.ActiveCenter[0];
    var vy1 = this.Loop.Points[0][1] - this.ActiveCenter[1];
    for (var j = 1; j < this.Loop.Points.length; ++j) {
      // Area of triangle is 1/2 magnitude of cross product.
      var vx2 = vx1;
      var vy2 = vy1;
      vx1 = this.Loop.Points[j][0] - this.ActiveCenter[0];
      vy1 = this.Loop.Points[j][1] - this.ActiveCenter[1];
      area += (vx1 * vy2) - (vx2 * vy1);
    }

    if (area < 0) {
      area = -area;
    }
    return area;
  };

  SAM.LassoWidget = LassoWidget;
})();

// ==============================================================================
// A replacement for the right click option to get the properties menu.
// This could be multi touch friendly.

(function () {
  'use strict';

  function WidgetPopup (widget, layer) {
    this.Widget = widget;
    this.Visible = false;
    this.HideTimerId = 0;

    var parent = layer.GetParent();

        // buttons to replace right click.
    var self = this;

        // We cannot append this to the canvas, so just append
        // it to the view panel, and add the viewport offset for now.
        // I should probably create a div around the canvas.
        // This is this only place I need viewport[0], [1] and I
        // was thinking of getting rid of the viewport offset.
    this.ButtonDiv =
            $('<div>').appendTo(parent)
            .hide()
            .css({'position': 'absolute',
              'z-index': '1'})
            .mouseenter(function () { self.CancelHideTimer(); })
            .mouseleave(function () { self.StartHideTimer(); });
    this.DeleteButton = $('<img>').appendTo(this.ButtonDiv)
            .css({'height': '20px'})
            .attr('src', SA.ImagePathUrl + 'deleteSmall.png')
            .on('click touchstart', function () { self.DeleteCallback(); });
    this.PropertiesButton = $('<img>').appendTo(this.ButtonDiv)
            .css({'height': '20px'})
            .attr('src', SA.ImagePathUrl + 'Menu.jpg')
            .on('click touchstart', function () { self.PropertiesCallback(); });

    this.HideCallback = undefined;
  }

    // Used to hide an interacotrs handle with the popup.
    // TODO:  Let the AnnotationLayer manage the "active" widget.
    // The popup should not be doing this (managing its own timer)
  WidgetPopup.prototype.SetHideCallback = function (callback) {
    this.HideCllback = callback;
  };

  WidgetPopup.prototype.DeleteCallback = function () {
    if (this.Widget.UserNoteFlag && SA.notesWidget) { SA.notesWidget.EventuallySaveUserNote(); }
    this.Widget.SetActive(false);
    this.Hide();

        // Messy.  Maybe closure callback can keep track of the layer.
    this.Widget.Layer.EventuallyDraw();
    this.Widget.Layer.RemoveWidget(this.Widget);

    if (window.SA) { SA.RecordState(); }
  };

  WidgetPopup.prototype.PropertiesCallback = function () {
    this.Hide();
    this.Widget.ShowPropertiesDialog();
  };

    // ------------------------------------------------------------------------------
  WidgetPopup.prototype.Show = function (x, y) {
    this.CancelHideTimer(); // Just in case: Show trumps previous hide.
    this.ButtonDiv.css({
      'left': x + 'px',
      'top': y + 'px'})
            .show();
  };

    // When some other event occurs, we want to hide the pop up quickly
  WidgetPopup.prototype.Hide = function () {
    this.CancelHideTimer(); // Just in case: Show trumps previous hide.
    this.ButtonDiv.hide();
    if (this.HideCallback) {
      (this.HideCallback)();
    }
  };

  WidgetPopup.prototype.StartHideTimer = function () {
    if (!this.HideTimerId) {
      var self = this;

      if (SAM.detectMobile()) {
        this.HideTimerId = setTimeout(function () { self.HideTimerCallback(); }, 1500);
      } else {
        this.HideTimerId = setTimeout(function () { self.HideTimerCallback(); }, 800);
      }
    }
  };

  WidgetPopup.prototype.CancelHideTimer = function () {
    if (this.HideTimerId) {
      clearTimeout(this.HideTimerId);
      this.HideTimerId = 0;
    }
  };

  WidgetPopup.prototype.HideTimerCallback = function () {
    this.ButtonDiv.hide();
    this.HideTimerId = 0;
  };

  SAM.WidgetPopup = WidgetPopup;
})();

// cross hairs was created as an anchor for text.
// Just two lines that cross at a point.
// I am not goint to support line width, or fillColor.
// Shape seems to define lines in a loop, so I will create a loop for now.

(function () {
  'use strict';

  function CrossHairs () {
    SAM.Shape.call(this);
    this.Length = 50; // Length of the crosing lines
    this.Width = 1; // Width of the cross hair lines.
    this.Origin = [10000, 10000]; // position in world coordinates.
    this.FillColor = [0, 0, 0];
    this.OutlineColor = [1, 1, 1];
    this.PointBuffer = [];
  }
  CrossHairs.prototype = new SAM.Shape();

  CrossHairs.prototype.destructor = function () {
        // Get rid of the buffers?
  };

  CrossHairs.prototype.UpdateBuffers = function (view) {
    this.PointBuffer = [];
    var cellData = [];
    var halfLength = (this.Length * 0.5) + 0.5;
    var halfWidth = (this.Width * 0.5) + 0.5;

    this.Matrix = mat4.create();
    mat4.identity(this.Matrix);

    this.PointBuffer.push(-halfWidth);
    this.PointBuffer.push(-halfWidth);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(-halfLength);
    this.PointBuffer.push(-halfWidth);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(-halfLength);
    this.PointBuffer.push(halfWidth);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(-halfWidth);
    this.PointBuffer.push(halfWidth);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(-halfWidth);
    this.PointBuffer.push(halfLength);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(halfWidth);
    this.PointBuffer.push(halfLength);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(halfWidth);
    this.PointBuffer.push(halfWidth);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(halfLength);
    this.PointBuffer.push(halfWidth);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(halfLength);
    this.PointBuffer.push(-halfWidth);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(halfWidth);
    this.PointBuffer.push(-halfWidth);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(halfWidth);
    this.PointBuffer.push(-halfLength);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(-halfWidth);
    this.PointBuffer.push(-halfLength);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(-halfWidth);
    this.PointBuffer.push(-halfWidth);
    this.PointBuffer.push(0.0);

    cellData.push(1);
    cellData.push(2);
    cellData.push(7);

    cellData.push(1);
    cellData.push(7);
    cellData.push(8);

    cellData.push(4);
    cellData.push(5);
    cellData.push(10);

    cellData.push(4);
    cellData.push(10);
    cellData.push(11);

    if (view.gl) {
      this.VertexPositionBuffer = view.gl.createBuffer();
      view.gl.bindBuffer(view.gl.ARRAY_BUFFER, this.VertexPositionBuffer);
      view.gl.bufferData(view.gl.ARRAY_BUFFER, new Float32Array(this.PointBuffer), view.gl.STATIC_DRAW);
      this.VertexPositionBuffer.itemSize = 3;
      this.VertexPositionBuffer.numItems = this.PointBuffer.length / 3;

      this.CellBuffer = view.gl.createBuffer();
      view.gl.bindBuffer(view.gl.ELEMENT_ARRAY_BUFFER, this.CellBuffer);
      view.gl.bufferData(view.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cellData), view.gl.STATIC_DRAW);
      this.CellBuffer.itemSize = 1;
      this.CellBuffer.numItems = cellData.length;
    }
  };

  SAM.CrossHairs = CrossHairs;
})();

(function () {
  'use strict';

  function Arrow () {
    SAM.Shape.call(this);
    this.Width = 10; // width of the shaft and size of the head
    this.Length = 50; // Length of the arrow in pixels
    this.Orientation = 45.0; // in degrees, counter clockwise, 0 is left
    this.Origin = [10000, 10000]; // Tip position in world coordinates.
    this.OutlineColor = [0, 0, 0];
    this.ZOffset = -0.1;
  }
  Arrow.prototype = new SAM.Shape();

  Arrow.prototype.destructor = function () {
    // Get rid of the buffers?
  };

  // This has to be in viewer coordinates bedcause we do not have the camera.
  // Point is in world coordinates.
  // Point origin is anchor and units pixels.
  Arrow.prototype.PointInShape = function (x, y) {
    // Rotate point so arrow lies along the x axis.
    var tmp = -(this.Orientation * Math.PI / 180.0);
    var ct = Math.cos(tmp);
    var st = Math.sin(tmp);
    var xNew = x * ct + y * st;
    var yNew = -x * st + y * ct;

    // Now we have to scale from global pixels to screen pixels.
    tmp = this.Width / 2.0;
    // Had to bump the y detection up by 3x because of unclickability on the iPad.
    if (xNew > 0.0 && xNew < this.Length * 1.3 && yNew < tmp * 3 && yNew > -tmp * 3) {
      return true;
    }
  };

  Arrow.prototype.UpdateBuffers = function (view) {
    this.PointBuffer = [];
    var cellData = [];
    var hw = this.Width * 0.5;
    var w2 = this.Width * 2.0;

    this.Matrix = mat4.create();
    mat4.identity(this.Matrix);

    this.PointBuffer.push(0.0);
    this.PointBuffer.push(0.0);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(w2);
    this.PointBuffer.push(this.Width);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(w2);
    this.PointBuffer.push(hw);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(this.Length);
    this.PointBuffer.push(hw);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(this.Length);
    this.PointBuffer.push(-hw);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(w2);
    this.PointBuffer.push(-hw);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(w2);
    this.PointBuffer.push(-this.Width);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(0.0);
    this.PointBuffer.push(0.0);
    this.PointBuffer.push(0.0);

    if (view.gl) {
      // Now create the triangles
      cellData.push(0);
      cellData.push(1);
      cellData.push(2);

      cellData.push(0);
      cellData.push(2);
      cellData.push(5);

      cellData.push(0);
      cellData.push(5);
      cellData.push(6);

      cellData.push(2);
      cellData.push(3);
      cellData.push(4);

      cellData.push(2);
      cellData.push(4);
      cellData.push(5);

      this.VertexPositionBuffer = view.gl.createBuffer();
      view.gl.bindBuffer(view.gl.ARRAY_BUFFER, this.VertexPositionBuffer);
      view.gl.bufferData(view.gl.ARRAY_BUFFER, new Float32Array(this.PointBuffer), view.gl.STATIC_DRAW);
      this.VertexPositionBuffer.itemSize = 3;
      this.VertexPositionBuffer.numItems = this.PointBuffer.length / 3;

      this.CellBuffer = view.gl.createBuffer();
      view.gl.bindBuffer(view.gl.ELEMENT_ARRAY_BUFFER, this.CellBuffer);
      view.gl.bufferData(view.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cellData), view.gl.STATIC_DRAW);
      this.CellBuffer.itemSize = 1;
      this.CellBuffer.numItems = cellData.length;
    }
  };

  // Polar is a pain.
  // This positions the tail a point in viewer coordinates.
  // This only works for world coordinat system, constant size, constant orientation.
  Arrow.prototype.SetTailViewer = function (x, y, cam) {
    var dx, dy;
    if (this.FixedSize) {
      var tipViewer = cam.ConvertPointWorldToViewer(this.Origin[0], this.Origin[1]);
      dx = x - tipViewer[0];
      dy = y - tipViewer[1];
    } else {
      var tailWorld = cam.ConvertPointViewerToWorld(x, y);
      dx = tailWorld[0] - this.Origin[0];
      dy = tailWorld[1] - this.Origin[1];
    }
    this.Length = Math.sqrt(dx * dx + dy * dy);
    this.Orientation = -Math.atan2(dy, dx) * 180.0 / Math.PI;
  };

  // Polar is a pain.
  // This positions the tail a point in viewer coordinates.
  // This only works for world coordinat system, constant size, constant orientation.
  Arrow.prototype.GetTailViewer = function (cam) {
    var theta = -this.Orientation * Math.PI / 180.0;
    var x, y;
    if (this.FixedSize) {
      var tipViewer = cam.ConvertPointWorldToViewer(this.Origin[0], this.Origin[1]);
      x = tipViewer[0] + this.Length * Math.cos(theta);
      y = tipViewer[1] + this.Length * Math.sin(theta);
      return [x, y];
    } else {
      x = this.Origin[0] + this.Length * Math.cos(theta);
      y = this.Origin[1] + this.Length * Math.sin(theta);
      var tailViewer = cam.ConvertPointWorldToViewer(x, y);
      return tailViewer;
    }
  };

  SAM.Arrow = Arrow;
})();

// ==============================================================================
// This widget will first be setup to define an arrow.
// Layer will forward events to the arrow.
// TODO: Active hover: circles cursor.

(function () {
  'use strict';

  // The arrow has just been created and is following the mouse.
  // I have to differentiate from DRAG because
  // dragging while just created cannot be relative.  It places the tip on the mouse.
  var NEW = 0;
  var NEW_DRAG_TAIL = 1;
  var DRAG = 2; // The whole arrow is being dragged.
  var DRAG_TIP = 3;
  var DRAG_TAIL = 4;
  var INACTIVE = 5; // The normal (resting) state.
  var ACTIVE = 6; // Mouse is receiving events.
  var HOVER = 7;  // Mouse is over the widget
  var DIALOG = 8; // Properties dialog is up

  // We might get rid of the new flag by passing in a null layer.
  function ArrowWidget (layer) {
    if (layer === null) {
      return null;
    }
    this.Layer = layer;
    this.Type = 'arrow';
    this.State = INACTIVE;

    // This method gets called if the active state of this widget turns on or off.
    // This is used to turn off the pencil button in the Panel.
    this.StateChangeCallback = undefined;
    // This is used by the annotationPanel to transfer draing mode to a new selected widget.
    this.SelectedCallback = undefined;

    // Wait to create this until the first move event.
    this.Arrow = new SAM.Arrow();
    this.Arrow.Origin = [0, 0];
    this.Arrow.SetFillColor([0.0, 0.0, 0.0]);
    this.Arrow.OutlineColor = [1.0, 1.0, 1.0];
    this.Arrow.Length = 50;
    this.Arrow.Width = 8;
    // Note: If the user clicks before the mouse is in the
    // canvas, this will behave odd.
    this.TipPosition = [0, 0];
    this.TipOffset = [0, 0];

    // Circle is to show an active tip and base.
    this.CircleTip = new SAM.Circle();
    this.CircleTip.SetFillColor([1, 1, 0]);
    this.CircleTip.SetOutlineColor([0.0, 0.0, 0.0]);
    this.CircleTip.Radius = 5;
    this.CircleTip.LineWidth = 1;
    this.CircleTip.PositionCoordinateSystem = 1; // Shape.VIEWER;
    // this.Circle.ZOffset = -0.05;

    this.CircleTail = new SAM.Circle();
    this.CircleTail.SetFillColor([1, 1, 0]);
    this.CircleTail.SetOutlineColor([0.0, 0.0, 0.0]);
    this.CircleTail.Radius = 5;
    this.CircleTail.PositionCoordinateSystem = 1; // Shape.VIEWER;

    // Get default properties.
    if (localStorage.ArrowWidgetDefaults) {
      var defaults = JSON.parse(localStorage.ArrowWidgetDefaults);
      if (defaults.Color) {
        this.Arrow.SetFillColor(defaults.Color);
      }
      if (defaults.Width) {
        this.Arrow.Width = defaults.Width;
      }
    }
  }

  // Not used yet, but might be useful.
  ArrowWidget.prototype.SetCreationCamera = function (cam) {
    // Lets save the zoom level (sort of).
    // Load will overwrite this for existing annotations.
    // This will allow us to expand annotations into notes.
    this.CreationCamera = cam.Serialize();
  };

  ArrowWidget.prototype.SetModifiedCallback = function (callback) {
    this.ModifiedCallback = callback;
  };

  // Called when the widget is modified.
  ArrowWidget.prototype.Modified = function () {
    if (this.ModifiedCallback) {
      this.ModifiedCallback(this);
    }
  };

  ArrowWidget.prototype.SetSelectedCallback = function (callback) {
    this.SelectedCallback = callback;
  };

  // This callback gets called when ever the active state changes,
  // even if caused by an external call. This widget is passed as a argument.
  // This is used to turn off the pencil button in the Panel.
  ArrowWidget.prototype.SetStateChangeCallback = function (callback) {
    this.StateChangeCallback = callback;
  };

  // Called when the state changes.
  ArrowWidget.prototype.StateChanged = function () {
    if (this.StateChangeCallback) {
      this.StateChangeCallback(this);
    }
  };

  // Sets state to "NEW"
  ArrowWidget.prototype.SetStateToDrawing = function () {
    // if (this.Layer) {
    // this.StateChanged();
    this.State = NEW;
    // return;
    // }
    // this.State = INACTIVE;
  };

  ArrowWidget.prototype.GetActive = function () {
    if (this.State === INACTIVE) {
      return false;
    }
    return true;
  };

  ArrowWidget.prototype.SetActive = function (flag) {
    if (flag === this.GetActive()) {
      return;
    }

    if (flag) {
      this.State = ACTIVE;
    } else {
      this.State = INACTIVE;
    }
    this.StateChanged();
    this.Layer.EventuallyDraw();
  };

  ArrowWidget.prototype.Draw = function () {
    var view = this.Layer.GetView();
    this.Arrow.Draw(view);
    if (this.State !== INACTIVE && this.State !== NEW && this.State !== DRAG) {
      var pts = this.GetViewPoints();
      this.CircleTip.Origin = pts[0];
      this.CircleTail.Origin = pts[1];
      this.CircleTip.Draw(view);
      this.CircleTail.Draw(view);
    }
  };

  ArrowWidget.prototype.Serialize = function () {
    if (this.Arrow === undefined) {
      return null;
    }

    var obj = {};
    obj.type = 'arrow';
    obj.origin = this.Arrow.Origin;
    obj.fillColor = SAM.ConvertColorToHex(this.Arrow.FillColor);
    obj.lineColor = SAM.ConvertColorToHex(this.Arrow.OutlineColor);
    obj.length = this.Arrow.Length;
    obj.width = this.Arrow.Width;
    obj.orientation = this.Arrow.Orientation;
    obj.fixedsize = this.Arrow.FixedSize;
    obj.fixedorientation = this.Arrow.FixedOrientation;

    return obj;
  };

  // Load a widget from a json object (origin MongoDB).
  ArrowWidget.prototype.Load = function (obj) {
    this.Arrow.Origin = [parseFloat(obj.origin[0]), parseFloat(obj.origin[1])];
    this.TipPosition = [parseFloat(obj.origin[0]), parseFloat(obj.origin[1])];
    this.Arrow.FillColor = [parseFloat(obj.fillcolor[0]), parseFloat(obj.fillcolor[1]), parseFloat(obj.fillcolor[2])];
    this.Arrow.OutlineColor = SAM.ConvertColor(obj.lineColor);
    this.Arrow.Length = parseFloat(obj.length);
    this.Arrow.Width = parseFloat(obj.width);
    this.Arrow.Orientation = parseFloat(obj.orientation);

    if (obj.fixedsize === undefined) {
      this.Arrow.FixedSize = false;
    } else {
      this.Arrow.FixedSize = (obj.fixedsize === 'true');
    }

    if (obj.fixedorientation === undefined) {
      this.Arrow.FixedOrientation = false;
    } else {
      this.Arrow.FixedOrientation = (obj.fixedorientation === 'true');
    }

    this.Arrow.UpdateBuffers(this.Layer.AnnotationView);
  };

  // When we toggle fixed size, we have to convert the length of the arrow
  // between viewer and world.
  ArrowWidget.prototype.SetFixedSize = function (fixedSizeFlag) {
    if (this.Arrow.FixedSize === fixedSizeFlag) {
      return;
    }
    var pixelsPerUnit = this.Layer.GetPixelsPerUnit();

    if (fixedSizeFlag) {
      // Convert length from world to viewer.
      this.Arrow.Length *= pixelsPerUnit;
      this.Arrow.Width *= pixelsPerUnit;
    } else {
      this.Arrow.Length /= pixelsPerUnit;
      this.Arrow.Width /= pixelsPerUnit;
    }
    this.Arrow.FixedSize = fixedSizeFlag;
    this.Arrow.UpdateBuffers(this.Layer.AnnotationView);
    this.Layer.EventuallyDraw();
  };

  // Selects the widget if the arrow is fuly contained in the selection rectangle.
  ArrowWidget.prototype.ApplySelect = function (selection) {
    var viewPts = this.GetViewPoints();
    if (selection.ViewerPointInSelection(viewPts[0][0], viewPts[0][1]) &&
        selection.ViewerPointInSelection(viewPts[1][0], viewPts[1][1])) {
      this.SetSelected(true);
      return true;
    }
    this.SetSelected(false);
    return false;
  };

  // Returns true if the mouse is over the arrow.
  ArrowWidget.prototype.HandleSelect = function () {
    if (this.State === DIALOG) {
      return;
    }
    var event = this.Layer.Event;
    var x = event.offsetX;
    var y = event.offsetY;

    if (this.PointViewerInArrow(x, y)) {
      this.Arrow.Selected = true;
      return this;
    }
    this.Arrow.Selected = false;
  };

  ArrowWidget.prototype.HandleMouseDown = function (layer) {
    if (this.State === INACTIVE || this.State === ACTIVE) {
      // Widget only responds when mouse is hovering over it,
      // otherwise, let the viewer do its thing.
      return true;
    }

    var event = layer.Event;
    if (event.which !== 1) {
      return false;
    }
    if (this.State === NEW) {
      this.TipPosition = [this.Layer.MouseX, this.Layer.MouseY];
      // Creation behaves differently.  It is not selected.
      // When finished, it goes in active.
      this.State = NEW_DRAG_TAIL;
      this.CircleTail.Selected = true;
      this.CircleTail.SetFillColor([1, 1, 0]);
    }
    if (this.State === HOVER) {
      if (this.CircleTip.Selected) {
        this.State = DRAG_TIP;
      } else if (this.CircleTail.Selected) {
        this.State = DRAG_TAIL;
      } else {
        this.State = DRAG;
      }
      var x = event.offsetX;
      var y = event.offsetY;
      var cam = this.Layer.GetCamera();
      this.LastMouseWorld = cam.ConvertPointViewerToWorld(x, y);
    }
    return false;
  };

  ArrowWidget.prototype.HandleMouseUp = function (layer) {
    if (this.State === INACTIVE || this.State === ACTIVE) {
      // Widget only responds when mouse is hovering over it,
      // otherwise, let the viewer do its thing.
      return true;
    }
    if (this.State === NEW_DRAG_TAIL) {
      this.State = INACTIVE;
      this.StateChanged();
      this.Layer.EventuallyDraw();
      this.Modified();
      return false;
    }

    var event = layer.Event;
    if (this.State === ACTIVE && event.which === 3) {
      // Right mouse was pressed.
      // Pop up the properties dialog.
      // Which one should we popup?
      // Add a ShowProperties method to the widget. (With the magic of javascript).
      this.ShowPropertiesDialog();
    }
    this.State = HOVER;
    this.Modified();
    return false;
  };

  ArrowWidget.prototype.PointViewerInArrow = function (x, y) {
    var pts = this.GetViewPoints();
    var vx = (pts[1][0] - pts[0][0]);
    var vy = (pts[1][1] - pts[0][1]);
    var vm = Math.sqrt(vx * vx + vy * vy);
    var nx = vx / vm;
    var ny = vy / vm;
    var mx = x - pts[0][0];
    var my = y - pts[0][1];
    var mm = Math.sqrt(mx * mx + my * my);
    var d = nx * mx + ny * my;
    var tx = mx - nx * d;
    var ty = my - ny * d;
    var tm = Math.sqrt(tx * tx + ty * ty);
    var widthViewer = this.Arrow.Width * vm / this.Arrow.Length;
    if (mm > vm || tm > (widthViewer / 2) + 2) {
      return false;
    }
    return true;
  };

  ArrowWidget.prototype.HandleMouseMove = function (layer) {
    if (this.State === INACTIVE) {
      return true;
    }
    var event = layer.Event;
    var x = this.Layer.MouseX;
    var y = this.Layer.MouseY;

    if (event.which === 1 && this.State === ACTIVE) {
      // If only active, left the viewer do its thing.
      return true;
    }

    // Hover logic.
    if (this.State === ACTIVE || this.State === HOVER) {
      var cursor = '';
      if (this.PointViewerInArrow(x, y)) {
        cursor = 'move';
        this.State = HOVER;
      } else {
        this.State = ACTIVE;
      }

      // Now deal with control point hovering.
      var dx = x - this.CircleTip.Origin[0];
      var dy = y - this.CircleTip.Origin[1];
      if (dx * dx + dy * dy < Math.pow(this.CircleTip.Radius, 2)) {
        this.CircleTip.Selected = true;
        cursor = 'move';
        this.State = HOVER;
      } else {
        this.CircleTip.Selected = false;
      }
      dx = x - this.CircleTail.Origin[0];
      dy = y - this.CircleTail.Origin[1];
      if (dx * dx + dy * dy < Math.pow(this.CircleTail.Radius, 2)) {
        this.CircleTail.Selected = true;
        cursor = 'move';
        this.State = HOVER;
      } else {
        this.CircleTail.Selected = false;
      }
      this.Layer.GetParent().css({'cursor': cursor});
      this.Layer.EventuallyDraw();

      return false;
    }

    var cam = this.Layer.GetCamera();
    var mouseWorld = cam.ConvertPointViewerToWorld(x, y);
    if (this.State === NEW) {
      // Just have the tip follow the mouse.
      this.Arrow.Origin = mouseWorld;
      this.Layer.EventuallyDraw();
      return false;
    }

    if (event.which !== 1) {
      return false;
    }

    if (this.State === DRAG) {
      // Tip follows its relative position to the mouse.
      dx = mouseWorld[0] - this.LastMouseWorld[0];
      dy = mouseWorld[1] - this.LastMouseWorld[1];
      this.Arrow.Origin[0] += dx;
      this.Arrow.Origin[1] += dy;
    } else if (this.State === DRAG_TAIL || this.State === NEW_DRAG_TAIL) {
      // Tail follows mouse, but tip stays fixed.
      this.Arrow.SetTailViewer(x, y, cam);
      this.Arrow.UpdateBuffers(this.Layer.AnnotationView);
    } else if (this.State === DRAG_TIP) {
      // Tip follows mouse, but tail does not move.
      // var tailViewer = this.Arrow.GetTailViewer(cam);
      var pts = this.GetViewPoints();
      var tailViewer = pts[1];
      this.Arrow.Origin = mouseWorld;
      this.Arrow.SetTailViewer(tailViewer[0], tailViewer[1], cam);
      this.Arrow.UpdateBuffers(this.Layer.AnnotationView);
    }
    this.LastMouseWorld = mouseWorld;
    this.Layer.EventuallyDraw();
    return false;
  };

  // Return points 1 and 2 in view (screen) coordinates.
  ArrowWidget.prototype.GetViewPoints = function () {
    var cam = this.Layer.GetCamera();
    var pt1 = this.Arrow.Origin;
    var tmp = -this.Arrow.Orientation * Math.PI / 180.0;
    var dx = this.Arrow.Length * Math.cos(tmp);
    var dy = this.Arrow.Length * Math.sin(tmp);

    var vpt1 = cam.ConvertPointWorldToViewer(pt1[0], pt1[1]);
    if (this.Arrow.FixedSize) {
      var vpt2 = [vpt1[0] + dx, vpt1[1] + dy];
    } else {
      var pt2 = [pt1[0] + dx, pt1[1] + dy];
      vpt2 = cam.ConvertPointWorldToViewer(pt2[0], pt2[1]);
    }

    return [vpt1, vpt2];
  };

  // TODO: Repurpose for dragging
  ArrowWidget.prototype.CheckActive = function () {
    var viewport = this.Layer.GetViewport();
    var cam = this.Layer.GetCamera();
    // TODO: Should not be accessing this without a getter.
    var m = cam.ImageMatrix;
    // Compute tip point in screen coordinates.
    var x = this.Arrow.Origin[0];
    var y = this.Arrow.Origin[1];
    // Convert from world coordinate to view (-1->1);
    var h = (x * m[3] + y * m[7] + m[15]);
    var xNew = (x * m[0] + y * m[4] + m[12]) / h;
    var yNew = (x * m[1] + y * m[5] + m[13]) / h;
    // Convert from view to screen pixel coordinates.
    xNew = (xNew + 1.0) * 0.5 * viewport[2] + viewport[0];
    yNew = (yNew + 1.0) * 0.5 * viewport[3] + viewport[1];
    yNew = viewport[3] - yNew;

    console.log('origin: ' + xNew + ', ' + yNew + ', mouse: ' + this.Layer.MouseX + ', ' + this.Layer.MouseY);

    // Use this point as the origin.
    x = this.Layer.MouseX - xNew;
    y = this.Layer.MouseY - yNew;
    // Rotate so arrow lies along the x axis.
    var tmp = -this.Arrow.Orientation * Math.PI / 180.0;
    var ct = Math.cos(tmp);
    var st = Math.sin(tmp);
    xNew = x * ct + y * st;
    yNew = -x * st + y * ct;

    var length = this.Arrow.Length;
    var halfWidth = this.Arrow.Width / 2.0;
    if (!this.Arrow.FixedSize) {
      var pixelsPerUnit = this.Layer.GetPixelsPerUnit();
      length *= pixelsPerUnit;
      halfWidth *= pixelsPerUnit;
    }

    this.ActiveTail = false;
    if (xNew > 0.0 && xNew < length && yNew > -halfWidth && yNew < halfWidth) {
      this.SetActive(true);
      // Save the position along the arrow to decide which drag behavior to use.
      if (xNew > length - halfWidth) {
        this.ActiveTail = true;
      }
      return true;
    } else {
      this.SetActive(false);
      return false;
    }
  };

  // Returns true if selected
  // This is sort of ugly.  Change it to delete directly if possible.
  // Return value will let the layer clean up.
  ArrowWidget.prototype.DeleteSelected = function () {
    return this.Arrow.DeleteSelected();
  };

  ArrowWidget.prototype.IsEmpty = function () {
    if (this.State === NEW) {
      return true;
    }
    return this.Arrow.IsEmpty();
  };

  // I am divorcing selected from active.
  ArrowWidget.prototype.IsSelected = function () {
    return this.Arrow.Selected;
  };

  ArrowWidget.prototype.SetSelected = function (flag) {
    this.Arrow.SetSelected(flag);
    if (flag && this.SelectedCallback) {
      this.SelectedCallback(this);
    }
  };

  // I need this because old schemes cannot use "Load"
  ArrowWidget.prototype.SetColor = function (hexColor) {
    this.Arrow.SetFillColor(hexColor);
    this.Layer.EventuallyDraw();
  };

  ArrowWidget.prototype.InitPropertiesDialog = function () {
    var self = this;

    this.Dialog = new SAM.Dialog(this.Layer.GetParent().parent());
    this.Dialog.SetApplyCallback(function () { self.DialogApplyCallback(); });
    // Customize dialog for an arrow.
    this.Dialog.Title.text('Arrow Properties');
    this.Dialog.Body.css({'margin': '1em 2em'});
    // Color
    this.Dialog.ColorDiv =
            $('<div>')
            .css({'height': '24px'})
            .appendTo(this.Dialog.Body)
            .addClass('sa-view-annotation-modal-div');
    this.Dialog.ColorLabel =
            $('<div>')
            .appendTo(this.Dialog.ColorDiv)
            .text('Color:')
            .addClass('sa-view-annotation-modal-input-label');
    this.Dialog.ColorInput =
            $('<input type="color">')
            .appendTo(this.Dialog.ColorDiv)
            .val('#30ff00')
            .addClass('sa-view-annotation-modal-input');

    // Width
    this.Dialog.WidthDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .addClass('sa-view-annotation-modal-div');
    this.Dialog.WidthLabel =
            $('<div>')
            .appendTo(this.Dialog.WidthDiv)
            .text('Shaft Width:')
            .addClass('sa-view-annotation-modal-input-label');
    this.Dialog.WidthInput =
            $('<input type="number">')
            .appendTo(this.Dialog.WidthDiv)
            .addClass('sa-view-annotation-modal-input')
            .keypress(function (event) { return event.keyCode !== 13; });
  };

  // Can we bind the dialog apply callback to an objects method?
  ArrowWidget.prototype.ShowPropertiesDialog = function () {
    if (this.Dialog === undefined) {
      this.InitPropertiesDialog();
    }
    this.WidgetPropertiesToDialog();
    var self = this;
    this.Dialog.SetApplyCallback(function () { self.DialogApplyCallback(); });
    this.Dialog.SetCloseCallback(function () { self.DialogCloseCallback(); });
    this.Dialog.Show(true);
    this.State = DIALOG;
  };

  ArrowWidget.prototype.DialogApplyCallback = function () {
    // Transfer properties fromt he dialog GUI to the widget.
    this.DialogPropertiesToWidget();
    // View bindings kept the dialog text input from working.
    if (!this.Layer) {
      return;
    }
    this.SetActive(false);
    this.Layer.EventuallyDraw();
  };

  ArrowWidget.prototype.DialogCloseCallback = function () {
    this.SetActive(false);
    this.Layer.EventuallyDraw();
  };

  // Fill the dialog values from the widget values.
  ArrowWidget.prototype.WidgetPropertiesToDialog = function () {
    this.Dialog.ColorInput.val(SAM.ConvertColorToHex(this.Arrow.FillColor));
    this.Dialog.WidthInput.val((this.Arrow.Width).toFixed(2));
  };

  // Copy the properties of the dialog into the widget
  ArrowWidget.prototype.DialogPropertiesToWidget = function () {
    var modified = false;

    // Get the color
    var hexcolor = SAM.ConvertColorToHex(this.Dialog.ColorInput.val());
    if (hexcolor !== this.Arrow.FillColor) {
      modified = true;
      this.Arrow.SetFillColor(hexcolor);
      this.Arrow.ChooseOutlineColor();
      modified = true;
    }

    var width = parseFloat(this.Dialog.WidthInput.val());
    if (width !== this.Arrow.Width) {
      this.Arrow.Width = width;
      modified = true;
    }

    if (modified) {
      // Save values in local storage as defaults for next time.
      localStorage.ArrowWidgetDefaults = JSON.stringify({
        Color: hexcolor,
        Width: width});
      this.Modified();
      this.Arrow.UpdateBuffers(this.Layer.AnnotationView);
    }
  };

  SAM.ArrowWidget = ArrowWidget;
})();


(function () {
  'use strict';

  function Circle () {
    SAM.Shape.call(this);
    this.Radius = 10; // Radius in pixels
    this.Origin = [10000, 10000]; // Center in world coordinates.
    this.OutlineColor = new Array(3);
    this.OutlineColor.fill(0);
    this.PointBuffer = [];
  }
  Circle.prototype = new SAM.Shape();

    // I know javascript does not have desctuctors.
    // I was thinking of calling this explicilty to hasten freeing of resources.
  Circle.prototype.destructor = function () {
    // Get rid of the buffers?
  };

  Circle.prototype.UpdateBuffers = function (view) {
    this.PointBuffer = [];
    var cellData = [];
    var lineCellData = [];
    var i;
    var theta;
    var numEdges = Math.floor(this.Radius / 2) + 10;
        // NOTE: numEdges logic will not work in world coordinates.
        // Limit numEdges to 180 to mitigate this issue.
    if (numEdges > 50 || !this.FixedSize) {
      numEdges = 50;
    }

    this.Matrix = mat4.create();
    mat4.identity(this.Matrix);

    if (view.gl) {
      if (this.LineWidth === 0) {
        for (i = 0; i <= numEdges; ++i) {
          theta = i * 2 * 3.14159265359 / numEdges;
          this.PointBuffer.push(this.Radius * Math.cos(theta));
          this.PointBuffer.push(this.Radius * Math.sin(theta));
          this.PointBuffer.push(0.0);
        }

        // Now create the triangles
        // It would be nice to have a center point,
        // but this would mess up the outline.
        for (i = 2; i < numEdges; ++i) {
          cellData.push(0);
          cellData.push(i - 1);
          cellData.push(i);
        }

        this.VertexPositionBuffer = view.gl.createBuffer();
        view.gl.bindBuffer(view.gl.ARRAY_BUFFER, this.VertexPositionBuffer);
        view.gl.bufferData(view.gl.ARRAY_BUFFER, new Float32Array(this.PointBuffer), view.gl.STATIC_DRAW);
        this.VertexPositionBuffer.itemSize = 3;
        this.VertexPositionBuffer.numItems = this.PointBuffer.length / 3;

        this.CellBuffer = view.gl.createBuffer();
        view.gl.bindBuffer(view.gl.ELEMENT_ARRAY_BUFFER, this.CellBuffer);
        view.gl.bufferData(view.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cellData), view.gl.STATIC_DRAW);
        this.CellBuffer.itemSize = 1;
        this.CellBuffer.numItems = cellData.length;
      } else {
        // var minRad = this.Radius - (this.LineWidth/2.0);
        // var maxRad = this.Radius + (this.LineWidth/2.0);
        var minRad = this.Radius;
        var maxRad = this.Radius + this.LineWidth;
        for (i = 0; i <= numEdges; ++i) {
          theta = i * 2 * 3.14159265359 / numEdges;
          this.PointBuffer.push(minRad * Math.cos(theta));
          this.PointBuffer.push(minRad * Math.sin(theta));
          this.PointBuffer.push(0.0);
          this.PointBuffer.push(maxRad * Math.cos(theta));
          this.PointBuffer.push(maxRad * Math.sin(theta));
          this.PointBuffer.push(0.0);
        }
        this.VertexPositionBuffer = view.gl.createBuffer();
        view.gl.bindBuffer(view.gl.ARRAY_BUFFER, this.VertexPositionBuffer);
        view.gl.bufferData(view.gl.ARRAY_BUFFER, new Float32Array(this.PointBuffer), view.gl.STATIC_DRAW);
        this.VertexPositionBuffer.itemSize = 3;
        this.VertexPositionBuffer.numItems = this.PointBuffer.length / 3;

        // Now create the fill triangles
        // It would be nice to have a center point,
        // but this would mess up the outline.
        for (i = 2; i < numEdges; ++i) {
          cellData.push(0);
          cellData.push((i - 1) * 2);
          cellData.push(i * 2);
        }
        this.CellBuffer = view.gl.createBuffer();
        view.gl.bindBuffer(view.gl.ELEMENT_ARRAY_BUFFER, this.CellBuffer);
        view.gl.bufferData(view.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cellData), view.gl.STATIC_DRAW);
        this.CellBuffer.itemSize = 1;
        this.CellBuffer.numItems = cellData.length;

        // Now the thick line
        for (i = 0; i < numEdges; ++i) {
          lineCellData.push(0 + i * 2);
          lineCellData.push(1 + i * 2);
          lineCellData.push(2 + i * 2);
          lineCellData.push(1 + i * 2);
          lineCellData.push(3 + i * 2);
          lineCellData.push(2 + i * 2);
        }
        this.LineCellBuffer = view.gl.createBuffer();
        view.gl.bindBuffer(view.gl.ELEMENT_ARRAY_BUFFER, this.LineCellBuffer);
        view.gl.bufferData(view.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(lineCellData), view.gl.STATIC_DRAW);
        this.LineCellBuffer.itemSize = 1;
        this.LineCellBuffer.numItems = lineCellData.length;
      }
    } else {
      for (i = 0; i <= numEdges; ++i) {
        theta = i * 2 * 3.14159265359 / numEdges;
        this.PointBuffer.push(this.Radius * Math.cos(theta));
        this.PointBuffer.push(this.Radius * Math.sin(theta));
        this.PointBuffer.push(0.0);
      }
    }
  };

  SAM.Circle = Circle;
})();


(function () {
  'use strict';

  // ==============================================================================
  // Mouse down defined the center.
  // Drag defines the radius.

  // The circle has just been created and is following the mouse.
  // I can probably merge this state with drag. (mouse up vs down though)
  var NEW_HIDDEN = 0;
  var NEW_DRAG = 1;
  var NEW_DRAG_RADIUS = 2;
  var DRAG = 3; // The whole circle is being dragged.
  var DRAG_RADIUS = 4;
  var DRAG_KEYPOINT = 5;
  var INACTIVE = 6; // Not responding to events at all
  var ACTIVE = 7; // Receive events.  Looking for a hover.
  var HOVER = 8; // Mouse is over the widget.
  var DIALOG = 9; // Properties dialog is up

  var CIRCUMFERENCE = 1;
  var INSIDE = 2;
  var CENTER = 3;

  var DEFAULT_LABEL;

  function CircleWidget (layer) {
    this.Layer = layer;

    // This is to save fields from loaded elements that we ignore.
    // That way we include them when we serialize.
    this.Element = {};

    // Get default properties.
    if (localStorage.CircleWidgetDefaults) {
      this.Defaults = JSON.parse(localStorage.CircleWidgetDefaults);
    } else {
      this.Defaults = {};
    }

    // This method gets called if anything is added, deleted or moved.
    this.ModifiedCallback = undefined;
    // This method gets called if the active state of this widget turns on or off.
    // This is used to turn off the pencil button in the Panel.
    this.StateChangeCallback = undefined;
    // This is used by the annotationPanel to transfer draing mode to a new selected widget.
    this.SelectedCallback = undefined;

    // Keep track of annotation created by students without edit
    // permission.
    this.Type = 'circle';

    this.Tolerance = 3.0;
    if (SAM.MOBILE_DEVICE) {
      this.Tolerance = 15.0;
    }

    this.Visibility = true;
    if (layer === null) {
      return;
    }

    // Lets save the zoom level (sort of).
    // Load will overwrite this for existing annotations.
    // This will allow us to expand annotations into notes.
    this.CreationCamera = layer.GetCamera().Serialize();

    var cam = layer.GetCamera();
    var viewport = layer.GetViewport();
    this.Circle = new SAM.Circle();
    this.Circle.Origin = new Array(2);
    this.Circle.Origin.fill(0);
    this.Circle.OutlineColor = new Array(3);
    this.Circle.SetOutlineColor('#00ff00');
    this.Circle.Radius = 50 * cam.Height / viewport[3];
    this.Circle.LineWidth = 5.0 * cam.Height / viewport[3];

    if (this.Defaults) {
      if (this.Defaults.Color) {
        this.Circle.OutlineColor = SAM.ConvertColor(this.Defaults.Color);
      }
      if (this.Defaults.LineWidth !== undefined) {
        // Only use the default if it is reasonable.
        if (this.Defaults.LineWidth === 0) {
          this.Circle.LineWidth = this.Defaults.LineWidth;
        } else {
          var tmp = this.Circle.LineWidth / this.Defaults.LineWidth;
          if (Math.max(tmp, 1 / tmp) < 10) {
            this.Circle.LineWidth = this.Defaults.LineWidth;
          }
        }
      }
      if (this.Defaults.Radius) {
        // Only use the default if it is reasonable.
        tmp = this.Circle.Radius / this.Defaults.Radius;
        if (Math.max(tmp, 1 / tmp) < 10) {
          this.Circle.Radius = this.Defaults.Radius;
        }
      }
    }

    this.Circle.FixedSize = false;

    // Note: If the user clicks before the mouse is in the
    // canvas, this will behave odd.

    // Cross hairs is to show an active center.
    this.Cross = new SAM.Circle();
    this.Cross.SetFillColor([1, 1, 0]);
    this.Cross.SetOutlineColor([0.0, 0.0, 0.0]);
    this.Cross.Radius = 5;
    this.Cross.LineWidth = 1;
    this.Cross.PositionCoordinateSystem = 1;

    if (DEFAULT_LABEL) {
      var text = new SAM.Text();
      text.BackgroundFlag = false;
      text.String = DEFAULT_LABEL;
      text.Position = this.Circle.Origin;
      this.Circle.Children['label'] = text;
    }

    this.State = INACTIVE;
  }

  CircleWidget.prototype.SetModifiedCallback = function (callback) {
    this.ModifiedCallback = callback;
  };

  CircleWidget.prototype.SetSelectedCallback = function (callback) {
    this.SelectedCallback = callback;
  };

  // I am divorcing selected from active.
  CircleWidget.prototype.IsSelected = function () {
    return this.Circle && this.Circle.Selected;
  };

  // This callback gets called when ever the active state changes,
  // even if caused by an external call. This widget is passed as a argument.
  // This is used to turn off the pencil button in the Panel.
  CircleWidget.prototype.SetStateChangeCallback = function (callback) {
    this.StateChangeCallback = callback;
  };

  // Called when the state changes.
  CircleWidget.prototype.StateChanged = function () {
    if (this.StateChangeCallback) {
      this.StateChangeCallback(this);
    }
  };

  // Sets state to "NEW" (dragging without mouse pressed
  CircleWidget.prototype.SetStateToDrawing = function () {
    this.State = NEW_HIDDEN;
  };

  // Called when the state changes.
  CircleWidget.prototype.Modified = function () {
    this.SaveDefaults();
    if (this.ModifiedCallback) {
      (this.ModifiedCallback)(this);
    }
  };

  // Called when the state changes.
  CircleWidget.prototype.SelectionChanged = function () {
    if (this.SelectedCallback) {
      (this.SelectedCallback)(this);
    }
  };

  // Not used yet, but might be useful.
  CircleWidget.prototype.SetCreationCamera = function (cam) {
    // Lets save the zoom level (sort of).
    // Load will overwrite this for existing annotations.
    // This will allow us to expand annotations into notes.
    this.CreationCamera = cam.Serialize();
  };

  // Selects the widget if the text is fuly contained in the selection rectangle.
  CircleWidget.prototype.ApplySelect = function (selection) {
    if (!this.Circle) {
      return;
    }
    var radius = this.Circle.Radius;
    var cam = this.Layer.GetCamera();
    var p = cam.ConvertPointWorldToViewer(this.Circle.Origin[0], this.Circle.Origin[1]);

    if (selection.ViewerPointInSelection(p[0] - radius, p[1] - radius) &&
        selection.ViewerPointInSelection(p[0] - radius, p[1] + radius) &&
        selection.ViewerPointInSelection(p[0] + radius, p[1] - radius) &&
        selection.ViewerPointInSelection(p[0] + radius, p[1] + radius)) {
      this.Circle.SetSelected(true);

      return true;
    }
    this.Circle.SetSelected(false);
    return false;
  };

  CircleWidget.prototype.DeleteSelected = function () {
    return this.Circle.DeleteSelected();
  };

  CircleWidget.prototype.IsEmpty = function () {
    if (this.State === NEW_HIDDEN || this.State === NEW_DRAG) {
      return true;
    }
    return this.Circle.IsEmpty();
  };

  CircleWidget.prototype.GetActive = function () {
    return this.State !== INACTIVE;
  };

  CircleWidget.prototype.SetActive = function (flag) {
    if (flag === false && this.State === NEW_DRAG) {
      // User is in the middle of dragging a circle)
      this.Cancel();
      return;
    }
    if (flag && this.State === INACTIVE) {
      this.State = HOVER;
      // Probably not right, but the widget probably became active because it was selected,
      // and the mouse is over the circle.
      this.Layer.GetParent().css({'cursor': 'move'});
      this.StateChanged();
    }
    if (!flag && this.State !== INACTIVE) {
      this.State = INACTIVE;
      this.StateChanged();
    }
    // TODO: Fix: Single select must be setting the state to inactive without calling this method.
    // Cursor was not changing back.
    if (!flag) {
      this.Layer.GetParent().css({'cursor': ''});
    }
    this.Layer.EventuallyDraw();
  };

  // I am not sure if this is used.  We have multiple selected states.
  // Default to the whole widget selected.
  CircleWidget.prototype.SetSelected = function (flag) {
    this.Circle.SetSelected(flag);

    if (flag && this.SelectedCallback) {
      (this.SelectedCallback)(this);
    }
    if (!flag) {
      // We can be selected without being active, but we cannot be
      // active without being selected.
      this.SetActive(false);
    }
  };

  CircleWidget.prototype.InitPropertiesDialog = function (layer) {
    var self = this;

    this.Dialog = new SAM.Dialog(this.Layer.GetParent().parent());
    this.Dialog.SetApplyCallback(function () { self.DialogApplyCallback(); });
    // Customize dialog for a circle.
    this.Dialog.Title.text('Circle Properties');
    this.Dialog.Body.css({'margin': '1em 2em', 'height': '14em'});
    // Radius
    this.Dialog.RadiusDiv =
            $('<div>')
            .css({'height': '24px'})
            .appendTo(this.Dialog.Body)
            .addClass('sa-view-annotation-modal-div');
    this.Dialog.RadiusLabel =
            $('<div>')
            .appendTo(this.Dialog.RadiusDiv)
            .text('Radius:')
            .addClass('sa-view-annotation-modal-input-label');
    this.Dialog.RadiusInput =
            $('<input type="number">')
            .appendTo(this.Dialog.RadiusDiv)
            .val(10)
            .addClass('sa-view-annotation-modal-input');

    // Center
    this.Dialog.CenterDiv =
            $('<div>')
            .css({'height': '24px'})
            .appendTo(this.Dialog.Body)
            .addClass('sa-view-annotation-modal-div');
    this.Dialog.CenterLabel =
            $('<div>')
            .appendTo(this.Dialog.CenterDiv)
            .text('Center:')
            .addClass('sa-view-annotation-modal-input-label');
    this.Dialog.CenterXInput =
            $('<input type="number">')
            .appendTo(this.Dialog.CenterDiv)
            .css({'width': '30%'})
            .val(0)
            .addClass('sa-view-annotation-modal-input');
    this.Dialog.CenterYInput =
            $('<input type="number">')
            .appendTo(this.Dialog.CenterDiv)
            .css({'width': '30%'})
            .val(0)
            .addClass('sa-view-annotation-modal-input');

    // Color
    this.Dialog.ColorDiv =
            $('<div>')
            .css({'height': '24px'})
            .appendTo(this.Dialog.Body)
            .addClass('sa-view-annotation-modal-div');
    this.Dialog.ColorLabel =
            $('<div>')
            .appendTo(this.Dialog.ColorDiv)
            .text('Color:')
            .addClass('sa-view-annotation-modal-input-label');
    this.Dialog.ColorInput =
            $('<input type="color">')
            .appendTo(this.Dialog.ColorDiv)
            .val('#30ff00')
            .addClass('sa-view-annotation-modal-input');

    // Line Width
    this.Dialog.LineWidthDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .addClass('sa-view-annotation-modal-div');
    this.Dialog.LineWidthLabel =
            $('<div>')
            .appendTo(this.Dialog.LineWidthDiv)
            .text('Line Width:')
            .addClass('sa-view-annotation-modal-input-label');
    this.Dialog.LineWidthInput =
            $('<input type="number">')
            .appendTo(this.Dialog.LineWidthDiv)
            .addClass('sa-view-annotation-modal-input')
            .keypress(function (event) { return event.keyCode !== 13; });

    // Label
    this.Dialog.LabelDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .addClass('sa-view-annotation-modal-div');
    this.Dialog.LabelLabel =
            $('<div>')
            .appendTo(this.Dialog.LabelDiv)
            .text('Label:')
            .addClass('sa-view-annotation-modal-input-label');
    this.Dialog.LabelInput =
            $('<input type="text">')
            .appendTo(this.Dialog.LabelDiv)
            .addClass('sa-view-annotation-modal-input')
            .keypress(function (event) { return event.keyCode !== 13; });

    // Area
    this.Dialog.AreaDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .addClass('sa-view-annotation-modal-div');
    this.Dialog.AreaLabel =
            $('<div>')
            .appendTo(this.Dialog.AreaDiv)
            .text('Area:')
            .addClass('sa-view-annotation-modal-input-label');
    this.Dialog.Area =
            $('<div>')
            .appendTo(this.Dialog.AreaDiv)
            .addClass('sa-view-annotation-modal-input');
  };

  CircleWidget.prototype.ShowPropertiesDialog = function () {
    if (this.Dialog === undefined) {
      this.InitPropertiesDialog();
    }
    this.WidgetPropertiesToDialog();
    var self = this;
    this.Dialog.SetApplyCallback(function () { self.DialogApplyCallback(); });
    this.Dialog.SetCloseCallback(function () { self.DialogCloseCallback(); });
    this.Dialog.Show(true);
    this.State = DIALOG;
  };

  CircleWidget.prototype.DialogApplyCallback = function (layer) {
    // Transfer properties fromt he dialog GUI to the widget.
    this.DialogPropertiesToWidget();
    // View bindings kept the dialog text input from working.
    if (!this.Layer) {
      return;
    }
    this.SetActive(false);
    this.Layer.EventuallyDraw();
    this.SetActive(false);
  };

  CircleWidget.prototype.DialogCloseCallback = function () {
    this.SetActive(false);
    this.Layer.EventuallyDraw();
    this.SetActive(false);
  };

  // Fill the dialog values from the widget values.
  CircleWidget.prototype.WidgetPropertiesToDialog = function () {
    this.Dialog.RadiusInput.val(Math.round(this.Circle.Radius));
    this.Dialog.CenterXInput.val(Math.round(this.Circle.Origin[0]));
    this.Dialog.CenterYInput.val(Math.round(this.Circle.Origin[1]));
    this.Dialog.ColorInput.val(SAM.ConvertColorToHex(this.Circle.OutlineColor));
    this.Dialog.LineWidthInput.val((this.Circle.LineWidth).toFixed(2));
    var label = '';
    if (this.Circle.Children.label && this.Circle.Children.label.String) {
      label = this.Circle.Children['label'].String;
    }
    this.Dialog.LabelInput.val(label);

    var area = (2.0 * Math.PI * this.Circle.Radius * this.Circle.Radius) * 0.25 * 0.25;
    var areaString = '';
    if (this.Circle.FixedSize) {
      areaString += area.toFixed(2);
      areaString += ' pixels^2';
    } else {
      if (area > 1000000) {
        areaString += (area / 1000000).toFixed(2);
        areaString += ' mm^2';
      } else {
        areaString += area.toFixed(2);
        areaString += ' um^2';
      }
    }
    this.Dialog.Area.text(areaString);
  };

  // I am having the two shapes share an origin/position point array.
  // That way code that just modifies oring will automatically change label.
  CircleWidget.prototype.SetOrigin = function (xy) {
    this.Circle.Origin = xy;
    if ('label' in this.Circle.Children) {
      this.Circle.Children.label.Position = xy;
    }
  };

  // Copy the properties of the dialog into the widget
  CircleWidget.prototype.DialogPropertiesToWidget = function () {
    var modified = false;

    var radius = parseInt(this.Dialog.RadiusInput.val());
    if (radius !== this.Circle.Radius) {
      this.Circle.Radius = radius;
      modified = true;
    }

    var cx = parseInt(this.Dialog.CenterXInput.val());
    var cy = parseInt(this.Dialog.CenterYInput.val());
    if (cx !== this.Circle.Origin[0] || cy !== this.Circle.Origin[1]) {
      this.Circle.Origin[0] = cx;
      this.Circle.Origin[1] = cy;
      modified = true;
    }

    // Get the color
    var hexcolor = SAM.ConvertColorToHex(this.Dialog.ColorInput.val());
    if (hexcolor !== this.Circle.OutlineColor) {
      modified = true;
      this.Circle.SetOutlineColor(hexcolor);
      modified = true;
    }

    var lineWidth = parseFloat(this.Dialog.LineWidthInput.val());
    if (lineWidth !== this.Circle.LineWidth) {
      this.Circle.LineWidth = lineWidth;
      modified = true;
    }

    var label = this.Dialog.LabelInput.val();
    label = label.trim();
    if (label === '') {
      DEFAULT_LABEL = undefined;
      delete this.Circle.Children.label;
    } else {
      if (!this.Circle.Children.label) {
        var text = new SAM.Text();
        text.BackgroundFlag = false;
        text.String = label;
        text.Position = this.Circle.Origin;
        this.Circle.Children['label'] = text;
        DEFAULT_LABEL = label;
      }
      this.Circle.Children.label.String = label;
      modified = true;
    }

    if (modified) {
      this.Modified();
      this.Circle.UpdateBuffers(this.Layer.AnnotationView);
    }
  };

  CircleWidget.prototype.SaveDefaults = function () {
    // Save values in local storage as defaults for next time.
    this.Defaults.Color = this.Circle.GetOutlineColor();
    this.Defaults.LineWidth = this.Circle.LineWidth;
    this.Defaults.Radius = this.Circle.Radius;

    localStorage.CircleWidgetDefaults = JSON.stringify(this.Defaults);
  };

  CircleWidget.prototype.Draw = function () {
    if (this.Visibility && this.State !== NEW_HIDDEN && this.Circle) {
      var view = this.Layer.GetView();
      this.Circle.Draw(view);
      if (this.State === ACTIVE || this.State === HOVER) {
        var origin = this.Circle.Origin;
        var cam = this.Layer.GetCamera();
        var pt = cam.ConvertPointWorldToViewer(origin[0], origin[1]);
        this.Cross.Origin = [pt[0], pt[1]];
        this.Cross.Draw(view);
      }
    }
  };

  CircleWidget.prototype.PasteCallback = function (layer, data, mouseWorldPt) {
    this.Load(data);
    // Place the widget over the mouse.
    // This would be better as an argument.
    this.SetOrigin([mouseWorldPt[0], mouseWorldPt[1]]);
    // TODO: Just have the caller draw.
    layer.EventuallyDraw();
  };

  CircleWidget.prototype.Serialize = function () {
    if (this.Circle === undefined) { return null; }
    var element = this.Element;
    element.type = 'circle';
    element.center = [this.Circle.Origin[0], this.Circle.Origin[1], 0];
    element.lineColor = SAM.ConvertColorToHex(this.Circle.OutlineColor);
    element.radius = this.Circle.Radius;
    element.lineWidth = this.Circle.LineWidth;
    // element.creation_camera = this.CreationCamera;

    if (this.Circle.Children.label && this.Circle.Children.label.String) {
      element.label = {'value': this.Circle.Children.label.String};
    }
    // Serialize the keypoints
    var childKey, child;
    for (childKey in this.Circle.Children) {
      child = this.Circle.Children[childKey];
      if (typeof (child) === 'object' && 'Radius' in child) {
        if (!('user' in element)) {
          element['user'] = {};
        }
        var user = element['user'];
        if (!('keypoints' in user)) {
          user['keypoints'] = [];
        }
        var keypoints = user['keypoints'];
        // This is an inefficient schema.  I have to search an array.
        // This will not add a new keypoint.
        for (var i = 0; i < keypoints.length; ++i) {
          var kp = keypoints[i];
          if (kp.category === childKey) {
            kp.xy = child.Origin;
          }
        }
      }
    }

    return element;
  };

  // Load a widget from a json object (origin MongoDB).
  // Layer is needed to update the bufferes.
  // TODO: delayed upldating bufferes until the first draw
  CircleWidget.prototype.Load = function (element) {
    this.Element = element;
    this.Circle.Origin[0] = Math.round(parseFloat(element.center[0]));
    this.Circle.Origin[1] = Math.round(parseFloat(element.center[1]));
    if (element['lineColor'] !== undefined) {
      this.Circle.OutlineColor = SAM.ConvertColor(element.lineColor);
    } else {
      this.Circle.OutlineColor[0] = 0.0;
      this.Circle.OutlineColor[1] = 1.0;
      this.Circle.OutlineColor[2] = 1.0;
    }
    this.Circle.Radius = Math.round(parseFloat(element.radius));
    this.Circle.LineWidth = 0;
    if (element.lineWidth) {
      this.Circle.LineWidth = parseFloat(element.lineWidth);
    }
    this.Circle.FixedSize = false;
    this.Circle.UpdateBuffers(this.Layer.AnnotationView);

    // How zoomed in was the view when the annotation was created.
    if (element.creation_camera !== undefined) {
      this.CreationCamera = element.CreationCamera;
    }

    if ('label' in element) {
      var str = element['label']['value'];
      var text = new SAM.Text();
      text.BackgroundFlag = false;
      text.String = str;
      text.Position = this.Circle.Origin;
      this.Circle.Children['label'] = text;
    }

    var circle, kp, idx;
    var keypoints;
    if ('user' in element) {
      var user = element['user'];
      if ('keypoints' in user) {
        keypoints = user['keypoints'];
        for (idx = 0; idx < keypoints.length; ++idx) {
          kp = keypoints[idx];
          circle = new SAM.Circle();
          if (kp['category'] === 'nose') {
            circle.SetFillColor([0.0, 1.0, 0]);
          } else if (kp['category'] === 'tail') {
            circle.SetFillColor([1.0, 0.0, 0]);
          } else if (kp['category'] === 'left_wingtip') {
            circle.SetFillColor([1.0, 0.0, 1.0]);
          } else if (kp['category'] === 'right_wingtip') {
            circle.SetFillColor([0.0, 1.0, 1.0]);
          } else {
            circle.SetFillColor([0.8, 0.8, 1]);
          }
          circle.SetOutlineColor([0.0, 0.0, 0.0]);
          circle.Radius = 2;
          circle.LineWidth = 1;
          circle.Origin = kp['xy'];
          this.Circle.Children[kp['category']] = circle;
        }
      } else if ('network_keypoints' in user) {
        keypoints = user['network_keypoints'];
        for (idx = 0; idx < keypoints.length; ++idx) {
          kp = keypoints[idx];
          circle = new SAM.Circle();
          if (kp['keypoint_category'] === 'nose') {
            circle.SetFillColor([0.5, 1.0, 0.5]);
          } else if (kp['keypoint_category'] === 'tail') {
            circle.SetFillColor([1.0, 0.5, 0.5]);
          } else {
            circle.SetFillColor([0.8, 0.8, 1]);
          }
          circle.SetOutlineColor([0.0, 0.0, 0.0]);
          circle.Radius = 2;
          circle.LineWidth = 1;
          circle.Origin = kp['xy'];
          this.Circle.Children[kp['keypoint_category']] = circle;
        }
      }
    }
  };

  CircleWidget.prototype.Cancel = function () {
    if (this.State === NEW_DRAG) {
      this.State = INACTIVE;
      // Circle has not been placed. Delete the circle.
      this.Circle.Selected = true;
      this.Layer.DeleteSelected();
    }
    this.SetActive(false);
  };

  CircleWidget.prototype.SetVisibility = function (vis) {
    this.Visibility = vis;
    this.Layer.EventuallyDraw();
  };

  CircleWidget.prototype.HandleKeyDown = function (layer) {
    if (layer.Event.keyCode === 86) {
      this.Visibility = !this.Visibility;
      layer.EventuallyDraw();
      return true;
    }

    if (this.State === INACTIVE) {
      return true;
    }

    // The dialog consumes all key events.
    if (this.State === DIALOG) {
      return false;
    }

    // Escape key
    if (event.keyCode === 27) {
      this.Cancel();
      return false;
    }

    // Copy
    if (event.keyCode === 67 && event.ctrlKey) {
      // control-c for copy
      // The extra identifier is not needed for widgets, but will be
      // needed if we have some other object on the clipboard.
      var clip = {Type: 'CircleWidget', Data: this.Serialize()};
      localStorage.ClipBoard = JSON.stringify(clip);
      return false;
    }

    return true;
  };

  CircleWidget.prototype.HandleMouseDown = function (layer) {
    if (this.State !== HOVER && this.State !== NEW_DRAG) {
      return true;
    }

    var event = layer.Event;
    if (event.which !== 1) {
      return false;
    }
    var cam = layer.GetCamera();
    if (this.State === NEW_DRAG) {
      // We need the viewer position of the circle center to drag radius.
      this.OriginViewer =
                cam.ConvertPointWorldToViewer(this.Circle.Origin[0],
                                              this.Circle.Origin[1]);
      this.State = NEW_DRAG_RADIUS;
    }
    if (this.State === HOVER) {
      var circlePart = this.MouseOverWhichPart(layer.Event);
      // Determine behavior from active radius.
      if (typeof (circlePart) === 'object') {
        this.State = DRAG_KEYPOINT;
        this.KeyPoint = circlePart;
      } else if (circlePart === CENTER) {
        this.State = DRAG;
      } else if (circlePart === CIRCUMFERENCE) {
        this.OriginViewer =
                    cam.ConvertPointWorldToViewer(this.Circle.Origin[0],
                                                  this.Circle.Origin[1]);
        this.State = DRAG_RADIUS;
      }
    }
    return false;
  };

  // returns false when it is finished doing its work.
  CircleWidget.prototype.HandleMouseUp = function (layer) {
    if (this.State === INACTIVE) {
      return true;
    }

    if (this.State === NEW_DRAG_RADIUS) {
      this.SetActive(false);
      this.Modified();
      this.Layer.EventuallyDraw();
    }

    if (this.State === DRAG || this.State === DRAG_RADIUS ||
        this.State === DRAG_KEYPOINT) {
      this.State = HOVER;
      this.Modified();
      this.Layer.EventuallyDraw();
      this.KeyPoint = undefined;
    }

    var event = layer.Event;
    if (this.State === HOVER && event.which === 3) {
      // Right mouse was pressed.
      // Pop up the properties dialog.
      // Which one should we popup?
      // Add a ShowProperties method to the widget. (With the magic of javascript).
      this.ShowPropertiesDialog();
    }

    return false;
  };

  // returns false when it is finished doing its work.
  CircleWidget.prototype.HandleMouseClick = function () {
    if (this.State === INACTIVE) {
      return true;
    }
    if (this.State === NEW_DRAG || this.State === NEW_DRAG_RADIUS) {
      this.SetActive(false);
      this.Modified();
      // A click to place bring up another circle for automatic / fast annotation.
      var widget = new SAM.CircleWidget(this.Layer);
      this.Layer.AddWidget(widget);
      widget.SetCreationCamera(this.Layer.GetCamera());
      widget.SetStateToDrawing();

      return false;
    }
    return true;
  };

  CircleWidget.prototype.HandleMouseMove = function (layer) {
    if (this.State === INACTIVE) {
      return true;
    }

    var event = layer.Event;
    var x = this.Layer.MouseX;
    var y = this.Layer.MouseY;

    // Hover logic.
    if (this.State === ACTIVE || this.State === HOVER) {
      var circlePart = this.MouseOverWhichPart(layer.Event);
      if (this.Circle.FillColor !== undefined && circlePart === INSIDE) {
        // Mouse if over a child keypoint.
        this.State = HOVER;
        this.Layer.GetParent().css({'cursor': 'move'});
        return false;
      }
      if (this.Circle.FillColor !== undefined && circlePart === INSIDE) {
        this.State = HOVER;
        this.Layer.GetParent().css({'cursor': 'move'});
        return false;
      }
      if (circlePart === CIRCUMFERENCE || circlePart === CENTER) {
        this.State = HOVER;
        this.Layer.GetParent().css({'cursor': 'move'});
        return false;
      }
      if (typeof (circlePart) === 'object' && 'Radius' in circlePart) {
        this.State = HOVER;
        this.Layer.GetParent().css({'cursor': 'move'});
        return false;
      }
      this.State = ACTIVE;
      this.Layer.GetParent().css({'cursor': ''});
      return true;
    }

    // Hack to fix weird state where mouse up is not called.
    if (event.which === 0 &&
        (this.State === NEW_DRAG_RADIUS || this.State === DRAG_RADIUS ||
         this.State === DRAG || this.State === DRAG_KEYPOINT)) {
      return this.HandleMouseUp(layer);
    }

    if (event.which === 0 && this.State === ACTIVE) {
      this.SetActive(this.CheckActive(event));
      return false;
    }

    var cam = layer.GetCamera();
    if (this.State === NEW_HIDDEN) {
      this.State = NEW_DRAG;
    }
    if (this.State === NEW_DRAG || this.State === DRAG) {
      if (SA && SA.notesWidget) { SA.notesWidget.MarkAsModified(); } // hack
      this.SetOrigin(cam.ConvertPointViewerToWorld(x, y));
      layer.EventuallyDraw();
    }

    if (this.State === DRAG_RADIUS || this.State === NEW_DRAG_RADIUS) {
      var viewport = layer.GetViewport();
      cam = layer.GetCamera();
      var dx = x - this.OriginViewer[0];
      var dy = y - this.OriginViewer[1];
      // Change units from pixels to world.
      this.Circle.Radius = Math.sqrt(dx * dx + dy * dy) * cam.Height / viewport[3];
      this.Circle.UpdateBuffers(layer.AnnotationView);
      if (SA && SA.notesWidget) { SA.notesWidget.MarkAsModified(); } // hack
      layer.EventuallyDraw();
    }

    if (this.State === DRAG_KEYPOINT) {
      if (SA && SA.notesWidget) { SA.notesWidget.MarkAsModified(); } // hack
      this.KeyPoint.Origin = cam.ConvertPointViewerToWorld(x, y);
      layer.EventuallyDraw();
    }

    if (this.State === INACTIVE) {
      this.CheckActive(event);
    }
    return false;
  };

  CircleWidget.prototype.HandleTouchPan = function (layer) {
    if (this.State === INACTIVE) {
      return true;
    }

    var event = layer.Event;
    var cam = layer.GetCamera();
    // TODO: Last mouse should net be in layer.
    var w0 = cam.ConvertPointViewerToWorld(layer.LastMouseX,
                                           layer.LastMouseY);
    var w1 = cam.ConvertPointViewerToWorld(event.offsetX, event.offsetY);

    // This is the translation.
    var dx = w1[0] - w0[0];
    var dy = w1[1] - w0[1];

    this.Circle.Origin[0] += dx;
    this.Circle.Origin[1] += dy;
    layer.EventuallyDraw();
    return false;
  };

  CircleWidget.prototype.HandleTouchPinch = function (layer) {
    if (this.State === INACTIVE) {
      return true;
    }

    this.Circle.Radius *= layer.PinchScale;
    this.Circle.UpdateBuffers(layer.AnnotationView);
    if (SA && SA.notesWidget) { SA.notesWidget.MarkAsModified(); } // hack
    layer.EventuallyDraw();
    return false;
  };

  CircleWidget.prototype.HandleTouchEnd = function (layer) {
    if (this.State === INACTIVE) {
      return true;
    }

    this.SetActive(false);
    return false;
  };

  // Returns the selected stroke or undefined.
  CircleWidget.prototype.HandleSelect = function () {
    if (this.State === NEW_HIDDEN || this.State === NEW_DRAG || this.State === DIALOG) {
      return false;
    }

    var circlePart = this.MouseOverWhichPart(this.Layer.Event);

    if (this.Circle.FillColor !== undefined && circlePart === INSIDE) {
      this.Circle.SetSelectede(true);
      return this;
    }
    if (circlePart === CIRCUMFERENCE || circlePart === CENTER) {
      this.Circle.SetSelected(true);
      return this;
    }
    // Handle clicking on the keypoints.
    if (typeof (circlePart) === 'object') {
      this.Circle.SetSelected(true);
      return this;
    }

    this.Circle.SetSelected(false);
    // hack to fix bug where circle remained active when no longer selected.
    this.SetActive(false);
    return false;
  };

  // Returns true or false.  Point is in viewer coordinates.
  CircleWidget.prototype.MouseOverWhichPart = function (event) {
    var pt = [event.offsetX, event.offsetY];
    var c, r, child, childKey, cam;
    var d, dx, dy;

    // Check the children (keypoints).
    for (childKey in this.Circle.Children) {
      child = this.Circle.Children[childKey];
      if (typeof (child) === 'object' && 'Radius' in child) {
        // Assume the child is a circle.
        c = child.Origin;
        r = child.Radius;
        if (!this.FixedSize) {
          cam = this.Layer.GetCamera();
          c = cam.ConvertPointWorldToViewer(c[0], c[1]);
          r = cam.ConvertScaleWorldToViewer(r);
        }
        dx = pt[0] - c[0];
        dy = pt[1] - c[1];
        d = Math.sqrt((dx * dx) + (dy * dy));
        if (Math.abs(d) < r + this.Tolerance) {
          return child;
        }
      }
    }

    c = this.Circle.Origin;
    r = this.Circle.Radius;
    var lineWidth = this.Circle.LineWidth;
    // Do the comparison in view coordinates.
    if (!this.FixedSize) {
      cam = this.Layer.GetCamera();
      c = cam.ConvertPointWorldToViewer(c[0], c[1]);
      r = cam.ConvertScaleWorldToViewer(r);
      lineWidth = cam.ConvertScaleWorldToViewer(lineWidth);
    }

    dx = pt[0] - c[0];
    dy = pt[1] - c[1];
    d = Math.sqrt(dx * dx + dy * dy);

    if (Math.abs(d - r) < this.Tolerance + lineWidth) {
      return CIRCUMFERENCE;
    }
    if (d < (2 * this.Tolerance + lineWidth)) {
      return CENTER;
    }
    if (d < r) {
      return INSIDE;
    }
    return 0;
  };

  SAM.CircleWidget = CircleWidget;
})();

// ==============================================================================
// Experment to manage multiple girder annotations in a single layer.

(function () {
  'use strict';

  function GroupWidget (viewer, newFlag) {
    if (viewer === null) {
      return;
    }
    this.Viewer = viewer;
    this.Viewer.AddWidget(this);
    this.Widgets = [];
    this.Active = false;
  }

  GroupWidget.prototype.Draw = function (view) {
    for (var i = 0; i < this.Widgets.length; ++i) {
      this.Widgets[i].Draw(view);
    }
  };

  GroupWidget.prototype.RemoveFromViewer = function () {
    if (this.Viewer) {
      this.Viewer.RemoveWidget(this);
    }
  };

  GroupWidget.prototype.HandleKeyPress = function (keyCode, shift) {
    for (var i = 0; i < this.Widgets.length; ++i) {
      var child = this.Widgets[i];
      if (child.HandleKeyPress) {
        if (!child.HandleKeyPress(keyCode, shift)) {
          return false;
        }
      }
    }
    return true;
  };

  GroupWidget.prototype.HandleMouseDown = function (event) {
    if (event.which !== 1) {
      return;
    }
    for (var i = 0; i < this.Widgets.length; ++i) {
      var child = this.Widgets[i];
      if (child.HandleMouseDown) {
        if (!child.HandleMouseDown(event)) {
          return false;
        }
      }
    }
    return true;
  };

  // returns false when it is finished doing its work.
  GroupWidget.prototype.HandleMouseUp = function (event) {
    for (var i = 0; i < this.Widgets.length; ++i) {
      var child = this.Widgets[i];
      if (child.HandleMouseDown) {
        child.HandleMouseUp(event);
      }
      return true;
    }
  };

  GroupWidget.prototype.HandleMouseMove = function (event) {
    for (var i = 0; i < this.Widgets.length; ++i) {
      var child = this.Widgets[i];
      if (child.HandleMouseMove) {
        if (!child.HandleMouseMove(event)) {
          return false;
        }
      }
    }
    return true;
  };

  GroupWidget.prototype.CheckActive = function (event) {
    for (var i = 0; i < this.Widgets.length; ++i) {
      var child = this.Widgets[i];
      if (child.CHeckActive) {
        if (child.CheckActive(event)) {
          this.Active = true;
          return true;
        }
      }
      this.Active = false;
      return false;
    }
  };

  // Multiple active states.  Active state is a bit confusing.
  GroupWidget.prototype.GetActive = function () {
    return this.Active;
  };

  // Setting to active always puts state into "active".
  // It can move to other states and stay active.
  GroupWidget.prototype.SetActive = function (flag) {
    alert('GroupWidget.SetActive not handled.');
  };

  SAM.GroupWidget = GroupWidget;
})();

// ==============================================================================
// Display a samller mask image ontop of a large image.
// Mask image will be an additional file in the image item.
// Not sure how to store the image in the annotation schema.

(function () {
  'use strict';

  // The cross has just been created and is following the mouse.
  // I can probably merge  this state with drag. (mouse up vs down though)
  var IMAGE_WIDGET_DRAG = 1; // The cross is being dragged.
  var IMAGE_WIDGET_WAITING = 3; // The normal (resting) state.
  var IMAGE_WIDGET_ACTIVE = 4; // Mouse is over the widget and it is receiving events.

  function ImageWidget (viewer, newFlag) {
    if (viewer === null) {
      return;
    }
    this.Viewer = viewer;
    this.Shape = new SAM.ImageAnnotation();
    this.Viewer.AddWidget(this);
    this.Viewer.AddShape(this.Shape);

    // New flag => widget is created in drag state.
    if (newFlag) {
      this.State = IMAGE_WIDGET_DRAG;
      this.Viewer.ActivateWidget(this);
      return;
    }

    this.State = IMAGE_WIDGET_WAITING;
  }

  ImageWidget.prototype.Draw = function (view) {
    this.Shape.Draw(view);
  };

  ImageWidget.prototype.RemoveFromViewer = function () {
    if (this.Viewer) {
      this.Viewer.RemoveWidget(this);
    }
  };

  ImageWidget.prototype.HandleKeyPress = function (keyCode, shift) {
    return false;
  };

  ImageWidget.prototype.HandleMouseDown = function (event) {
    if (event.which !== 1) {
      return;
    }
    if (this.State === IMAGE_WIDGET_DRAG) {
      // We need the viewer position of the IMAGE center to drag radius.
      this.OriginViewer = this.Viewer.ConvertPointWorldToViewer(this.Shape.Origin[0], this.Shape.Origin[1]);
      this.State = IMAGE_WIDGET_WAITING;
    }
    if (this.State === IMAGE_WIDGET_ACTIVE) {
      this.State = IMAGE_WIDGET_DRAG;
    }
  };

  // returns false when it is finished doing its work.
  ImageWidget.prototype.HandleMouseUp = function (event) {
    if (this.State === IMAGE_WIDGET_ACTIVE && event.which === 3) {
      // Right mouse was pressed.
      // Pop up the properties dialog.
      // this.State = IMAGE_WIDGET_PROPERTIES_DIALOG;
      // this.ShowPropertiesDialog();
    } else if (this.State === IMAGE_WIDGET_DRAG) {
      this.SetActive(false);
    }
  };

  ImageWidget.prototype.HandleMouseMove = function (event) {
    var x = this.Viewer.MouseX;
    var y = this.Viewer.MouseY;

    if (this.Viewer.MouseDown === false && this.State === IMAGE_WIDGET_ACTIVE) {
      this.CheckActive(event);
      return;
    }

    if (this.State === IMAGE_WIDGET_DRAG) {
      var tmp = this.Viewer.ConvertPointViewerToWorld(x, y);
      // Trying to preserve pointer so I do not need to update correlation points.
      this.Shape.Origin[0] = tmp[0];
      this.Shape.Origin[1] = tmp[1];
      this.Viewer.EventuallyRender();
    }

    if (this.State === IMAGE_WIDGET_WAITING) {
      this.CheckActive(event);
    }
  };

  ImageWidget.prototype.CheckActive = function (event) {
    // change dx and dy to vector from center of IMAGE.
    if (this.FixedSize) {
      alert('Fixed size not implemented');
      return;
    }

    var dx = event.worldX - this.Shape.Origin[0];
    var dy = event.worldY - this.Shape.Origin[1];

    // We need to scale to pixels
    var cam = this.Viewer.GetCamera();
    var viewport = this.Viewer.GetViewport();
    var k = viewport[3] / cam.Height;
    dx = dx * k;
    dy = dy * k;

    var d = Math.sqrt(dx * dx + dy * dy);
    var active = false;
    if (d < 3.0) {
      active = true;
    }

    this.SetActive(active);
    return active;
  };

  // Multiple active states.  Active state is a bit confusing.
  ImageWidget.prototype.GetActive = function () {
    if (this.State === IMAGE_WIDGET_WAITING) {
      return false;
    }
    return true;
  };

  // Setting to active always puts state into "active".
  // It can move to other states and stay active.
  ImageWidget.prototype.SetActive = function (flag) {
    if (flag === this.GetActive()) {
      return;
    }

    if (flag) {
      this.State = IMAGE_WIDGET_ACTIVE;
      this.Shape.Active = true;
      this.Viewer.ActivateWidget(this);
      this.Viewer.EventuallyRender();
    } else {
      this.State = IMAGE_WIDGET_WAITING;
      this.Shape.Active = false;
      this.Viewer.DeactivateWidget(this);
      this.Viewer.EventuallyRender();
    }
  };

  SAM.ImageWidget = ImageWidget;
})();

// Draw an image as an annotation object.  This simple drawing object
// is like a shape, but I am not subclassing shape because shape
// is about drawing vector graphics.

// We only support rendering in slide coordinate system for now.

(function () {
  'use strict';

  function ImageAnnotation () {
    this.Visibility = true;

        // Slide position of the upper left image corner.
    this.Origin = [0, 0];
    this.Image = undefined;

    this.Height = 5000;
  }

  ImageAnnotation.prototype.destructor = function () {
        // Get rid of the image.
  };

    // View (main view).
  ImageAnnotation.prototype.Draw = function (view) {
    if (!this.Visibility || !this.Image) {
      return;
    }

    var context = view.Context2d;
    context.save();
        // Identity (screen coordinates).
    context.setTransform(1, 0, 0, 1, 0, 0);
        // Change canvas coordinates to View (-1->1, -1->1).
    context.transform(0.5 * view.Viewport[2], 0.0,
                          0.0, -0.5 * view.Viewport[3],
                          0.5 * view.Viewport[2],
                          0.5 * view.Viewport[3]);

        // Change canvas coordinates to slide (world). (camera: slide to view).
    var m = view.Camera.GetWorldMatrix();
    var h = 1.0 / m[15];
    context.transform(m[0] * h, m[1] * h,
                      m[4] * h, m[5] * h,
                      m[12] * h, m[13] * h);

        // Change canvas to image coordinate system.
    var scale = this.Height / this.Image.height;
    context.transform(scale, 0,
                          0, scale,
                          this.Origin[0], this.Origin[1]);

    // context.drawImage(this.Image, 0, 0);
    context.fillRect(100, 100, 500, 300);

    context.restore();
  };

  SAM.ImageAnnotation = ImageAnnotation;
})();

// Since there is already a rectangle widget (for axis aligned rectangle)
// renaming this as Rect, other possible name is OrientedRectangle

(function () {
  'use strict';

  // Bits for WhichDrag (not the best way to encode this state).
  var DRAG_X0 = 1;
  var DRAG_X1 = 2;
  var DRAG_Y0 = 4;
  var DRAG_Y1 = 8;
  var SYMMETRIC = 16; // Lock the position of the center
  // var ASPECT = 32;    // Lock the aspect ratio
  // These two are only used alone.  However, they are drag features.
  var CENTER = 64;
  var ROTATE = 128;

  var NEW = 0;         // Newly created and waiting to be placed.
  var INACTIVE = 1;    // Not resposnsive tp mouse events
  var ACTIVE = 2;      // Mouse is receiving move events, but mouse is not over.
  var HOVER = 3;       // Mouse is over the widget and it is receiving events.
  var DRAG = 4;        // Mouse is down and dragging part of widget. Modified by WhichDrag.
  var DIALOG = 5;      // Properties dialog is up

  // enum for part identification.
  var CORNER = 0;
  var EDGE = 1;

  // Remember the last size to use for the next.
  var DEFAULT_WIDTH = -1;
  var DEFAULT_HEIGHT = -1;

  var DEFAULT_LABEL;

  function Rect () {
    SAM.Shape.call(this);

    this.Width = 50;
    this.Height = 50;
    this.Orientation = 0; // Angle with respect to x axis ?
    this.Origin = new Array(2); // Center in world coordinates.
    this.Origin.fill(10000);
    this.OutlineColor = new Array(3);
    this.OutlineColor.fill(0);
    this.PointBuffer = [];
  }

  Rect.prototype = new SAM.Shape();

  Rect.prototype.destructor = function () {
    // Get rid of the buffers?
  };

  // Rect.prototype.Draw = function(view) {
  //   if (this.Image) {
  //     view.Context2d.drawImage(this.Image, 0,0);
  //   }
  //   SAM.Shape.prototype.Draw.call(this, view);
  // }

  Rect.prototype.UpdateBuffers = function (view) {
    this.PointBuffer = [];

    this.Matrix = mat4.create();
    mat4.identity(this.Matrix);
    mat4.rotateZ(this.Matrix, this.Orientation / 180.0 * 3.14159);

    this.PointBuffer.push(1 * this.Width / 2.0);
    this.PointBuffer.push(1 * this.Height / 2.0);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(-1 * this.Width / 2.0);
    this.PointBuffer.push(1 * this.Height / 2.0);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(-1 * this.Width / 2.0);
    this.PointBuffer.push(-1 * this.Height / 2.0);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(1 * this.Width / 2.0);
    this.PointBuffer.push(-1 * this.Height / 2.0);
    this.PointBuffer.push(0.0);

    this.PointBuffer.push(1 * this.Width / 2.0);
    this.PointBuffer.push(1 * this.Height / 2.0);
    this.PointBuffer.push(0.0);
  };

  function RectWidget (layer) {
    if (layer === null) {
      return null;
    }
    this.Layer = layer;
    this.Type = 'rect';
    this.Visibility = true;
    // Keep track of annotation created by students without edit
    // permission.
    this.UserNoteFlag = !SA.Edit;

    // This method gets called if the active state of this widget turns on or off.
    // This is used to turn off the pencil button in the Panel.
    this.StateChangeCallback = undefined;
    // This is used by the annotationPanel to transfer draing mode to a new selected widget.
    this.SelectedCallback = undefined;

    this.Tolerance = 0.05;
    if (SAM.detectMobile()) {
      this.Tolerance = 0.1;
    }

    var cam = this.Layer.GetCamera();
    var viewport = this.Layer.GetViewport();
    this.Shape = new Rect();
    // TODO: Correct the mix or orientation and rotation.
    this.Shape.Orientation = cam.GetImageRotation();
    this.Shape.Origin.fill(0);
    this.Shape.SetOutlineColor([0.0, 0.0, 0.0]);
    if (DEFAULT_WIDTH > 0) {
      this.Shape.Height = DEFAULT_HEIGHT;
      this.Shape.Width = DEFAULT_WIDTH;
    } else {
      this.Shape.Height = 50.0 * cam.Height / viewport[3];
      this.Shape.Width = 50.0 * cam.Height / viewport[3];
    }
    this.Shape.LineWidth = 0;
    this.Shape.FixedSize = false;

    // This is a handle for translation.
    this.CenterCircle = new SAM.Circle();
    this.CenterCircle.SetFillColor([1, 1, 0]);
    this.CenterCircle.SetOutlineColor([0.0, 0.0, 0.0]);
    this.CenterCircle.Radius = 5;
    this.CenterCircle.LineWidth = 1;
    this.CenterCircle.PositionCoordinateSystem = 1;

    this.Rotatable = true;

    // Circle is a handle for rotation.
    this.RotateCircle = new SAM.Circle();
    this.RotateCircle.SetFillColor([1, 1, 0]);
    this.RotateCircle.SetOutlineColor([0.0, 0.0, 0.0]);
    this.RotateCircle.Radius = 5;
    this.RotateCircle.LineWidth = 1;
    this.RotateCircle.PositionCoordinateSystem = 1;

    // Get default properties.
    if (localStorage.RectWidgetDefaults) {
      var defaults = JSON.parse(localStorage.RectWidgetDefaults);
      if (defaults.Color) {
        this.Shape.SetOutlineColor(defaults.Color);
      }
    }

    if (DEFAULT_LABEL) {
      var text = new SAM.Text();
      text.BackgroundFlag = false;
      text.String = DEFAULT_LABEL;
      text.Position = this.Circle.Origin;
      this.Circle.Children['label'] = text;
    }

    // Note: If the user clicks before the mouse is in the
    // canvas, this will behave odd.

    this.Layer.GetParent().css({'cursor': 'default'});
    this.State = INACTIVE;
    this.WhichDrag = 0;      // Bits
  }

  RectWidget.prototype.SetOrigin = function (x, y) {
    this.Shape.Origin[0] = x;
    this.Shape.Origin[1] = y;
    if (this.Shape.Children.Label) {
      this.Shape.Children.Label = this.Shape.Origin;
    }
  };

  // Not used yet, but might be useful.
  RectWidget.prototype.SetCreationCamera = function (cam) {
    // Lets save the zoom level (sort of).
    // Load will overwrite this for existing annotations.
    // This will allow us to expand annotations into notes.
    this.CreationCamera = cam.Serialize();
  };

  RectWidget.prototype.SetModifiedCallback = function (callback) {
    this.ModifiedCallback = callback;
  };

  // Called when the widget is modified.
  RectWidget.prototype.Modified = function () {
    if (this.ModifiedCallback) {
      this.ModifiedCallback(this);
    }
  };

  RectWidget.prototype.SetSelectedCallback = function (callback) {
    this.SelectedCallback = callback;
  };

  // This callback gets called when ever the active state changes,
  // even if caused by an external call. This widget is passed as a argument.
  // This is used to turn off the pencil button in the Panel.
  RectWidget.prototype.SetStateChangeCallback = function (callback) {
    this.StateChangeCallback = callback;
  };

  // Called when the state changes.
  RectWidget.prototype.StateChanged = function () {
    if (this.StateChangeCallback) {
      this.StateChangeCallback(this);
    }
  };

  // Bad name "drawing".  New widget dragging.
  RectWidget.prototype.SetStateToDrawing = function () {
    this.State = NEW;
    this.Shape.Visibility = false;
    // Do not render mouse "cursor" unti it moves and we know its location.
    this.Visibility = false;
    this.Layer.GetParent().css({'cursor': 'move'});
  };

  // Returns true if selected
  // This is sort of ugly.  Change it to delete directly if possible.
  // Return value will let the layer clean up.
  RectWidget.prototype.DeleteSelected = function () {
    return this.Shape.DeleteSelected();
  };

  RectWidget.prototype.IsEmpty = function () {
    if (this.State === NEW) {
      return true;
    }
    return this.Shape.IsEmpty();
  };

  // I am divorcing selected from active.
  RectWidget.prototype.IsSelected = function () {
    return this.Shape.Selected;
  };

  RectWidget.prototype.SetSelected = function (flag) {
    this.Shape.SetSelected(flag);
    if (flag && this.SelectedCallback) {
      (this.SelectedCallback)(this);
    }
    if (!flag) {
      // We can be selected without being active, but we cannot be
      // active without being selected.
      this.SetActive(false);
    }
  };

  // Selects the widget if the shape is fuly contained in the selection rectangle.
  RectWidget.prototype.ApplySelect = function (selection) {
    var pts = this.GetCornerPoints();
    var bds = [pts[0][0], pts[0][0], pts[0][1], pts[0][1]];
    for (var i = 1; i < 4; ++i) {
      bds[0] = Math.min(bds[0], pts[i][0]);
      bds[1] = Math.max(bds[1], pts[i][0]);
      bds[2] = Math.min(bds[2], pts[i][1]);
      bds[3] = Math.max(bds[3], pts[i][1]);
    }
    if (selection.ViewerPointInSelection(bds[0], bds[2]) &&
        selection.ViewerPointInSelection(bds[0], bds[3]) &&
        selection.ViewerPointInSelection(bds[1], bds[2]) &&
        selection.ViewerPointInSelection(bds[1], bds[3])) {
      this.SetSelected(true);
      return true;
    }
    this.SetSelected(false);
    return false;
  };

  // Tolerance in screen pixels
  RectWidget.prototype.GetTolerance = function () {
    var width = this.Shape.GetLineWidth();
    // Tolerance: 5 screen pixels.
    var minWidth = 20.0 / this.Layer.GetPixelsPerUnit();
    if (width < minWidth) { width = minWidth; }
    return width;
  };

  // Returns true if the mouse is over the rectangle.
  RectWidget.prototype.HandleSelect = function () {
    if (this.State === DIALOG) {
      return;
    }
    // Check to see if a stroke was clicked.
    // var x = this.Layer.MouseX;
    // var y = this.Layer.MouseY;
    var z = this.Layer.ZTime;
    if (this.Shape.Origin.length > 2 && this.Shape.Origin[2] !== z) {
      return false;
    }

    // var pt = this.Layer.GetCamera().ConvertPointViewerToWorld(x, y);

    var part = this.PointOnWhichPart();
    if (part !== undefined) {
      this.SetSelected(true);
      return true;
    } else {
      this.SetSelected(false);
    }

    return false;
  };

  // Threshold above is the only option for now.
  RectWidget.prototype.SetThreshold = function (threshold) {
    if (this.confidence !== undefined) {
      this.Visibility = this.confidence >= threshold;
    }
  };

  RectWidget.prototype.Draw = function () {
    if (this.Visibility === false) {
      return;
    }
    var view = this.Layer.GetView();
    if (this.Layer.ZTime !== undefined && this.Shape.Origin.length > 2) {
      if (this.Layer.ZTime !== this.Shape.Origin[2]) {
        return;
      }
    }
    this.Shape.Draw(view);
    if (this.State !== INACTIVE && this.State !== NEW && this.State !== DRAG) {
      var pts = this.GetCornerPoints();
      this.CenterCircle.Origin = pts[4];
      this.CenterCircle.Draw(view);
      // var cam = this.Layer.GetCamera();
      if (this.Rotatable) {
        this.RotateCircle.Origin = pts[0];
        this.RotateCircle.Draw(view);
      }
    }
  };

  RectWidget.prototype.PasteCallback = function (data, layer, mouseWorldPt) {
    this.Load(data);
    // Place the widget over the mouse.
    // This would be better as an argument.
    this.SetOrigin(mouseWorldPt[0], mouseWorldPt[1]);
    layer.EventuallyDraw();
    this.Modified();
  };

  RectWidget.prototype.Serialize = function () {
    if (this.Shape === undefined) { return null; }
    var obj = {
      'type': 'rectangle',
      'center': this.Shape.Origin,
      'width': this.Shape.Width,
      'height': this.Shape.Height,
      'rotation': this.Shape.GetOrientation(),
      // caller might handle this already.
      'lineWidth': this.Shape.LineWidth,
      'lineColor': SAM.ConvertColorToHex(this.Shape.OutlineColor)
    };
    if (obj.center.length === 2) {
      obj.center.push(0);
    }

    if (this.Shape.Children.label && this.Shape.Children.label.String) {
      obj.label = {'value': this.Shape.Children.label.String};
    }
    if ('UserImageUrl' in this.Shape) {
      obj.user = {'imageUrl': this.Shape.UserImageUrl};
    }

    return obj;
  };

  // Load a widget from a json object (origin MongoDB).
  RectWidget.prototype.Load = function (obj) {
    this.UserNoteFlag = obj.user_note_flag;
    this.SetOrigin(parseFloat(obj.center[0]),
                   parseFloat(obj.center[1]));
    if (obj.center.length > 2) {
      this.Shape.Origin[2] = parseFloat(obj.center[2]);
    }

    if (obj.lineColor) {
      this.Shape.OutlineColor = SAM.ConvertColor(obj.lineColor);
    }
    this.Shape.Width = parseFloat(obj.width);
    if (obj.confidence) {
      this.confidence = parseFloat(obj.confidence);
    }
    if (obj.height) {
      this.Shape.Height = parseFloat(obj.height);
    }
    if (obj.rotation) {
      this.Shape.Orientation = parseFloat(obj.rotation);
    }
    if (obj.lineWidth !== undefined) {
      this.Shape.LineWidth = parseFloat(obj.lineWidth);
    }
    this.Shape.FixedSize = false;
    this.Shape.UpdateBuffers(this.Layer.AnnotationView);

    // How zoomed in was the view when the annotation was created.
    if (obj.creation_camera !== undefined) {
      this.CreationCamera = obj.CreationCamera;
    }

    if ('label' in obj) {
      var str = obj['label']['value'];
      // I universally inserted label "test" before the label was rendered.
      if (str !== 'test') {
        var text = new SAM.Text();
        text.BackgroundFlag = false;
        text.String = str;
        text.Position = this.Shape.Origin;
        this.Shape.Children['label'] = text;
      }
    }

    if ('user' in obj) {
      var user = obj.user;
      if ('imageUrl' in user) {
        this.Shape.UserImageUrl = user.imageUrl;
        this.Shape.Image = new Image();
        var self = this;
        $(self.Shape.Image).one('load', function () {
          var width = self.Shape.Image.width;
          var height = self.Shape.Image.height;
          var hiddenCanvas = $('<canvas width=' + width + '  height=' + height + '>');
          var ctx = hiddenCanvas[0].getContext('2d');
          ctx.drawImage(self.Shape.Image, 0, 0);
          ctx.beginPath();
          ctx.lineWidth = '100';
          ctx.strokeStyle = 'blue';
          ctx.arc(500, 500, 300, 0, 2 * Math.PI);
          ctx.stroke();
          ctx.clearRect(200, 200, 300, 300);
          self.Shape.Image.src = hiddenCanvas[0].toDataURL();
        });

        this.Shape.Image.src = user.imageUrl;
        // On loaded, render?
      }
    }
  };

  RectWidget.prototype.SetVisibility = function (vis) {
    this.Visibility = vis;
    this.Layer.EventuallyDraw();
  };

  RectWidget.prototype.HandleKeyDown = function (layer) {
    if (layer.Event.keyCode === 86) {
      this.Visibility = !this.Visibility;
      layer.EventuallyDraw();
      return true;
    }

    if (!this.Visibility || this.State === INACTIVE) {
      return true;
    }

    // The dialog consumes all key events.
    if (this.State === DIALOG) {
      return false;
    }

    var event = layer.Event;
    if (this.State === NEW) {
      // escape key (or space or enter) to turn off drawing
      if (event.keyCode === 27 || event.keyCode === 32 || event.keyCode === 13) {
        this.Modified();
        this.Deactivate();
                // this widget was temporary, All rects created have been copied.
        this.Layer.RemoveWidget(this);
        return false;
      }
    }

    // Copy
    if (event.keyCode === 67 && event.ctrlKey) {
      // control-c for copy
      // The extra identifier is not needed for widgets, but will be
      // needed if we have some other object on the clipboard.
      var clip = {Type: 'RectWidget', Data: this.Serialize()};
      localStorage.ClipBoard = JSON.stringify(clip);
      return false;
    }

    return true;
  };

  RectWidget.prototype.HandleMouseDown = function (layer) {
    if (!this.Visibility || this.State === INACTIVE) {
      return true;
    }
    if (this.State === NEW) {
      this.WhichDrag = DRAG_X0 + DRAG_Y0 + SYMMETRIC;
    }
    if (this.State === HOVER) {
      // var part = this.PointOnWhichPart();
      this.State = DRAG;
      this.LastMouse = layer.GetMouseWorld();
      // Which drag is already set by mouse move.
    }

    return false;
  };

  RectWidget.prototype.HandleMouseMove = function (layer) {
    if (this.State === INACTIVE) {
      return true;
    }
    var event = layer.Event;

    // Dragging is complicated enough that we have to compute reactangle
    // from the mouse movement vector (and not contraints).
    var worldPt0 = this.LastMouseWorld;
    var worldPt1 = this.Layer.GetMouseWorld();
    if (worldPt0 === undefined) {
      worldPt0 = worldPt1;
    }
    this.LastMouseWorld = worldPt1;
    var dx = worldPt1[0] - worldPt0[0];
    var dy = worldPt1[1] - worldPt0[1];
    var x = worldPt1[0] - this.Shape.Origin[0];
    var y = worldPt1[1] - this.Shape.Origin[1];

    // Mouse moving with no button pressed:
    if (event.which === 0) {
      // This keeps the rectangle from being drawn in the wrong place
      // before we get our first event.
      if (this.State === NEW) {
        this.Shape.Visibility = true;
        this.WhichDrag = CENTER;
        // THis is ignored until the mouse is pressed.
        this.Visibility = true;
        // Center follows mouse.
        this.SetOrigin(worldPt1[0], worldPt1[1]);
        this.Layer.EventuallyDraw();
        return false;
      }
      if (this.State === ACTIVE || this.State === HOVER) {
        var part = this.PointOnWhichPart();
        if (part === undefined) {
          this.State = ACTIVE;
          this.Layer.GetParent().css({'cursor': ''});
          return false;
        }
        this.State = HOVER;
        if (part[0] === CORNER) {
          switch (part[1]) {
            case 0:
              if (this.Rotatable) {
                this.Layer.GetParent().css({'cursor': 'pointer'});
                this.WhichDrag = ROTATE;
              } else {
                this.Layer.GetParent().css({'cursor': 'nw-resize'});
                this.WhichDrag = DRAG_X0 + DRAG_Y0;
              }
              break;
            case 1:
              this.Layer.GetParent().css({'cursor': 'ne-resize'});
              this.WhichDrag = DRAG_X1 + DRAG_Y0;
              break;
            case 2:
              this.Layer.GetParent().css({'cursor': 'se-resize'});
              this.WhichDrag = DRAG_X1 + DRAG_Y1;
              break;
            case 3:
              this.Layer.GetParent().css({'cursor': 'sw-resize'});
              this.WhichDrag = DRAG_X0 + DRAG_Y1;
              break;
            case 4:
              this.Layer.GetParent().css({'cursor': 'move'});
              this.WhichDrag = CENTER;
          }
        }
        if (part[0] === EDGE) {
          switch (part[1]) {
            case 0:
              this.Layer.GetParent().css({'cursor': 'ns-resize'});
              this.WhichDrag = DRAG_Y0;
              break;
            case 1:
              this.Layer.GetParent().css({'cursor': 'ew-resize'});
              this.WhichDrag = DRAG_X1;
              break;
            case 2:
              this.Layer.GetParent().css({'cursor': 'ns-resize'});
              this.WhichDrag = DRAG_Y1;
              break;
            case 3:
              this.Layer.GetParent().css({'cursor': 'ew-resize'});
              this.WhichDrag = DRAG_X0;
              break;
          }
        }
        return false;
      }
    }

    if (event.which !== 1) { return false; }

    // For transforming between world and box coordinate systems.
    var rotation = this.Shape.GetRotation();
    var c = Math.cos(rotation);
    var s = Math.sin(rotation);
    if (this.State === NEW || this.State === DRAG) {
      if (this.WhichDrag & CENTER) {
        // Special case with no modifiers.  Just translate the whole rectangle.
        this.SetOrigin(worldPt1[0], worldPt1[1]);
        this.Layer.EventuallyDraw();
        this.Modified();
        return false;
      }
      if (this.WhichDrag & ROTATE) {
        // Special case with no modifiers.  Just translate the whole rectangle.
        // Compute two vectors, then rotate to align them.
        var v0 = [-this.Shape.Width, -this.Shape.Height];
        var mag = Math.sqrt(v0[0] * v0[0] + v0[1] * v0[1]);
        v0[0] = v0[0] / mag;
        v0[1] = v0[1] / mag;
        var v1 = [x, y];
        mag = Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1]);
        v1[0] = v1[0] / mag;
        v1[1] = v1[1] / mag;
        c = v0[0] * v1[0] + v0[1] * v1[1];
        s = v0[0] * v1[1] - v0[1] * v1[0];
        this.Shape.Orientation = -Math.atan2(s, c) * 180 / Math.PI;
        this.Layer.EventuallyDraw();
        this.Modified();
        return false;
      }
      if (this.WhichDrag & SYMMETRIC) {
        var rx = c * x - s * y;
        var ry = s * x + c * y;
        if (this.WhichDrag & (DRAG_X1 + DRAG_X0)) {
          this.Shape.Width = 2 * rx;
        }
        if (this.WhichDrag & (DRAG_Y1 + DRAG_Y0)) {
          this.Shape.Height = 2 * ry;
        }
      } else {
        // Draging when not symmetric is a pain.
        // ------ This is not finihsed. -----------
        // Rotate mouse vector to be in rectangles coordinate system.
        // Position of the mouse in box coordinates.
        // Constrain the mouse vector based on axes being modified.
        // Transform the detla mouse to rectangle coordinate system.
        var rdx = (c * dx) - (s * dy);
        var rdy = (s * dx) + (c * dy);
        if (this.WhichDrag & DRAG_X1) {
          this.Shape.Width += rdx;
        } else if (this.WhichDrag & DRAG_X0) {
          this.Shape.Width -= rdx;
        } else {
          // This axis is not being maodified.  Ignore it.
          rdx = 0;
        }
        if (this.WhichDrag & DRAG_Y1) {
          this.Shape.Height += rdy;
        } else if (this.WhichDrag & DRAG_Y0) {
          this.Shape.Height -= rdy;
        } else {
          // This axis is not being maodified.  Ignore it.
          rdy = 0;
        }
        // Rotate the constrained mouse back to world coordinate system.
        dx = (c * rdx) + (s * rdy);
        dy = (-s * rdx) + (c * rdy);
        // Center is moving half as fast as the mouse.
        this.SetOrigin(this.Shape.Origin[0] + dx / 2.0,
                       this.Shape.Origin[1] + dy / 2.0);
      }
    }

    DEFAULT_WIDTH = this.Shape.Width;
    DEFAULT_HEIGHT = this.Shape.Height;
    this.Modified();
    this.Shape.UpdateBuffers();
    this.Layer.EventuallyDraw();
    return false;
  };

  // returns false when it is finished doing its work.
  RectWidget.prototype.HandleMouseUp = function () {
    if (!this.Visibility || this.State === INACTIVE) {
      return true;
    }
    if (this.State === NEW) {
      this.SetActive(false);
    }
    if (this.State === DRAG) {
      this.State = HOVER;
    }
    // Interaction can make these negative.
    this.Shape.Width = Math.abs(this.Shape.Width);
    this.Shape.Height = Math.abs(this.Shape.Height);
    this.Layer.EventuallyDraw();

    return false;
  };

  // returns false when it is finished doing its work.
  RectWidget.prototype.HandleMouseClick = function () {
    if (!this.Visibility || this.State === INACTIVE) {
      return true;
    }
    if (this.State === NEW) {
      this.SetActive(false);
      this.Modified();
      return false;
    }
    return true;
  };

  // Multiple active states. Active state is a bit confusing.
  RectWidget.prototype.GetActive = function () {
    if (this.State === INACTIVE) {
      return false;
    }
    return true;
  };

  RectWidget.prototype.SetActive = function (flag) {
    if (flag === this.GetActive()) {
      return;
    }

    if (flag) {
      this.State = ACTIVE;
    } else {
      this.State = INACTIVE;
    }
    this.StateChanged();
    this.Layer.EventuallyDraw();
  };

  // Can we bind the dialog apply callback to an objects method?
  RectWidget.prototype.ShowPropertiesDialog = function () {
    if (this.Dialog === undefined) {
      this.InitPropertiesDialog();
    }
    this.WidgetPropertiesToDialog();
    var self = this;
    this.Dialog.SetApplyCallback(function () { self.DialogApplyCallback(); });
    this.Dialog.SetCloseCallback(function () { self.DialogCloseCallback(); });
    this.Dialog.Show(true);
    this.State = DIALOG;
  };

  RectWidget.prototype.DialogApplyCallback = function () {
    this.DialogPropertiesToWidget();
    this.SetActive(false, this.Layer);
    this.Layer.EventuallyDraw();
  };

  RectWidget.prototype.DialogCloseCallback = function () {
    this.SetActive(false);
    this.Layer.EventuallyDraw();
  };

  // Fill the dialog values from the widget values.
  RectWidget.prototype.WidgetPropertiesToDialog = function () {
    this.Dialog.ColorInput.val(SAM.ConvertColorToHex(this.Shape.OutlineColor));
    this.Dialog.LineWidthInput.val((this.Shape.LineWidth).toFixed(2));

    var label = '';
    if (this.Shape.Children.label && this.Shape.Children.label.String) {
      label = this.Shape.Children['label'].String;
    }
    this.Dialog.LabelInput.val(label);

    var area = this.Shape.Width * this.Shape.Height;
    var areaString = '';
    if (this.Shape.FixedSize) {
      areaString += area.toFixed(2);
      areaString += ' pixels^2';
    } else {
      if (area > 1000000) {
        areaString += (area / 1000000).toFixed(2);
        areaString += ' mm^2';
      } else {
        areaString += area.toFixed(2);
        areaString += ' um^2';
      }
    }
    this.Dialog.Area.text(areaString);
  };

  // Copy the properties of the dialog into the widget
  RectWidget.prototype.DialogPropertiesToWidget = function () {
    var modified = true;

    var hexcolor = this.Dialog.ColorInput.val();
    this.Shape.SetOutlineColor(hexcolor);
    this.Shape.LineWidth = parseFloat(this.Dialog.LineWidthInput.val());
    this.Shape.UpdateBuffers(this.Layer.AnnotationView);

    var label = this.Dialog.LabelInput.val();
    label = label.trim();
    if (label === '') {
      DEFAULT_LABEL = undefined;
      delete this.Shape.Children.label;
    } else {
      if (!this.Shape.Children.label) {
        var text = new SAM.Text();
        text.BackgroundFlag = false;
        text.String = label;
        text.Position = this.Shape.Origin;
        this.Shape.Children['label'] = text;
        DEFAULT_LABEL = label;
      }
      this.Shape.Children.label.String = label;
      modified = true;
    }

    if (modified) {
      // Save values in local storage as defaults for next time.
      localStorage.RectWidgetDefaults = JSON.stringify({
        Color: hexcolor,
        Width: this.Shape.LineWidth});
      this.Modified();
      this.Shape.UpdateBuffers(this.Layer.AnnotationView);
    }
  };

  // Get Corner points in the viewer coordinate system.
  // [ uperLeft, upperRight, lowerRight, lowerRight]
  RectWidget.prototype.GetCornerPoints = function () {
    var cam = this.Layer.GetCamera();
    var theta = this.Shape.GetRotation();
    var c = Math.cos(theta);
    var s = Math.sin(theta);
    var origin = this.Shape.Origin;
    var rw = this.Shape.Width / 2.0;
    var rh = this.Shape.Height / 2.0;

    var x, y;
    x = c * rw + s * rh;
    y = -s * rw + c * rh;
    var pt0 = [origin[0] - x, origin[1] - y];
    pt0 = cam.ConvertPointWorldToViewer(pt0[0], pt0[1]);
    var pt2 = [origin[0] + x, origin[1] + y];
    pt2 = cam.ConvertPointWorldToViewer(pt2[0], pt2[1]);

    rw = -rw;
    x = c * rw + s * rh;
    y = -s * rw + c * rh;
    var pt1 = [origin[0] - x, origin[1] - y];
    pt1 = cam.ConvertPointWorldToViewer(pt1[0], pt1[1]);
    var pt3 = [origin[0] + x, origin[1] + y];
    pt3 = cam.ConvertPointWorldToViewer(pt3[0], pt3[1]);

    var pt4 = [
      (pt0[0] + pt2[0]) * 0.5,
      (pt0[1] + pt2[1]) * 0.5];

    return [pt0, pt1, pt2, pt3, pt4];
  };

  // Points are order upperLeft, uuperRight, lowerRight, lowerLeft, center
  RectWidget.prototype.PointOnWhichPart = function () {
    var dx, dy;
    var event = this.Layer.Event;
    var x = event.offsetX;
    var y = event.offsetY;
    var tolerance = this.Shape.LineWidth + 3;
    var cornerTolerance2 = (tolerance + 2) * (tolerance + 2);
    var corners = this.GetCornerPoints();
    // First, check the corners.
    for (var i = 0; i < 5; ++i) {
      var corner = corners[i];
      dx = x - corner[0];
      dy = y - corner[1];
      if (dx * dx + dy * dy < cornerTolerance2) {
        return [CORNER, i];
      }
    }
    // Now check the edges.
    var corner0 = corners[3];
    for (i = 0; i < 4; ++i) {
      var corner1 = corners[i];
      if (this.Shape.IntersectPointLine([x, y], corner0, corner1, tolerance) !== undefined) {
        // Chance the edge index to start on top edge (=0).
        return [EDGE, (i + 3) % 4];
      }
      corner0 = corner1;
    }
    return undefined;
  };

  RectWidget.prototype.InitPropertiesDialog = function () {
    var self = this;
    this.Dialog = new SAM.Dialog(this.Layer.GetParent().parent());
    this.Dialog.SetApplyCallback(function () { self.DialogApplyCallback(); });
    // Customize dialog for a circle.
    this.Dialog.Title.text('Rect Annotation Editor');
    // Color
    this.Dialog.ColorDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.ColorLabel =
            $('<div>')
            .appendTo(this.Dialog.ColorDiv)
            .text('Color:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.ColorInput =
            $('<input type="color">')
            .appendTo(this.Dialog.ColorDiv)
            .val('#30ff00')
            .css({'display': 'table-cell'});

    // Line Width
    this.Dialog.LineWidthDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.LineWidthLabel =
            $('<div>')
            .appendTo(this.Dialog.LineWidthDiv)
            .text('Line Width:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.LineWidthInput =
            $('<input type="number">')
            .appendTo(this.Dialog.LineWidthDiv)
            .css({'display': 'table-cell'})
            .keypress(function (event) { return event.keyCode !== 13; });

    // Label
    this.Dialog.LabelDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .addClass('sa-view-annotation-modal-div');
    this.Dialog.LabelLabel =
            $('<div>')
            .appendTo(this.Dialog.LabelDiv)
            .text('Label:')
            .addClass('sa-view-annotation-modal-input-label');
    this.Dialog.LabelInput =
            $('<input type="text">')
            .appendTo(this.Dialog.LabelDiv)
            .addClass('sa-view-annotation-modal-input')
            .keypress(function (event) { return event.keyCode !== 13; });

    // Area
    this.Dialog.AreaDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.AreaLabel =
            $('<div>')
            .appendTo(this.Dialog.AreaDiv)
            .text('Area:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.Area =
            $('<div>')
            .appendTo(this.Dialog.AreaDiv)
            .css({'display': 'table-cell'});

    // Bounds
    this.Dialog.BoundsDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.BoundsLabel =
            $('<div>')
            .appendTo(this.Dialog.BoundsDiv)
            .text('Bounds:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.Bounds =
            $('<div>')
            .appendTo(this.Dialog.BoundsDiv)
            .css({'display': 'table-cell'});
  };

  SAM.Rect = Rect;
  SAM.RectWidget = RectWidget;
})();

// This widget just implements a 1 time selection of a rectangle on the screen.
// It draws the rectangle as a dom box (not in the canvas).
// I made it a first class widget and make it active (events are fowarded).
// I will choose the second, but this widget is meant to be
// temporary and not serialize to database.
// Since the rectangle may not be axis aligned withthe world, I added
// methods to check if a point is in the rectangle.

(function () {
  'use strict';

  var INACTIVE = 0;     // Normal inactive resting state.
  var START = 1;        // waiting for the first mouse down to place point1.
  var DRAG = 2;         // Mouse is down and user is dragging point2.
  var FINISH = 3;       // Mouse is up and the rectangle is finished.

  function RectSelectWidget (layer) {
    this.Layer = layer;
    SAM.Shape.call(this);

    this.State = INACTIVE;

    this.Point1 = undefined;
    this.Point2 = undefined;

    this.Rectangle = $('<div>')
      .css({
        'position': 'absolute',
        'border': '1px dashed #FF0'})
      .hide();
    this.FinishCallback = undefined;
    this.Camera = new SAM.Camera();
  }

  RectSelectWidget.prototype.SetFinishCallback = function (callback) {
    this.FinishCallback = callback;
  };

  // TODO: GET RID OF THIS (USE SetActive instead)
  // Starts the process of dragging a rectangle (just changes the cursor.
  RectSelectWidget.prototype.SetStateToDrawing = function () {
    this.State = START;
    this.Layer.GetParent().css({'cursor': 'nw-resize'});
  };

  RectSelectWidget.prototype.IsEmpty = function () {
    return true;
  };

  // Starts the process of dragging a rectangle (just changes the cursor.
  RectSelectWidget.prototype.SetActive = function (flag) {
    if (!flag && this.State !== INACTIVE) {
      this.State = INACTIVE;
      this.Layer.GetParent().css({'cursor': ''});
    }
    if (flag && this.State === INACTIVE) {
      this.State = START;
      this.Layer.GetParent().css({'cursor': 'nw-resize'});
    }
  };

  RectSelectWidget.prototype.Draw = function () {
    if (this.State === DRAG) {
      var x = Math.min(this.Point1[0], this.Point2[0]);
      var y = Math.min(this.Point1[1], this.Point2[1]);
      var w = Math.abs(this.Point1[0] - this.Point2[0]);
      var h = Math.abs(this.Point1[1] - this.Point2[1]);
      this.Rectangle
        .css({
          'left': x.toString() + 'px',
          'top': y.toString() + 'px',
          'width': w.toString() + 'px',
          'height': h.toString() + 'px'})
        .show();
    }
  };

  RectSelectWidget.prototype.HandleMouseDown = function () {
    // Should we allow multiple selections, or a single use?
    if (this.State !== START) {
      return true;
    }
    this.State = DRAG;
    this.Rectangle.appendTo(this.Layer.GetParent());
    var event = this.Layer.Event;
    var x = event.offsetX;
    var y = event.offsetY;
    this.Point1 = [x, y];
    this.Point2 = [x, y];
    this.Draw();
    return false;
  };

  RectSelectWidget.prototype.HandleMouseMove = function () {
    if (this.State !== DRAG) {
      return true;
    }
    var event = this.Layer.Event;
    var x = event.offsetX;
    var y = event.offsetY;
    this.Point2 = [x, y];
    this.Draw();
    return false;
  };

  RectSelectWidget.prototype.HandleMouseUp = function () {
    if (this.State !== DRAG) {
      return true;
    }
    this.State = FINISH;
    this.Layer.GetParent().css({'cursor': ''});
    this.Rectangle.hide().remove();
    // Compute the world coordinates of the points.
    var x1 = Math.min(this.Point1[0], this.Point2[0]);
    var y1 = Math.min(this.Point1[1], this.Point2[1]);
    var x2 = Math.max(this.Point1[0], this.Point2[0]);
    var y2 = Math.max(this.Point1[1], this.Point2[1]);

    this.Point1 = [x1, y1];
    this.Point2 = [x2, y2];

    this.Camera.DeepCopy(this.Layer.GetCamera());
    if (this.FinishCallback) {
      this.FinishCallback(this);
    }
    return false;
  };

  RectSelectWidget.prototype.ViewerPointInSelection = function (x, y) {
    if (x > this.Point1[0] && x < this.Point2[0] &&
        y > this.Point1[1] && y < this.Point2[1]) {
      return true;
    }
    return false;
  };

  RectSelectWidget.prototype.WorldPointInSelection = function (x, y) {
    var viewerPt = this.Camera.ConvertPointWorldToViewer(x, y);
    return this.ViewerPointInSelection(viewerPt[0], viewerPt[1]);
  };

  SAM.RectSelectWidget = RectSelectWidget;
})();

// No rotation for now. No direct interaction for now.
// No properties dialog for now.
// Only the world / slide conrdinate system supported.
// Does nto supprot fixed size

// How are we going to store them in girder annotations?

(function () {
  // Depends on the CIRCLE widget
  'use strict';

  // use shape api, bu this is simpler so do not subclass.
  function RectSet () {
    this.Scale = 1.0;
    // a single array [x,y,x,y,x,y...]
    this.Centers = [];
    this.Widths = [];
    this.Heights = [];
    this.Labels = [];
    this.Confidences = [];
    this.Vectors = [];
    this.Visibilities = undefined;
    // Hack to hide rects below a specific confidence.
    this.Threshold = 0.0;

    // Add metadata to be stored for a given rectangle
    this.Metadata = [];
    // For now, one can be active.  Highlight one
    this.ActiveIndex = -1;
  }

  RectSet.prototype.GetLength = function () {
    return this.Widths.length;
  };

  RectSet.prototype.GetCenter = function (idx) {
    idx = idx << 1;
    return [this.Centers[idx], this.Centers[idx + 1]];
  };

  RectSet.prototype.SetCenter = function (idx, pt) {
    idx = idx * 2;
    this.Centers[idx] = pt[0];
    this.Centers[idx + 1] = pt[1];
  };

  // Set the size (width,height) of all the rectangles.
  RectSet.prototype.SetShape = function (shape) {
    for (var i = 0; i < this.Widths.length; ++i) {
      this.Widths[i] = shape[0];
      this.Heights[i] = shape[1];
    }
  };

  // Set the size (width,height) of all the rectangles.
  RectSet.prototype.SetScale = function (scale) {
    var k = scale / this.Scale;
    this.Scale = scale;
    for (var i = 0; i < this.Widths.length; ++i) {
      this.Widths[i] *= k;
      this.Heights[i] *= k;
    }
  };

  RectSet.prototype.SetMetadata = function (idx, metadataObj) {
    this.Metadata[idx] = metadataObj;
  };

  RectSet.prototype.GetMetadata = function (idx) {
    return this.Metadata[idx];
  };

  // Helper for ground truth.
  RectSet.prototype.CopyRectangle = function (source, inIdx, outIdx) {
    if (outIdx === undefined) {
      outIdx = this.Labels.length;
    }
    var inTmp = inIdx * 2;
    var outTmp = outIdx * 2;
    this.Centers[outTmp] = source.Centers[inTmp];
    this.Centers[outTmp + 1] = source.Centers[inTmp + 1];
    this.Widths[outIdx] = source.Widths[inIdx];
    this.Heights[outIdx] = source.Heights[inIdx];
    this.Labels[outIdx] = source.Labels[inIdx];
    this.Confidences[outIdx] = source.Confidences[inIdx];
    this.Metadata[outIdx] = source.Metadata[inIdx];
  };

  RectSet.prototype.AddRectangle = function (center, width, height) {
    var outIdx = this.Labels.length;
    this.Centers[outIdx * 2] = center[0];
    this.Centers[outIdx * 2 + 1] = center[1];
    this.Widths[outIdx] = width;
    this.Heights[outIdx] = height;
    this.Labels[outIdx] = '';
    this.Confidences[outIdx] = 1.0;
    // Default Metadata is empty
    this.Metadata[outIdx] = {};
    return this.Widths.length - 1;
  };

  RectSet.prototype.DeleteRectangle = function (index) {
    if (index < 0 || index >= this.Widths.length) {
      return;
    }

    this.Centers.splice(2 * index, 2);
    this.Widths.splice(index, 1);
    this.Heights.splice(index, 1);
    this.Labels.splice(index, 1);
    this.Confidences.splice(index, 1);
    this.Metadata.splice(index, 1);
    if (this.ActiveIndex === index) {
      this.ActiveIndex = -1;
    }
  };

  RectSet.prototype.SetOutlineColor = function (c) {
    this.Color = SAM.ConvertColorToHex(c);
  };

  // do not worry about webGl for now.  Only canvas drawing.
  // webgl would support more rects I assume.
  RectSet.prototype.Draw = function (view) {
    // 2d Canvas ( saving is probably not necessary ) -----------
    view.Context2d.save();

    // We only support image coordinate system for now.
    var cam = view.GetCamera();
    var t = cam.GetImageToViewerTransform();
    view.Context2d.setTransform(t[0], t[1], t[2], t[3], t[4], t[5]);

    var pixelSize = cam.ConvertScaleViewerToImage(1);
    var cIdx = 0;
    var x, y, vx, vy;

    // draw the vectors
    view.Context2d.beginPath();
    for (var i = 0; i < this.Vectors.length; ++i) {
      if ((!this.Visibilities || this.Visibilities[i]) &&
          (this.Confidences[i] >= this.Threshold)) {
        vx = this.Vectors[cIdx];
        x = this.Centers[cIdx++];
        vy = this.Vectors[cIdx];
        y = this.Centers[cIdx++];

        view.Context2d.moveTo(x, y);
        view.Context2d.lineTo(x + vx, y + vy);
      } else {
        cIdx += 2;
      }
    }
    view.Context2d.strokeStyle = '#ff00ff';
    view.Context2d.lineWidth = pixelSize * 3;
    view.Context2d.stroke();

    cIdx = 0;
    view.Context2d.lineWidth = pixelSize * 2;
    for (i = 0; i < this.Widths.length; ++i) {
      if ((!this.Visibilities || this.Visibilities[i]) &&
          (this.Confidences[i] >= this.Threshold)) {
        var hw = this.Widths[i] / 2;
        var hh = this.Heights[i] / 2;
        x = this.Centers[cIdx++];
        y = this.Centers[cIdx++];

        view.Context2d.beginPath();
        if (this.LabelColors && this.LabelColors[this.Labels[i]]) {
          view.Context2d.strokeStyle = this.LabelColors[this.Labels[i]];
        } else if (this.Color) {
          view.Context2d.strokeStyle = this.Color;
        } else {
          if (this.Confidences[i] === 0) {
            view.Context2d.strokeStyle = '#ff0000';
          } else {
            var r = Math.floor(this.Confidences[i] * 255);
            view.Context2d.strokeStyle = '#' + r.toString(16) + 'ff00';
          }
        }
        view.Context2d.moveTo(x - hw, y - hh);
        view.Context2d.lineTo(x + hw, y - hh);
        view.Context2d.lineTo(x + hw, y + hh);
        view.Context2d.lineTo(x - hw, y + hh);
        view.Context2d.lineTo(x - hw, y - hh);

        view.Context2d.stroke();

        if (i === this.ActiveIndex) {
          // mark the rectangle
          view.Context2d.beginPath();
          view.Context2d.strokeStyle = '#00ffff';
          view.Context2d.moveTo((x - hw), y);
          view.Context2d.lineTo((x - hw / 2), y);
          view.Context2d.moveTo((x + hw), y);
          view.Context2d.lineTo((x + hw / 2), y);
          view.Context2d.moveTo(x, (y - hh));
          view.Context2d.lineTo(x, (y - hh / 2));
          view.Context2d.moveTo(x, (y + hh));
          view.Context2d.lineTo(x, (y + hh / 2));
          view.Context2d.stroke();
        }
      } else {
        cIdx += 2;
      }
    }

    view.Context2d.restore();
  };

  function RectSetWidget (layer, newFlag) {
    this.Visibility = true;
    // Keep track of annotation created by students without edit
    // permission.
    this.UserNoteFlag = !SA.Edit;

    if (layer === null) {
      return;
    }

    this.Shape = new RectSet();
    if (layer) {
      layer.AddWidget(this);
    }
    this.Active = false;
  }

  RectSetWidget.prototype.GetLength = function () {
    return this.Shape.Widths.length;
  };

  RectSetWidget.prototype.IsEmpty = function () {
    return this.GetLength() === 0;
  };

  // Prioritizing by confidence does not work because they all have such high (equal) confidences.
  // Lets prioritize by area instead
  RectSetWidget.prototype.ComputeVisibilities = function (layer) {
    var rectSet = this.Shape;
    if (rectSet.Visibilities === undefined) {
      rectSet.Visibilities = Array(rectSet.Confidences.length);
      rectSet.Hash = new SAM.SpatialHash();
      var bds = layer.GetViewer().GetOverViewBounds();
      rectSet.Hash.Build(rectSet, bds);
    }
    var visibilities = rectSet.Visibilities;
    visibilities.fill(true);

    // Rectangles are reverse sorted by confidnece
    for (var i = 0; i < visibilities.length; ++i) {
      if (visibilities[i] === true && rectSet.Confidences[i] >= rectSet.Threshold) {
        var width = rectSet.Widths[i];
        var height = rectSet.Heights[i];
        var area1 = width * height;
        var center = rectSet.GetCenter(i);
        // Get all the other rects overlapping this one.
        var indexes = rectSet.Hash.GetOverlapping(center, width, height, 0.3);
        for (var j = 0; j < indexes.length; ++j) {
          var rect2Idx = indexes[j];
          if (rect2Idx !== i && visibilities[rect2Idx] &&
              rectSet.Confidences[rect2Idx] >= rectSet.Threshold) {
            // which should we hide?  Look at area to decide
            var area2 = rectSet.Widths[rect2Idx] * rectSet.Heights[rect2Idx];
            if (area1 < area2) {
              visibilities[i] = false;
            } else {
              visibilities[rect2Idx] = false;
            }
          }
        }
      }
    }
  };

  // note: this assumes rects are squares.
  // I assume that the annotations are fixed and do not change after this
  // is called.  This can be called multiple times
  // (when threshold or size changes).
  // Remove overlapping annoations (visibility = false).
  // greedy: first supresses later)
  RectSetWidget.prototype.ComputeVisibilitiesConfidence = function (layer) {
    var rectSet = this.Shape;
    if (rectSet.Visibilities === undefined) {
      rectSet.Visibilities = Array(rectSet.Confidences.length);
      rectSet.Hash = new SAM.SpatialHash();
      var bds = layer.GetViewer().GetOverViewBounds();
      rectSet.Hash.Build(rectSet, bds);
    }
    var visibilities = rectSet.Visibilities;
    visibilities.fill(false);

    // Rectangles are reverse sorted by confidnece
    for (var i = 0; i < visibilities.length; ++i) {
      if (visibilities[i] === false && rectSet.Confidences[i] >= rectSet.Threshold) {
        var width = rectSet.Widths[i];
        var height = rectSet.Heights[i];
        var center = rectSet.GetCenter(i);
        // Get all the other rects overlapping this one.
        var indexes = rectSet.Hash.GetOverlapping(center, width, height, 0.3);
        var alone = true;
        for (var j = 0; j < indexes.length; ++j) {
          var rect2Idx = indexes[j];
          // Odd: Make them visible one by one.
          if (rect2Idx < i && visibilities[rect2Idx]) {
            // found a visibile neighbor.
            alone = false;
          }
        }
        visibilities[i] = alone;
      }
    }
  };

  // Change the visiblities and colors to indicate change.
  // This assume that the visibilities have been computed already.
  // and hash has been built too.
  RectSet.prototype.ChangeDetectionVisibilities = function (rectSet1, rectSet2,
                                                            overlapThresh) {
    var visibilities1 = rectSet1.Visibilities;
    var visibilities2 = rectSet2.Visibilities;

    for (var i = 0; i < visibilities1.length; ++i) {
      if (visibilities1[i]) {
        var c = rectSet1.GetCenter(i);
        var w = rectSet1.Widths[i];
        var h = rectSet1.Widths[i];
        var indexes = rectSet2.Hash.GetOverlapping(c, w, h, 0.3);
        for (var j = 0; j < indexes.length; ++j) {
          visibilities2[indexes[j]] = false;
          visibilities1[i] = false;
        }
      }
    }
  };

  // Sort by confidences
  // Note: Not used yet.
  RectSetWidget.prototype.Sort = function (lowToHigh) {
    // Create an array to sort that also keeps the indexes.
    var sortable = new Array(this.Confidences.length);
    var reverse = 1;
    if (lowToHigh) {
      reverse = -1;
    }
    for (var i = 0; i < sortable.length; ++i) {
      sortable[i] = {conf: reverse * this.Confidences[i], idx: i};
    }
    sortable.sort(function (a, b) {
      if (a.conf > b.conf) {
        return 1;
      }
      if (a.conf < b.conf) {
        return -1;
      }
      // a must be equal to b
      return 0;
    });
    // Update all arrays.
    var newConfidences = new Array(this.Confidences.length);
    var newCenters = new Array(this.Centers.length);
    var newLabels = new Array(this.Centers.length);
    var newMetadata = new Array(this.Metadata.length);
    for (i = 0; i < newConfidences.length; ++i) {
      var i2 = sortable[i].idx;
      newLabels[i] = this.Labels[i2];
      newMetadata[i] = this.Metadata[i2];
      newConfidences[i] = this.Confidences[i2];
      i2 = i2 * 2;
      newCenters[2 * i] = this.Centers[i2];
      newCenters[2 * i + 1] = this.Centers[i2 + 1];
    }
    this.Centers = newCenters;
    this.Confidences = newConfidences;
    this.Labels = newLabels;
    this.Metadata = newMetadata;
  };

  // Threshold above is the only option for now.
  RectSetWidget.prototype.SetThreshold = function (threshold) {
    this.Shape.Threshold = threshold;
  };

  RectSetWidget.prototype.Draw = function (layer) {
    if (this.Visibility) {
      this.Shape.Draw(layer.GetView());
    }
  };

  RectSetWidget.prototype.Serialize = function () {
    if (this.Shape === undefined) { return null; }

    var obj = {type: 'rect_set'};
    if (this.UserNoteFlag !== undefined) {
      obj.user_note_flag = this.UserNoteFlag;
    }
    if (this.Shape.Color) {
      obj.color = SAM.ConvertColor(this.Shape.Color);
    }
    if (this.Label) {
      obj.label = this.Label;
    }
    var num = this.Shape.Widths.length;
    obj.confidences = new Array(num);
    obj.widths = new Array(num);
    obj.heights = new Array(num);
    obj.labels = new Array(num);
    obj.metadata = new Array(num);
    obj.centers = new Array(num * 2);
    for (var i = 0; i < num; ++i) {
      obj.widths[i] = this.Shape.Widths[i];
      obj.heights[i] = this.Shape.Heights[i];
      obj.confidences[i] = this.Shape.Confidences[i];
      obj.centers[i] = this.Shape.Centers[i];
      obj.centers[i + num] = this.Shape.Centers[i + num];
      obj.labels[i] = this.Shape.Labels[i];
      obj.metadata[i] = this.Shape.Metadata[i];
    }
    return obj;
  };

  // Load a widget from a json object (origin MongoDB).
  RectSetWidget.prototype.Load = function (obj) {
    this.UserNoteFlag = obj.user_note_flag;
    if (obj.label) {
      this.Label = obj.label;
    }
    if (obj.color) {
      this.Shape.Color = [
        parseFloat(obj.color[0]),
        parseFloat(obj.color[1]),
        parseFloat(obj.color[2])];
    }
    var num = obj.widths.length;
    this.Shape.Confidences = new Array(num);
    this.Shape.Labels = new Array(num);
    this.Shape.Widths = new Array(num);
    this.Shape.Heights = new Array(num);
    this.Shape.Centers = new Array(num * 2);
    if (obj.vectors) {
      this.Shape.Vectors = new Array(num * 2);
    }
    this.Shape.Metadata = new Array(num);
    for (var i = 0; i < num; ++i) {
      this.Shape.Widths[i] = parseFloat(obj.widths[i]);
      this.Shape.Heights[i] = parseFloat(obj.heights[i]);
      this.Shape.Confidences[i] = parseFloat(obj.confidences[i]);
      if (obj.labels) {
        this.Shape.Labels[i] = obj.labels[i];
      } else {
        this.Shape.Labels[i] = '';
      }
      if (obj.metadata) {
        this.Shape.Metadata[i] = obj.metadata[i];
      } else {
        this.Shape.Metadata[i] = {};
      }
      this.Shape.Centers[i] = parseFloat(obj.centers[i]);
      this.Shape.Centers[i + num] = parseFloat(obj.centers[i + num]);
      if (obj.vectors) {
        this.Shape.Vectors[i] = parseFloat(obj.vectors[i]);
        this.Shape.Vectors[i + num] = parseFloat(obj.vectors[i + num]);
      }
    }
  };

  RectSetWidget.prototype.HandleDoubleClick = function (layer) {
    return true;
  };

  RectSetWidget.prototype.HandleMouseUp = function (layer) {
    return true;
  };

  RectSetWidget.prototype.HandleMouseMove = function (layer) {
    return true;
  };

  RectSetWidget.prototype.HandleMouseWheel = function (layer) {
    return true;
  };

  RectSetWidget.prototype.HandleTouchPan = function (layer) {
    return true;
  };

  RectSetWidget.prototype.HandleTouchPinch = function (layer) {
    return true;
  };

  RectSetWidget.prototype.HandleTouchEnd = function (layer) {
    return true;
  };

  RectSetWidget.prototype.CheckActive = function (layer) {
    return this.Active;
  };

  // Multiple active states. Active state is a bit confusing.
  RectSetWidget.prototype.GetActive = function () {
    return this.Active;
  };

  // Does notning now.
  RectSetWidget.prototype.SetActive = function (flag, layer) {
    if (!this.Visibility) {
      this.Visibility = true;
    }
    if (flag === this.GetActive()) {
      return;
    }
    this.Active = flag;
    layer.EventuallyDraw();
  };

  RectSetWidget.prototype.RemoveFromLayer = function (layer) {
    if (layer) {
      layer.RemoveWidget(this);
    }
    layer = null;
  };

  RectSetWidget.prototype.Deactivate = function (layer) {
  };

  RectSetWidget.prototype.PlacePopup = function (layer) {
  };

  RectSetWidget.prototype.ShowPropertiesDialog = function (layer) {
  };

  SAM.RectSetWidget = RectSetWidget;
  SAM.RectSet = RectSet;
})();

(function () {
  'use strict';

  var WAITING = 3; // The normal (resting) state.
  var ACTIVE = 4; // Mouse is over the widget and it is receiving events.
  var PROPERTIES_DIALOG = 5; // Properties dialog is up

  var DRAG = 6;
  var DRAG_LEFT = 7;
  var DRAG_RIGHT = 8;
  var DRAG_TOP = 9;
  var DRAG_BOTTOM = 10;
  // Worry about corners later.

  function Grid () {
    SAM.Shape.call(this);
    // Dimension of grid bin
    this.BinWidth = 20.0;
    this.BinHeight = 20.0;
    // Number of grid bins in x and y
    this.Dimensions = [10, 8];
    this.Orientation = 0; // Angle with respect to x axis ?
    this.Origin = [10000, 10000]; // middle.
    this.OutlineColor = [0, 0, 0];
    this.PointBuffer = [];
    this.ActiveIndex = undefined;
  }

  Grid.prototype = new SAM.Shape();

  Grid.prototype.UpdateBuffers = function (view) {
    // TODO: Having a single poly line for a shape is to simple.
    // Add cell arrays.
    this.PointBuffer = [];

    // Matrix is computed by the draw method in Shape superclass.
    // TODO: Used to detect first initialization.
    // Get this out of this method.
    this.Matrix = mat4.create();
    mat4.identity(this.Matrix);
    // mat4.rotateZ(this.Matrix, this.Orientation / 180.0 * 3.14159);

    if (this.Dimensions[0] < 1 || this.Dimensions[1] < 1 ||
            this.BinWidth <= 0.0 || this.BinHeight <= 0.0) {
      return;
    }

    var totalWidth = this.BinWidth * this.Dimensions[0];
    var totalHeight = this.BinHeight * this.Dimensions[1];
    var halfWidth = totalWidth / 2;
    var halfHeight = totalHeight / 2;

    // Draw all of the x polylines.
    var x = this.Dimensions[1] % 2 ? 0 : totalWidth;
    var y = 0;
    this.PointBuffer.push(x - halfWidth);
    this.PointBuffer.push(y - halfHeight);
    this.PointBuffer.push(0.0);

    for (var i = 0; i < this.Dimensions[1]; ++i) {
      // shuttle back and forth.
      x = x ? 0 : totalWidth;
      this.PointBuffer.push(x - halfWidth);
      this.PointBuffer.push(y - halfHeight);
      this.PointBuffer.push(0.0);
      y += this.BinHeight;
      this.PointBuffer.push(x - halfWidth);
      this.PointBuffer.push(y - halfHeight);
      this.PointBuffer.push(0.0);
    }
    // shuttle back and forth.
    x = x ? 0 : totalWidth;
    this.PointBuffer.push(x - halfWidth);
    this.PointBuffer.push(y - halfHeight);
    this.PointBuffer.push(0.0);

    // Draw all of the y lines.
    for (i = 0; i < this.Dimensions[0]; ++i) {
      // shuttle up and down.
      y = y ? 0 : totalHeight;
      this.PointBuffer.push(x - halfWidth);
      this.PointBuffer.push(y - halfHeight);
      this.PointBuffer.push(0.0);
      x += this.BinWidth;
      this.PointBuffer.push(x - halfWidth);
      this.PointBuffer.push(y - halfHeight);
      this.PointBuffer.push(0.0);
    }
    y = y ? 0 : totalHeight;
    this.PointBuffer.push(x - halfWidth);
    this.PointBuffer.push(y - halfHeight);
    this.PointBuffer.push(0.0);
  };

  function GridWidget (layer, newFlag) {
        // Keep track of annotation created by students without edit
        // permission.
    this.UserNoteFlag = !SA.Edit;

    var self = this;
    this.Dialog = new SAM.Dialog(function () { self.DialogApplyCallback(); });
        // Customize dialog for a circle.
    this.Dialog.Title.text('Grid Annotation Editor');

        // Grid Size
        // X
    this.Dialog.BinWidthDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.BinWidthLabel =
            $('<div>')
            .appendTo(this.Dialog.BinWidthDiv)
            .text('Bin Width:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.BinWidthInput =
            $('<input>')
            .appendTo(this.Dialog.BinWidthDiv)
            .css({'display': 'table-cell'})
            .keypress(function (event) { return event.keyCode !== 13; });
        // Y
    this.Dialog.BinHeightDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.BinHeightLabel =
            $('<div>')
            .appendTo(this.Dialog.BinHeightDiv)
            .text('Bin Height:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.BinHeightInput =
            $('<input>')
            .appendTo(this.Dialog.BinHeightDiv)
            .css({'display': 'table-cell'})
            .keypress(function (event) { return event.keyCode !== 13; });

        // Orientation
    this.Dialog.RotationDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.RotationLabel =
            $('<div>')
            .appendTo(this.Dialog.RotationDiv)
            .text('Rotation:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.RotationInput =
            $('<input>')
            .appendTo(this.Dialog.RotationDiv)
            .css({'display': 'table-cell'})
            .keypress(function (event) { return event.keyCode !== 13; });

        // Color
    this.Dialog.ColorDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.ColorLabel =
            $('<div>')
            .appendTo(this.Dialog.ColorDiv)
            .text('Color:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.ColorInput =
            $('<input type="color">')
            .appendTo(this.Dialog.ColorDiv)
            .val('#30ff00')
            .css({'display': 'table-cell'});

        // Line Width
    this.Dialog.LineWidthDiv =
            $('<div>')
            .appendTo(this.Dialog.Body)
            .css({'display': 'table-row'});
    this.Dialog.LineWidthLabel =
            $('<div>')
            .appendTo(this.Dialog.LineWidthDiv)
            .text('Line Width:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
    this.Dialog.LineWidthInput =
            $('<input type="number">')
            .appendTo(this.Dialog.LineWidthDiv)
            .css({'display': 'table-cell'})
            .keypress(function (event) { return event.keyCode !== 13; });

    this.Tolerance = 0.05;
    if (SAM.MOBILE_DEVICE) {
      this.Tolerance = 0.1;
    }

    if (layer === null) {
      return;
    }

        // Lets save the zoom level (sort of).
        // Load will overwrite this for existing annotations.
        // This will allow us to expand annotations into notes.
    this.CreationCamera = layer.GetCamera().Serialize();

    this.Layer = layer;
    this.Popup = new SAM.WidgetPopup(this);
    var cam = layer.AnnotationView.Camera;
    var viewport = layer.AnnotationView.Viewport;
    this.Grid = new Grid();
    this.Grid.Origin = [0, 0];
    this.Grid.OutlineColor = [0.0, 0.0, 0.0];
    this.Grid.SetOutlineColor('#0A0F7A');
        // Get the default bin size from the layer scale bar.
    if (layer.ScaleWidget) {
      this.Grid.BinWidth = layer.ScaleWidget.LengthWorld;
    } else {
      this.Grid.BinWidth = 30 * cam.Height / viewport[3];
    }
    this.Grid.BinHeight = this.Grid.BinWidth;
    this.Grid.LineWidth = 2.0 * cam.Height / viewport[3];
    this.Grid.FixedSize = false;

    var width = 0.8 * viewport[2] / layer.GetPixelsPerUnit();
    this.Grid.Dimensions[0] = Math.floor(width / this.Grid.BinWidth);
    var height = 0.8 * viewport[3] / layer.GetPixelsPerUnit();
    this.Grid.Dimensions[1] = Math.floor(height / this.Grid.BinHeight);
    this.Grid.UpdateBuffers(this.Layer.AnnotationView);

    this.Text = new SAM.Text();
        // Shallow copy is dangerous
    this.Text.Position = this.Grid.Origin;
    this.Text.String = SAM.DistanceToString(this.Grid.BinWidth * 0.25e-6);
    this.Text.Color = [0.0, 0.0, 0.5];
    this.Text.Anchor = [0, 0];
    this.Text.UpdateBuffers(this.Layer.AnnotationView);

        // Get default properties.
    if (localStorage.GridWidgetDefaults) {
      var defaults = JSON.parse(localStorage.GridWidgetDefaults);
      if (defaults.Color) {
        this.Dialog.ColorInput.val(SAM.ConvertColorToHex(defaults.Color));
        this.Grid.SetOutlineColor(this.Dialog.ColorInput.val());
      }
      if (defaults.LineWidth !== undefined) {
        this.Dialog.LineWidthInput.val(defaults.LineWidth);
        this.Grid.LineWidth = defaults.LineWidth;
      }
    }

    this.Layer.AddWidget(this);

    this.State = WAITING;
  }

    // sign specifies which corner is origin.
    // gx, gy is the point in grid pixel coordinates offset from the corner.
  GridWidget.prototype.ComputeCorner = function (xSign, ySign, gx, gy) {
        // Pick the upper left most corner to display the grid size text.
    var xRadius = this.Grid.BinWidth * this.Grid.Dimensions[0] / 2;
    var yRadius = this.Grid.BinHeight * this.Grid.Dimensions[1] / 2;
    xRadius += gx;
    yRadius += gy;
    var x = this.Grid.Origin[0];
    var y = this.Grid.Origin[1];
        // Choose the corner from 0 to 90 degrees in the window.
    var roll = (this.Layer.GetCamera().GetImageRotation() -
                    this.Grid.Orientation) / 90; // range 0-4
    roll = Math.round(roll);
        // Modulo that works with negative numbers;
    roll = ((roll % 4) + 4) % 4;
    var c = Math.cos(3.14156 * this.Grid.Orientation / 180.0);
    var s = Math.sin(3.14156 * this.Grid.Orientation / 180.0);
    var dx, dy;
    if (roll === 0) {
      dx = xSign * xRadius;
      dy = ySign * yRadius;
    } else if (roll === 3) {
      dx = xSign * xRadius;
      dy = -ySign * yRadius;
    } else if (roll === 2) {
      dx = -xSign * xRadius;
      dy = -ySign * yRadius;
    } else if (roll === 1) {
      dx = -xSign * xRadius;
      dy = ySign * yRadius;
    }
    x = x + c * dx + s * dy;
    y = y + c * dy - s * dx;

    return [x, y];
  };

  GridWidget.prototype.Draw = function (view) {
    this.Grid.Draw(view);

        // Corner in grid pixel coordinates.
    var x = -(this.Grid.BinWidth * this.Grid.Dimensions[0] / 2);
    var y = -(this.Grid.BinHeight * this.Grid.Dimensions[1] / 2);
    this.Text.Anchor = [0, 20];
    this.Text.Orientation = (this.Grid.Orientation -
                                 this.Layer.GetCamera().GetImageRotation());
        // Modulo that works with negative numbers;
    this.Text.Orientation = ((this.Text.Orientation % 360) + 360) % 360;
        // Do not draw text upside down.
    if (this.Text.Orientation > 90 && this.Text.Orientation < 270) {
      this.Text.Orientation -= 180.0;
      this.Text.Anchor = [this.Text.PixelBounds[1], 0];
            // x += this.Text.PixelBounds[1]; // wrong units (want world
            // pixels , this is screen pixels).
    }
        // Convert to world Coordinates.
    var radians = this.Grid.Orientation * Math.PI / 180;
    var c = Math.cos(radians);
    var s = Math.sin(radians);
    var wx = c * x + s * y;
    var wy = c * y - s * x;
    this.Text.Position = [this.Grid.Origin[0] + wx, this.Grid.Origin[1] + wy];

    this.Text.Draw(view);
  };

    // This needs to be put in the layer.
    // GridWidget.prototype.RemoveFromViewer = function() {
    //    if (this.Viewer) {
    //        this.Viewer.RemoveWidget(this);
    //    }
    // };

  GridWidget.prototype.PasteCallback = function (data, mouseWorldPt, camera) {
    this.Load(data);
        // Keep the pasted grid from rotating when the camera changes.
    var dr = this.Layer.GetCamera().GetImageRotation() -
        camera.GetImageRotation();
    this.Grid.Orientation += dr;
        // Place the widget over the mouse.
        // This would be better as an argument.
    this.Grid.Origin = [mouseWorldPt[0], mouseWorldPt[1]];
    this.Text.Position = [mouseWorldPt[0], mouseWorldPt[1]];

    if (this.UserNoteFlag && SA.notesWidget) { SA.notesWidget.EventuallySaveUserNote(); }
    if (SAM.NotesWidget && !this.UserNoteFlag) { SAM.NotesWidget.MarkAsModified(); } // Hack
    this.Layer.EventuallyDraw();
  };

  GridWidget.prototype.Serialize = function () {
    if (this.Grid === undefined) { return null; }
    var obj = {};
    obj.type = 'grid';
    obj.user_note_flag = this.UserNoteFlag;
    obj.origin = this.Grid.Origin;
    obj.lineColor = SAM.ConvertColorToHex(this.Grid.OutlineColor);
    obj.bin_width = this.Grid.BinWidth;
    obj.bin_height = this.Grid.BinHeight;
    obj.dimensions = this.Grid.Dimensions;
    obj.orientation = this.Grid.Orientation;
    obj.lineWidth = this.Grid.LineWidth;
    obj.creation_camera = this.CreationCamera;
    return obj;
  };

    // Load a widget from a json object (origin MongoDB).
  GridWidget.prototype.Load = function (obj) {
    this.UserNoteFlag = obj.user_note_flag;
    this.Grid.Origin[0] = parseFloat(obj.origin[0]);
    this.Grid.Origin[1] = parseFloat(obj.origin[1]);
    this.Grid.OutlineColor = SAM.CovertColor(obj.lineColor);
    if (obj.width) { this.Grid.BinWidth = parseFloat(obj.width); }
    if (obj.height) { this.Grid.BinHeight = parseFloat(obj.height); }
    if (obj.bin_width) { this.Grid.BinWidth = parseFloat(obj.bin_width); }
    if (obj.bin_height) { this.Grid.BinHeight = parseFloat(obj.bin_height); }
    this.Grid.Dimensions[0] = parseInt(obj.dimensions[0]);
    this.Grid.Dimensions[1] = parseInt(obj.dimensions[1]);
    this.Grid.Orientation = parseFloat(obj.orientation);
    this.Grid.LineWidth = parseFloat(obj.lineWidth);
    this.Grid.FixedSize = false;
    this.Grid.UpdateBuffers(this.Layer.AnnotationView);

    this.Text.String = SAM.DistanceToString(this.Grid.BinWidth * 0.25e-6);
        // Shallow copy is dangerous
    this.Text.Position = this.Grid.Origin;
    this.Text.UpdateBuffers(this.Layer.AnnotationView);

        // How zoomed in was the view when the annotation was created.
    if (obj.creation_camera !== undefined) {
      this.CreationCamera = obj.CreationCamera;
    }
  };

  GridWidget.prototype.HandleKeyPress = function (keyCode, shift) {
        // The dialog consumes all key events.
    if (this.State === PROPERTIES_DIALOG) {
      return false;
    }

        // Copy
    if (event.keyCode === 67 && event.ctrlKey) {
            // control-c for copy
            // The extra identifier is not needed for widgets, but will be
            // needed if we have some other object on the clipboard.
            // The camera is needed so grid does not rotate when pasting in
            // another stack section.
      var clip = {Type: 'GridWidget',
        Data: this.Serialize(),
        Camera: this.Layer.GetCamera().Serialize()};
      localStorage.ClipBoard = JSON.stringify(clip);
      return false;
    }

    return true;
  };

  GridWidget.prototype.HandleDoubleClick = function (event) {
    return true;
  };

  GridWidget.prototype.HandleMouseDown = function (event) {
    if (event.which !== 1) {
      return true;
    }
    var cam = this.Layer.GetCamera();
    this.DragLast = cam.ConvertPointViewerToWorld(event.offsetX, event.offsetY);
    return false;
  };

    // returns false when it is finished doing its work.
  GridWidget.prototype.HandleMouseUp = function (event) {
    this.SetActive(false);
    if (window.SA) { SA.RecordState(); }
    if (this.UserNoteFlag && SA.notesWidget) { SA.notesWidget.EventuallySaveUserNote(); }
    if (SAM.NotesWidget && !this.UserNoteFlag) { SAM.NotesWidget.MarkAsModified(); } // Hack

    return true;
  };

    // Orientation is a pain,  we need a world to shape transformation.
  GridWidget.prototype.HandleMouseMove = function (event) {
    if (event.which === 1) {
      var cam = this.Layer.GetCamera();
      var world =
                cam.ConvertPointViewerToWorld(event.offsetX, event.offsetY);
      var dx, dy;
      if (this.State === DRAG) {
        dx = world[0] - this.DragLast[0];
        dy = world[1] - this.DragLast[1];
        this.DragLast = world;
        this.Grid.Origin[0] += dx;
        this.Grid.Origin[1] += dy;
      } else {
                // convert mouse from world to Grid coordinate system.
        dx = world[0] - this.Grid.Origin[0];
        dy = world[1] - this.Grid.Origin[1];
        var c = Math.cos(3.14156 * this.Grid.Orientation / 180.0);
        var s = Math.sin(3.14156 * this.Grid.Orientation / 180.0);
        var x = c * dx - s * dy;
        var y = c * dy + s * dx;
                // convert from shape to integer grid indexes.
        x = (0.5 * this.Grid.Dimensions[0]) + (x / this.Grid.BinWidth);
        y = (0.5 * this.Grid.Dimensions[1]) + (y / this.Grid.BinHeight);
        var ix = Math.round(x);
        var iy = Math.round(y);
                // Change grid dimemsions
        dx = dy = 0;
        var changed = false;
        if (this.State === DRAG_RIGHT) {
          dx = ix - this.Grid.Dimensions[0];
          if (dx) {
            this.Grid.Dimensions[0] = ix;
                        // Compute the change in the center point origin.
            dx = 0.5 * dx * this.Grid.BinWidth;
            changed = true;
          }
        } else if (this.State === DRAG_LEFT) {
          if (ix) {
            this.Grid.Dimensions[0] -= ix;
                        // Compute the change in the center point origin.
            dx = 0.5 * ix * this.Grid.BinWidth;
            changed = true;
          }
        } else if (this.State === DRAG_BOTTOM) {
          dy = iy - this.Grid.Dimensions[1];
          if (dy) {
            this.Grid.Dimensions[1] = iy;
                        // Compute the change in the center point origin.
            dy = 0.5 * dy * this.Grid.BinHeight;
            changed = true;
          }
        } else if (this.State === DRAG_TOP) {
          if (iy) {
            this.Grid.Dimensions[1] -= iy;
                        // Compute the change in the center point origin.
            dy = 0.5 * iy * this.Grid.BinHeight;
            changed = true;
          }
        }
        if (changed) {
                    // Rotate the translation and apply to the center.
          x = c * dx + s * dy;
          y = c * dy - s * dx;
          this.Grid.Origin[0] += x;
          this.Grid.Origin[1] += y;
          this.Grid.UpdateBuffers(this.Layer.AnnotationView);
        }
      }
      this.Layer.EventuallyDraw();
      return;
    }

    if (event.which === 0) {
            // Update the active state if theuser is not interacting.
      this.SetActive(this.CheckActive(event));
    }

    return true;
  };

  GridWidget.prototype.HandleMouseWheel = function (event) {
        /*
        var x = event.offsetX;
        var y = event.offsetY;

        if (this.State === ACTIVE) {
            if(this.NormalizedActiveDistance < 0.5) {
                var ratio = 1.05;
                var direction = 1;
                if(event.wheelDelta < 0) {
                     ratio = 0.95;
                    direction = -1;
                }
                if(event.shiftKey) {
                    this.Grid.Length = this.Grid.Length * ratio;
                }
                if(event.ctrlKey) {
                    this.Grid.BinWidth = this.Grid.BinWidth * ratio;
                }
                if(!event.shiftKey && !event.ctrlKey) {
                    this.Grid.Orientation = this.Grid.Orientation + 3 * direction;
                 }

                this.Grid.UpdateBuffers(this.Layer.AnnotationView);
                this.PlacePopup();
                this.Layer.EventuallyDraw();
            }
        }
        */
  };

  GridWidget.prototype.HandleTouchPan = function (event) {
        /*
          w0 = this.Viewer.ConvertPointViewerToWorld(EVENT_MANAGER.LastMouseX,
          EVENT_MANAGER.LastMouseY);
          w1 = this.Viewer.ConvertPointViewerToWorld(event.offsetX,event.offsetY);

          // This is the translation.
          var dx = w1[0] - w0[0];
          var dy = w1[1] - w0[1];

          this.Grid.Origin[0] += dx;
          this.Grid.Origin[1] += dy;
          this.Layer.EventuallyDraw();
        */
    return true;
  };

  GridWidget.prototype.HandleTouchPinch = function (event) {
        // this.Grid.UpdateBuffers(this.Layer.AnnotationView);
        // this.Layer.EventuallyDraw();
    return true;
  };

  GridWidget.prototype.HandleTouchEnd = function (event) {
    if (this.UserNoteFlag && SA.notesWidget) { SA.notesWidget.EventuallySaveUserNote(); }
    if (SAM.NotesWidget && !this.UserNoteFlag) { SAM.NotesWidget.MarkAsModified(); } // Hack
    this.SetActive(false);
  };

  GridWidget.prototype.CheckActive = function (event) {
    var x, y;
    if (this.Grid.FixedSize) {
      x = event.offsetX;
      y = event.offsetY;
    } else {
      x = event.worldX;
      y = event.worldY;
    }
    x = x - this.Grid.Origin[0];
    y = y - this.Grid.Origin[1];
    // Rotate to grid.
    var c = Math.cos(3.14156 * this.Grid.Orientation / 180.0);
    var s = Math.sin(3.14156 * this.Grid.Orientation / 180.0);
    var rx = c * x - s * y;
    var ry = c * y + s * x;

    // Convert to grid coordinates (0 -> dims)
    x = (0.5 * this.Grid.Dimensions[0]) + (rx / this.Grid.BinWidth);
    y = (0.5 * this.Grid.Dimensions[1]) + (ry / this.Grid.BinHeight);
    var ix = Math.round(x);
    var iy = Math.round(y);
    if (ix < 0 || ix > this.Grid.Dimensions[0] ||
            iy < 0 || iy > this.Grid.Dimensions[1]) {
      this.SetActive(false);
      return false;
    }

    // x,y get the residual in pixels.
    x = (x - ix) * this.Grid.BinWidth;
    y = (y - iy) * this.Grid.BinHeight;

    // Compute the screen pixel size for tollerance.
    var tolerance = 5.0 / this.Layer.GetPixelsPerUnit();

    if (Math.abs(x) < tolerance || Math.abs(y) < tolerance) {
      this.ActiveIndex = [ix, iy];
      return true;
    }

    return false;
  };

    // Multiple active states. Active state is a bit confusing.
  GridWidget.prototype.GetActive = function () {
    if (this.State === WAITING) {
      return false;
    }
    return true;
  };

  GridWidget.prototype.Deactivate = function () {
    this.Layer.AnnotationView.Parent.css({'cursor': 'default'});
    this.Popup.StartHideTimer();
    this.State = WAITING;
    this.Grid.Active = false;
    this.Layer.DeactivateWidget(this);
    if (this.DeactivateCallback) {
      this.DeactivateCallback();
    }
    this.Layer.EventuallyDraw();
  };

    // Setting to active always puts state into "active".
    // It can move to other states and stay active.
  GridWidget.prototype.SetActive = function (flag) {
    if (flag) {
      this.State = ACTIVE;
      this.Grid.Active = true;

      if (!this.ActiveIndex) {
        console.log('No active index');
        return;
      }
      if (this.ActiveIndex[0] === 0) {
        this.State = DRAG_LEFT;
        this.Layer.AnnotationView.Parent.css({'cursor': 'col-resize'});
      } else if (this.ActiveIndex[0] === this.Grid.Dimensions[0]) {
        this.State = DRAG_RIGHT;
        this.Layer.AnnotationView.Parent.css({'cursor': 'col-resize'});
      } else if (this.ActiveIndex[1] === 0) {
        this.State = DRAG_TOP;
        this.Layer.AnnotationView.Parent.css({'cursor': 'row-resize'});
      } else if (this.ActiveIndex[1] === this.Grid.Dimensions[1]) {
        this.State = DRAG_BOTTOM;
        this.Layer.AnnotationView.Parent.css({'cursor': 'row-resize'});
      } else {
        this.State = DRAG;
        this.Layer.AnnotationView.Parent.css({'cursor': 'move'});
      }

            // Compute the location for the pop up and show it.
      this.PlacePopup();
    } else {
      this.Deactivate();
    }
    this.Layer.EventuallyDraw();
  };

    // This also shows the popup if it is not visible already.
  GridWidget.prototype.PlacePopup = function () {
        // Compute corner has its angle backwards.  I do not see how this works.
    var pt = this.ComputeCorner(1, -1, 0, 0);
    var cam = this.Layer.GetCamera();
    pt = cam.ConvertPointWorldToViewer(pt[0], pt[1]);
    this.Popup.Show(pt[0] + 10, pt[1] - 30);
  };

  GridWidget.prototype.ShowPropertiesDialog = function () {
    this.Dialog.ColorInput.val(SAM.ConvertColorToHex(this.Grid.OutlineColor));
    this.Dialog.LineWidthInput.val((this.Grid.LineWidth).toFixed(2));
        // convert 40x scan pixels into meters
    this.Dialog.BinWidthInput.val(SAM.DistanceToString(this.Grid.BinWidth * 0.25e-6));
    this.Dialog.BinHeightInput.val(SAM.DistanceToString(this.Grid.BinHeight * 0.25e-6));
    this.Dialog.RotationInput.val(this.Grid.Orientation);

    this.Dialog.Show(true);
  };

  GridWidget.prototype.DialogApplyCallback = function () {
    var hexcolor = this.Dialog.ColorInput.val();
    this.Grid.SetOutlineColor(hexcolor);
    this.Grid.LineWidth = parseFloat(this.Dialog.LineWidthInput.val());
    this.Grid.BinWidth = SAM.StringToDistance(this.Dialog.BinWidthInput.val()) * 4e6;
    this.Grid.BinHeight = SAM.StringToDistance(this.Dialog.BinHeightInput.val()) * 4e6;
    this.Grid.Orientation = parseFloat(this.Dialog.RotationInput.val());
    this.Grid.UpdateBuffers(this.Layer.AnnotationView);
    this.SetActive(false);

    this.Text.String = SAM.DistanceToString(this.Grid.BinWidth * 0.25e-6);
    this.Text.UpdateBuffers(this.Layer.AnnotationView);

    if (window.SA) { SA.RecordState(); }
    this.Layer.EventuallyDraw();

    if (this.UserNoteFlag && SA.notesWidget) { SA.notesWidget.EventuallySaveUserNote(); }
    if (SAM.NotesWidget && !this.UserNoteFlag) { SAM.NotesWidget.MarkAsModified(); } // Hack
    localStorage.GridWidgetDefaults = JSON.stringify({Color: hexcolor, LineWidth: this.Grid.LineWidth});
  };

  SAM.GridWidget = GridWidget;
})();

(function () {
  'use strict';

  var WAITING = 3; // The normal (resting) state.
  var ACTIVE = 4; // Mouse is over the widget and it is receiving events.

  // view argument is the main view (needed to get the spacing...)
  // Viewer coordinates.
  // Horizontal or vertical
  function Scale () {
    SAM.Shape.call(this);
    // Dimension of scale element
    this.BinLength = 100.0; // unit length in screen pixels
    this.TickSize = 6; // Screen pixels
    this.NumberOfBins = 1;
    this.Orientation = 0; // 0 or 90
    this.Origin = [10000, 10000]; // middle.
    this.OutlineColor = [0, 0, 0];
    this.PointBuffer = [];
    this.PositionCoordinateSystem = SAM.Shape.VIEWER;
  }

  Scale.prototype = new SAM.Shape();

  Scale.prototype.destructor = function () {
    // Get rid of the buffers?
  };

  Scale.prototype.UpdateBuffers = function (view) {
    // TODO: Having a single poly line for a shape is to simple.
    // Add cell arrays.
    this.PointBuffer = [];

    // Matrix is computed by the draw method in Shape superclass.
    // TODO: Used to detect first initialization.
    // Get this out of this method.
    this.Matrix = mat4.create();
    mat4.identity(this.Matrix);

    // Draw all of the x lines.
    var x = 0;
    var y = this.TickSize;
    this.PointBuffer.push(x);
    this.PointBuffer.push(y);
    this.PointBuffer.push(0.0);
    y = 0;
    this.PointBuffer.push(x);
    this.PointBuffer.push(y);
    this.PointBuffer.push(0.0);

    for (var i = 0; i < this.NumberOfBins; ++i) {
      x += this.BinLength;
      this.PointBuffer.push(x);
      this.PointBuffer.push(y);
      this.PointBuffer.push(0.0);
      y = this.TickSize;
      this.PointBuffer.push(x);
      this.PointBuffer.push(y);
      this.PointBuffer.push(0.0);
      y = 0;
      this.PointBuffer.push(x);
      this.PointBuffer.push(y);
      this.PointBuffer.push(0.0);
    }
  };

  function ScaleWidget () {
    this.PixelsPerMeter = 0;
    this.Shape = new Scale();
    this.Shape.OutlineColor = [0.0, 0.0, 0.0];
    this.Shape.Origin = [200, 15];
    this.Shape.BinLength = 200;
    this.Shape.FixedSize = true;

    this.Text = new SAM.Text();
    this.Text.PositionCoordinateSystem = SAM.Shape.VIEWER;
    this.Text.Position = [200, 0];
    this.Text.String = '';
    this.Text.Color = [0.0, 0.0, 0.0];
    // I want the anchor to be the center of the text.
    // This is a hackl estimate.
    this.Text.Anchor = [20, 0];

    this.State = WAITING;
  }

  // Change the length of the scale based on the camera.
  ScaleWidget.prototype.Update = function (view) {
    if (!view) { return; }
    // Compute the number of screen pixels in a meter.
    var scale = Math.round(
      view.GetPixelsPerUnit() / view.GetMetersPerUnit());
    if (this.PixelsPerMeter === scale) {
      return;
    }

    // Save the scale so we know when to regenerate.
    this.PixelsPerMeter = scale;
    var target = 200; // pixels
    var e = 0;
        // Note: this assumes max bin length is 1 meter.
    var binLengthViewer = this.PixelsPerMeter;
        // keep reducing the length until it is reasonable.
    while (binLengthViewer > target) {
      binLengthViewer = binLengthViewer / 10;
      --e;
    }
    // Now compute the units from e.
    this.Units = 'nm';
    var factor = 1e-9;
    if (e >= -6) {
      this.Units = '\xB5m';
      factor = 1e-6;
    }
    if (e >= -3) {
      this.Units = 'mm';
      factor = 1e-3;
    }
    if (e >= -2) {
      this.Units = 'cm';
      factor = 1e-2;
    }
    if (e >= 0) {
      this.Units = 'm';
      factor = 1;
    }
    if (e >= 3) {
      this.Units = 'km';
      factor = 1000;
    }
    // Length is set to the viewer pixel length of a tick / unit.
    this.Shape.BinLength = binLengthViewer;
    // Now add bins to get close to the target length.
    this.Shape.NumberOfBins = Math.floor(target / binLengthViewer);
    // compute the length of entire scale bar (units: viewer pixels).
    var scaleLengthViewer = binLengthViewer * this.Shape.NumberOfBins;
    var scaleLengthMeters = scaleLengthViewer / this.PixelsPerMeter;
    // Compute the label.
    // The round should not change the value, only get rid of numerical error.
    var labelNumber = Math.round(scaleLengthMeters / factor);
    this.Label = labelNumber.toString() + this.Units;

    // Save the length of the scale bar in world units.
    // World (highest res image) pixels default to 0.25e-6 meters.
    this.LengthWorld = scaleLengthMeters * 4e6;

    // Update the label text and position
    this.Text.String = this.Label;
    this.Text.UpdateBuffers(view);
    this.Text.Position = [this.Shape.Origin[0] + (scaleLengthViewer / 2),
      this.Shape.Origin[1] - 15];

    this.Shape.UpdateBuffers(view);
  };

  ScaleWidget.prototype.Draw = function (view) {
    if (!view || !view.HasUnits()) {
      return;
    }
    // Update the scale if zoom changed.
    this.Update(view);
    this.Shape.Draw(view);
    this.Text.Draw(view);
  };

    // This needs to be put in the Viewer.
    // ScaleWidget.prototype.RemoveFromViewer = function() {
    //    if (this.Layer) {
    //        this.RemoveWidget(this);
    //    }
    // };

  ScaleWidget.prototype.HandleKeyPress = function (keyCode, shift) {
    return true;
  };

  ScaleWidget.prototype.HandleDoubleClick = function (event) {
    return true;
  };

  ScaleWidget.prototype.HandleMouseDown = function (event) {
        /*
        if (event.which !== 1) {
            return true;
        }
        this.DragLast = this.Layer.ConvertPointViewerToWorld(event.offsetX, event.offsetY);
        */
    return false;
  };

    // returns false when it is finished doing its work.
  ScaleWidget.prototype.HandleMouseUp = function (event) {
        /*
        this.SetActive(false);
        if (window.SA) {SA.RecordState();}
        */
    return true;
  };

    // Orientation is a pain,  we need a world to shape transformation.
  ScaleWidget.prototype.HandleMouseMove = function (event) {
        /*
        if (event.which === 1) {
            var world =
                this.Layer.ConvertPointViewerToWorld(event.offsetX, event.offsetY);
            var dx, dy;
            if (this.State === DRAG) {
                dx = world[0] - this.DragLast[0];
                dy = world[1] - this.DragLast[1];
                this.DragLast = world;
                this.Shape.Origin[0] += dx;
                this.Shape.Origin[1] += dy;
            } else {
                // convert mouse from world to Shape coordinate system.
                dx = world[0] - this.Shape.Origin[0];
                dy = world[1] - this.Shape.Origin[1];
                var c = Math.cos(3.14156* this.Shape.Orientation / 180.0);
                var s = Math.sin(3.14156* this.Shape.Orientation / 180.0);
                var x = c*dx - s*dy;
                var y = c*dy + s*dx;
                // convert from shape to integer scale indexes.
                x = (0.5*this.Shape.Dimensions[0]) + (x /
                  this.Shape.Width);
                y = (0.5*this.Shape.Dimensions[1]) + (y /
                  this.Shape.Height);
                var ix = Math.round(x);
                var iy = Math.round(y);
                // Change scale dimemsions
                dx = dy = 0;
                var changed = false;
                if (this.State === DRAG_RIGHT) {
                    dx = ix - this.Shape.Dimensions[0];
                    if (dx) {
                        this.Shape.Dimensions[0] = ix;
                        // Compute the change in the center point origin.
                        dx = 0.5 * dx * this.Shape.Width;
                        changed = true;
                    }
                } else if (this.State === DRAG_LEFT) {
                    if (ix) {
                        this.Shape.Dimensions[0] -= ix;
                        // Compute the change in the center point origin.
                        dx = 0.5 * ix * this.Shape.Width;
                        changed = true;
                    }
                } else if (this.State === DRAG_BOTTOM) {
                    dy = iy - this.Shape.Dimensions[1];
                    if (dy) {
                        this.Shape.Dimensions[1] = iy;
                        // Compute the change in the center point origin.
                        dy = 0.5 * dy * this.Shape.Height;
                        changed = true;
                    }
                } else if (this.State === DRAG_TOP) {
                    if (iy) {
                        this.Shape.Dimensions[1] -= iy;
                        // Compute the change in the center point origin.
                        dy = 0.5 * iy * this.Shape.Height;
                        changed = true;
                    }
                }
                if (changed) {
                    // Rotate the translation and apply to the center.
                    x = c*dx + s*dy;
                    y = c*dy - s*dx;
                    this.Shape.Origin[0] += x;
                    this.Shape.Origin[1] += y;
                    this.Shape.UpdateBuffers(this.Layer.AnnotationView);
                }
            }
            eventuallyRender();
            return
        }

        this.CheckActive(event);
*/
    return true;
  };

  ScaleWidget.prototype.HandleMouseWheel = function (event) {
        /*
        var x = event.offsetX;
        var y = event.offsetY;

        if (this.State === ACTIVE) {
            if(this.NormalizedActiveDistance < 0.5) {
                var ratio = 1.05;
                var direction = 1;
                if(event.wheelDelta < 0) {
                     ratio = 0.95;
                    direction = -1;
                }
                if(event.shiftKey) {
                    this.Shape.BinLength = this.Shape.BinLength * ratio;
                }
                if(event.ctrlKey) {
                    this.Shape.Width = this.Shape.Width * ratio;
                }
                if(!event.shiftKey && !event.ctrlKey) {
                    this.Shape.Orientation = this.Shape.Orientation + 3 * direction;
                 }

                this.Shape.UpdateBuffers(this.Layer.AnnotationView);
                this.PlacePopup();
                eventuallyRender();
            }
        }
        */
  };

  ScaleWidget.prototype.HandleTouchPan = function (event) {
        /*
          w0 = this.Layer.ConvertPointViewerToWorld(EVENT_MANAGER.LastMouseX,
          EVENT_MANAGER.LastMouseY);
          w1 = this.Layer.ConvertPointViewerToWorld(event.offsetX,event.offsetY);

          // This is the translation.
          var dx = w1[0] - w0[0];
          var dy = w1[1] - w0[1];

          this.Shape.Origin[0] += dx;
          this.Shape.Origin[1] += dy;
          eventuallyRender();
        */
    return true;
  };

  ScaleWidget.prototype.HandleTouchPinch = function (event) {
        // this.Shape.UpdateBuffers(this.Layer.AnnotationView);
        // eventuallyRender();
    return true;
  };

  ScaleWidget.prototype.HandleTouchEnd = function (event) {
    this.SetActive(false);
  };

  ScaleWidget.prototype.CheckActive = function (event) {
        /*
        var x,y;
        if (this.Shape.FixedSize) {
            x = event.offsetX;
            y = event.offsetY;
            pixelSize = 1;
        } else {
            x = event.worldX;
            y = event.worldY;
        }
        x = x - this.Shape.Origin[0];
        y = y - this.Shape.Origin[1];
        // Rotate to scale.
        var c = Math.cos(3.14156* this.Shape.Orientation / 180.0);
        var s = Math.sin(3.14156* this.Shape.Orientation / 180.0);
        var rx = c*x - s*y;
        var ry = c*y + s*x;

        // Convert to scale coordinates (0 -> dims)
        x = (0.5*this.Shape.Dimensions[0]) + (rx / this.Shape.Width);
        y = (0.5*this.Shape.Dimensions[1]) + (ry / this.Shape.Height);
        var ix = Math.round(x);
        var iy = Math.round(y);
        if (ix < 0 || ix > this.Shape.Dimensions[0] ||
            iy < 0 || iy > this.Shape.Dimensions[1]) {
            this.SetActive(false);
            return false;
        }

        // x,y get the residual in pixels.
        x = (x - ix) * this.Shape.Width;
        y = (y - iy) * this.Shape.Height;

        // Compute the screen pixel size for tollerance.
        var tolerance = 5.0 / this.Layer.GetPixelsPerUnit();

        if (Math.abs(x) < tolerance || Math.abs(y) < tolerance) {
            this.SetActive(true);
            if (ix === 0) {
                this.State = DRAG_LEFT;
                thisLayer.AnnotationView.Parent.css({'cursor':'col-resize'});
            } else if (ix === this.Shape.Dimensions[0]) {
                this.State = DRAG_RIGHT;
                this.Layer.AnnotationView.Parent.css({'cursor':'col-resize'});
            } else if (iy === 0) {
                this.State = DRAG_TOP;
                this.Viewer.AnnotationView.Parent.css({'cursor':'row-resize'});
            } else if (iy === this.Shape.Dimensions[1]) {
                this.State = DRAG_BOTTOM;
                this.Layer.MainView.Parent.css({'cursor':'row-resize'});
            } else {
                this.State = DRAG;
                this.Layer.MainView.Parent.css({'cursor':'move'});
            }
            return true;
        }
        */
    this.SetActive(false);
    return false;
  };

    // Multiple active states. Active state is a bit confusing.
  ScaleWidget.prototype.GetActive = function () {
    if (this.State === WAITING) {
      return false;
    }
    return true;
  };

  ScaleWidget.prototype.Deactivate = function () {
    // this.View.Parent.css({'cursor': 'default'});
    // this.Popup.StartHideTimer();
    this.State = WAITING;
    this.Shape.Active = false;
    // this.Layer.DeactivateWidget(this);
    // if (this.DeactivateCallback) {
    //   this.DeactivateCallback();
    // }
    this.Layer.EventuallyDraw();
  };

    // Setting to active always puts state into "active".
    // It can move to other states and stay active.
  ScaleWidget.prototype.SetActive = function (flag) {
    if (flag === this.GetActive()) {
      return;
    }

    if (flag) {
      this.State = ACTIVE;
      this.Shape.Active = true;
      // this.Layer.ActivateWidget(this);
      // this.Layer.EventuallyDraw();
      // Compute the location for the pop up and show it.
    } else {
      this.Deactivate();
    }
    // this.Layer.EventuallyDraw();
  };

  SAM.ScaleWidget = ScaleWidget;
})();

(function () {
  'use strict';

  function Dialog (parent) {
    parent = parent || 'body';
    if (!SAM.DialogOverlay) {
      SAM.DialogOverlay = $('<div>')
                .appendTo(parent)
                .css({
                  'position': 'fixed',
                  'left': '0px',
                  'width': '100%',
                  'background-color': '#AAA',
                  'opacity': '0.4',
                  'z-index': '1010'})
                .saFullHeight()
                .hide();
    }

    this.Dialog =
            $('<div>')
            .appendTo(parent)
            .css({'z-index': '1011'})
            .addClass('sa-view-dialog-div');

    this.Row1 = $('<div>')
            .addClass('sa-view-dialog-title')
            .appendTo(this.Dialog)
            .css({'width': '100%',
              'height': '2.5em',
              'box-sizing': 'border-box'});
    this.Title = $('<div>')
            .appendTo(this.Row1)
            .css({'float': 'left'})
            .addClass('sa-view-dialog-title')
            .text('Title');
    this.CloseButton = $('<div>')
            .appendTo(this.Row1)
            .css({'float': 'right'})
            .addClass('sa-view-dialog-close')
            .text('Close');

    this.Body =
            $('<div>')
            .appendTo(this.Dialog)
            .css({'width': '100%',
              'box-sizing': 'border-box',
              'margin-bottom': '30px'});

    this.ApplyButtonDiv = $('<div>')
            .appendTo(this.Dialog)
            .addClass('sa-view-dialog-apply-div');
    this.ApplyButton = $('<button>')
            .appendTo(this.ApplyButtonDiv)
            .addClass('sa-view-dialog-apply-button')
            .text('Apply');
  }

  Dialog.prototype.SetApplyCallback = function (callback) {
    var self = this;
    // Return true needed to hide the spectrum color picker.
    self.ApplyButton.click(function (e) {
      // hack
      SA.ContentEditableHasFocus = false;
      self.Hide();
      (callback)();
      return true;
    });
  };

  Dialog.prototype.SetCloseCallback = function (callback) {
    var self = this;
    // Return true needed to hide the spectrum color picker.
    this.CloseButton.click(function (e) {
      SA.ContentEditableHasFocus = false;
      self.Hide();
      (callback)();
      return true;
    });
  };

  Dialog.prototype.Show = function (modal) {
        // hack
    SA.ContentEditableHasFocus = true;
    var self = this;
    SAM.DialogOverlay.show();
    this.Dialog.fadeIn(300);

    if (modal) {
      SAM.DialogOverlay.off('click.dialog');
    } else {
      SAM.DialogOverlay.on(
                'click.dialog',
                function (e) { self.Hide(); });
    }
    SAM.ContentEditableHasFocus = true; // blocks viewer events.
  };

  Dialog.prototype.Hide = function () {
    SAM.DialogOverlay.off('click.dialog');
    SAM.DialogOverlay.hide();
    this.Dialog.fadeOut(300);
    SAM.ContentEditableHasFocus = false;
  };

  SAM.Dialog = Dialog;
})();

// ==============================================================================
// Iterate over ractangle annotations.
// Right now, add an arrow for each.

// Load arrows on page load and next image.
// Save arrows on next image.

// TODO: Merge this with annotation editor.  Copied from that class, and much of the code is the same.

(function () {
  'use strict';

  // action states
  var KEY_UP = 0;
  // var KEY_DOWN = 1;
  // var KEY_USED_ADVANCE = 2;
  // var KEY_USED_NO_ADVANCE = 3;

  var GirderAnnotationIterator = function (parent, viewer, itemId, classes) {
    // when iterating, only show the current rect.
    this.HighlightedRect = new SAM.Rect();
    this.HighlightedRect.OutlineColor = [1, 1, 0];

    // quick hack to add arrows.
    this.ArrowMode = true;

    // Make an anntoation layer a helper object.
    this.ViewerParent = viewer.GetDiv();
    this.Layer = new SAM.AnnotationLayer(this.ViewerParent);
    this.Layer.SetCamera(viewer.GetCamera());
    viewer.AddLayer(this);

    if (this.ArrowMode) {
      this.ArrowLayer = new SAM.AnnotationLayer(this.ViewerParent);
      this.ArrowLayer.SetCamera(viewer.GetCamera());
      this.LoadItemArrows(itemId, 'plane-nose', this.ArrowLayer);
    }

    this.Viewer = viewer;
    this.ActiveClassIndex = 0;
    this.ItemId = itemId;
    this.CreateClasses(classes);

    // Combined key click action.
    this.ActionState = KEY_UP;

    this.InitializeGui(parent, 'GirderAnnotationIterator');

    // Mode: stepping through ( and processing events).
    this.IteratorIndex = -1;

    // active class is highlighted in the gui.
    // It is the class used for clicks
    this.SetActiveClassIndex(0);
  };

  // Since we have to make forwarding methods, just use the layer as a helper object.
  GirderAnnotationIterator.prototype.EventuallyDraw = function () {
    if (!this.RenderPending) {
      this.RenderPending = true;
      var self = this;
      window.requestAnimationFrame(
        function () {
          self.RenderPending = false;
          self.Draw();
        });
    }
    // this.Layer.EventuallyDraw();
  };
  GirderAnnotationIterator.prototype.GetView = function () {
    return this.Layer.GetView();
  };
  GirderAnnotationIterator.prototype.GetCamera = function () {
    return this.Layer.GetCamera();
  };
  GirderAnnotationIterator.prototype.Remove = function () {
    // We are moving to the next slide in the folder and this object is being
    // discarded. Save the arrows.
    // this.Save();

    this.LayerControl.remove();
    this.InstructionsHeading.remove();
    this.InstructionsUL.remove();

    this.Layer.Remove();
    if (this.ArrowLayer) {
      this.ArrowLayer.Remove();
    }
    this.Viewer.RemoveLayer(this);
  };
  GirderAnnotationIterator.prototype.UpdateSize = function () {
    this.Layer.UpdateSize();
    if (this.ArrowLayer) {
      this.ArrowLayer.UpdateSize();
    }
  };

  GirderAnnotationIterator.prototype.CreateClasses = function (classNames) {
    var numClasses = classNames.length;
    this.Classes = [];
    for (var i = 0; i < numClasses; ++i) {
      var classObj = {
        label: classNames[i],
        index: i};
      this.Classes.push(classObj);
      // assign colors to the labels
      // detections will be yellow
      // Detection class is yellow.
      if (i === 0) {
        classObj.color = '#FFFF00';
      } else if (i === 1) { // Second (false positive) is red
        classObj.color = '#FF0000';
      } else if (i === 2) { // last (true positive) is green
        classObj.color = '#00FF00';
      } else {
        // the rest will range from purple to cyan
        var k = (i - 3) / (numClasses - 4);
        this.Classes[i].color = SAM.ConvertColorToHex([k, 1 - k, 1]);
      }
      this.RequestAnnotationFromName(classObj);
    }
  };

  GirderAnnotationIterator.prototype.RequestAnnotationFromName = function (classObj) {
    if (!window.girder) {
      window.alert('Could not find girder client');
      return;
    }
    var self = this;
    girder.rest.restRequest({
      url: 'annotation?itemId=' + this.ItemId + '&name=' + classObj.label + '&limit=1',
      method: 'GET'
    }).done(function (data) {
      if (data.length > 0) {
        // The annotation exists.  Reuest it.
        classObj.annotation_id = data[0]['_id'];
        self.RequestAnnotationFromId(classObj);
      } else {
        // Annotation does not exist yet.  Make it.
        var annot = {
          'elements': [],
          'name': classObj.label};
        // Make a new annotation in the database.
        girder.rest.restRequest({
          url: 'annotation?itemId=' + self.ItemId,
          method: 'POST',
          contentType: 'application/json',
          data: JSON.stringify(annot)
        }).done(function (retAnnot) {
          // This has the girder id.
          classObj.annotation_id = retAnnot['_id'];
          self.LoadAnnotation(retAnnot, classObj);
        });
      }
    });
  };

  GirderAnnotationIterator.prototype.RequestAnnotationFromId = function (classObj) {
    if (!window.girder) {
      window.alert('Could not find girder client');
      return;
    }
    var self = this;
    girder.rest.restRequest({
      url: 'annotation/' + classObj.annotation_id,
      method: 'GET',
      contentType: 'application/json'
    }).done(function (data) {
      self.LoadAnnotation(data, classObj);
    });
  };

  // TODO: Share this code (to parse girder data) with girderWidget.
  GirderAnnotationIterator.prototype.LoadAnnotation = function (data, classObj) {
    // Used for saving the annotation back to girder.
    classObj.annotation = data.annotation;

    // Put all the rectangles into one set.
    var setObj = {};
    setObj.type = 'rect_set';
    setObj.centers = [];
    setObj.widths = [];
    setObj.heights = [];
    setObj.confidences = [];
    setObj.labels = [];

    var annot = data.annotation;
    for (var i = 0; i < annot.elements.length; ++i) {
      var element = annot.elements[i];

      if (element.type === 'rectangle') {
        setObj.widths.push(element.width);
        setObj.heights.push(element.height);
        setObj.centers.push(element.center[0]);
        setObj.centers.push(element.center[1]);
        if (element.scalar === undefined) {
          element.scalar = 1.0;
        }
        setObj.confidences.push(element.scalar);
        // ignore the database label because we use our own
        setObj.labels.push(classObj.label);
      }
    }

    var widget = new SAM.RectSetWidget();
    widget.Load(setObj);
    widget.Hash = new SpatialHash();
    var bds = this.Viewer.GetOverViewBounds();
    widget.Hash.Build(widget.Shape, bds);

    // We want to color by labels (not widget)
    var shape = widget.Shape;
    if (!shape.LabelColors) {
      shape.LabelColors = {};
      // Colors setup in contructor.
      for (i = 0; i < this.Classes.length; ++i) {
        shape.LabelColors[this.Classes[i].label] = this.Classes[i].color;
      }
    }

    classObj.widget = widget;
    widget.Shape.SetOutlineColor(classObj.color);
    this.EventuallyDraw();
  };

  // Use the last size, or one from the active widgets.
  // Limit by sensible sizes for the viewer.
  GirderAnnotationIterator.prototype.GetSquareSize = function () {
    // if (localStorage.GirderAnnotationIteratorDefaults) {
    //   var defaults = JSON.parse(localStorage.GirderAnnotationIteratorDefaults);
    var size = 64;
    if (this.SquareSize) {
      // Default to the last size applied
      size = this.SquareSize;
    } else if (this.Classes.length > 0) {
      // Look to previous annotations for a size/
      var classObj = this.Classes[this.ActiveClassIndex];
      if (classObj.widget) {
        var rectSet = classObj.widget.Shape;
        if (rectSet.Heights.length > 0) {
          size = rectSet.Heights[0];
        }
      }
    }
    // Constrain the size to be visible.
    var cam = this.GetCamera();
    var viewHeight = cam.GetHeight();
    if (size > viewHeight / 0.75) {
      size = viewHeight / 0.75;
      this.SquareSize = size;
    }
    // Use pixel size to limit the smaller rect.
    var viewPixelSize = cam.GetSpacing();
    if (size < viewPixelSize * 10) {
      size = viewPixelSize * 10;
      this.SquareSize = size;
    }

    return size;
  };

  // Returns true if it was a valid class index.
  GirderAnnotationIterator.prototype.SetActiveClassIndex = function (idx) {
    if (idx < 0 || idx >= this.Classes.length) {
      return false;
    }
    this.Classes[this.ActiveClassIndex].gui
            .css({'background-color': '#FFF'});
    this.ActiveClassIndex = idx;
    this.Classes[idx].gui
            .css({'background-color': '#DEF'});
    this.SetCursorColor(this.ViewerParent, this.Classes[idx].color);
    if (!this.IteratorClass) {
      var selectedClass = this.Classes[idx];
      this.ActiveLabel.text(selectedClass.label);
    }
    return false;
  };

  GirderAnnotationIterator.prototype.GetActive = function () {
    // return this.IteratorIndex > -1;
    return true;
  };

  // TODO: Clean this up.  Probably put the widgets in the layer.
  GirderAnnotationIterator.prototype.Draw = function () {
    this.Layer.Draw();
    var view = this.Layer.GetView();
    this.HighlightedRect.Draw(view);
    if (this.ArrowLayer) {
      this.ArrowLayer.Draw();
    }

    for (var i = 0; i < this.Classes.length; ++i) {
      if (this.Classes[i].widget) {
        this.Classes[i].widget.Draw(this.Layer);
      }
    }
  };

  GirderAnnotationIterator.prototype.HandleMouseDown = function (event) {
    if (this.ArrowLayer) {
      return this.ArrowLayer.HandleMouseDown(event);
    }
    return true;
  };

  GirderAnnotationIterator.prototype.HandleMouseUp = function (event) {
    if (this.ArrowLayer) {
      return this.ArrowLayer.HandleMouseUp(event);
    }
    return true;
  };

  GirderAnnotationIterator.prototype.HandleMouseClick = function (event) {
    // We even give inactive layers a chance to claim the selection.
    // It is a way to find which group a mark belongs to.
    var selectedWidget = this.ArrowLayer.HandleSelect(event);
    if (selectedWidget === this.SelectedWidget) {
      return;
    }
    if (this.SelectedWidget) {
      this.SelectedWidget.SetActive(false);
      this.SelectedWidget.SetSelected(false);
    }
    if (selectedWidget) {
      selectedWidget.SetActive(true);
      this.SelectedWidget = selectedWidget;
      return false;
    }
    this.SelectedWidget = undefined;
    return true;
  };

  // Highlight on hover.
  GirderAnnotationIterator.prototype.HandleMouseMove = function (event) {
    if (this.ArrowLayer) {
      return this.ArrowLayer.HandleMouseMove(event);
    }
    return true;
  };

  // Make the annotation larger and smaller with the mouse wheel.
  // TODO: Remove this legacy function
  GirderAnnotationIterator.prototype.HandleMouseWheel = function (event) {
    return true;
  };

  // Stepping through the detection sequence.
  // -1 is none
  GirderAnnotationIterator.prototype.SetIteratorIndex = function (idx) {
    // Highlight the current
    this.SetHighlightedRect(this.IteratorClass, idx);
    this.IteratorIndex = idx;
    if (idx === -1) {
      this.IteratorClass = undefined;
    }
    // Animate to put this rec in the middle of the view.
    this.UpdateActiveView();
  };

  // The highlighted rect (sometimes the same as the
  // iteration index / rect).
  GirderAnnotationIterator.prototype.SetHighlightedRect = function (classObj, idx) {
    var widget = classObj.widget;
    var rectSet = widget.Shape;

    widget.Visibility = false;
    this.HighlightedRect.Visibility = true;
    this.HighlightedRect.Width = rectSet.Widths[idx];
    this.HighlightedRect.Height = rectSet.Heights[idx];
    this.HighlightedRect.Orientation = 0; // rectSet.Orientations[idx];
    var x = rectSet.Centers[idx * 2];
    var y = rectSet.Centers[idx * 2 + 1];
    this.HighlightedRect.Origin = [x, y];
    // this.OutlineColor = [0, 0, 0];
    this.HighlightedRect.UpdateBuffers();

    this.EventuallyDraw();
  };

  GirderAnnotationIterator.prototype.HandleKeyDown = function (event) {
    if (this.IteratorClass) {
      return false;
    }
    if (this.ArrowLayer) {
      return this.ArrowLayer.HandleMouseUp(event);
    }
    return true;
  };

  GirderAnnotationIterator.prototype.HandleKeyUp = function (event) {
    if (this.IteratorClass) {
      // iterating
      if (event.keyCode === 46 || event.keyCode === 8) { // delete key
        if (this.ArrowLayer) {
          this.ArrowLayer.DeleteSelected();
          this.ArrowLayer.EventuallyDraw();
        }
        event.preventDefault();
        return false;
      }

      // Escape key stops iteration.
      if (event.keyCode === 27) { // escape
        this.Stop();
        return false;
      }

      // Forward and backward.
      if (this.IteratorClass) {
        if (event.keyCode === 37) {
          // Left cursor key
          this.ChangeCurrent(-1);
          return false;
        } else if (event.keyCode === 39 || event.keyCode === 32) {
          // Right cursor key (or space bar)
          this.ChangeCurrent(1);
          return false;
        }
      }
    }

    if (this.ArrowLayer) {
      return this.ArrowLayer.HandleMouseUp(event);
    }
    return true;
  };

  // Animate to the new current rect.
  GirderAnnotationIterator.prototype.UpdateActiveView = function () {
    if (this.IteratorClass === undefined ||
        this.IteratorClass.widget === undefined) {
      return true;
    }

    var rectSet = this.IteratorClass.widget.Shape;

    // Change the index / confidence label.
    var idx = this.IteratorIndex;
    if (idx < 0) {
      var selectedClass = this.Classes[this.ActiveClassIndex];
      this.ActiveLabel.text(selectedClass.label);
      return;
    } else {
      this.ActiveLabel.text(idx.toString() + ' of ' +
                            rectSet.Labels.length.toString() + ', ' +
                            rectSet.Confidences[idx].toPrecision(2) +
                            ', ' + rectSet.Labels[idx]);
    }

    var viewer = this.Viewer;
    // viewer.ZoomTarget = this.Layer.GetCamera().GetHeight();
    viewer.RollTarget = this.GetCamera().GetWorldRoll();
    viewer.TranslateTarget = rectSet.GetCenter(this.IteratorIndex);
    viewer.AnimateLast = new Date().getTime();
    viewer.AnimateDuration = 200.0;
    viewer.EventuallyRender(true);
  };

  GirderAnnotationIterator.prototype.HandleArrowFinished = function (widget) {
    this.ArrowWidget = undefined;
  };

  GirderAnnotationIterator.prototype.StartArrow = function (widget) {
    if (this.SelectedWidget) {
      this.SelectedWidget.SetActive(false);
      this.SelectedWidget.SetSelected(false);
    }
    var self = this;
    if (!this.ArrowWidget) {
      this.ArrowWidget = new SAM.ArrowWidget(this.ArrowLayer);
      this.ArrowWidget.SetColor('#00ffff');
      this.ArrowWidget.Arrow.Width = 2.0;
      this.ArrowLayer.AddWidget(this.ArrowWidget);
      this.ArrowWidget.SetStateToDrawing();
      this.ArrowWidget.SetStateChangeCallback(
        function (widget) { self.HandleArrowFinished(widget); });
    }
  };

  GirderAnnotationIterator.prototype.LoadItemArrows = function (itemId, name, layer) {
    var self = this;
    girder.rest.restRequest({
      url: 'annotation?itemId=' + itemId + '&name=' + name + '&limit=1',
      method: 'GET'
    }).done(function (data) {
      if (data.length > 0) {
        // The annotation exists.  Reuest it.
        self.ArrowAnnotationId = data[0]['_id'];
        girder.rest.restRequest({
          url: 'annotation/' + self.ArrowAnnotationId,
          method: 'GET',
          contentType: 'application/json'
        }).done(function (data) {
          self.LoadAnnotationArrows(data);
        });
      } else {
        // Annotation does not exist yet.  Make an empty one.
        var annot = {
          'elements': [],
          'name': name};
        self.ArrowAnnotation = annot;
        // Make a new annotation in the database.
        girder.rest.restRequest({
          url: 'annotation?itemId=' + itemId,
          method: 'POST',
          contentType: 'application/json',
          data: JSON.stringify(annot)
        }).done(function (retAnnot) {
          // This has the girder id.
          self.ArrowAnnotationId = retAnnot['_id'];
        });
      }
    });
  };

  // TODO: Share this code (to parse girder data) with girderWidget.
  GirderAnnotationIterator.prototype.LoadAnnotationArrows = function (data, classObj) {
    // Used for saving the annotation back to girder.
    this.ArrowAnnotation = data.annotation;

    var annot = data.annotation;
    for (var i = 0; i < annot.elements.length; ++i) {
      var element = annot.elements[i];
      var dx = element.points[1][0] - element.points[0][0];
      var dy = element.points[1][1] - element.points[0][1];
      var length = Math.sqrt(dx * dx + dy * dy);
      var orientation = Math.atan2(dy, dx) * 180 / Math.PI;

      if (element.type === 'arrow') {
        var obj = {
          origin: element.points[0],
          length: length,
          width: element.lineWidth,
          orientation: orientation,
          fillcolor: SAM.ConvertColor(element.fillColor),
          outlinecolor: SAM.ConvertColor(element.lineColor)
        };
        var widget = new SAM.ArrowWidget(this.ArrowLayer);
        widget.Load(obj);
        this.ArrowLayer.AddWidget(widget);
      }
    }

    this.EventuallyDraw();
  };

  // Forward = 1, backward = -1
  GirderAnnotationIterator.prototype.ChangeCurrent = function (direction) {
    if (this.IteratorClass.widget === undefined) {
      return true;
    }
    var rectSet = this.IteratorClass.widget.Shape;
    var index = this.IteratorIndex;
    var confThresh = this.GetConfidenceThreshold();

    // loop to skip rects below the threshold
    while (true) {
      index += direction;
      if (index < 0 || index >= rectSet.Widths.length) {
        this.Stop();
        return;
      }
      if (rectSet.Confidences[index] >= confThresh) {
        if (this.ArrowMode) {
          this.StartArrow();
        }
        this.SetIteratorIndex(index);
        return;
      }
    }
  };

  GirderAnnotationIterator.prototype.HandleClick = function (event) {
    return true;
  };

  // Initialize the gui / dom
  GirderAnnotationIterator.prototype.InitializeGui = function (parent, label) {
    var self = this;

    // The wrapper div that controls a single layer.
    this.LayerControl = $('<div>')
      .appendTo(parent)
      .css({
        'border': '1px solid #CCC',
        'width': '100%'
      });

    this.ActiveLabel = $('<div>')
      .appendTo(this.LayerControl)
      .prop('title', 'Start sorting detections')
      .attr('contenteditable', 'false')
      .text('');

    var buttonContainer = $('<p>')
      .appendTo(this.LayerControl);
    this.StartStopButton = $('<button>')
      .appendTo(buttonContainer)
      .text('Start')
      .css({'background-color': '#5F5'})
      .prop('title', 'Start sorting detections')
      // .button()
      .css({'width': '5em'})
      .on('click', function () { self.StartStop(); });
    $('<button>')
      .appendTo(buttonContainer)
      .text('Save')
      .prop('title', 'Save annotations to server')
      .click(function () { self.Save(); });

    // Wrapper for the confidence slider.
    var confWrapper = $('<div>')
      .appendTo(this.LayerControl)
      .css({
        'border': '1px solid #CCC',
        'width': '100%',
        'height': '50px'
      });

    this.Slider = $('<input type="range" min="0" max="100">')
      .appendTo(confWrapper)
      .on('input',
          function () {
            self.SliderCallback();
          });

    $('<div>')
      .appendTo(confWrapper)
      .html('0%')
      .css({ 'float': 'left' });
    $('<div>')
      .appendTo(confWrapper)
      .html('Confidence')
      .css({
        'float': 'right',
        'position': 'relative',
        'left': '-50%',
        'text-align': 'left'});
    $('<div>')
      .appendTo(confWrapper)
      .html('100%')
      .css({ 'float': 'right' });

    var classContainer = $('<p>')
      .appendTo(this.LayerControl);
    for (var i = 0; i < this.Classes.length; ++i) {
      this.MakeClassButton(classContainer, i);
    }

    // Instructions
    this.InstructionsHeading = $('<h4>')
      .appendTo(parent)
      .text('Instructions');
    this.InstructionsUL = $('<ul>')
      .appendTo(parent);
    var browsingLI = $('<li>')
      .appendTo(this.InstructionsUL)
      .text('Browsing');
    var browsingUL = $('<ul>')
      .appendTo(browsingLI);
    $('<li>')
      .appendTo(browsingUL)
      .text('Arrow keys: pan screen');
    $('<li>')
      .appendTo(browsingUL)
      .text('Left mouse drag: pan');
    $('<li>')
      .appendTo(browsingUL)
      .text('Scroll wheel: zoom');
    $('<li>')
      .appendTo(browsingUL)
      .text('"<" button: previous image');
    $('<li>')
      .appendTo(browsingUL)
      .text('">" button: next image');
    $('<li>')
      .appendTo(browsingUL)
      .text('"Start" button: iterate over all planes');

    var iteratingLI = $('<li>')
      .appendTo(this.InstructionsUL)
      .text('Iterating');
    var iteratingUL = $('<ul>')
      .appendTo(iteratingLI);
    $('<li>')
      .appendTo(iteratingUL)
      .text('Space bar: advance to next plane');
    $('<li>')
      .appendTo(iteratingUL)
      .text('Right arrow key: advance to next plane');
    $('<li>')
      .appendTo(iteratingUL)
      .text('Left arrow key: back to previos plane');
    $('<li>')
      .appendTo(iteratingUL)
      .text('A new arrow is automatically triggerd when you advance');
    $('<li>')
      .appendTo(iteratingUL)
      .text("Mouse down: place the arrow's tip");
    $('<li>')
      .appendTo(iteratingUL)
      .text("Drag with mouse down: place the arrow's base");
    $('<li>')
      .appendTo(iteratingUL)
      .text('Mouse up: finish the arrow');
    $('<li>')
      .appendTo(iteratingUL)
      .text('Click on an arrow to make it dragable');
  };

  GirderAnnotationIterator.prototype.MakeClassButton = function (classContainer, index) {
    var self = this;
    var classObj = this.Classes[index];
    classObj.gui = $('<div>')
            .appendTo(classContainer)
            .text((index).toString() + ': ' + classObj.label)
            .css({'color': classObj.color})
            .click(function () { self.SetActiveClassIndex(index); });
  };

  GirderAnnotationIterator.prototype.UpdateHash = function () {
    var bds = this.Viewer.GetOverViewBounds();
    for (var i = 0; i < this.Classes.length; ++i) {
      var widget = this.Classes[i].widget;
      widget.Hash.Build(widget.Shape, bds);
    }
  };

  GirderAnnotationIterator.prototype.GetConfidenceThreshold = function () {
    return parseInt(this.Slider.val()) / 100.0;
  };

  // Confidence threshold slider.
  GirderAnnotationIterator.prototype.SliderCallback = function () {
    var visValue = this.GetConfidenceThreshold();
    for (var i = 0; i < this.Classes.length; ++i) {
      if (this.Classes[i].widget) {
        this.Classes[i].widget.SetThreshold(visValue);
      }
    }
    this.EventuallyDraw();
    // In case we are iterating and the curent becomes invisible.
    this.CheckIteratorVisibility();
  };

  GirderAnnotationIterator.prototype.CheckIteratorVisibility = function () {
    if (!this.IteratorClass || this.IteratorIndex < 0) {
      return;
    }
    // In case the first is not visible.
    var rectSet = this.IteratorClass.widget.Shape;
    var confThresh = this.GetConfidenceThreshold();
    if (rectSet.Confidences[this.IteratorIndex] < confThresh) {
      this.ChangeCurrent(1);
    }
  };

  GirderAnnotationIterator.prototype.Stop = function () {
    this.SetIteratorIndex(-1);
    this.InteractorClass = undefined;
    this.StartStopButton
      .text('Start')
      .css({'background-color': '#5F5'})
      .prop('title', 'Start sorting detections');
  };

  // Start iterating over the selected class.
  GirderAnnotationIterator.prototype.Start = function () {
    this.Viewer.Focus();
    // zoom in
    var viewer = this.Viewer;
    viewer.ZoomTarget = 500;
    this.IteratorClass = this.Classes[this.ActiveClassIndex];
    if (this.IteratorClass.widget.Shape.GetLength() < 1) {
      window.alert('No annotations in ' + this.IteratorClass.label);
      this.IteratorClass = undefined;
      return;
    }
    this.SetIteratorIndex(0);
    // In case the first is not visible.
    this.CheckIteratorVisibility();
    this.StartStopButton
      .text('Stop')
      .css({'background-color': '#F55'})
      .prop('title', 'Stop sorting detections');

    if (this.ArrowMode) {
      this.StartArrow();
    }
  };

  // Stop iterating.
  GirderAnnotationIterator.prototype.StartStop = function () {
    if (this.IteratorClass) {
      // Currently interating: Stop action
      this.Stop();
    } else {
      // Not interating yet:  Start action
      this.Start();
    }
  };

  // Move labeled rects in detections to classes.
  // Called before annotations are saved to the database
  GirderAnnotationIterator.prototype.SplitDetections = function () {
    // Build an object to make indexing classes easier.
    var shapes = {};
    for (var i = 0; i < this.Classes.length; ++i) {
      shapes[this.Classes[i].label] = this.Classes[i];
      // Create a new rectSet for each class.
      // Best way to deal with the shuffle.
      this.Classes[i].newRectSet = new SAM.RectSet();
      this.Classes[i].newRectSet.LabelColors = this.Classes[i].widget.Shape.LabelColors;
      this.Classes[i].newRectSet.Threshold = this.Classes[i].widget.Shape.Threshold;
    }

    for (i = 0; i < this.Classes.length; ++i) {
      var inRectSet = this.Classes[i].widget.Shape;
      for (var inIdx = 0; inIdx < inRectSet.GetLength(); ++inIdx) {
        var label = inRectSet.Labels[inIdx];
        var outRectSet = shapes[label].newRectSet;
        outRectSet.CopyRectangle(inRectSet, inIdx,
                                 outRectSet.GetLength());
      }
    }

    // Now keep the new rect sets and dispose of the old.
    for (i = 0; i < this.Classes.length; ++i) {
      this.Classes[i].widget.Shape = this.Classes[i].newRectSet;
      delete this.Classes[i].newRectSet;
    }

    this.UpdateHash();
  };

  GirderAnnotationIterator.prototype.Save = function () {
    // Save arrows in the database
    var annotation = this.ArrowAnnotation;
    annotation.elements = this.ArrowLayerToGirderElements(this.ArrowLayer);
    SA.PushProgress();
    girder.rest.restRequest({
      url: 'annotation/' + this.ArrowAnnotationId,
      method: 'PUT',
      data: JSON.stringify(annotation),
      contentType: 'application/json'
    }).done(function () { SA.PopProgress(); });
  };

  // returns an elements array.
  GirderAnnotationIterator.prototype.ArrowLayerToGirderElements = function (layer) {
    var returnElements = [];

    for (var idx = 0; idx < layer.GetNumberOfWidgets(); ++idx) {
      var widget = layer.GetWidget(idx).Serialize();
      var pt1 = [widget.origin[0], widget.origin[1], 0];
      var pt2 = [widget.origin[0], widget.origin[1], 0];
      var theta = widget.orientation * Math.PI / 180.0;
      pt2[0] += widget.length * Math.cos(theta);
      pt2[1] += widget.length * Math.sin(theta);
      var points = [pt1, pt2];
      var element = {
        'type': 'arrow',
        'lineWidth': widget.width,
        'fillColor': SAM.ConvertColorToHex(widget.fillcolor),
        'lineColor': SAM.ConvertColorToHex(widget.outlinecolor),
        'points': points};
      returnElements.push(element);
    }
    return returnElements;
  };

  // Converts rectSetWidget into girder annotation elements.
  // returns an elements array.
  GirderAnnotationIterator.prototype.RectSetToGirderElements = function (rectSetWidget) {
    var returnElements = [];

    var widget = rectSetWidget.Serialize();
    var num = widget.widths.length;
    for (var j = 0; j < num; ++j) {
      var element = {'type': 'rectangle',
        'label': {'value': widget.labels[j]},
        'center': [widget.centers[2 * j], widget.centers[2 * j + 1], 0],
        'height': widget.heights[j],
        'width': widget.widths[j],
        'rotation': 0,
        'scalar': widget.confidences[j]};
      returnElements.push(element);
    }
    return returnElements;
  };

  // Now we are always active.  We have interaction state === ITERATING to
  // indicate cycling through annotations one by one.
  GirderAnnotationIterator.prototype.SetActive = function (active) {
    if (active === this.Active) {
      return;
    }
    this.Active = active;
    this.EventuallyDraw();
  };

  GirderAnnotationIterator.prototype.SetCursorColor = function (element, color) {
    // create off-screen canvas
    var cursor = document.createElement('canvas');
    var ctx = cursor.getContext('2d');

    cursor.width = 16;
    cursor.height = 24;

    // draw an arrow

    // ctx.lineWidth = 1;
    ctx.moveTo(0, 18);
    ctx.lineTo(0, 0); // tip
    ctx.lineTo(12, 12);
    ctx.lineTo(7, 13);
    ctx.lineTo(11, 21);
    ctx.lineTo(8, 22);
    ctx.lineTo(4, 14);
    ctx.closePath();

    ctx.fillStyle = color;
    ctx.fill();
    ctx.strokeStyle = '#000';
    ctx.stroke();

    // set image as cursor (modern browsers can take PNGs as cursor).
    element[0].style.cursor = 'url(' + cursor.toDataURL() + '), auto';
  };

  // 2d
  // I am extending the annotations from simple points to rectangles with
  // different sizes.  Each item will be added to multiple bins.
  // This serves two purposes.
  // Given a point, find the (best) picked renctanlge.
  // Given a rectangle find all rectangle that overlap
  function SpatialHash () {
    // Must be initialized before use.
  }

  SpatialHash.prototype.Initialize = function (bounds, size) {
    this.Origin = [bounds[0], bounds[2]];
    this.BinSize = Math.sqrt((bounds[1] - bounds[0]) * (bounds[3] - bounds[2]) / (size + 1));
    this.XDim = Math.ceil((bounds[1] - bounds[0]) / this.BinSize);
    this.YDim = Math.ceil((bounds[3] - bounds[2]) / this.BinSize);
    this.Grid = new Array(this.YDim);
    for (var y = 0; y < this.YDim; ++y) {
      var row = new Array(this.XDim);
      for (var x = 0; x < this.XDim; ++x) {
        row[x] = [];
      }
      this.Grid[y] = row;
    }
  };

  SpatialHash.prototype.Add = function (center, w, h, idx) {
    var x, y;
    x = center[0] - (w / 2);
    var col1 = Math.floor((x - this.Origin[0]) / this.BinSize);
    col1 = Math.max(Math.min(col1, this.XDim - 1), 0);
    x = center[0] + (w / 2);
    var col2 = Math.floor((x - this.Origin[0]) / this.BinSize);
    col2 = Math.max(Math.min(col2, this.XDim - 1), 0);

    y = center[1] - (h / 2);
    var row1 = Math.floor((y - this.Origin[1]) / this.BinSize);
    row1 = Math.max(Math.min(row1, this.YDim - 1), 0);
    y = center[1] + (h / 2);
    var row2 = Math.floor((y - this.Origin[1]) / this.BinSize);
    row2 = Math.max(Math.min(row2, this.YDim - 1), 0);

    for (var r = row1; r <= row2; ++r) {
      for (var c = col1; c <= col2; ++c) {
        this.Grid[r][c].push(idx);
      }
    }
  };

  // This object does not detect when the rect widget changes.
  SpatialHash.prototype.Build = function (rectSet, bounds) {
    this.RectSet = rectSet;
    var numRects = rectSet.GetLength();
    this.Initialize(bounds, numRects);
    for (var idx = 0; idx < numRects; ++idx) {
      var tmp = idx << 1;
      this.Add([rectSet.Centers[tmp], rectSet.Centers[tmp + 1]],
               rectSet.Widths[idx], rectSet.Heights[idx], idx);
    }
  };

  // Returns the index of the best rect for the point selected.
  // Returns -1 if there are no rects containing the point.
  SpatialHash.prototype.Get = function (pt, confThresh) {
    // Find binds touching this square.
    // Transform bounds to grid indexes  (keep in range).
    var x = Math.max(Math.min(
      Math.floor((pt[0] - this.Origin[0]) / this.BinSize), this.XDim - 1), 0);
    var y = Math.max(Math.min(
      Math.floor((pt[1] - this.Origin[1]) / this.BinSize), this.YDim - 1), 0);

    var bin = this.Grid[y][x];

    // Find the closest entry to location in these bins.
    var best;
    for (var i = 0; i < bin.length; ++i) {
      var rectIdx = bin[i];
      var conf = this.RectSet.Confidences[rectIdx];
      var w = this.RectSet.Widths[rectIdx];
      var h = this.RectSet.Heights[rectIdx];
      var cx = this.RectSet.Centers[rectIdx << 1];
      var cy = this.RectSet.Centers[(rectIdx << 1) + 1];
      var dx = Math.abs(cx - pt[0]);
      var dy = Math.abs(cy - pt[1]);
      if (dx < w / 2 && dy < h / 2 && confThresh <= conf) {
        var dist = Math.max(dx, dy);
        if (!best || dist <= best.dist) {
          best = {
            dist: dist,
            index: rectIdx,
            center: [cx, cy],
            width: w,
            height: h};
        }
      }
    }
    return best;
  };

  // For changed detection
  // Returns a list of all rectangles that overlap the input rectangle by
  // the specified threshold fraction.
  SpatialHash.prototype.GetOverlapping = function (center, width, height,
                                                   overlapThresh) {
    var overlapping = [];
    var hw1 = width / 2;
    var hh1 = height / 2;
    var cx1 = center[0];
    var cy1 = center[1];
    var area1 = width * height;

    // Loop over bins touching the input rectangle
    var x, y;
    x = center[0] - hw1;
    var col1 = Math.floor((x - this.Origin[0]) / this.BinSize);
    col1 = Math.max(Math.min(col1, this.XDim - 1), 0);
    x = center[0] + hw1;
    var col2 = Math.floor((x - this.Origin[0]) / this.BinSize);
    col2 = Math.max(Math.min(col2, this.XDim - 1), 0);

    y = center[1] - hh1;
    var row1 = Math.floor((y - this.Origin[1]) / this.BinSize);
    row1 = Math.max(Math.min(row1, this.YDim - 1), 0);
    y = center[1] + hh1;
    var row2 = Math.floor((y - this.Origin[1]) / this.BinSize);
    row2 = Math.max(Math.min(row2, this.YDim - 1), 0);

    for (var r = row1; r <= row2; ++r) {
      for (var c = col1; c <= col2; ++c) {
        var bin = this.Grid[r][c];
        // compare all the rectangles referenced by this bin
        for (var i = 0; i < bin.length; ++i) {
          var rectIdx = bin[i];
          var hw2 = this.RectSet.Widths[rectIdx] / 2;
          var hh2 = this.RectSet.Heights[rectIdx] / 2;
          var area2 = hw2 * hh2 * 4.0;
          var cx2 = this.RectSet.Centers[rectIdx << 1];
          var cy2 = this.RectSet.Centers[(rectIdx << 1) + 1];
          // Compute the intersection.
          var xMin = Math.max(cx1 - hw1, cx2 - hw2);
          var xMax = Math.min(cx1 + hw1, cx2 + hw2);
          var yMin = Math.max(cy1 - hh1, cy2 - hh2);
          var yMax = Math.min(cy1 + hh1, cy2 + hh2);
          var dx = Math.max(0, xMax - xMin);
          var dy = Math.max(0, yMax - yMin);
          var overlap = (dx * dy) / Math.min(area1, area2);
          if (overlap > overlapThresh) {
            var found = false;
            // SHould be few overlapping.  Linear search should be fine.
            for (var j = 0; j < overlapping.length && !found; ++j) {
              if (overlapping[j] === rectIdx) {
                found = true;
              }
            }
            if (!found) {
              overlapping.push(rectIdx);
            }
          }
        }
      }
    }

    return overlapping;
  };

  SAM.SpatialHash = SpatialHash;
  SAM.GirderAnnotationIterator = GirderAnnotationIterator;
})();

// GUI to navigate a stack and manager views.
// I will try to keep loading to "on demand" as much as possible.
// Put a section transform in the camera.
// Connect section bounds to camera section transform.
// Restrict viewer to bounds of section.
// Startup in the middle of the first bounds.

// TODO: If we can, delay creating the saSection until the cache root is loaded.

// TODO: Make sure that the annotation (stored in slide coordiantes) get
// transformed to section coordinates before they are rendered.

// NOTE: Three different sections.

//   metaSection: loaded from the girder item metadata.
//   stackSection: object internal to this class.
//   saSection: Object slide atlas uses to manage sections.
// TODO: Merge these in the future if possible.

// Loading is a bit confusing (due to load on demand requirements):
// Initialize (block / serialized)
// 1: LoadFolder (called externally): Just gets the number of items in the folder.
// 2: LoadFolderImageIds (chunked recursively):
//      Gets the itemIds and meta data.  Creates the instance stack array.
//      Section objects have bounds an transform, imageId.
//      calls LoadStackMetaData to asynchronously load other item info.
// Initialize (non blocking/ asynchonous, throttled)
// 1: LoadStackMetaData:
//      Choose a (high priority) section that needs metadata loaded.
//      Call CreateSaSection to load the metadata
//      (with a recursive callback to LoadStackMetaData)
// 2: CreateSaSection: Loads the image tile meta data if necesary.
//      No: Just call CreateSaSectionFromCache
//      Yes: GirderRequest->LoadItem
// 3: LoadItem: .....

(function () {
    // Depends on the CIRCLE widget
  'use strict';

  function GirderStackWidget (parent, display, overlay, apiRoot) {
    // We need a common center to treat as the center for the stack.
    // This is used to compute the transforms from the section centers.
    this.VolumeCenter = undefined;

    this.SectionIndex = -1;
    // Stuff needs to be initialized on the first render.
    this.First = true;
    this.ApiRoot = apiRoot;
    // List of stackSections
    this.Stack = [];
    // dictionary to share caches when multiple sections on one slide
    this.Caches = {};
    this.Display = display;
    // Have the viewer call this objects event methods.
    display.AddLayer(this);
    // For debugging (place two section on top of each other to judge alignment.
    // this.Overlay = overlay;

    var self = this;
    // THese event bindings do not work.
    this.SliderDiv = $('<div>')
      .appendTo(parent)
      .css({
        // 'background-color': '#fff',
        // 'opacity': '0.2',
        'position': 'absolute',
        'left': '0px',
        'bottom': '5px',
        'width': '100%',
        'z-index': '1000'})
      .on('keyup', function (e) { self.HandleKeyUp(e); })
      .hover(
        function () {
          self.SliderDiv.focus();
          // self.SliderDiv.css({'opacity': '1'});
        },
        function () {
          self.SliderDiv.blur();
          // self.SliderDiv.css({'opacity': '0.2'});
        });
    this.SliderDiv
      .slider({
        start: function (e, ui) { self.StartCallback(ui.value); },
        slide: function (e, ui) { self.SlideCallback(ui.value); },
        stop: function (e, ui) { self.StopCallback(ui.value); }
      });

    this.SlideLabel = $('<div>')
      .appendTo(this.SliderDiv)
      .css({
        'position': 'absolute',
        'top': '-25px',
        'text-align': 'center',
        'color': '#ddf',
        'text-shadow': '2px 2px #000'})
      .hide();
  }

  GirderStackWidget.prototype.SetAnnotationName = function (name) {
    this.AnnotationName = name;
  };

  GirderStackWidget.prototype.StartCallback = function (value) {
    this.SlideLabel.text(this.SectionIndex.toString());
    var x = 100 * value / (this.Stack.length - 1);
    this.SlideLabel.css({'left': x + '%'});
    this.SlideLabel.show();
  };

  GirderStackWidget.prototype.SlideCallback = function (value) {
    // TODO: Display the thumbnail (instead of the whold slide).
    // Does rending the whole image while sliding  cause too many tiles
    // requests?
    this.SetSectionIndex(value);
    var x = 100 * value / (this.Stack.length - 1);
    this.SlideLabel.text(value.toString());
    this.SlideLabel.css({'left': x + '%'});
  };

  GirderStackWidget.prototype.StopCallback = function (value) {
    this.SetSectionIndex(value);
    this.SlideLabel.text(value.toString());
    this.SlideLabel.hide();
  };

  GirderStackWidget.prototype.HandleKeyUp = function (e) {
    if (e.keyCode === 33 || e.keyCode === 80) {
      // page up or p
      this.Previous();
      return false;
    } else if (e.keyCode === 34 || e.keyCode === 32 || e.keyCode === 78) {
      // page down, space or n
      this.Next();
      return false;
    }
    return true;
  };

  GirderStackWidget.prototype.Next = function () {
    this.SetSectionIndex(this.SectionIndex + 1);
  };

  GirderStackWidget.prototype.Previous = function () {
    this.SetSectionIndex(this.SectionIndex - 1);
  };

  // Load all the images in a folder as a stack.
  GirderStackWidget.prototype.LoadFolder = function (folderId) {
    var self = this;
    this.Stack = [];
    // This just gets the number of items.
    // All we need to start is the number of images in the folder.
    // However, the folder may contain non image items (like this stack).
    this.ErrorCount = 0;
    if (window.girder) {
      girder.rest.restRequest({
        url: ('folder/' + folderId + '/details'),
        method: 'GET',
        contentType: 'application/json'
      }).done(function (resp) {
        // Just serialize loading the item info
        var length = resp.nItems;
        var limit = 100;
        self.LoadFolderImageIds(folderId, 0, limit, length);
      });
    }
  };

  // ============================================================================
  // Load all the images in a folder as a stack.
  // All this does is get the ids of the images in the folder.
  // Image data is loaded on demand
  GirderStackWidget.prototype.LoadFolderImageIds = function (folderId,
                                                             offset, limit, length) {
    var self = this;
    if (offset >= length) {
      // We have received all the ImageIds in the stack
      if (this.Stack.length > 0) {
        this.SetSectionIndex(0);
        // Get meta data for all images in the stack.
        this.ErrorCount = 0;
        this.LoadStackMetaData();
      }
      return;
    }

    // Get the next bite.
    girder.rest.restRequest({
      url: 'item?folderId=' + folderId + '&limit=' + limit +
        '&offset=' + offset + '&sort=lowerName&sortdir=1',
      method: 'GET',
      contentType: 'application/json',
      error: function (error, status) {
        self.ErrorCount += 1;
        if (self.ErrorCount < 100) {
          console.error(error.status + ' ' + error.statusText, error.responseText);
          // try again:
          self.LoadFolderImageIds(folderId, offset, limit, length);
        } else {
          console.log('Too many errors loading folder');
        }
      }
    }).done(function (resp) {
      for (var j = 0; j < resp.length; ++j) {
        var item = resp[j];
        var stackSection;
        // TODO: Handle small images too.
        if (item.largeImage) {
          if (item.meta && item.meta.sections) {
            // Add all the sections listed in the meta data.
            var metaSections = item.meta.sections;
            for (var sIdx = 0; sIdx < metaSections.length; ++sIdx) {
              var metaSection = metaSections[sIdx];
              stackSection = {imageId: item._id};
              if (metaSection.trans) {
                stackSection.transform = metaSection.trans;
              }
              if (metaSection.bounds) {
                // These bounds are in image coordinate ssytem.
                stackSection.bounds = [
                  metaSection.bounds[0],
                  metaSection.bounds[2],
                  metaSection.bounds[1],
                  metaSection.bounds[3]];
              }
              self.Stack.push(stackSection);
            }
          } else {
            // Just add a single section (the whole slide)
            stackSection = {imageId: resp[j]._id};
            self.Stack.push(stackSection);
          }
        }
      }
      // Serialize the bites.
      self.LoadFolderImageIds(folderId, offset + limit, limit, length);
    });
  };

  // Load section meta-data from the stack item.
  // This is a second path that allows editing of the sequence.
  GirderStackWidget.prototype.LoadSections = function (sectionData) {
    var self = this;
    this.Stack = [];

    if (sectionData.length > 0) {
      this.SetSectionIndex(0);
    }

    for (var idx = 0; idx < sectionData.length; ++idx) {
      var metaSection = sectionData[idx];
      var stackSection = {imageId: metaSection.itemId};
      if (metaSection.trans) {
        stackSection.transform = metaSection.trans;
      }
      if (metaSection.bounds) {
        // These bounds are in image coordinate ssytem.
        stackSection.bounds = [
          metaSection.bounds[0],
          metaSection.bounds[2],
          metaSection.bounds[1],
          metaSection.bounds[3]];
      }
      self.Stack.push(stackSection);
    }
    this.LoadStackMetaData();
  };

  // Does everything necessary to load the section into the viewer.
  // Does nothing if the section is not loaded from the datbase yet.
  GirderStackWidget.prototype.SetSectionIndex = function (index) {
    if (index >= this.Stack.length) {
      index = this.Stack.length - 1;
    }
    if (index < 0) {
      return;
    }
    if (this.SectionIndex === index) {
      return;
    }
    console.log('stack index ' + index.toString());
    this.SectionIndex = index;
    // Tell annotation what time to display.
    var num = this.Display.GetNumberOfLayers();
    for (var i = 0; i < num; ++i) {
      var layer = this.Display.GetLayer(i);
      if (layer && layer.SetTime) {
        layer.SetTime(index);
      }
    }

    this.RenderSection(this.Stack[index]);
  };

  // The section images must be loaded before this call.
  GirderStackWidget.prototype.RenderSection = function (stackSection) {
    if (stackSection.SaSection === undefined) {
      return;
    }

    var cache = this.Caches[stackSection.imageId];
    if (cache === undefined || !cache.RootsLoaded) {
      // The load callback will render if the section is current.
      return;
    }
    // Here display is just a viewer.
    // We can only initialize the slide when all the image ids are loaded
    // and we know the length of the stack.  This will change with multiple
    // sections per image.
    if (this.First) {
      delete this.First;
      this.SliderDiv.slider('option', 'max', this.Stack.length - 1);
      // Only reset the camera on the first render.
      this.Display.SetCamera([
        (stackSection.bounds[0] + stackSection.bounds[1]) / 2,
        (stackSection.bounds[2] + stackSection.bounds[3]) / 2],
                             0, (stackSection.bounds[3] - stackSection.bounds[2]));
    }
    // Let the SlideAtlas sections deal with the transformations
    this.Display.SetSection(stackSection.SaSection);
    if (cache.Annotation) {
      var annotLayer = this.Display.GetAnnotationLayer();
      DisplayAnnotation(annotLayer, cache.Annotation);
    }
    this.Display.EventuallyRender();

    // get the next section for the overlay
    if (this.Overlay) {
      var idx = this.Stack.indexOf(stackSection);
      if (idx !== -1 && idx < this.Stack.length - 1) {
        var nextSection = this.Stack[idx + 1];
        cache = this.Caches[nextSection.imageId];
        if (cache === undefined || !cache.RootsLoaded) {
          return;
        }
        this.Overlay.SetSection(nextSection.SaSection);
      }
      this.Overlay.DrawTiles();
    }
  };

  // ============================================================================
  // Load minimal meta data for every section.  Throttle and Prioritize.
  // It would be silly to make a general purpose queue when we know all the
  // images that have to be loaded.  Just load them serially but compute a
  // priority based on the current image index.
  // Assume the stack is static.
  GirderStackWidget.prototype.LoadStackMetaData = function () {
    if (this.ErrorCount > 100) {
      console.error('Too many errors loading item tile info.');
      return;
    }
    if (this.Stack.length === 0) {
      return;
    }
    // Find the next highest priority image info to load.
    var self = this;
    // Find the highest priority section whose image has not been loaded.
    var startIdx = Math.max(this.SectionIndex, 0);
    // Multiple section can have the same image id.
    var foundSection = this.Stack[startIdx];
    if (foundSection.SaSection) {
      // already loaded
      foundSection = undefined;
    }

    var radius = 1;
    // Tolerate overshoot with startIdx+radius
    while (!foundSection && radius < this.Stack.length) {
      // Look forward.
      var idx = startIdx + radius;
      if (idx >= 0 && idx < this.Stack.length) {
        foundSection = this.Stack[idx];
        if (foundSection.SaSection) {
          // already loaded
          foundSection = undefined;
        }
      }
      // Look backward
      idx = startIdx - radius;
      if (!foundSection && idx >= 0 && idx < this.Stack.length) {
        foundSection = this.Stack[idx];
        if (foundSection.SaSection) {
          // already loaded
          foundSection = undefined;
        }
      }
      ++radius;
    }

    if (foundSection) {
      // Recursively call this method to throttle requests.
      this.CreateSaSection(foundSection,
                           function () { self.LoadStackMetaData(); });
    }
  };

  // This gets called to create the saSection.  It may need to make a cache
  // and get the image data from the server to do it.
  GirderStackWidget.prototype.CreateSaSection = function (stackSection, callback) {
    var cache = this.Caches[stackSection.imageId];
    if (cache) {
      // we have the cache already
      this.CreateSaSectionFromCache(stackSection, cache);
      if (callback) {
        (callback)();
      }
      return;
    }

    // We need to request image data from the server to setup the cache.
    var self = this;
    girder.rest.restRequest({
      url: 'item/' + stackSection.imageId + '/tiles',
      method: 'GET',
      contentType: 'application/json',
      error: function (error, status) {
        console.error(error.status + ' ' + error.statusText, error.responseText);
        this.ErrorCount += 1;
        if (callback) {
          (callback)();
        }
      }
    }).done(function (resp) {
      self.LoadItem(resp, stackSection, callback);
    });
  };

  // This is only called once per item.
  GirderStackWidget.prototype.LoadItem = function (resp, stackSection, callback) {
    var w = resp.sizeX;
    var h = resp.sizeY;

    // If the item did not have bounds meta data, set bounds to be the
    // whole slide.
    if (stackSection.bounds === undefined) {
      stackSection.bounds = [0, w - 1, 0, h - 1];
    }
    // Get / setup the cache.
    var cache = new SA.Cache();
    this.Caches[stackSection.imageId] = cache;
    var tileSource = new GirderTileSource(w, h, resp.tileWidth, resp.tileHeight,
                                          0, resp.levels - 1,
                                          this.ApiRoot,
                                          stackSection.imageId,
                                          [0, w - 1, 0, h - 1]);
    cache.SetTileSource(tileSource);
    // Setup the slideAtlas section
    var saSection = new SA.Section();
    saSection.AddCache(cache);
    stackSection.SaSection = saSection;

    cache.SetTileSource(tileSource);
    // Request the lowest resolution tile from girder.
    var self = this;
    cache.LoadRoots(
      function () {
        cache.RootsLoaded = true;
        // If the current section uses this cache. render it.
        if (self.SectionIndex !== -1) {
          var currentSection = self.Stack[self.SectionIndex];
          if (stackSection.imageId === currentSection.imageId) {
            self.RenderSection(currentSection);
          }
        }
      });
    this.CreateSaSectionFromCache(stackSection, cache);

    // Load annotation if necessary.
    // Associated it with the cache.
    // TODO: REnder when load if section is current.
    if (this.AnnotationName) {
      girder.rest.restRequest({
        url: 'annotation?itemId=' + stackSection.imageId + '&name=' + this.AnnotationName,
        method: 'GET',
        contentType: 'application/json',
        error: function (error, status) {
          console.error(error.status + ' ' + error.statusText, error.responseText);
        }
      }).done(function (resp) {
        if (resp.length > 0) {
          var annotId = resp[0]['_id'];
          girder.rest.restRequest({
            url: 'annotation/' + annotId,
            method: 'GET',
            contentType: 'application/json',
            error: function (error, status) {
              console.error(error.status + ' ' + error.statusText, error.responseText);
            }
          }).done(function (resp) {
            cache.Annotation = resp.annotation;
          });
        }
      });
    }

    // This serializes the requests. Starts loading the next after the
    // current is finished.
    if (callback) {
      (callback)();
    }
  };

  GirderStackWidget.prototype.CreateSaSectionFromCache = function (stackSection, cache) {
    // If the girder meta data did not set up the section defaults, do it
    // here. The center is the first pass at the transformation.
    var image = cache.GetImageData();
    if (stackSection.bounds === undefined) {
      stackSection.bounds = [0, image.dimensions[0] - 1, 0, image.dimensions[1] - 1];
    }
    var bds = stackSection.bounds;
    var center = [
      (bds[0] + bds[1]) * 0.5,
      (bds[2] + bds[3]) * 0.5];
    if (!this.VolumeCenter) {
      this.VolumeCenter = center;
    }
    // Set a default center to the middle of the bounds.
    if (stackSection.transform === undefined) {
      stackSection.transform = [
        1, 0, 0, 1,
        center[0] - this.VolumeCenter[0],
        center[1] - this.VolumeCenter[1]];
    }

    // Setup the slideAtlas section
    var saSection = new SA.Section();
    saSection.AddCache(cache);
    // First set the world to image transformation.
    saSection.SetTransform(stackSection.transform);

    // Now set the slide atla section bounds. They are best kept in world
    // coordinate system because they are used for interaction.
    // The stackSection bounds are in image coodindate system (for now).
    // TODO: fix this:  Since we only have translation, hack in the
    // conversion to world coordinate system.
    var tmp = SAM.InvertTransform(stackSection.transform);
    saSection.Bounds = SAM.TransformBounds(tmp, bds);

    stackSection.SaSection = saSection;
  };

  var GirderTileSource = function (width, height,
                                   tileWidth, tileHeight,
                                   minLevel, maxLevel,
                                   apiRoot, imageId,
                                   bounds) {
    this.height = height;
    this.width = width;
    this.TileWidth = tileWidth;
    this.TileHeight = tileHeight;
    this.apiRoot = apiRoot;
    this.imageId = imageId;
    this.bounds = bounds;
    this.maxLevel = maxLevel;
  };

  GirderTileSource.prototype.getTileUrl = function (level, x, y, z) {
    return this.apiRoot + '/item/' + this.imageId +
      '/tiles/zxy/' + level + '/' + x + '/' + y;
  };

  // TODO: Copied from girderWidget.  Share code!!!!!!!!!!!!!!!!
  // Move the annotation info to the layer widgets and draw.
  // Converts annotObj from girder to slideAtlas
  var DisplayAnnotation = function (annotLayer, girderAnnot) {
    annotLayer.SetVisibility(true);
    annotLayer.Reset();

    // Put all the rectangles into one set.
    var setObj = {};
    setObj.type = 'rect_set';
    setObj.centers = [];
    setObj.widths = [];
    setObj.heights = [];
    setObj.confidences = [];
    setObj.labels = [];

    var annot = girderAnnot;
    for (var i = 0; i < annot.elements.length; ++i) {
      var element = annot.elements[i];
      var obj = {};

      if (element.type === 'view') {
                // Set the camera / view.
        var cam = annotLayer.GetCamera();
        cam.SetWorldFocalPoint(element.center);
        cam.SetHeight(element.height);
        if (element.rotation) {
          cam.SetWorldRoll(element.rotation);
        } else {
          cam.SetWorldRoll(0);
        }
        // Ignore width for now because it is determined by the
        // viewport.
        cam.ComputeMatrix();
        // How to handle forcing viewer to render?
        // I could have a callback.
        // I could also make a $('.sa-viewer').EventuallyRender();
        // or $('.sa-viewer').saViewer('EventuallyRender');
        if (annotLayer.Viewer) {
          annotLayer.Viewer.EventuallyRender();
        }
      }
      if (element.type === 'circle') {
        obj.type = element.type;
        obj.lineColor = SAM.ConvertColor(element.lineColor);
        obj.lineWidth = element.lineWidth;
        obj.origin = element.center;
        obj.radius = element.radius;
        annotLayer.LoadWidget(obj);
      }
      if (element.type === 'arrow') {
        obj.type = 'text';
        obj.string = element.label.value;
        obj.color = SAM.ConvertColor(element.fillColor);
        obj.size = element.label.fontSize;
        obj.position = element.points[0].slice(0);
        obj.offset = element.points[1].slice(0);
        obj.offset[0] -= obj.position[0];
        obj.offset[1] -= obj.position[1];
        annotLayer.LoadWidget(obj);
      }
      if (element.type === 'rectanglegrid') {
        obj.type = 'grid';
        obj.lineColor = SAM.ConvertColor(element.lineColor);
        obj.lineWidth = element.lineWidth;
        obj.origin = element.center;
        obj.bin_width = element.width / element.widthSubdivisions;
        obj.bin_height = element.height / element.heightSubdivisions;
        obj.orientation = element.rotation;
        obj.dimensions = [element.widthSubdivisions, element.heightSubdivisions];
        annotLayer.LoadWidget(obj);
      }
      if (element.type === 'rectangle') {
        if (element.type === 'rectangle') { // switch behavior to ....
          setObj.widths.push(element.width);
          setObj.heights.push(element.height);
          setObj.centers.push(element.center[0]);
          setObj.centers.push(element.center[1]);
          if (element.scalar === undefined) {
            element.scalar = 1.0;
          }
          setObj.confidences.push(element.scalar);
          if (element.vector === undefined) {
            element.vector = [0, 0, 0];
          }
          if (setObj.vectors === undefined) {
            setObj.vectors = [];
          }
          setObj.vectors.push(element.vector[0]);
          setObj.vectors.push(element.vector[1]);
          if (element.label) {
            setObj.labels.push(element.label.value);
          } else {
            setObj.labels.push('');
          }
        } else {
          obj.type = 'rect';
          obj.lineColor = SAM.ConvertColor(element.lineColor);
          obj.lineWidth = element.lineWidth;
          obj.origin = element.center;
          obj.width = element.width;
          obj.length = element.height;
          obj.orientation = element.rotation;
          annotLayer.LoadWidget(obj);
        }
      }
      if (element.type === 'polyline') {
        obj.type = element.type;
        obj.closedloop = element.closed;
        obj.lineColor = SAM.ConvertColor(element.lineColor);
        obj.lineWidth = element.lineWidth;
        obj.points = element.points;
        annotLayer.LoadWidget(obj);
      }
    }

    if (setObj.widths.length > 0) {
      annotLayer.LoadWidget(setObj);
    }

    annotLayer.EventuallyDraw();
  };

  SAM.GirderStackWidget = GirderStackWidget;
})();

// export { GirderStackWidget }


(function () {
  // Depends on the CIRCLE widget
  'use strict';

  var d3 = 'not loaded';

  function GirderRocWidget (parent, positives, negatives, apiRoot) {
    this.ChipSize = 128;
    this.MaxChips = 200;
    this.Positives = positives;
    this.Negatives = negatives;
    this.NumPositives = positives.length;
    this.NumNegatives = negatives.length;
    // Combine the two lists, but label them first.
    for (var i = 0; i < positives.length; ++i) {
      positives[i].positive = true;
    }
    for (i = 0; i < negatives.length; ++i) {
      negatives[i].positive = false;
    }
    this.Detections = positives.concat(negatives);
    this.Detections.sort(
      function (a, b) {
        return b.element.scalar - a.element.scalar;
      });

    this.Container = $('<div>')
      .appendTo(parent)
      .css({
        'width': '100%',
        'margin-right': '30px'});

    this.RocDiv = $('<div>')
      .appendTo(this.Container)
      .css({
        'width': '100%',
        'position': 'relative'});
    this.LightBoxDiv = $('<div>')
      .appendTo(this.Container)
      .css({
        'width': '100%',
        'min-height': '500px',
        'position': 'relative'});

    this.FalsePositiveDiv = $('<div>')
      .appendTo(this.LightBoxDiv)
      .css({
        'border': '1px solid #AAA',
        'position': 'absolute',
        'left': '0px',
        'width': '50%',
        'top': '0px'});
    this.FalseNegativeDiv = $('<div>')
      .appendTo(this.LightBoxDiv)
      .css({
        'position': 'absolute',
        'left': '50%',
        'width': '50%',
        'top': '0px'});

    var self = this;
    this.SliderDiv = $('<div>')
      .appendTo(this.RocDiv)
      .css({
        'position': 'absolute',
        'left': '0px',
        'bottom': '0px',
        'width': '100%',
        'z-index': '10'})
       // .on('keyup', function (e) { self.HandleKeyUp(e); })
      .hover(
        function () {
          self.SliderDiv.focus();
          // self.SliderDiv.css({'opacity': '1'});
        },
        function () {
          self.SliderDiv.blur();
          // self.SliderDiv.css({'opacity': '0.2'});
        });
    this.SliderDiv
      .slider({
        start: function (e, ui) {},
        slide: function (e, ui) {
          var thresh = 1.0 - ui.value / 100.0;
          self.UpdateThreshold(thresh);
        },
        stop: function (e, ui) {}
      });

    this.DrawGraph();

    // Make the thumbnails / chips.
    this.InitializeChips();
    this.UpdateThreshold(1.0);
  }

  GirderRocWidget.prototype.UpdateThreshold = function (thresh) {
    // Find the point for this threshold.
    // TODO: Search from last point.
    var i = 0;
    var x = 0;
    var y = 0;
    for (i = 0; i < this.Points.length; ++i) {
      if (this.Points[i][2] < thresh) {
        x = this.Points[i][0];
        y = this.Points[i][1];
        break;
      }
    }
    console.log(thresh);
    x = this.XScale(x);
    y = this.YScale(y);
    this.Dot
      .attr('cx', x)
      .attr('cy', y);

    this.ThreshLabel
      .attr('x', x)
      .attr('y', y)
      .text(thresh.toFixed(2));

    // Update chip visibility.
    // TODO: Incremental update
    for (i = 0; i < this.Detections.length; ++i) {
      var d = this.Detections[i];
      if (d.imgDiv) {
        if (d.positive) {
          if (d.element.scalar <= thresh) {
            d.imgDiv.show();
          } else {
            d.imgDiv.hide();
          }
        } else {
          if (d.element.scalar >= thresh) {
            d.imgDiv.show();
          } else {
            d.imgDiv.hide();
          }
        }
      }
    }
  };

  GirderRocWidget.prototype.GetImageUrl = function (imageId, left, top, width, height, targetHeight) {
    var magnification = 40.0 * targetHeight / height;
    if (magnification > 40) {
      magnification = 40;
    }
    return 'api/v1/item/' + imageId + '/tiles/region?magnification=' + magnification +
           '&left=' + left + '&top=' + top + '&regionWidth=' + width + '&regionHeight=' + height +
           '&units=base_pixels&exact=false&encoding=JPEG&jpegQuality=95&jpegSubsampling=0';
  };

  GirderRocWidget.prototype.InitializeChips = function () {
    this.Positives.sort(
      function (a, b) {
        return a.element.scalar - b.element.scalar;
      });
    this.Negatives.sort(
      function (a, b) {
        return b.element.scalar - a.element.scalar;
      });
    this.Positives = this.Positives.slice(0, this.MaxChips);
    this.Negatives = this.Negatives.slice(0, this.MaxChips);

    for (var i = 0; i < this.Positives.length; ++i) {
      this.CreateChip(this.Positives[i], this.FalseNegativeDiv);
    }
    for (i = 0; i < this.Negatives.length; ++i) {
      this.CreateChip(this.Negatives[i], this.FalsePositiveDiv);
    }
  };

  GirderRocWidget.prototype.CreateChip = function (chip, parent) {
    var imageId = chip.imageId;
    var e = chip.element;
    if (e.type === 'rectangle') {
      var left = Math.round(e.center[0] - e.width / 2);
      var top = Math.round(e.center[1] - e.height / 2);
      // Use closure to keep track of images state?
      var imgDiv = $('<div>')
          .appendTo(parent)
          .addClass('img-div')
          .css({
            'height': (this.ChipSize + 8).toString() + 'px',
            'width': (this.ChipSize + 8).toString() + 'px',
            'margin': '1px',
            'display': 'inline-block',
            'position': 'relative',
            'cursor': 'crosshair',
            'border': '4px solid #EEE'})
          // needed to receive key events
          .attr('tabindex', '0');
      var img = $('<img>')
        .appendTo(imgDiv)
        .addClass('img-chip')
          .css({
            'height': this.ChipSize.toString() + 'px',
            'width': this.ChipSize.toString() + 'px',
            'cursor': 'crosshair'})
        .attr('tabindex', '0')
        .prop('src', this.GetImageUrl(imageId, left, top, 920, 920, this.ChipSize));
      chip.imgDiv = imgDiv;
      chip.img = img;
    }
  };

  // Initialize and draw the graph.
  GirderRocWidget.prototype.DrawGraph = function () {
    this.Points = [];
    var negCount = 0;
    var posCount = 0;

    var stride = Math.round(this.Detections.length / 100);

    for (var i = 0; i < this.Detections.length; ++i) {
      var d = this.Detections[i];
      if (stride === 0 || i % stride === 0) {
        this.Points.push([negCount, posCount, d.element.scalar]);
      }
      if (d.positive) {
        ++posCount;
      } else {
        ++negCount;
      }
    }
    // Add the last point.
    this.Points.push([negCount, posCount]);

    // Draw the d3 graph
    var margin = {top: 20, right: 20, bottom: 50, left: 70};
    var width = 600 - margin.left - margin.right;
    var height = 400 - margin.top - margin.bottom;

    var xScale = d3.scale.linear()
      .domain([0, this.NumNegatives])
      .range([0, width]);
    var yScale = d3.scale.linear()
      .domain([0, this.NumPositives])
      .range([height, 0]);

    var xAxis = d3.svg.axis()
      .scale(xScale)
      .orient('bottom')
      .ticks(5);
      // .style({'stroke-width': '1.5px'});
    var yAxis = d3.svg.axis()
      .scale(yScale)
      .orient('left')
      .ticks(5);
      // .style({'stroke-width': '1.5px'});

    // append the svg obgect to the body of the page
    // appends a 'group' element to 'svg'
    // moves the 'group' element to the top left margin

    var svg = d3.select(this.RocDiv[0]).append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
      .append('g')
        .attr('transform',
              'translate(' + margin.left + ',' + margin.top + ')');

    var valueline = d3.svg.line()
      .x(function (d) { return xScale(d[0]); })
      .y(function (d) { return yScale(d[1]); });

    svg.append('path')
      .attr('class', 'line')
      .attr('fill', 'none')
      .attr('stroke', 'blue')
      .attr('d', valueline(this.Points));

    svg.append('g')
        .attr('class', 'x axis')
        .attr('stroke-width', '1')
        .attr('transform', 'translate(0,' + height + ')')
        .call(xAxis)
      .append('text')
        .style('text-anchor', 'end')
        .attr('transform', 'translate(' + width + ', 0)')
        .attr('dy', '-.55em')
        .text('False Positives');

    svg.append('g')
        .attr('class', 'y axis')
        .attr('stroke-width', '1')
        .call(yAxis)
      .append('text')
        .attr('transform', 'rotate(-90)')
        .attr('y', 6)
        .attr('dy', '.71em')
        .style('text-anchor', 'end')
        .text('True Positives');

    this.XScale = xScale;
    this.YScale = yScale;
    this.Dot = svg.append('circle')
      .attr('cx', '0')
      .attr('cy', height.toString())
      .attr('r', '30')
      .attr('stroke', 'black')
      .attr('stroke-width', '1')
      .attr('fill', 'yellow')
      .attr('r', '10');
    this.ThreshLabel = svg.append('text')
      .attr('x', '0')
      .attr('y', '0')
      .attr('dy', '-20')
      .style('text-anchor', 'middle')
      .text('0.0');
  };

  SAM.GirderRocWidget = GirderRocWidget;
})();

// export { GirderRocWidget }

// ==============================================================================
// View Object
// Viewport (x_lowerleft, y_lowerleft, width, height)
// A view has its own camera and list of tiles to display.
// Views can share a cache for tiles.

(function () {
  'use strict';

  function View (parent, useWebGL) {
    this.Viewport = [0, 0, 100, 100];

    // Should widgets use shapes?
    // Should views be used independently to viewers?
    this.ShapeList = [];

    // connectome: remove Cache ivar.
    this.Camera = new SAM.Camera();
    this.OutlineColor = [0, 0.5, 0];
    this.OutlineMatrix = mat4.create();
    this.OutlineCamMatrix = mat4.create();

    this.Parent = parent;
    if (parent) {
      this.Parent = parent;
    } else {
      // USed for off screen rendering. (Can we depreciate off screen feature in girder viewer?)
      this.Parent = $('<div>');
    }
    // 2d canvas
    // Add a new canvas.
    this.Canvas = $('<canvas>');

    if (!useWebGL) {
      this.Context2d = this.Canvas[0].getContext('2d');
    }

    this.Canvas
      .appendTo(this.Parent)
      .css({
        'position': 'absolute',
        'left': '0%',
        'top': '0%',
        'width': '100%',
        'height': '100%'});

    this.Parent
      .addClass('sa-view-canvas-div');
  }

  // Try to remove all global and circular references to this view.
  View.prototype.Delete = function () {
    this.Parent.off('mousedown.viewer');
    this.Parent.off('mousemove.viewer');
    this.Parent.off('wheel.viewer');
    this.Parent.off('touchstart.viewer');
    this.Parent.off('touchmove.viewer');
    this.Parent.off('touchend.viewer');
    this.Parent.off('keydown.viewer');
    this.Parent.off('wheel.viewer');
    delete this.ShapeList;
    // delete this.Section;
    delete this.Camera;
    // delete this.Tiles;
    delete this.Parent;
    delete this.Canvas;
  };

  View.prototype.GetCamera = function () {
    return this.Camera;
  };

  // For shared camera with viewer.
  View.prototype.SetCamera = function (cam) {
    this.Camera = cam;
  };

  // Get raw image data from the view.
  View.prototype.GetImageData = function () {
    // interesting: When does it need to be set?
    // ctx.imageSmoothingEnabled = true;
    // useful for debugging
    // ctx.putImageData(imagedata, dx, dy);
    var cam = this.Camera;
    var width = Math.floor(cam.ViewportWidth);
    var height = Math.floor(cam.ViewportHeight);
    var ctx = this.Context2d;
    var data = ctx.getImageData(0, 0, width, height);
    data.Camera = new SAM.Camera();
    data.Camera.DeepCopy(this.Camera);
    // This will ne slow (wrapper class, or tack on methods)
    Object.setPrototypeOf(data, new SAM.ImageData());
    data.IncX = 4;
    // Super has height and width which should be imutable.
    data.width = width;
    data.height = height;
    data.IncY = data.IncX * data.width;
    return data;
  };

  // Get the current scale factor between pixels and world units.
  // World unit is the highest resolution image pixel.
  // Returns the size of a world pixel in screen pixels.
  // factor: screen/world
  // The default world pixel = 0.25e-6 meters
  View.prototype.GetPixelsPerUnit = function () {
    // Determine the scale difference between the two coordinate systems.
    var m = this.Camera.GetWorldMatrix();

    // Convert from world coordinate to view (-1->1);
    return 0.5 * this.Viewport[2] / (m[3] + m[15]); // m[3] for x, m[7] for height
  };

  View.prototype.HasUnits = function () {
    var cache = this.GetCache();
    if (!cache || !cache.Image || !cache.Image.units) { return false; }
    return cache.Image.units !== 'Units';
  };

  View.prototype.GetMetersPerUnit = function () {
    var cache = this.GetCache();
    var dist;
    if (!cache) {
      dist = {value: 250,
        units: 'nm'};
    } else {
      dist = {value: cache.Image.spacing[0],
        units: cache.Image.units};
    }
    SAM.ConvertToMeters(dist);
    return dist.value;
  };

  // TODO: Get rid of these since the user can manipulate the parent / canvas
  // div which can be passed into the constructor.
  // View.prototype.appendTo = function (j) {
  //  return this.Parent.appendTo(j);
  // };

  // View.prototype.remove = function (j) {
  //  return this.Parent.remove(j);
  // };

  // View.prototype.css = function (j) {
  //  return this.Parent.css(j);
  // };

  // TODO: Get rid of this.
  View.prototype.GetViewport = function () {
    return this.Viewport;
  };

  View.prototype.GetWidth = function () {
    return this.Parent.width();
  };

  View.prototype.GetHeight = function () {
    return this.Parent.height();
  };

  View.prototype.UpdateSize = function () {
    this.UpdateCanvasSize();
  };

  // The canvasDiv changes size, the width and height of the canvas and
  // camera need to follow.  I am going to make this the resize callback.
  View.prototype.UpdateCanvasSize = function () {
    if (!this.Parent.is(':visible')) {
      return false;
    }

    var pos = this.Parent.position();
    // var width = this.Parent.innerWidth();
    // var height = this.Parent.innerHeight();
    var width = this.Parent.width();
    var height = this.Parent.height();
    // resizable is making width 0 intermitently ????
    if (width <= 0 || height <= 0) { return false; }

    this.SetViewport([pos.left, pos.top, width, height]);

    return true;
  };

  // This is meant to be called internally by UpdateCanvasSize.
  // However, if the parent(canvasDiv) is hidden, it might need to be
  // set explcitly.
  // TODO: Change this to simply width and height.
  View.prototype.SetViewport = function (viewport) {
    var width = viewport[2];
    var height = viewport[3];

    this.Canvas.attr('width', width.toString());
    this.Canvas.attr('height', height.toString());

    // TODO: Get rid of this ivar
    this.Viewport = viewport;

    // TODO: Just set the width and height of the camera.
    // There is no reason, the camera needs to know the
    // the position of the cameraDiv.
    this.Camera.SetViewport(viewport);
  };

  View.prototype.CaptureImage = function () {
    var url = this.Canvas[0].toDataURL();
    var newImg = document.createElement('img'); // create
    newImg.src = url;
    return newImg;
  };

  // Legacy
  // A list of shapes to render in the view
  View.prototype.AddShape = function (shape) {
    this.ShapeList.push(shape);
  };

  // NOTE: AnnotationLayer has the api where the shapes draw themselves (with
  // reference to this view.  I like that better than the view knowing
  // how to draw all these things.
  View.prototype.DrawShapes = function () {
    if (!this.Parent.is(':visible')) {
      return;
    }
    for (var i = 0; i < this.ShapeList.length; i++) {
      this.ShapeList[i].Draw(this);
    }
  };

  View.prototype.Clear = function () {
    this.Context2d.save();
    this.Context2d.setTransform(1, 0, 0, 1, 0, 0);
    // TODO: get width and height from the canvas.
    this.Context2d.clearRect(0, 0, this.Viewport[2], this.Viewport[3]);
    this.Context2d.restore();
  };

  View.prototype.DrawHistory = function (windowHeight) {
    if (this.gl) {
      alert('Drawing history does not work with webGl yet.');
    } else {
      var ctx = this.Context2d;
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);

      // Start with a transform that flips the y axis.
      ctx.setTransform(1, 0, 0, -1, 0, this.Viewport[3]);

      // Map (-1->1, -1->1) to the viewport.
      // Origin of the viewport does not matter because drawing is relative
      // to this view's canvas.
      ctx.transform(0.5 * this.Viewport[2], 0.0,
                          0.0, 0.5 * this.Viewport[3],
                          0.5 * this.Viewport[2],
                          0.5 * this.Viewport[3]);

      // ctx.fillRect(0.0,0.1,0.5,0.5); // left, right, width, height

      // The camera maps the world coordinate system to (-1->1, -1->1).
      var cam = this.Camera;
      var m = cam.GetWorldMatrix();
      var h = 1.0 / m[15];
      ctx.transform(m[0] * h, m[1] * h,
                    m[4] * h, m[5] * h,
                    m[12] * h, m[13] * h);

      var timeLine = SA.recorderWidget.TimeLine;
      for (var i = 0; i < timeLine.length; ++i) {
        cam = timeLine[i].ViewerRecords[0].Camera;
        var height = cam.Height;
        var width = cam.Width;
        // camer roll is already in radians.
        var c = Math.cos(cam.GetWorldRoll());
        var s = Math.sin(cam.GetWorldRoll());
        ctx.save();
        // transform to put focal point at 0,0
        var fp = cam.GetWorldFocalPoint();
        ctx.transform(c, -s,
                      s, c,
                      fp[0], fp[1]);

        // Compute the zoom factor for opacity.
        var opacity = 2 * windowHeight / height;
        if (opacity > 1.0) { opacity = 1.0; }

        ctx.fillStyle = 'rgba(0,128,0,' + opacity + ')';
        ctx.fillRect(-width / 2, -height / 2, width, height); // left, right, width, height
        ctx.stroke();
        ctx.restore();
      }
      ctx.restore();
    }
  };

  // Draw a cross hair in the center of the view.
  View.prototype.DrawFocalPoint = function () {
    if (this.gl) {
      alert('Drawing focal point does not work with webGl yet.');
    } else {
      var x = this.Viewport[2] * 0.5;
      var y = this.Viewport[3] * 0.5;
      var ctx = this.Context2d;
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.strokeStyle = 'rgba(255,255,200,100)';
      ctx.fillStyle = 'rgba(0,0,50,100)';

      ctx.beginPath();
      ctx.fillRect(x - 30, y - 1, 60, 3);
      ctx.rect(x - 30, y - 1, 60, 3);
      ctx.fillRect(x - 1, y - 30, 3, 60);
      ctx.rect(x - 1, y - 30, 3, 60);

      var r = y / 2;
      ctx.beginPath();
      ctx.moveTo(x - r, y - r + 30);
      ctx.lineTo(x - r, y - r);
      ctx.lineTo(x - r + 30, y - r);
      ctx.moveTo(x + r, y - r + 30);
      ctx.lineTo(x + r, y - r);
      ctx.lineTo(x + r - 30, y - r);
      ctx.moveTo(x + r, y + r - 30);
      ctx.lineTo(x + r, y + r);
      ctx.lineTo(x + r - 30, y + r);
      ctx.moveTo(x - r, y + r - 30);
      ctx.lineTo(x - r, y + r);
      ctx.lineTo(x - r + 30, y + r);
      ctx.stroke();

      ++r;
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(0,0,50,100)';
      ctx.moveTo(x - r, y - r + 30);
      ctx.lineTo(x - r, y - r);
      ctx.lineTo(x - r + 30, y - r);
      ctx.moveTo(x + r, y - r + 30);
      ctx.lineTo(x + r, y - r);
      ctx.lineTo(x + r - 30, y - r);
      ctx.moveTo(x + r, y + r - 30);
      ctx.lineTo(x + r, y + r);
      ctx.lineTo(x + r - 30, y + r);
      ctx.moveTo(x - r, y + r - 30);
      ctx.lineTo(x - r, y + r);
      ctx.lineTo(x - r + 30, y + r);
      ctx.stroke();
      ctx.restore();
    }
  };

  // Draw a cross hair at each correlation point.
  // pointIdx is 0 or 1.  It indicates which correlation point should be drawn.
  View.prototype.DrawCorrelations = function (correlations, pointIdx) {
    if (this.gl) {
      alert('Drawing correlations does not work with webGl yet.');
    } else {
      var ctx = this.Context2d;
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.strokeStyle = 'rgba(200,255,255,100)';
      ctx.fillStyle = 'rgba(255,0,0,100)';
      for (var i = 0; i < correlations.length; ++i) {
        var wPt = correlations[i].GetPoint(pointIdx);
        var m = this.Camera.GetWorldMatrix();
        // Change coordinate system from world to -1->1
        var x = (wPt[0] * m[0] + wPt[1] * m[4] + m[12]) / m[15];
        var y = (wPt[0] * m[1] + wPt[1] * m[5] + m[13]) / m[15];
        // Transform coordinate system from -1->1 to canvas
        x = (1.0 + x) * this.Viewport[2] * 0.5;
        y = (1.0 - y) * this.Viewport[3] * 0.5;

        ctx.beginPath();
        ctx.fillRect(x - 20, y - 1, 40, 3);
        ctx.rect(x - 20, y - 1, 40, 3);
        ctx.fillRect(x - 1, y - 20, 3, 40);
        ctx.rect(x - 1, y - 20, 3, 40);

        ctx.stroke();
      }
      ctx.restore();
    }
  };

  // NOTE: Not used anymore. Viewer uses a DOM.
  View.prototype.DrawCopyright = function (copyright) {
    if (copyright === undefined) {
      return;
    }
    if (this.gl) {
      // not implemented yet.
    } else {
      this.Context2d.setTransform(1, 0, 0, 1, 0, 0);
      this.Context2d.font = '18px Arial';
      var x = this.Viewport[2] * 0.5 - 50;
      var y = this.Viewport[3] - 10;
      this.Context2d.fillStyle = 'rgba(128,128,128,0.5)';
      this.Context2d.fillText(copyright, x, y);
      // this.Context2d.strokeStyle = "rgba(255,255,255,0.5)";
      // this.Context2d.strokeText(copyright,x,y);
    }
  };

  // I think this was only used for webgl.  Not used anymore
  View.prototype.DrawOutline = function (backgroundFlag) {
    if (this.gl) {
      var program = SA.polyProgram;
      this.gl.useProgram(program);

      this.gl.viewport(this.Viewport[0],
                             this.Viewport[3] - this.Viewport[1],
                             this.Viewport[2],
                             this.Viewport[3]);

      // Draw a line around the viewport, so move (0,0),(1,1) to (-1,-1),(1,1)
      mat4.identity(this.OutlineCamMatrix);
      this.OutlineCamMatrix[0] = 2.0; // width x
      this.OutlineCamMatrix[5] = 2.0; // width y
      this.OutlineCamMatrix[10] = 0;
      this.OutlineCamMatrix[12] = -1.0;
      this.OutlineCamMatrix[13] = -1.0;
      var viewFrontZ = this.Camera.ZRange[0] + 0.001;
      var viewBackZ = this.Camera.ZRange[1] - 0.001;
      this.OutlineCamMatrix[14] = viewFrontZ; // front plane

      mat4.identity(this.OutlineMatrix);

      this.gl.uniformMatrix4fv(program.mvMatrixUniform, false, this.OutlineMatrix);

      if (backgroundFlag) {
        // White background fill
        this.OutlineCamMatrix[14] = viewBackZ; // back plane
        this.gl.uniformMatrix4fv(program.pMatrixUniform, false, this.OutlineCamMatrix);
        this.gl.uniform3f(program.colorUniform, 1.0, 1.0, 1.0);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, SA.squarePositionBuffer);
        this.gl.vertexAttribPointer(program.vertexPositionAttribute,
                                            SA.squarePositionBuffer.itemSize,
                                            this.gl.FLOAT, false, 0, 0);
        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, SA.squarePositionBuffer.numItems);
      }

      // outline
      this.OutlineCamMatrix[14] = viewFrontZ; // force in front
      this.gl.uniformMatrix4fv(program.pMatrixUniform, false, this.OutlineCamMatrix);
      this.gl.uniform3f(program.colorUniform, this.OutlineColor[0], this.OutlineColor[1], this.OutlineColor[2]);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, SA.squareOutlinePositionBuffer);
      this.gl.vertexAttribPointer(program.vertexPositionAttribute,
                                        SA.squareOutlinePositionBuffer.itemSize,
                                        this.gl.FLOAT, false, 0, 0);
      this.gl.drawArrays(this.gl.LINE_STRIP, 0, SA.squareOutlinePositionBuffer.numItems);
    }
  };

    // =================================================
    // Extend the image data returned by the canvas.

  function ImageData () {
    this.IncX = 1;
    this.IncY = 1;
  }

  ImageData.prototype.GetIntensity = function (x, y) {
    if (!this.data) { return 0; }
    x = Math.round(x);
    y = Math.round(y);
    var idx = x * this.IncX + y * this.IncY;
    return (this.data[idx] + this.data[idx + 1] + this.data[idx + 2]) / 3;
  };

  ImageData.prototype.InBounds = function (x, y) {
    if (!this.data) { return false; }
    return (x >= 0 && x < this.width && y >= 0 && y < this.height);
  };

  // Mark edges visited so we do not create the same contour twice.
  // I cannot mark the pixel cell because two contours can go through the same cell.
  // Note:  I have to keep track of both the edge and the direction the contour leaves
  // the edge.  The backward direction was to being contoured because the starting
  // edge was already marked.  The order of the points here matters.  Each point
  // marks 4 edges.
  ImageData.prototype.MarkEdge = function (x0, y0, x1, y1) {
    if (!this.EdgeMarks) {
      var numTemplates = Math.round((this.width) * (this.height));
      this.EdgeMarks = new Array(numTemplates);
      for (var i = 0; i < numTemplates; ++i) {
        this.EdgeMarks[i] = 0;
      }
    }

    var edge = 0;
    if (x0 !== x1) {
      edge = (x0 < x1) ? 1 : 4;
    } else if (y0 !== y1) {
      edge = (y0 < y1) ? 2 : 8;
    }

    var idx = x0 + y0 * (this.width);
    var mask = this.EdgeMarks[idx];
    if (mask & edge) {
      return true;
    }
    this.EdgeMarks[idx] = mask | edge;
    return false;
  };

  SAM.ImageData = ImageData;
  SAM.View = View;
})();

// This is created by the girder plugin to create anntotation layers.
// This manages a list of annotation layers as divs on the left side of the viewer window.

// Added: currently visible annotations names to the "localStorage" so they remain open when stepping
// through images with the navigator.

// Each layer is a group of vector annotations that can be turned on and off together.
// Layers first started off as markup,  but I am extending this to include a raster mask layer.

// Notes:
// LayerGuis, are annotationLayerGui objects that manaage an annotation layer and GUI

// TODO:
// I want layerGui to own the tools, but the tools have to be available before the first layer is created.
// Make a default layerGui that is not visible until it has its first annotation

// TODO:
// Click Select circle not working
// Cannot navigate viewer with touch.

(function () {
  'use strict';

  function LayerPanel (viewer, itemId) {
    this.Viewer = viewer;
    this.Parent = viewer.GetDiv();
    this.ItemId = itemId;
    this.LayerGuis = [];
    this.ModifiedCount = 0;
    this.EditingLayerGui = undefined;

    this.Viewer.ScaleOn();

    // Because of loading on demand, the easiest way to restore
    // visibile annotations from local storage is to load a list
    // here.
    this.RestoreVisibilityFromLocalStorage();

    // Create a parent div to hold all of the annotation labels
    // Warning: These are duplicated in layerPanel
    this.Margin = 6;
    this.ToolDivHeight = 70;

    // Holds the annotation buttons.  The tool div acutally floats in the viewer.
    this.Div = $('<div>')
      // Have to use this parent, or events are blocked.
      .appendTo(this.Parent)
      .attr('id', 'saAnnotationPanel')
      .hover(function () { $(this).css({'opacity': '1'}); },
             function () { $(this).css({'opacity': '0.6'}); })
      .css({
        'position': 'absolute',
        'left': '3px',
        'top': (5 * this.Margin + this.ToolDivHeight) + 'px',
        'bottom': (2 * this.Margin) + 'px',
        'opacity': '0.6',
        'z-index': '2'});

    // Test
    /*
    var self = this;
    var obj = {'item_id': "5cd437d71841c12368df8519",
               'name': "test.txt",
               'data': "Hello World"};
    girder.rest.restRequest({
      url: 'item/' + obj.item_id + '/tiles',
      method: 'GET'
    }).done(function (data) {
      obj.sizeX = data.sizeX;
      obj.sizeY = data.sizeY;
      self.TestUploadFile(obj);
    });
    */

    this.Parent = viewer.GetDiv();
    this.InitializeHelp(this.Parent.parent());

    // The pannel should probably not be managing this navigation widget.
    // I am putting it here as a temporary home.
    if (itemId) {
      this.InitializeNavigation(viewer.GetDiv(), itemId);
      this.Initialize(this.Div, itemId);
    }

    // To get event calls from the viewer.
    this.Viewer.AddLayer(this);
  }

  LayerPanel.prototype.TestUploadFile = function (obj) {
    var self = this;
    girder.rest.restRequest({
      url: 'item/' + obj.item_id + '/files',
      method: 'GET'
    }).done(function (data) {
      for (var idx = 0; idx < data.length; ++idx) {
        if (data[idx].name === obj.name) {
          obj.file_id = data[idx]._id;
          break;
        }
      }
      self.TestUploadFile2(obj);
    });
  };

  LayerPanel.prototype.TestUploadFile2 = function (obj) {
    var self = this;
    var params;
    if ('file_id' in obj) {
      params = {
        'size': obj.data.length
      };
      girder.rest.restRequest({
        url: 'file/' + obj.file_id + '/contents',
        params: params,
        method: 'PUT'
      }).done(function (data) {
        obj.upload_id = data._id;
        self.TestUploadFile3(obj);
      });
    } else {
      params = {
        'parentType': 'item',
        'parentId': obj.item_id,
        'name': 'test.txt',
        'size': obj.data.length,
        // 'mimeType':'image/png'
        'mimeType': 'text/plain'
      };
      girder.rest.restRequest({
        url: 'file',
        params: params,
        method: 'POST'
      }).done(function (data) {
        obj.upload_id = data._id;
        self.TestUploadFile3(obj);
      });
    }
  };

  LayerPanel.prototype.TestUploadFile3 = function (obj) {
    var params = {
      'offset': 0,
      'uploadId': obj.upload_id
    };
    girder.rest.restRequest({
      url: 'file/chunk',
      params: params,
      method: 'POST',
      data: obj.data
    }).done(function (data) {
      console.log('upload sucessful ' + data['_id']);
    });
  };

  // onresize callback.  Canvas width and height and the camera need
  // to be synchronized with the canvas div.
  LayerPanel.prototype.UpdateSize = function () {
    for (var i = 0; i < this.LayerGuis.length; ++i) {
      var layerGui = this.LayerGuis[i];
      var layer = layerGui.layer;
      if (layer && layer.UpdateSize) {
        layer.UpdateSize();
      }
    }
  };

  LayerPanel.prototype.Draw = function () {
    for (var i = 0; i < this.LayerGuis.length; ++i) {
      var layerGui = this.LayerGuis[i];
      var layer = layerGui.Layer;
      if (layer && layer.Draw) {
        layer.Draw();
      }
    }
  };

  LayerPanel.prototype.Reset = function () {
    for (var i = 0; i < this.LayerGuis.length; ++i) {
      var layerGui = this.LayerGuis[i];
      var layer = layerGui.layer;
      if (layer && layer.Reset) {
        layer.Reset();
      }
    }
  };

  LayerPanel.prototype.InitializeNavigation = function (parent, itemId) {
    var nav = new SA.GirderNavigationWidget(parent, itemId);
    var self = this;
    nav.SetChangeItemCallback(function (itemId) { self.ChangeItem(itemId); });
  };

  // This call back pattern is all because we load on demand.
  // Gets the annotation being edited. If one is not editing, look for one
  // with the default name (users last name).  If none are found, one is created.
  // The tools use this method.
  LayerPanel.prototype.WithEditingLayerCall = function (callback) {
    if (!this.EditingLayerGui) {
      this.EditingLayerGui = this.GetDefaultLayerGui();
    }

    // Make sure it is loaded before executing the callback.
    var layerGui = this.EditingLayerGui;
    layerGui.AfterLoad(function () {
      layerGui.DisplayAnnotation();
      layerGui.EditOn();
      (callback)(layerGui);
    });
  };

  // ===============================================================================
  // TODO: The information has to find a different home.
  LayerPanel.prototype.InitializeHelp = function (parent) {
    var helpDiv = $('<div>')
        .appendTo(parent)
        .css({
          'position': 'absolute',
          'left': '3px',
          'top': '3px',
          'min-height': '300px',
          'min-width': '200px',
          'background-color': '#fff',
          'border': '1px solid #666666',
          'z-index': '400'})
        .hide()
        .on('mouseleave',
            function (e) {
              helpDiv.hide();
            });
    // var helpCloseButton =
    $('<div>')
      .appendTo(helpDiv)
      .prop('title', 'close')
      .addClass('sa-view-button')
      .css({
        'position': 'absolute',
        'right': '3px',
        'top': '3px',
        'height': '24px',
        'color': '#000',
        'z-index': '300'})
      .text('close')
      .on('click touchend',
          function (e) {
            helpDiv.hide();
          });

    var fullScreenOnDiv = $('<div>')
        .appendTo(helpDiv)
        .css({'width': '100%'});
    $('<img>')
      .appendTo(fullScreenOnDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'fullScreen32.png')
      .css({'height': '24px'});
    $('<p>')
      .appendTo(fullScreenOnDiv)
      .css({'display': 'inline-block'})
      .text('Expand the viewer to fullscreen.');

    var fullScreenOffDiv = $('<div>')
        .appendTo(helpDiv)
        .css({'width': '100%'});
    $('<img>')
      .appendTo(fullScreenOffDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'fullScreenOff32.png')
      .css({'height': '24px'});
    $('<p>')
      .appendTo(fullScreenOffDiv)
      .css({'display': 'inline-block'})
      .text('Exit fullscreen');

    var textDiv = $('<div>')
        .appendTo(helpDiv)
        .css({'width': '100%'});
    $('<img>')
      .appendTo(textDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'Text.png')
      .css({'height': '24px'});
    $('<p>')
      .appendTo(textDiv)
      .css({'display': 'inline-block'})
      .text('Text tool: Select text to drag it.');

    var arrowDiv = $('<div>')
        .appendTo(helpDiv)
        .css({'width': '100%'});
    $('<img>')
      .appendTo(arrowDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'Arrow.png')
      .css({'height': '24px'});
    $('<p>')
      .appendTo(arrowDiv)
      .css({'display': 'inline-block'})
      .text('Arrow tool: draw an arrow. Mouse press places the tip. Mouse drag places the end.');

    var pencilDiv = $('<div>')
        .appendTo(helpDiv)
        .css({'width': '100%'});
    $('<img>')
      .appendTo(pencilDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'Pencil-icon.png')
      .css({'height': '24px'});
    $('<p>')
      .appendTo(pencilDiv)
      .css({'display': 'inline-block'})
      .text('Pencil tool: draw lines on the slide. Click on a line to select it.');

    var openDiv = $('<div>')
        .appendTo(helpDiv)
        .css({'width': '100%'});
    $('<img>')
      .appendTo(openDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'open_lasso.png')
      .css({
        'height': '24px',
        'margin-left': '24px'});
    $('<p>')
      .appendTo(openDiv)
      .css({'display': 'inline-block'})
      .text('Open pencil mode: Simple open strokes.');

    var closedDiv = $('<div>')
        .appendTo(helpDiv)
        .css({'width': '100%'});
    $('<img>')
      .appendTo(closedDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'select_lasso.png')
      .css({
        'height': '24px',
        'margin-left': '24px'});
    $('<p>')
      .appendTo(closedDiv)
      .css({'display': 'inline-block'})
      .text('Closed pencil mode: Draw closed loops that can be modified with subsequent strokes. Editing strokes must cross the loop twice.');

    // Selection -------------------------------------------------------------------
    $('<hr>')
      .appendTo(helpDiv);
    $('<p>')
      .appendTo(helpDiv)
      .css({'display': 'inline-block'})
      .text('Click on any annotation to select it. The delete key deletes selected annotations. When one annotation is selected it can be edited.');

    var rectSelectDiv = $('<div>')
        .appendTo(helpDiv)
        .css({'width': '100%'});
    $('<img>')
      .appendTo(rectSelectDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'rect_select.png')
      .css({'height': '24px'});
    $('<p>')
      .appendTo(rectSelectDiv)
      .css({'display': 'inline-block'})
      .text('The rectancle selection tool allows multiple annotations to be selected at once.');

    var propertiesDiv = $('<div>')
        .appendTo(helpDiv)
        .css({'width': '100%'});
    $('<img>')
      .appendTo(propertiesDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'Menu.jpg')
      .css({'height': '24px'});
    $('<p>')
      .appendTo(propertiesDiv)
      .css({'display': 'inline-block'})
      .text('Show the selected annotation\'s property dialog.');

    // Annotation buttons ---------------------------------------------------------
    $('<hr>')
      .appendTo(helpDiv);

    var annotationButtonDiv = $('<div>')
        .appendTo(helpDiv)
        .css({'width': '100%'});
    $('<img>')
      .appendTo(annotationButtonDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'AnnotationButton.jpg')
      .css({'height': '24px'});
    $('<p>')
      .appendTo(annotationButtonDiv)
      .css({'display': 'inline-block'})
      .text('Annotation buttons represent markup collections. YOu can click the name to change it.');

    var visibilityDiv = $('<div>')
        .appendTo(helpDiv)
        .css({'width': '100%'});
    $('<img>')
      .appendTo(visibilityDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'eyeClosed32.png')
      .css({
        'height': '24px',
        'margin-left': '24px'});
    $('<img>')
      .appendTo(visibilityDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'eyeOpen32.png')
      .css({'height': '24px'});
    $('<p>')
      .appendTo(visibilityDiv)
      .css({'display': 'inline-block'})
      .text('The visibility toggle hides or shows all the markups in the annotation group.');

    var editDiv = $('<div>')
        .appendTo(helpDiv)
        .css({'width': '100%'});
    $('<img>')
      .appendTo(editDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'edit_up.png')
      .css({
        'height': '24px',
        'margin-left': '24px'});
    $('<img>')
      .appendTo(editDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'edit_down.png')
      .css({'height': '24px'});
    $('<p>')
      .appendTo(editDiv)
      .css({'display': 'inline-block'})
      .text('The edit toggle selects a single annotation group for editing.');

    var deleteDiv = $('<div>')
        .appendTo(helpDiv)
        .css({'width': '100%'});
    $('<img>')
      .appendTo(deleteDiv)
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'remove.png')
      .css({
        'height': '24px',
        'margin-left': '24px'});
    $('<p>')
      .appendTo(deleteDiv)
      .css({'display': 'inline-block'})
      .text('Delete a selected annotation. If no annotation is selected, the whole annotation group will be deleted.');

    // Toggle the help window on and off.
    // var helpButton =
    $('<img>')
      .appendTo(parent)
      .prop('title', 'help')
      .addClass('sa-view-button')
      .attr('src', SA.ImagePathUrl + 'question32.png')
      .css({
        'position': 'absolute',
        'left': '35px',
        'top': '2px',
        'height': '24px',
        'z-index': '300'})
      .on('click touchend',
          function (e) {
            helpDiv.show();
          });
  };

  // ===============================================================================
  // Call back from navigation to update the annotation to match the viewer item.
  LayerPanel.prototype.ChangeItem = function (itemId) {
    // Change the image in the viewer.
    var self = this;

    this.ItemId = itemId;

    // There is contention trying to restore annotation visibility in the next item.
    // Deleting Annotation Buttons erases local storage of the visible names.
    // Probably a better solution than this is to have two set visibility methods.
    // Only the one used by the gui changes local storage values.
    // For now, save and restore the cached names.
    var savedNames = this.LocalStorageVisibleAnnotationNames.splice(0);

    // Now for the annotation stuff.
    this.DeleteAnnotationButtons();
    this.LocalStorageVisibleAnnotationNames = savedNames;
    this.Initialize(this.Div, itemId);
    girder.rest.restRequest({
      url: 'item/' + itemId + '/tiles',
      method: 'GET'
    }).done(function (data) {
      self.LoadItemToViewer(itemId, data);
    });
  };

  // Now update the annotation GUI
  LayerPanel.prototype.DeleteAnnotationButtons = function () {
    this.EditingLayerGui = undefined;
    for (var i = 0; i < this.LayerGuis.length; ++i) {
      var layerGui = this.LayerGuis[i];
      layerGui.EditOff();
      layerGui.VisibilityOff();
      if (layerGui.Div) {
        layerGui.Div.remove();
      }
    }
    this.LayerGuis = [];
  };

  LayerPanel.prototype.RestoreVisibilityFromLocalStorage = function () {
    this.LocalStorageVisibleAnnotationNames = [];
    var str = localStorage.getItem('SAAnnotationVisibility');
    if (str) {
      this.LocalStorageVisibleAnnotationNames = JSON.parse(str);
    }
  };

  LayerPanel.prototype.SaveVisibilityInLocalStorage = function () {
    // Start with the list in storage already.
    var names = this.LocalStorageVisibleAnnotationNames;

    // Only modify the names this view has.
    // I had a problem where one section did not have an annotation name,
    // So the annotation would turn off when I did not want it to.
    for (var idx = 0; idx < this.LayerGuis.length; ++idx) {
      var layerGui = this.LayerGuis[idx];
      var name = layerGui.Name;
      var nameIdx = names.indexOf(name);
      // Toggle
      if (layerGui.Visible && nameIdx === -1) {
        names.push(layerGui.Name);
      }
      if (!layerGui.Visible && nameIdx !== -1) {
        names.splice(nameIdx, 1);
      }
    }

    localStorage.setItem('SAAnnotationVisibility', JSON.stringify(names));
    this.LocalStorageVisibleAnnotationNames = names;
  };

  LayerPanel.prototype.LoadItemToViewer = function (itemId, data) {
    // TODO: if a viewer already exists, do we render again?
    // SlideAtlas bundles its own version of jQuery, which should attach itself to 'window.$' when it's sourced
    // The 'this.$el' still uses the Girder version of jQuery, which will not have 'saViewer' registered on it.
    var tileSource = {
      height: data.sizeY,
      width: data.sizeX,
      tileWidth: data.tileWidth,
      tileHeight: data.tileHeight,
      minLevel: 0,
      maxLevel: data.levels - 1,
      units: 'mm',
      spacing: [data.mm_x, data.mm_y],
      getTileUrl: function (level, x, y, z) {
        // Drop the 'z' argument
        var apiroot = 'api/v1';
        return apiroot + '/item/' + itemId + '/tiles/zxy/' + level + '/' + x + '/' + y;
      }
    };
    if (!data.mm_x) {
      // tileSource.units = 'pixels';
      tileSource.spacing = [1, 1];
    }

    var note = SA.TileSourceToNote(tileSource);
    this.Viewer.SetNote(note, 0, true);
    // Viewer.prototype.SetViewerRecord(viewerRecord, lockCamera);
  };

  LayerPanel.prototype.Initialize = function (parent, itemId) {
    // The multiple nested annotation button divs are to get the scrollbar
    // on the left, but keep the text left justified.
    this.ScrollDiv = $('<div>')
      .appendTo(parent)
      .attr('id', 'saAnnotationButtons')
      .css({
        'direction': 'rtl',
        'overflow-y': 'auto'
        // 'position': 'absolute',
        // 'left': (3 * this.Margin) + 'px',
        // 'top': (10 * this.Margin) + 'px',
        // 'bottom': (5* this.Margin) + 'px',
        // 'width': '30%',
        // 'opacity': '0.4',
        // 'z-index': '2'
      });

    // A container for the list of buttons.
    this.ButtonDiv = $('<div>')
      .appendTo(this.ScrollDiv)
      .on('mousemove touchmove', function () { return true; })
      .css({'direction': 'ltr'});

    // Get a list of annotations and populate the button div.
    // But first, get info about the user (to manage sharing).
    var self = this;
    girder.rest.restRequest({
      url: 'user/me',
      method: 'GET'
    }).done(function (data) {
      if (!data) {
        self.UserData = {_id: '0000', login: 'guest'};
      } else {
        self.UserData = data;
      }
      if (itemId) { // This check is probably unnecessary
        self.RequestGirderImageItem(itemId);
      }
    });
  };

  // Get a list of annotations and make the buttons.
  // Do not get or load the annotation data yet.
  LayerPanel.prototype.RequestGirderImageItem = function (itemId) {
    // I think data is the wrong place to pass these parameters.
    var data = {
      'limit': 50,
      'offset': 0,
      'sort': 'lowerName',
      'sortdir': 0};

    var self = this;
    // This gives an array of {_id: '....',annotation:{name: '....'},itemId: '....'}
    girder.rest.restRequest({
      url: 'annotation?itemId=' + itemId,
      method: 'GET',
      data: JSON.stringify(data)
    }).done(function (data) {
      self.LoadGirderItemAnnotations(data);
    });
  };
  // Just the meta data for the items.  Make buttons from the meta data.
  LayerPanel.prototype.LoadGirderItemAnnotations = function (data) {
    // TODO: Figure out the edit button (hide it if the user does not have access.)
    for (var i = 0; i < data.length; ++i) {
      var layerGui = new SAM.AnnotationLayerGui(data[i], this);
      this.LayerGuis.push(layerGui);
    }

    // If the user has write access, we need a default layerGui.
    // First we have to see if we have write access to the folder containing this item.
    // We get the folder from the item ........
    if (this.ItemId) {
      var self = this;
      girder.rest.restRequest({
        url: 'item/' + this.ItemId,
        method: 'GET'
      }).done(function (data) {
        self.CheckItemDataAccessTools(data);
      });
    }
  };
  LayerPanel.prototype.CheckItemDataAccessTools = function (data) {
    // First we have to see if we have write access to the folder containing this item.
    var self = this;
    girder.rest.restRequest({
      url: 'folder/' + data.folderId,
      method: 'GET'
    }).done(function (data) {
      self.CheckFolderDataAccessTools(data);
    });
  };
  LayerPanel.prototype.CheckFolderDataAccessTools = function (data) {
    if (data._accessLevel === 0) {
      // No access, skip creating the tools (which are confusing to have
      // if annoation cannot be saved.
      return;
    }

    this.InitializeDefaultToolPanel();
  };

  // This is done when this object is first created, and
  // when the dafault layerGui name is changed.
  LayerPanel.prototype.InitializeDefaultToolPanel = function () {
    this.DefaultToolPanel = new SAM.AnnotationToolPanel(this);
    this.DefaultToolPanel.Show();
  };

  LayerPanel.prototype.GetDefaultLayerName = function () {
    return this.UserData.login;
  };

  // Find or make a deafult GUI (user name).  Return it.
  LayerPanel.prototype.GetDefaultLayerGui = function () {
    var layerGui;
    var defaultLayerName = this.GetDefaultLayerName();
    for (var idx = 0; idx < this.LayerGuis.length; ++idx) {
      layerGui = this.LayerGuis[idx];
      if (layerGui.Name === defaultLayerName) {
        return layerGui;
      }
    }

    // Setting the ToolPanel is deferred until it starts editing.
    layerGui = new SAM.AnnotationLayerGui(
      {'annotation': {'name': defaultLayerName}, 'creatorId': this.UserData._id},
      this);
    this.LayerGuis.push(layerGui);
    return layerGui;
  };

  // ===========================================================================
  // Forward events to layers.

  // onresize callback.  Canvas width and height and the camera need
  // to be synchronized with the canvas div.
  LayerPanel.prototype.UpdateSize = function () {
    for (var i = 0; i < this.LayerGuis.length; ++i) {
      var layerGui = this.LayerGuis[i];
      var layer = layerGui.layer;
      if (layer && layer.UpdateSize) {
        layer.UpdateSize();
      }
    }
  };

  LayerPanel.prototype.Draw = function () {
    for (var i = 0; i < this.LayerGuis.length; ++i) {
      var layerGui = this.LayerGuis[i];
      var layer = layerGui.Layer;
      if (layer && layer.Draw) {
        layer.Draw();
      }
    }
  };

  LayerPanel.prototype.Reset = function () {
    for (var i = 0; i < this.LayerGuis.length; ++i) {
      var layerGui = this.LayerGuis[i];
      var layer = layerGui.layer;
      if (layer && layer.Reset) {
        layer.Reset();
      }
    }
  };

  // TODO: Try to put this into annotationLayerGui (if it makes sense).
  LayerPanel.prototype.HandleTouchStart = function (event) {
    if (this.CheckForIPadPencil(event)) {
      // User is drawing with a pencil.  Make sure a layer is editable.
      this.WithEditingLayerCall(
        function (layerGui) {
          // A small hack.
          layerGui.SelectedWidgets = [layerGui.Layer.GetIPadPencilWidget()];
          layerGui.Layer.HandleTouchStart(event);
        });
      return false;
    }
    if (this.EditingLayerGui) {
      var layer = this.EditingLayerGui.Layer;
      if (layer && layer.HandleTouchStart) {
        return layer.HandleTouchStart(event);
      }
    }
    return true;
  };

  LayerPanel.prototype.HandleTouchMove = function (event) {
    this.CheckForIPadPencil(event);
    if (this.EditingLayerGui) {
      var layer = this.EditingLayerGui.Layer;
      if (layer && layer.HandleTouchMove) {
        return layer.HandleTouchMove(event);
      }
    }
    return true;
  };

  LayerPanel.prototype.HandleTouchEnd = function (event) {
    // No touches for end events so we cannot check for ipad pencil.
    if (this.EditingLayerGui) {
      var layer = this.EditingLayerGui.Layer;
      if (layer && layer.HandleTouchEnd) {
        // To cache pencil editing.
        this.EditingLayerGui.UpdateToolVisibility();
        return layer.HandleTouchEnd(event);
      }
    }
    return true;
  };

  LayerPanel.prototype.HandleMouseDown = function (event) {
    if (this.EditingLayerGui) {
      var layer = this.EditingLayerGui.Layer;
      if (layer && layer.HandleMouseDown) {
        return layer.HandleMouseDown(event);
      }
    }
    return true;
  };

  LayerPanel.prototype.HandleMouseUp = function (event) {
    if (this.EditingLayerGui) {
      var layer = this.EditingLayerGui.Layer;
      if (layer && layer.HandleMouseUp) {
        return layer.HandleMouseUp(event);
      }
    }
    return true;
  };

  LayerPanel.prototype.HandleMouseMove = function (event) {
    if (this.EditingLayerGui) {
      var layer = this.EditingLayerGui.Layer;
      if (layer && layer.HandleMouseMove) {
        return layer.HandleMouseMove(event);
      }
    }
    return true;
  };

  LayerPanel.prototype.HandleMouseWheel = function (event) {
    if (this.EditingLayerGui) {
      var layer = this.EditingLayerGui.Layer;
      if (layer && layer.HandleMouseWheel) {
        return layer.HandleMouseWheel(event);
      }
    }
    return true;
  };

  LayerPanel.prototype.HandleKeyDown = function (event) {
    if (!this.EditingLayerGui) {
      return true;
    }
    var layer = this.EditingLayerGui.Layer;
    // Handle the delete key special
    // Multiple widgets ( in the layer being edit) can be deleted.
    if (event.keyCode === 46 || event.keyCode === 8) { // delete key
      if (this.EditingLayerGui) {
        this.EditingLayerGui.DeleteSelected();
        // TODO: SHould this be in "DeleteSelected"?
        layer.EventuallyDraw();
        event.preventDefault();
        return false;
      }
    }

    if (layer && layer.HandleKeyDown) {
      return layer.HandleKeyDown(event);
    }

    return true;
  };

  // I am going to use click / tap to select markup.
  // How can we enforce only one selected at a time (for click)?
  // First one to consume the click stops propagation.
  // The problem is:  What should we do if one is already selected?
  // Event propagation will turn anyones off in the early layers.
  // After event propagation is stoped,  Loop through the rest
  // un selecting them.
  // NOTE: Select opperates on all layers.  It will choose a new "EditingLayerGui".
  LayerPanel.prototype.HandleMouseClick = function (event) {
    if (this.EditingLayerGui) {
      // See if a widget in the editing wants to handle the click.
      var layer = this.EditingLayerGui.Layer;
      if (layer && layer.HandleMouseClick) {
        if (!layer.HandleMouseClick(event)) {
          // false means the event was consumed.
          return false;
        }
      }

      // This selection path (for an editing layer) is to avoid an
      // undesireable behavior. Accidentally clicking an annotation in
      // a different layer Changed the new layer to take editing focus.
      // New annotations end up in the wrong layer.

      var selectedWidgets = [];
      if (layer.HandleSelect) {
        selectedWidgets = layer.HandleSelect(event);
      }
      // The Gui needs to know which widgets are selected.
      // I do not think I want the layer to keep a pointer to the gui.
      this.EditingLayerGui.SetSelectedWidgets(selectedWidgets);
      // Returning false stops propagation of the event.
      return selectedWidgets.length === 0;
    }

    // This selection path is to turn editing on for a layer.
    // The layer is choosen by which widget is picked.

    // TODO: Get rid of the multiple strokes in a single pencil widget.
    // It was a bad idea. It is 'hard' because lasso interaction editing of loops
    // depends on the two strokes to be in the same widget.  I do not want to
    // Break everything by rewritting this widget again.  I need to detect
    // If the same stroke was selected again (to show the popup).
    // This is the best way to trigger the popup. Ha,  it is not. I am getting
    // rid of the popup anyway.  I will just put a popup button in the option
    // panel.

    for (var i = 0; i < this.LayerGuis.length; ++i) {
      var layerGui = this.LayerGuis[i];
      layer = layerGui.Layer;
      if (!layer) {
        continue;
      }
      if (layer.HandleSelect) {
        selectedWidgets = layer.HandleSelect(event);
        if (selectedWidgets.length > 0) {
          this.SetEditingLayerGui(layerGui);
          this.EditingLayerGui.SetSelectedWidgets(selectedWidgets);
          return false;
        }
      }
    }

    return true;
  };

  // The EditinlayerGui is always set. If non are checked by the user,
  // then use the default layer. The tools of the layer being edited are
  // displayed in this layer panel
  LayerPanel.prototype.SetEditingLayerGui = function (layerGui) {
    if (this.EditingLayerGui === layerGui) {
      return;
    }
    this.DefaultToolPanel.Hide();

    // This check is only used on the first call after this object has been created.
    if (this.EditingLayerGui) {
      this.EditingLayerGui.GetToolPanel().Hide();
      this.EditingLayerGui.EditOff();
    }
    if (layerGui === undefined) {
      this.DefaultToolPanel.Show();
    } else {
      layerGui.GetToolPanel().Show();
    }
    this.EditingLayerGui = layerGui;
  };

  // This adds a pencil ivar (= true) for events generated by the iPad pencil.
  LayerPanel.prototype.CheckForIPadPencil = function (event, debug) {
    if (SAM.MOBILE_DEVICE === 'iPad' && event.touches && event.touches.length === 1) {
      var touch = event.touches[0];
      // iPad pencil generates a force.
      if (touch.force && !isNaN(touch.force) && touch.force !== 0) {
        if (debug) {
          print('event force = ' + touch.force);
        }
        event.pencil = true;
        // Hack
        // TODO: Trigger this on selected stroke.
        this.PencilOpenClosedToggle.show();
        return true;
      } else {
        if (debug) {
          if (touch.force === undefined) {
            print('No force in event');
          } else {
            print('non qualified event force = ' + touch.force);
          }
        }
      }
    }
    return false;
  };

  SAM.LayerPanel = LayerPanel;
})();

// AnnotationLayer holds the view and annotations in a girder annotation object.
// This class (AnnotationLayerGui) holds the GUI button that controls the name,
// visibiltiy button, and edit/save button.  Each annotation layer has one of these objects.

(function () {
  'use strict';

  // This is a helper object that manages one annoation layer.
  function AnnotationLayerGui (metadata, layerPanel) {
    // This is needed because EditOn, has to turn off any other layers editing.
    this.LayerPanel = layerPanel;
    this.Viewer = this.LayerPanel.Viewer;
    // Only widgets in a single layer can be selected at the same time.
    this.SelectedWidgets = [];

    this.ActiveColor = '#7CF';
    this.DefaultColor = '#DDD';
    this.ButtonSize = '16px';
    if (SAM.MOBILE_DEVICE === 'iPad') {
      this.ButtonSize = '24px';
    }

    // For now, users can only see their own annotations.
    // if (metadata.creatorId !== this.LayerPanel.UserData._id) {
    //  return;
    // }
    var self = this;
    var div = $('<div>')
      .appendTo(layerPanel.ButtonDiv)
      .css({
        'display': 'table',
        'min-width': (2 * this.Radius) + 'px',
        'min-height': (2 * this.Radius) + 'px',
        'margin': '2px',
        'background-color': this.DefaultColor,
        'opacity': '0.7',
        'border': '1px solid #666666',
        'border-radius': '2px'
      });
    // Block the viewer from getting events
    // when the buttons and toggles are pressed.
    // This also blocks content editable for the button.
    // Try putting this one level doewn.
    // div.on('mousedown mousemove mouseup touchstart touchend',
    // function () { return false; });

    // Button is for the label and to make it current.
    var nameButton = $('<div>')
        .appendTo(div)
        .css({
          'display': 'inline',
          'position': 'static',
          'padding-left': '4px',
          'padding-right': '4px'})
        .text(metadata.annotation.name);

    nameButton.hover(
      function () {
        $(this).css({'background-color': this.ActiveColor,
          'cursor': 'text'});
      },
      function () {
        $(this).css({'background-color': this.DefaultColor,
          'cursor': 'pointer'});
      });

    // Check is for visibility
    var visToggle = $('<img>')
        .appendTo(div)
        .attr('type', 'image')
        .attr('src', SA.ImagePathUrl + 'eyeClosed32.png')
        .css({
          'display': 'inline',
          'width': this.ButtonSize,
          'height': this.ButtonSize,
          'cursor': 'pointer',
          'position': 'static',
          'margin': '1px',
          'background-color': this.DefaultColor,
          'border': '1px solid #555'});

    // Edit
    var editToggle = $('<img>')
        .appendTo(div)
        .addClass('saEditToggle')
        .attr('type', 'image')
        .attr('src', SA.ImagePathUrl + 'edit_up.png')
        .css({
          'display': 'inline',
          'width': this.ButtonSize,
          'height': this.ButtonSize,
          'cursor': 'pointer',
          'position': 'relative',
          'margin': '1px',
          'background-color': '#fff',
          'border': '1px solid #555'});

    // Delete
    var deleteButton = $('<img>')
        .appendTo(div)
        .attr('type', 'image')
        .attr('src', SA.ImagePathUrl + 'remove.png')
        .css({
          'display': 'inline',
          'width': this.ButtonSize,
          'height': this.ButtonSize,
          'cursor': 'pointer',
          'position': 'relative',
          'color': 'red',
          'margin': '1px',
          'background-color': '#DDD',
          'border': '1px solid #555'})
        .hide();

    // var slider = $('<div>')
    //  .appendTo(div)
    //  .css({'width': '10em',
    //        'margin': '5px'});

    this.GirderAnnotId = metadata._id;
    this.CreatorId = metadata.creatorId;
    this.Data = undefined; //  load on demand
    this.Div = div;
    this.VisToggle = visToggle;
    this.Visible = false;
    this.EditToggle = editToggle;
    this.Editing = false;
    this.NameButton = nameButton;
    this.DeleteButton = deleteButton;
    this.Name = metadata.annotation.name;
    this.Modified = false;

    // Block the viewer from getting events
    // when the buttons and toggles are pressed.
    visToggle.on('mousedown mousemove mouseup touchmove touchend',
                 function () { return false; });
    editToggle.on('mousedown mousemove mouseup touchmove touchend',
                 function () { return false; });
    deleteButton.on('mousedown mousemove mouseup touchmove touchend',
                 function () { return false; });
    nameButton.on('mousedown mousemove mouseup touchmove touchend',
                 function () { return false; });

    // If this is active (which imples checked), unchecking
    // will also deactivate the annotation button.
    visToggle.hover(
      function () {
        $(this).css({'background-color': this.ActiveColor});
      },
      function () {
        $(this).css({'background-color': this.DefaultColor});
      });
    visToggle.on(
      'click touchstart',
      function () {
        if (self.Visible) {
          self.VisibilityOff();
        } else {
          self.AfterLoad(function () { self.VisibilityOn(); });
        }
      });

    editToggle.on(
      'click touchstart',
      function () {
        if (self.Editing) {
          self.EditOff();
        } else {
          self.AfterLoad(function () { self.EditOn(); });
        }
        return false;
      });

    // The user can only activate his own annotations
    if (metadata.creatorId === this.LayerPanel.UserData._id) {
      this.EditNameOff();
      deleteButton.on(
        'click touchstart',
        function () {
          self.DeleteCallback();
          return false;
        });
    }

    // Restore any visible annotations from a previous session.
    if (this.LayerPanel.LocalStorageVisibleAnnotationNames.indexOf(this.Name) > -1) {
      this.AfterLoad(function () {
        self.VisibilityOn();
      });
    }
  }

  AnnotationLayerGui.prototype.MakeAnnotationLayer = function (viewer) {
    // Create an annotation layer by default.
    // viewer.GetDiv() is Same as this.Parent
    var annotationLayer = new SAM.AnnotationLayer(viewer.GetDiv());
    // Only for the text widget (dialog).
    // It needs this reference to turn off events to make the text input work.
    annotationLayer.SetViewer(viewer);
    // Lets just shallow copy the viewers camera to synchronize all layer views..
    annotationLayer.SetCamera(viewer.GetCamera());

    // TODO: Get rid of this.  master view is passed to draw.
    // Hack so the scale widget can get the spacing.
    annotationLayer.ScaleWidget.View = this.MainView;
    // Hack only used for girder testing.
    annotationLayer.SetViewer(viewer);
    annotationLayer.UpdateSize();
    this.Layer = annotationLayer;

    // I am not sure that this is still used.
    var self = this;
    annotationLayer.SetActivatedCallback(function () { self.EditOn(); });
    annotationLayer.SetModifiedCallback(function () { self.AnnotationModified(); });

    return annotationLayer;
  };

  AnnotationLayerGui.prototype.GetToolPanel = function () {
    if (!this.ToolPanel) {
      if (this.Name === this.LayerPanel.GetDefaultLayerName()) {
        this.ToolPanel = this.LayerPanel.DefaultToolPanel;
      } else if (this.Data.annotation.elements.length > 0 &&
          this.Data.annotation.elements[0].user &&
          this.Data.annotation.elements[0].user.imageUrl) {
        this.ToolPanel = new SAM.MaskToolPanel(this.LayerPanel);
      } else {
        this.ToolPanel = new SAM.AnnotationToolPanel(this.LayerPanel);
      }
      this.ToolPanel.SetLayerGui(this);
    }
    return this.ToolPanel;
  };

  // Only one editable at a time (or none)
  AnnotationLayerGui.prototype.EditOn = function () {
    if (this.Editing) {
      this.UpdateToolVisibility();
      return;
    }
    this.Editing = true;

    // Wait as long as possible before creating and setting the tool panel.
    // create it now.  SetEditinglayerGui needs to tool panel.
    this.GetToolPanel();

    // Make the name editable.
    var self = this;
    this.NameButton
      .on('click touchstart', function () {
        self.AfterLoad(function () { self.EditNameOn(); });
        return false;
      });

    this.EditToggle
      .attr('src', SA.ImagePathUrl + 'edit_down.png');
    // Make the delete button visible.
    this.DeleteButton.show();

    // Turn the new on on.
    this.LayerPanel.SetEditingLayerGui(this);
    // Change the color of the GUI.
    this.Div.css({'background-color': this.ActiveColor});
    // Make the markup visible
    this.VisibilityOn();

    this.UpdateToolVisibility();
  };

  AnnotationLayerGui.prototype.EditOff = function () {
    if (!this.Editing) {
      return;
    }
    this.Editing = false;

    this.EditToggle
      .attr('src', SA.ImagePathUrl + 'edit_up.png');

    // Deactivate any widgets in the layer.
    if (this.Layer) {
      this.Layer.SetSelected(false);
      this.Layer.Deactivate();
      this.Layer.EventuallyDraw();
    }
    // Disable editing of the name.
    this.EditNameOff();
    this.NameButton.off('click touchstart');

    // Save the annotation if anything changed.
    if (this.Modified) {
      this.RecordAndSave();
    }
    // Hide the delete button
    this.DeleteButton.hide();
    // Turn the background to the default.
    if (this.LayerPanel.EditingLayerGui === this) {
      this.Div.css({'background-color': this.DefaultColor});
      this.LayerPanel.SetEditingLayerGui(undefined);
    }

    this.UpdateToolVisibility();
  };

  // Called when the user draws something.
  AnnotationLayerGui.prototype.AnnotationModified = function () {
    if (!this.Modified) {
      // For wanr when leaing page with modified annotations.
      // I do not think the count is necessary.
      this.LayerPanel.ModifiedCount += 1; // ????
    }
    this.Modified = true;
    // Change the background color of the edit toggle to show that is is modified.
    if (this.LayerPanel.UserData.login !== 'guest') {
      this.EditToggle.css({'background-color': '#F55'});
    }

    // Save after 30 seconds regardless of additional markup.
    var self = this;
    if (!this.SaveTimerId) {
      console.log('Save in 30 seconds');
      this.SaveTimerId = setTimeout(function () { self.RecordAndSave(); }, 30000);
    }

    window.onbeforeunload = function (event) {
      console.log('Leaving page ' + self.LayerPanel.ModifiedCount);
      return true;
    };
  };

  AnnotationLayerGui.prototype.VisibilityOn = function () {
    if (this.Visible) {
      return;
    }
    this.Visible = true;
    this.VisToggle
      .attr('src', SA.ImagePathUrl + 'eyeOpen32.png');
    this.DisplayAnnotation();

    // Record the visibility of this annotation in local storage.
    this.LayerPanel.SaveVisibilityInLocalStorage();
  };

  AnnotationLayerGui.prototype.VisibilityOff = function () {
    if (!this.Visible) {
      return;
    }
    this.Visible = false;
    this.VisToggle
      .attr('src', SA.ImagePathUrl + 'eyeClosed32.png');
    this.Layer.SetVisibility(false);

    // Editing annots must be visible.
    this.EditOff();
    // Record the visibility of this annotation in local storage.
    this.LayerPanel.SaveVisibilityInLocalStorage();
  };

  // There are two modes for name editing.  This is the inner mode.
  // When the mouse if over the button, make the div content editable.
  AnnotationLayerGui.prototype.EditNameOn = function () {
    var self = this;
    this.EditOn();

    // Get rid of the events blocking viewer interaction
    // but also blocking content editable.
    this.Viewer.InteractionOff();
    this.NameButton.off();
    this.NameButton.attr('tabindex', '1');
    // Sometimes the leave even does not fire, and the viewer appears non functional
    this.LayerPanel.Div.on('mousedown.namebutton', function () { self.EditNameOff(); });
    this.LayerPanel.Div.on('mouseleave.namebutton', function () { self.EditNameOff(); });
    this.Viewer.GetDiv().on('mousedown.namebutton', function () { self.EditNameOff(); });

    this.NameButton
      .attr('contentEditable', true);
    this.NameButton.focus();
  };

  AnnotationLayerGui.prototype.EditNameOff = function () {
    // console.log('edit name off');

    var self = this;
    // Did the name change?
    var name = this.NameButton.text();
    if (name !== this.Name) {
      // Yes,  schedule the change to be saved on the server.
      this.Name = name;
      this.AnnotationModified();
    }

    this.Viewer.InteractionOn();

    this.LayerPanel.Div.off('mousedown.namebutton');
    this.LayerPanel.Div.off('mouseleave.namebutton');
    this.Viewer.GetDiv().off('mousedown.namebutton');

    this.NameButton
      .attr('contentEditable', false)
      .css({'cursor': 'pointer'})
      .on('click touchstart', function () {
        self.AfterLoad(function () { self.EditNameOn(); });
        return false;
      });

    // Turn viewer event blocking on again.
    this.NameButton.on('mousedown mousemove mouseup touchstart touchend',
                       function () { return false; });

    if (this.Name !== this.LayerPanel.GetDefaultLayerName()) {
      this.LayerPanel.InitializeDefaultToolPanel();
    }
  };

  // This call back pattern is all because we load on demand.
  // Call a method after an annotation is loaded.
  AnnotationLayerGui.prototype.AfterLoad = function (callback) {
    // guest annotation
    if (this.GirderAnnotId === undefined) {
      (callback)();
      return;
    }
    if (this.Data) {
      (callback)();
    } else {
      // We need to load the annotation first.
      var self = this;
      $('body').css({'cursor': 'wait'});
      girder.rest.restRequest({
        url: 'annotation/' + this.GirderAnnotId,
        method: 'GET',
        contentType: 'application/json'
      }).done(function (data) {
        $('body').css({'cursor': ''});
        self.Data = data;
        (callback)();
      });
    }
  };

  // Call back from deleteButton.
  AnnotationLayerGui.prototype.DeleteCallback = function () {
    if (!this.LayerPanel.EditingLayerGui) {
      return;
    }
    this.Delete();
  };

  AnnotationLayerGui.prototype.Delete = function () {
    if (!this.LayerPanel.EditingLayerGui.Layer.IsSelected()) {
      if (!confirm('Do you want to delete the entire annotation group?' + this.Name)) {
        return;
      }
      if (this.SaveTimerId) {
        clearTimeout(this.SaveTimerId);
        this.SaveTimerId = undefined;
      }
      // Visibility and editing off.
      this.VisibilityOff();

      if (!this.GirderAnnotId) {
        // Not Saved yet.
        this.DeleteAnnotationGui();
        return;
      }

      // Delete it from the database before deleting the GUI.
      var self = this;
      girder.rest.restRequest({
        url: 'annotation/' + this.GirderAnnotId,
        method: 'DELETE',
        contentType: 'application/json'
      }).done(function (ret) {
        self.DeleteAnnotationGui();
      });
    }
  };

  AnnotationLayerGui.prototype.DeleteAnnotationGui = function () {
    // Break these links which will allow the default tool panel to
    // create another layerGUi if it is used.
    if (this.ToolPanel) {
      this.ToolPanel.SetLayerGui(undefined);
      this.ToolPanel = undefined;
    }
    // Visibility and editing off.
    this.VisibilityOff();
    // Remove the buttons
    this.Div.remove();
    // Take it out of the annotation panel.
    var idx = this.LayerPanel.LayerGuis.indexOf(this);
    this.LayerPanel.LayerGuis.splice(idx, 1);
  };

  // TODO: Load annotations into a 'group'.  Manage separate groups.
  // Move the annotation info to the layer widgets and draw.
  AnnotationLayerGui.prototype.DisplayAnnotation = function () {
    // If there is no layer, we have to create one
    if (!this.Layer) {
      var layer = this.MakeAnnotationLayer(this.Viewer);
      layer.Reset();

      // Put all the rectangles into one set.
      var setObj = {};
      setObj.type = 'rect_set';
      setObj.centers = [];
      setObj.widths = [];
      setObj.heights = [];
      setObj.confidences = [];
      setObj.labels = [];

      if (!this.Data) {
        return;
      }

      var annot = this.Data.annotation;
      for (var i = 0; i < annot.elements.length; ++i) {
        var element = annot.elements[i];
        var obj = {};

        if (element.type === 'view') {
          // Set the camera / view.
          var cam = this.Layer.GetCamera();
          cam.SetWorldFocalPoint(element.center);
          cam.SetHeight(element.height);
          if (element.rotation) {
            cam.SetWorldRoll(element.rotation);
          } else {
            cam.SetWorldRoll(0);
          }
          // Ignore width for now because it is determined by the
          // viewport.
          cam.ComputeMatrix();
          // How to handle forcing viewer to render?
          // I could have a callback.
          // I could also make a $('.sa-viewer').EventuallyRender();
          // or $('.sa-viewer').saViewer('EventuallyRender');
          if (this.Layer.Viewer) {
            this.Layer.Viewer.EventuallyRender();
          }
        }
        if (element.type === 'circle') {
          this.Layer.LoadWidget(element);
        }
        if (element.type === 'rect') {
          this.Layer.LoadWidget(element);
        }
        if (element.type === 'arrow') {
          if (element.label) {
            obj.type = 'text';
            obj.string = element.label.value;
            obj.color = SAM.ConvertColor(element.fillColor);
            obj.size = element.label.fontSize;
            obj.position = element.points[0].slice(0);
            obj.offset = element.points[1].slice(0);
            obj.offset[0] -= obj.position[0];
            obj.offset[1] -= obj.position[1];
            obj.visibility = element.points[0][2];
            this.Layer.LoadWidget(obj);
          } else {
            obj.type = 'arrow';
            obj.origin = element.points[0].slice(0);
            obj.fillColor = element.fillColor;
            obj.lineColor = element.lineColor;
            var dx = element.points[1][0] - element.points[0][0];
            var dy = element.points[1][1] - element.points[0][1];
            var length = Math.sqrt((dx * dx) + (dy * dy));
            obj.length = length;
            // The upper left origin causes orientation to be negative.
            obj.orientation = -Math.atan2(dy / length, dx / length) * 180 / Math.PI;
            if (element.lineWidth !== undefined) {
              obj.width = element.lineWidth;
            } else {
              obj.width = 10;
            }
            obj.fixedsize = 'false';
            obj.fixedorientation = 'false';
            this.Layer.LoadWidget(obj);
          }
        }
        if (element.type === 'rectanglegrid') {
          obj.type = 'grid';
          obj.lineColor = SAM.ConvertColor(element.lineColor);
          obj.lineWidth = element.lineWidth;
          obj.origin = element.center;
          obj.bin_width = element.width / element.widthSubdivisions;
          obj.bin_height = element.height / element.heightSubdivisions;
          obj.orientation = element.rotation;
          obj.dimensions = [element.widthSubdivisions, element.heightSubdivisions];
          this.Layer.LoadWidget(obj);
        }
        if (element.type === 'rectangle') {
          // Switch to rect set versus individual rects. if false
          var keepRectSets = false;
          if (keepRectSets && element.type === 'rectangle') { // switch behavior to ....
            setObj.widths.push(element.width);
            setObj.heights.push(element.height);
            setObj.centers.push(element.center[0]);
            setObj.centers.push(element.center[1]);
            if (element.scalar === undefined) {
              element.scalar = 1.0;
            }
            setObj.confidences.push(element.scalar);
            if (element.label) {
              setObj.labels.push(element.label.value);
            } else {
              setObj.labels.push('');
            }
          } else {
            this.Layer.LoadWidget(element);
          }
        }
        if (element.type === 'polyline') {
          // Make a pencil instead.
          obj.type = 'pencil';
          obj.lineColor = SAM.ConvertColor(element.lineColor);
          obj.lineWidth = element.lineWidth;
          obj.shapes = [element.points];
          obj.closedFlags = [element.closed];
          this.Layer.LoadWidget(obj);
        }
      }

      if (setObj.widths.length > 0) {
        this.Layer.LoadWidget(setObj);
      }
    }

    this.Layer.SetVisibility(true);
    this.Layer.EventuallyDraw();
  };

  // Records and saves an annotation. Will create a new one if this obj has no id.
  AnnotationLayerGui.prototype.RecordAndSave = function () {
    var self = this;
    if (this.SaveTimerId) {
      clearTimeout(self.SaveTimerId);
      self.SaveTimerId = undefined;
    }

    // console.log('Save annotation');
    if (!this.Data) {
      this.Data = {annotation: {elements: []}};
    }
    // Read markup and put into data object.
    this.Data.annotation.elements = this.RecordAnnotation();
    this.Data.annotation.name = this.Name;

    // Change the color of the edit toggle to yellow, to show we are saving.
    this.EditToggle.css({'background-color': '#FF5'});

    if (!this.GirderAnnotId) {
      if (this.Layer.IsEmpty()) {
        // Do not save a new annotation if it is empty.
        this.AnnotationSaved();
        return;
      }
      // A new annotation
      girder.rest.restRequest({
        url: 'annotation?itemId=' + this.LayerPanel.ItemId,
        method: 'POST',
        contentType: 'application/json',
        data: JSON.stringify(this.Data.annotation)
      }).done(function (retAnnot) {
        // Saving has finished.
        // This has the girder id.
        self.GirderAnnotId = self.Data._id = retAnnot._id;
        self.AnnotationSaved();
      });
    } else {
      // Save a modified annotation.
      girder.rest.restRequest({
        url: 'annotation/' + this.GirderAnnotId,
        method: 'PUT',
        contentType: 'application/json',
        data: JSON.stringify(this.Data.annotation)
      }).done(function (retAnnot) {
        // This has the girder id.
        self.AnnotationSaved();
      });
    }
  };

  // Called when the annotation is saved successfully..
  AnnotationLayerGui.prototype.AnnotationSaved = function () {
    if (this.Modified) {
      this.LayerPanel.ModifiedCount -= 1; // ???
    }
    this.Modified = false;
    this.Div.css({'border': '1px solid #666'});
    this.EditToggle.css({'background-color': '#FFF'});
    if (this.LayerPanel.ModifiedCount === 0) {
      window.onbeforeunload = undefined;
    }
  };

  // Converts annotation layer widgets into girder annotation elements.
  // returns an elements array.
  AnnotationLayerGui.prototype.RecordAnnotation = function () {
    var returnElements = [];
    var i;
    var j;
    var k;
    var points;

    // record the view.
    var element;
    for (i = 0; i < this.Layer.GetNumberOfWidgets(); ++i) {
      if (!this.Layer.GetWidget(i).Serialize) {
        continue;
      }
      var widget = this.Layer.GetWidget(i).Serialize();
      if (widget.type === 'circle') {
        element = widget;
      }
      if (widget.type === 'rectangle') {
        element = widget;
      }
      if (widget.type === 'text') {
        // Will not keep scale feature..
        points = [widget.position, widget.offset];
        points[1][0] += widget.position[0];
        points[1][1] += widget.position[1];
        // Have to add a z coordinate for the scheme
        // Hacky way to save visibility state.
        points[0][2] = points[1][2] = widget.visibility;
        element = {
          'type': 'arrow',
          'lineWidth': 10,
          'fillColor': SAM.ConvertColorToHex(widget.color),
          'points': points};
        element.label = {
          'value': widget.string,
          'fontSize': widget.size,
          'color': SAM.ConvertColorToHex(widget.color)};
      }
      if (widget.type === 'arrow') {
        // Will not keep scale feature..
        var pt1 = [widget.origin[0], widget.origin[1], 0];
        var pt2 = [widget.origin[0], widget.origin[1], 0];
        var theta = -widget.orientation * Math.PI / 180.0;
        pt2[0] += widget.length * Math.cos(theta);
        pt2[1] += widget.length * Math.sin(theta);
        points = [pt1, pt2];
        element = {
          'type': 'arrow',
          // 'lineWidth': widget.lineWidth,
          'lineColor': widget.lineColor,
          'fillColor': widget.fillColor,
          'points': points};
      }
      if (widget.type === 'grid') {
        element = {
          'type': 'rectanglegrid',
          'center': widget.origin,
          'width': widget.bin_width * widget.dimensions[0],
          'height': widget.bin_height * widget.dimensions[1],
          'rotation': widget.orientation,
          'normal': [0, 0, 1.0],
          'widthSubdivisions': widget.dimensions[0],
          'heightSubdivisions': widget.dimensions[1],
          'lineWidth': widget.lineWidth,
          'lineColor': widget.lineColor};
      }
      if (widget.type === 'rect_set') {
        var num = widget.widths.length;
        for (j = 0; j < num; ++j) {
          element = {
            'type': 'rectangle',
            'label': {'value': widget.labels[j]},
            'center': [widget.centers[2 * j], widget.centers[2 * j + 1], 0],
            'height': widget.heights[j],
            'width': widget.widths[j],
            'rotation': 0,
            'scalar': widget.confidences[j]};
          returnElements.push(element);
        }
        element = undefined;
      }
      if (widget.type === 'polyline') {
        element = {
          'type': 'polyline',
          'closed': widget.closedloop,
          'lineWidth': widget.lineWidth,
          'lineColor': widget.lineColor,
          'points': widget.points};
      }
      if (widget.type === 'lasso') {
        element = {
          'type': 'polyline',
          'closed': true,
          'lineWidth': widget.lineWidth,
          'lineColor': widget.lineColor,
          'points': widget.points};
      }
      // Pencil scheme not exact match.  Need to split up polylines.
      if (widget.type === 'pencil') {
        for (k = 0; k < widget.shapes.length; ++k) {
          points = widget.shapes[k];
          element = {
            'type': 'polyline',
            'closed': widget.closedFlags[k],
            'points': points};
          // Hackish way to deal with multiple lines.
          if (widget.lineColor !== undefined) {
            element.lineColor = widget.lineColor;
          }
          if (widget.lineWidth !== undefined) {
            element.lineWidth = Math.round(widget.lineWidth);
          }
          returnElements.push(element);
          element = undefined;
        }
      } else if (element) {
        returnElements.push(element);
        element = undefined;
      }
    }
    return returnElements;
  };

  AnnotationLayerGui.prototype.UpdateToolVisibility = function () {
    if (this.ToolPanel) {
      this.ToolPanel.UpdateToolVisibility();
    }
  };

  // Rectangle select is only active on the editing layer.
  // Only widgets from one layer can be selected.
  // Called by the SelectedDeleteButton click event (or delete key).
  // Returns true if a widget was deleted.
  AnnotationLayerGui.prototype.DeleteSelected = function () {
    if (this.Layer.IsEmpty()) {
      this.Delete();
      return;
    }
    if (this.Layer.DeleteSelected()) {
      this.AnnotationModified();
      if (this.Layer.IsEmpty()) {
        this.Delete();
        return;
      }
    }
    this.SelectedWidgets = [];
    // TODO: Clean this up.
    var toolPanel = this.GetToolPanel();
    toolPanel.ToolRadioButtonCallback(toolPanel.CursorButton);
    this.UpdateToolVisibility();
    this.Layer.EventuallyDraw();
  };

  // If only one widget is selected, we make it active (and show the properties button.
  // You can call this with selectedWidget = undefined to unset it.
  // "selectedLayerGui" is the one that contains the widget.
  AnnotationLayerGui.prototype.SetSelectedWidgets = function (selectedWidgets) {
    // Unselect previous selected widgets.
    // I do not think this is necessary.  The picking process should do this.
    // for (var i = 0; i < this.SelectedWidgets.length; ++i) {
    //   var widget = this.SelectedWidgets[i];
    //   widget.SetActive(false);
    // }
    this.SelectedWidgets = [];

    var tools;
    // No widget: Go back to the cursor mode.
    if (!selectedWidgets || selectedWidgets.length === 0) {
      // Nothing was selected.
      // Change the state back to cursor.
      // TODO: Clean this API up.
      tools = this.GetToolPanel();
      tools.HighlightRadioToolButton(tools.CursorButton);
      // See if we can move this to CursorOn
      this.Viewer.EventuallyRender();
      tools.UpdateToolVisibility();
      return true;
    }

    this.EditOn();
    // Hack so I do not need to deal with multiple selection right now.
    var selectedWidget = selectedWidgets[0];

    // TODO: Try to get rid of this case statement.
    // TODO: Move this into ToolPanel
    // Change the tool radio to reflect the widget choosen.
    tools = this.GetToolPanel();
    if (selectedWidget.Type === 'pencil') {
      // Make the open-closed toggle button match the state of the selected widget.
      // I could not (easily) put this in UpdateToolVisibility because the widget
      // was changed to match the button before this code executed.
      if (selectedWidget.IsModeClosed()) {
        tools.SetPencilModeToClosed();
      } else {
        tools.SetPencilModeToOpen();
      }
      // Turn on the pencil tool
      // I am trying to avoid triggering the button. It has caused headaches in the past.
      // This might miss setting up a callback on the widget.
      tools.HighlightRadioToolButton(tools.PencilButton);
      // Should we change this to SetActive(true)?
      selectedWidget.SetStateToDrawing(this.Layer);
    }
    if (selectedWidget.Type === 'text') {
      selectedWidget.SetActive(true);
      tools.HighlightRadioToolButton(tools.TextButton);
    }
    if (selectedWidget.Type === 'arrow') {
      tools.HighlightRadioToolButton(tools.ArrowButton);
      selectedWidget.SetActive(true);
    }
    if (selectedWidget.Type === 'circle') {
      tools.HighlightRadioToolButton(tools.CircleButton);
      selectedWidget.SetActive(true);
    }
    if (selectedWidget.Type === 'rect') {
      tools.HighlightRadioToolButton(tools.RectangleButton);
      selectedWidget.SetActive(true);
    }

    // TODO: This ivar is only really needed for the properties dialog.
    // We could just find the first selected widget ....
    this.SelectedWidgets = selectedWidgets;
    tools.UpdateToolVisibility();
  };

  SAM.AnnotationLayerGui = AnnotationLayerGui;
})();

// Split off from girderAnnotationPannel.js
// NOTE: These two classes have not been untangled completely.
// Try to get rid of "LayerPanel" ivar wherever it is used.

// This creates and manages the set of radio buttons for annotating.
// I tis a bit complex with the states.

// Get iPad pencil automatically triggering pecil tool (transiently)

// Get an eraser pencil option working.

// Text widget does not change background rect size when new lines are added.
// Fix potential infinte loop in pencil widget combine strokes.

// Delete stroke should select the last stroke in the widget. If the widget
// is empty, the widget should be removed and the tool state should go to cursor.

// Pencil should work on the overview.
// Copy?
// Higher opacity on ipad.
// ? button for instructions
// Eraser button.
// Double click a stroke brings up delete.
// Separate out the pencil dialog from the pencil widget.  make it apply to individual strokes.
// pop up dialog on doulbe click.

// Text background flag does not toggle.

// 1: fix delay before pencil starts drawing (gap in line).
//  9: Make the panel collapse to a single button.
// 11: make sure it works on an ipad / surface.

// 3: undo.

// Notes:  It was tricky getting two modes of activating tools:  1 radio button, 2 click to select widget.
// Here is what happens for the two paths:
// Click Tool button
//   0: Update the radio GUI.
//   2: Inactivate previous widget.
//   1: Layer editon (good)
//   3: Activate a new widget active
// Click widget (single select)
//   0: Inactivate Previous widget.
//   1: Widget state to Editing (Widget handles this)
//   2: Layer editon (good)
//   3: Changes tool button GUI.

// TODO: Clean up the access to "AnnotationLayerGui::SelectedWidgets"

(function () {
  'use strict';

  // PencilToggle.
  var OPEN = 0;
  var CLOSED = 1;

  // Parent is the viewer.Div
  // TODO: Simplify the args.
  function AnnotationToolPanel (layerPanel) {
    this.LayerPanel = layerPanel;
    // Any new layers created have to know the viewer.
    this.Viewer = layerPanel.Viewer;

    this.Parent = this.Viewer.GetDiv();

    // -----------------------------------------------------

    // CSS maybe?
    this.Margin = layerPanel.Margin;
    this.ToolDivHeight = layerPanel.ToolDivHeight;

    // If we have write access, this creates markup tools.
    this.ToolPanel = $('<div>')
      .appendTo(this.Parent.parent())
      .hover(function () { $(this).css({'opacity': '1'}); },
             function () { $(this).css({'opacity': '0.6'}); })
      .css({
        'position': 'absolute',
        'background-color': '#fff',
        'border': '1px solid #666666',
        'left': '3px',
        'top': (5 * this.Margin) + 'px',
        // 'height': this.ToolDivHeight.toString() + 'px',
        'opacity': '0.6',
        'z-index': '300'})
      .draggable()
      .hide();

    this.ToolDiv = $('<div>')
      .appendTo(this.ToolPanel);

    this.OptionsDiv = $('<div>')
      .appendTo(this.ToolPanel)
      .attr('id', 'saAnnotationTools');

    this.InitializeTools();
  }

  AnnotationToolPanel.prototype.SetLayerGui = function (layerGui) {
    this.LayerGui = layerGui;
  };

  AnnotationToolPanel.prototype.GetLayerGui = function () {
    if (!this.LayerGui) {
      this.LayerGui = this.LayerPanel.GetDefaultLayerGui();
      // The layer panel aleady sets this,
      // but it cannot hurt to do this for saftey.
      // It is a hack.  No API.
      // this.LayerGui.ToolPanel = this;
    }
    return this.LayerGui;
  };

  AnnotationToolPanel.prototype.Hide = function () {
    this.ToolPanel.hide();
  };

  AnnotationToolPanel.prototype.Show = function () {
    this.ToolPanel.show();
  };

  AnnotationToolPanel.prototype.InitializeTools = function () {
    var self = this;

    // Radio buttons for tools. (One active at a time).
    this.CursorButton = this.AddToolRadioButton('cursor_arrow.png', 'CursorOn');
    this.TextButton = this.AddToolRadioButton('Text.png', 'TextButtonOn');
    this.ArrowButton = this.AddToolRadioButton('Arrow.png', 'ArrowButtonOn');
    this.CircleButton = this.AddToolRadioButton('Circle.png', 'CircleButtonOn');
    this.RectangleButton = this.AddToolRadioButton('rectangle.gif', 'RectangleButtonOn');
    this.PencilButton = this.AddToolRadioButton('Pencil-icon.png', 'PencilButtonOn');
    this.RectSelectButton = this.AddToolRadioButton('rect_select.png', 'RectSelectOn');

    // This is visibile, only when a annotation is being edited.
    this.RectSelectButton.hide();
    this.CursorButton.css({
      'border': '2px solid #333',
      'background-color': '#bcf'});

    // Default just lets the viewer handle the events.
    this.ActiveToolButton = this.CursorButton;

    // Not part of the radio group.  This is a sub option for pencils.
    this.PencilOpenClosedState = OPEN;
    this.PencilOpenClosedToggle = $('<img>')
      .appendTo(this.OptionsDiv)
      .addClass('sa-view-annotation-button sa-flat-button-active')
      .addClass('sa-active')
      .css({
        'border': '1px solid #333',
        'width': '28px',
        'height': '28px',
        'background-color': '#fff'})
      .attr('type', 'image')
      .prop('title', 'open/closed')
      .attr('src', SA.ImagePathUrl + 'open_lasso.png')
      .on('click touchstart',
          function () {
            self.TogglePencilOpenClosed();
            return false;
          })
      .hide();
    this.PencilOpenClosedToggle.on('mousedown mousemove mouseup touchmove touchend',
                                   function () { return false; });

    // Not part of the radio group.  This is a sub option for pencils.
    this.PencilOpenClosedState = OPEN;
    this.PencilOpenClosedToggle = $('<img>')
      .appendTo(this.OptionsDiv)
      .addClass('sa-view-annotation-button sa-flat-button-active')
      .addClass('sa-active')
      .css({
        'border': '1px solid #333',
        'background-color': '#fff'})
      .attr('type', 'image')
      .prop('title', 'open/closed')
      .attr('src', SA.ImagePathUrl + 'open_lasso.png')
      .on('click touchstart',
          function () {
            self.TogglePencilOpenClosed();
            return false;
          })
      .hide();
    this.PencilOpenClosedToggle.on('mousedown mousemove mouseup touchmove touchend',
                                   function () { return false; });

    // A menu button that pops up when a markup is selected.
    // Not part of the radio group.  This is a sub option for widgets.
    this.PropertiesDialogButton = $('<img>')
      .appendTo(this.OptionsDiv)
      .addClass('sa-view-annotation-button sa-flat-button-active')
      .addClass('sa-active')
      .css({
        'border': '1px solid #333',
        'width': '28px',
        'height': '28px',
        'background-color': '#fff'})
      .attr('type', 'image')
      .prop('title', 'properties')
      .attr('src', SA.ImagePathUrl + 'Menu.jpg')
      .on('click touchstart',
          function () {
            self.ShowSelectedWidgetMenu();
            return false;
          })
      .hide()
      .on('mousedown mousemove mouseup touchmove touchend',
          function () { return false; });

    this.LoadDefaults();
  };

  AnnotationToolPanel.prototype.AddToolRadioButton = function (imageFile, onCallbackName) {
    var self = this;
    var button = $('<img>')
        .appendTo(this.ToolDiv)
        .css({
          'border': '2px solid #ccc',
          'margin': '1px',
          'background-color': '#fff',
          'width': '28px',
          'height': '28px'
        })
        .attr('type', 'image')
        .attr('src', SA.ImagePathUrl + imageFile)
      .on('click touchstart',
          function () {
            self.ToolRadioButtonCallback(button);
            return false;
          })
      // To block the viewer moving.
      .on('mousedown mousemove mouseup touchmove touchend',
          function () { return false; });
      // On off functionality
    if (onCallbackName) {
      button.on(
        'radio-on',
        function () {
          self.LayerPanel.WithEditingLayerCall(
            function (layerGui) {
              self.Viewer.InteractionOn();
              (self[onCallbackName])(layerGui);
            });
        });
    }
    return button;
  };

  // Change the state of the Radio GUI, but do not trigger side effects (PencidOn ...)
  AnnotationToolPanel.prototype.HighlightRadioToolButton = function (pressedButton) {
    if (pressedButton === this.ActiveToolButton) {
      return false;
    }
    // Turn off the old one. We have to do this by turning on the cursor.
    this.ActiveToolButton
      .css({
        'border': '2px solid #ccc',
        'background-color': '#fff'});
    // Turn on the new one.
    pressedButton.css({
      'border': '2px solid #222',
      'background-color': '#cdf'});
    this.ActiveToolButton = pressedButton;
  };

  // General for the radio
  // This assumes button is in the ToolRadioButtons list.
  AnnotationToolPanel.prototype.ToolRadioButtonCallback = function (pressedButton) {
    if (pressedButton === this.ActiveToolButton) {
      return false;
    }
    // GUI only change/
    this.HighlightRadioToolButton(pressedButton);

    // Turn off previous tool widgets. (deactivate)
    if (this.LayerPanel.EditingLayerGui) {
      var layer = this.LayerPanel.EditingLayerGui.Layer;
      layer.InactivateAll();
    }

    // Turn on the new one.
    // Note: This ensures a layer is highlighted.
    pressedButton.trigger('radio-on');

    // Show the open closed toggle and other options.
    this.UpdateToolVisibility();
  };

  // Called by the PropertiesDialogButton click event.
  AnnotationToolPanel.prototype.ShowSelectedWidgetMenu = function () {
    var layerGui = this.GetLayerGui();
    if (!layerGui.SelectedWidgets.length === 1) {
      return;
    }

    var widget = layerGui.SelectedWidgets[0];
    if (widget.SetStateToDialog) {
      widget.SetStateToDialog();
    } else {
      widget.ShowPropertiesDialog();
    }
  };

  // When tools have nothing to modify, they disappear.
  // TODO: Help tool. to explain why a tool is not available.
  AnnotationToolPanel.prototype.UpdateToolVisibility = function () {
    if (this.GetLayerGui().SelectedWidgets.length === 1) {
      this.PropertiesDialogButton.show();
    } else {
      this.PropertiesDialogButton.hide();
    }

    // Pencil is always visible. If a layer is not being edited, one is created and set to editon.

    // RectangleSelect is only active when a layer is being edited and it has marks.
    //     An alternitive single select with mouseclick can always select and mark.
    // It does not make sense to create an annotation if one is not editing.
    // any created annotation will have no marks to select. Instead I will disable
    // the button until one is selected.
    // Just show and hid it for now.  I would really like to gray it out and put a hint
    // why it is grayed out.
    if (this.LayerPanel.EditingLayer && !this.LayerPanel.EditingLayer.Layer.IsEmpty()) {
      this.RectSelectButton.show();
    } else {
      this.RectSelectButton.hide();
    }

    // Open closed button is visible when any polylines are selected.
    // or the drawing pencil is active.
    var lineSelected = false;
    if (this.LayerPanel.EditingLayer) {
      var layer = this.LayerPanel.EditingLayer.Layer;
      for (var idx = 0; idx < layer.GetNumberOfWidgets(); ++idx) {
        var widget = layer.GetWidget(idx);
        if (widget.Type === 'pencil' && widget.IsSelected && widget.IsSelected()) {
          lineSelected = true;
          break;
        }
      }
    }
    // Some layer has to be being edited.
    if (this.LayerPanel.EditingLayer) {
      if (this.ActiveToolButton === this.PencilButton || lineSelected) {
        this.PencilOpenClosedToggle.show();
      } else {
        this.PencilOpenClosedToggle.hide();
      }
    }
  };

  AnnotationToolPanel.prototype.LoadDefaults = function () {
    if (localStorage.SaAnnotationPanelDefaults) {
      var defaults = JSON.parse(localStorage.SaAnnotationPanelDefaults);
      if (defaults.PencilMode === 'closed') {
        this.SetPencilModeToClosed();
      }
    }
  };

  AnnotationToolPanel.prototype.SaveDefaults = function () {
    var defaults = {'PencilMode': 'open'};
    if (this.PencilOpenClosedState === CLOSED) {
      defaults.PencilMode = 'closed';
    }
    localStorage.SaAnnotationPanelDefaults = JSON.stringify(defaults);
  };

  AnnotationToolPanel.prototype.TogglePencilOpenClosed = function () {
    if (this.PencilOpenClosedState === CLOSED) {
      this.SetPencilModeToOpen();
    } else {
      this.SetPencilModeToClosed();
    }
    if (this.LayerPanel.EditingLayer) {
      var layer = this.LayerPanel.EditingLayer.Layer;
      layer.EventuallyDraw();
    }
  };

  AnnotationToolPanel.prototype.SetPencilModeToOpen = function () {
    if (this.PencilOpenClosedState === OPEN) {
      return;
    }
    this.PencilOpenClosedState = OPEN;
    this.PencilOpenClosedToggle
        .attr('src', SA.ImagePathUrl + 'open_lasso.png');

    if (this.LayerGui) {
      var layerGui = this.LayerGui;
      for (var i = 0; i < layerGui.SelectedWidgets.length; ++i) {
        var widget = layerGui.SelectedWidgets[i];
        if (widget.SetModeToOpen) {
          widget.SetModeToOpen();
        }
        if (this.LayerPanel.EditingLayer) {
          this.LayerPanel.EditingLayer.Layer.EventuallyDraw();
        }
      }
    }
    this.SaveDefaults();
  };

  AnnotationToolPanel.prototype.SetPencilModeToClosed = function () {
    if (this.PencilOpenClosedState === CLOSED) {
      return;
    }
    this.PencilOpenClosedState = CLOSED;
    this.PencilOpenClosedToggle
        .attr('src', SA.ImagePathUrl + 'select_lasso.png');

    if (this.LayerGui) {
      var layerGui = this.LayerGui;
      for (var i = 0; i < layerGui.SelectedWidgets.length; ++i) {
        var widget = layerGui.SelectedWidgets[i];
        if (widget.SetModeToClosed) {
          widget.SetModeToClosed();
        }
        if (this.LayerPanel.EditingLayer) {
          this.LayerPanel.EditingLayer.Layer.EventuallyDraw();
        }
      }
    }
    this.SaveDefaults();
  };

  // ============================================================================
  // new (used) stuff.

  AnnotationToolPanel.prototype.CursorOn = function () {
    if (this.LayerPanel.EditingLayer && this.LayerPanel.EditingLayer.Layer) {
      this.LayerPanel.EditingLayer.Layer.SetSelected(false);
      this.LayerPanel.EditingLayer.Layer.EventuallyDraw();
    }
    this.Viewer.GetParentDiv().css({'cursor': ''});
    this.ActiveToolButton = this.CursorButton;
    // Is this thie correct behavior?
    if (this.LayerGui) {
      this.LayerGui.SelectedWidgets = [];
    }
  };

  // An annotation has to be selected for editing before this is called.
  // It starts a rectSelectWidget for the user.
  AnnotationToolPanel.prototype.RectSelectOn = function () {
    var self = this;
    var layerGui = this.LayerPanel.EditingLayer;
    // Anything being edited has to be loaded too.
    var layer = layerGui.Layer;
    layer.SetSelected(false);
    var rectSelectWidget = new SAM.RectSelectWidget(layer);
    rectSelectWidget.SetFinishCallback(function (w) { self.RectSelectOff(rectSelectWidget); });
    layer.AddWidget(rectSelectWidget);
    // Start receiving events.
    // Normally this happens as a call back when state changes to drawing.
    layer.ActivateWidget(rectSelectWidget);
    rectSelectWidget.SetStateToDrawing(layer);
  };
  // This is called when the selection has been made by the user.
  AnnotationToolPanel.prototype.RectSelectOff = function (selector) {
    var layerGui = this.LayerPanel.EditingLayer;
    var selectedWidgets = [];
    var layer = layerGui.Layer;
    for (var idx = 0; idx < layer.GetNumberOfWidgets(); ++idx) {
      var w = layer.GetWidget(idx);
      if (w.ApplySelect && w.ApplySelect(selector)) {
        selectedWidgets.push(w);
      }
    }
    layer.RemoveWidget(selector);
    layer.EventuallyDraw();

    layerGui = this.GetLayerGui();
    if (selectedWidgets.length === 1) {
      layerGui.SetSelectedWidget(selectedWidgets[0]);
    } else {
      // See if we can move this to CursorOn
      layerGui.SelectedWidgets = selectedWidgets;
      this.HighlightRadioToolButton(this.CursorButton);
    }
    this.UpdateToolVisibility();
  };

  // TextButton is really a toggle (part of a radio group).
  // Text buttonOn <=> dialog showing.
  // Selecting a text automatically turns text button on and shows dialog.
  // I do not know if any call actually passes a wiodget.
  // Widget is an optional arguement. May not ever be called with a widget.
  AnnotationToolPanel.prototype.TextButtonOn = function (layerGui) {
    // The layer has to be in editing mode.
    layerGui.EditOn();

    var widget;
    // Get a text widget.
    // Look for a selected widget to reuse.
    var layer = layerGui.Layer;
    if (!widget) {
      widget = layer.GetASelectedWidget('text');
    }
    if (!widget) {
      // A selected textWidget was not found. Make a new text widget.
      widget = new SAM.TextWidget(layer);
      // widget.State = 3; // hack hack TODO: fix (text chowing up before dialog closes.
      // Dialog needs tu turn off and on bindings.
      // TODO: REmove dialogs from widget and manage them here.
      // Widgets can share a dialog.
      layer.AddWidget(widget);
      // widget.SetCreationCamera(layer.GetCamera());
      widget.SetStateToDialog();
    }

    // Activate the widget to start drawing.
    // TODO: Fix the Text dialog creation process.  THis is not right but necvessary it seems.
    // widget.SetActive(true);

    // If the text is deactivated by closing the dialog, this will turn off the
    // text button.
    var self = this;
    widget.SetStateChangeCallback(function () {
      if (!widget.Layer) {
        // string was empty.  TODO: find a better way to handle widget initiated delete.
        self.GetLayerGui().SelectedWidgets = [];
        self.ToolRadioButtonCallback(self.CursorButton);
        self.UpdateToolVisibility();
      } else if (!widget.GetActive()) {
        self.ToolRadioButtonCallback(self.CursorButton);
      }
    });

    this.GetLayerGui().SelectedWidgets = [widget];
  };

  // Widget is an optional arguement.
  AnnotationToolPanel.prototype.ArrowButtonOn = function (layerGui) {
    // The layer has to be in editing mode.
    layerGui.EditOn();

    var widget;
    // Get an arrow widget.
    // Look for a selected widget to reuse.
    var layer = layerGui.Layer;
    if (!widget) {
      widget = layer.GetASelectedWidget('arrow');
    }
    if (!widget) {
      // A selected arrowWidget was not found. Make a new arrow widget.
      widget = new SAM.ArrowWidget(layer);
      // Dialog needs tu turn off and on bindings.
      // TODO: REmove dialogs from widget and manage them here.
      // Widgets can share a dialog.
      layer.AddWidget(widget);
      // widget.SetCreationCamera(layer.GetCamera());
    }

    // Activate the widget to start drawing.
    widget.SetStateToDrawing(layer);

    // If the arrow is deactivated with a key stroke, this will turn off the
    // arrow button when the widget deactivates itself.
    var self = this;
    widget.SetStateChangeCallback(function () {
      if (!widget.GetActive()) {
        self.ToolRadioButtonCallback(self.CursorButton);
      }
    });

    this.GetLayerGui().SelectedWidgets = [widget];
  };

  AnnotationToolPanel.prototype.CircleButtonOn = function (layerGui) {
    // The layer has to be in editing mode.
    layerGui.EditOn();

    var widget;
    // Get an arrow widget.
    // Look for a selected widget to reuse.
    var layer = layerGui.Layer;
    if (!widget) {
      widget = layer.GetASelectedWidget('circle');
    }
    if (!widget) {
      // A selected arrowWidget was not found. Make a new arrow widget.
      widget = new SAM.CircleWidget(layer);
      // Dialog needs tu turn off and on bindings.
      // TODO: REmove dialogs from widget and manage them here.
      // Widgets can share a dialog.
      layer.AddWidget(widget);
      // widget.SetCreationCamera(layer.GetCamera());
    }

    // Activate the widget to start drawing.
    widget.SetStateToDrawing(layer);

    // If the arrow is deactivated with a key stroke, this will turn off the
    // arrow button when the widget deactivates itself.
    var self = this;
    widget.SetStateChangeCallback(function () {
      if (!widget.GetActive()) {
        self.ToolRadioButtonCallback(self.CursorButton);
      }
    });

    this.GetLayerGui().SelectedWidgets = [widget];
  };

  AnnotationToolPanel.prototype.RectangleButtonOn = function (layerGui) {
    // The layer has to be in editing mode.
    layerGui.EditOn();

    var widget;
    // Get an arrow widget.
    // Look for a selected widget to reuse.
    var layer = layerGui.Layer;
    if (!widget) {
      widget = layer.GetASelectedWidget('rect');
    }
    if (!widget) {
      // A selected arrowWidget was not found. Make a new arrow widget.
      widget = new SAM.RectWidget(layer);
      // Dialog needs to turn off and on bindings.
      // TODO: REmove dialogs from widget and manage them here.
      // Widgets can share a dialog.
      layer.AddWidget(widget);
      // widget.SetCreationCamera(layer.GetCamera());
    }

    // Activate the widget to start drawing.
    widget.SetStateToDrawing(layer);

    // If the rectangle is deactivated with a key stroke, this will turn off the
    // rectangle button when the widget deactivates itself.
    var self = this;
    widget.SetStateChangeCallback(function () {
      if (!widget.GetActive()) {
        self.ToolRadioButtonCallback(self.CursorButton);
      }
    });

    this.GetLayerGui().SelectedWidgets = [widget];
  };

  // Widget is an optional arguement.
  AnnotationToolPanel.prototype.PencilButtonOn = function (layerGui) {
    // The layer has to be in editing mode.
    layerGui.EditOn();

    var widget;
    // Get a pencil widget.
    // Look for a selected widget to reuse.
    var layer = layerGui.Layer;
    if (!widget) {
      widget = layer.GetASelectedWidget('pencil');
    }
    if (!widget) {
      // A selected pencilWidget was not found. Make a new pencil widget.
      widget = new SAM.PencilWidget(layer);
      // Dialog needs tu turn off and on bindings.
      // TODO: REmove dialogs from widget and manage them here.
      // Widgets can share a dialog.
      layer.AddWidget(widget);
      // widget.SetCreationCamera(layer.GetCamera());
    }

    // Activate the widget to start drawing.
    widget.SetStateToDrawing(layer);

    // If the pencil is deactivated with a key stroke, this will turn off the
    // pencil button when the widget deactivates itself.
    var self = this;
    widget.SetStateChangeCallback(function () {
      if (!widget.GetActive()) {
        self.ToolRadioButtonCallback(self.CursorButton);
      }
    });

    // Will it use open or closed strokes?
    if (this.PencilOpenClosedState === OPEN) {
      widget.SetModeToOpen(layer);
    } else {
      widget.SetModeToClosed(layer);
    }

    this.GetLayerGui().SelectedWidgets = [widget];
  };

  AnnotationToolPanel.prototype.SetTime = function (time) {
    for (var i = 0; i < this.AnnotationObjects.length; ++i) {
      var layerGui = this.AnnotationObjects[i];
      var layer = layerGui.Layer;
      if (layer) {
        layer.ZTime = time;
      }
    }
  };

  SAM.AnnotationToolPanel = AnnotationToolPanel;
})();

// Split off from annotationToolPanel.js
// This is for mask tools: draw and erase.

(function () {
  'use strict';

  // Parent is the viewer.Div
  // TODO: Simplify the args.
  function MaskToolPanel (layerPanel) {
    this.LayerPanel = layerPanel;
    // Any new layers created have to know the viewer.
    this.Viewer = layerPanel.Viewer;

    this.Parent = this.Viewer.GetDiv();

    // -----------------------------------------------------

    // CSS maybe?
    this.Margin = layerPanel.Margin;
    this.ToolDivHeight = layerPanel.ToolDivHeight;

    // If we have write access, this creates markup tools.
    this.ToolPanel = $('<div>')
      .appendTo(this.Parent.parent())
      .hover(function () { $(this).css({'opacity': '1'}); },
             function () { $(this).css({'opacity': '0.6'}); })
      .css({
        'position': 'absolute',
        'background-color': '#fff',
        'border': '1px solid #666666',
        'left': '3px',
        'top': (5 * this.Margin) + 'px',
        'opacity': '0.6',
        'z-index': '300'})
      .draggable()
      .hide();

    this.ToolDiv = $('<div>')
      .appendTo(this.ToolPanel);

    this.OptionsDiv = $('<div>')
      .appendTo(this.ToolPanel)
      .attr('id', 'saAnnotationTools');

    this.InitializeTools();
  }

  MaskToolPanel.prototype.SetLayerGui = function (layerGui) {
    this.LayerGui = layerGui;
  };

  MaskToolPanel.prototype.Hide = function () {
    this.ToolPanel.hide();
  };

  MaskToolPanel.prototype.Show = function () {
    this.ToolPanel.show();
  };

  MaskToolPanel.prototype.InitializeTools = function () {
    // Radio buttons for tools. (One active at a time).
    this.CursorButton = this.AddToolRadioButton('cursor_arrow.png', 'CursorOn');
    this.PaintButton = this.AddToolRadioButton('paint64.png', 'PaintButtonOn');
    this.EraseButton = this.AddToolRadioButton('eraser64.png', 'EraseButtonOn');

    this.CursorButton.css({
      'border': '2px solid #333',
      'background-color': '#bcf'});

    // Default just lets the viewer handle the events.
    this.ActiveToolButton = this.CursorButton;
  };

  MaskToolPanel.prototype.AddToolRadioButton = function (imageFile, onCallbackName) {
    var self = this;
    var button = $('<img>')
        .appendTo(this.ToolDiv)
        .css({
          'border': '2px solid #ccc',
          'margin': '1px',
          'background-color': '#fff',
          'width': '28px',
          'height': '28px'
        })
        .attr('type', 'image')
        .attr('src', SA.ImagePathUrl + imageFile)
      .on('click touchstart',
          function () {
            self.ToolRadioButtonCallback(button);
            return false;
          })
      // To block the viewer moving.
      .on('mousedown mousemove mouseup touchmove touchend',
          function () { return false; });
      // On off functionality
    if (onCallbackName) {
      button.on(
        'radio-on',
        function () {
          self.LayerPanel.WithEditingLayerCall(
            function (annotObj) {
              (self[onCallbackName])(annotObj);
            });
        });
    }
    return button;
  };

  // Change the state of the Radio GUI, but do not trigger side effects (PencidOn ...)
  MaskToolPanel.prototype.HighlightRadioToolButton = function (pressedButton) {
    if (pressedButton === this.ActiveToolButton) {
      return false;
    }
    // Turn off the old one. We have to do this by turning on the cursor.
    this.ActiveToolButton
      .css({
        'border': '2px solid #ccc',
        'background-color': '#fff'});
    // Turn on the new one.
    pressedButton.css({
      'border': '2px solid #222',
      'background-color': '#cdf'});
    this.ActiveToolButton = pressedButton;
  };

  // General for the radio
  // This assumes button is in the ToolRadioButtons list.
  MaskToolPanel.prototype.ToolRadioButtonCallback = function (pressedButton) {
    if (pressedButton === this.ActiveToolButton) {
      return false;
    }
    // GUI only change/
    this.HighlightRadioToolButton(pressedButton);

    // Turn off previous tool widgets. (deactivate)
    if (this.LayerPanel.EditingLayer) {
      var layer = this.LayerPanel.EditingLayer.Layer;
      layer.InactivateAll();
    }

    // Turn on the new one.
    // Note: This ensures a layer is highlighted.
    pressedButton.trigger('radio-on');

    // Show the open closed toggle and other options.
    this.UpdateToolVisibility();
  };

  MaskToolPanel.prototype.UpdateToolVisibility = function () {
    console.log('UpdateToolVisibility not needed here.  Does it have to be called?');
  };

  MaskToolPanel.prototype.CursorOn = function () {
    if (this.LayerPanel.EditingLayer && this.LayerPanel.EditingLayer.Layer) {
      this.LayerPanel.EditingLayer.Layer.SetSelected(false);
      this.LayerPanel.EditingLayer.Layer.EventuallyDraw();
    }
    this.Viewer.GetParentDiv().css({'cursor': ''});
    this.ActiveToolButton = this.CursorButton;
    // Is this thie correct behavior?
    this.LayerGui.SelectedWidgets = [];
  };

  MaskToolPanel.prototype.PaintButtonOn = function (annotObj) {
    // The layer has to be in editing mode.
    annotObj.EditOn();

    var widget;
    // Get a paint widget.
    // Look for a selected widget to reuse.
    var layer = annotObj.Layer;
    // ??????
    if (!widget) {
      widget = layer.GetASelectedWidget('paint');
    }
    if (!widget) {
      // A selected arrowWidget was not found. Make a new arrow widget.
      widget = new SAM.PaintWidget(layer);
      layer.AddWidget(widget);
      widget.SetCreationCamera(layer.GetCamera());
    }

    // Activate the widget to start drawing.
    widget.SetStateToDrawing(layer);

    // If the widget is deactivated with a key stroke, this will turn off the
    // widget button when the widget deactivates itself.
    var self = this;
    widget.SetStateChangeCallback(function () {
      if (!widget.GetActive()) {
        self.ToolRadioButtonCallback(self.CursorButton);
      }
    });

    this.LayerGui.SelectedWidgets = [widget];
  };

  MaskToolPanel.prototype.EraseButtonOn = function (annotObj) {
    // The layer has to be in editing mode.
    annotObj.EditOn();

    var widget;
    // Get an erase widget.
    // Look for a selected widget to reuse.
    var layer = annotObj.Layer;
    // ??????
    if (!widget) {
      widget = layer.GetASelectedWidget('erase');
    }
    if (!widget) {
      // A selected arrowWidget was not found. Make a new arrow widget.
      widget = new SAM.EraseWidget(layer);
      layer.AddWidget(widget);
      widget.SetCreationCamera(layer.GetCamera());
    }

    // Activate the widget to start drawing.
    widget.SetStateToDrawing(layer);

    // If the widget is deactivated with a key stroke, this will turn off the
    // widget button when the widget deactivates itself.
    var self = this;
    widget.SetStateChangeCallback(function () {
      if (!widget.GetActive()) {
        self.ToolRadioButtonCallback(self.CursorButton);
      }
    });

    this.LayerGui.SelectedWidgets = [widget];
  };

  MaskToolPanel.prototype.SetTime = function (time) {
    for (var i = 0; i < this.AnnotationObjects.length; ++i) {
      var annotObj = this.AnnotationObjects[i];
      var layer = annotObj.Layer;
      if (layer) {
        layer.ZTime = time;
      }
    }
  };

  SAM.MaskToolPanel = MaskToolPanel;
})();

// It seems I cannot control the order these files are loaded.
window.SA = window.SA || {};

// Utilities to manage cookies

(function () {
  'use strict';

  SA.setCookie = function (cName, value, exdays) {
    var exdate = new Date();
    exdate.setDate(exdate.getDate() + exdays);
    var cValue = escape(value) + ((exdays === null) ? '' : '; expires=' + exdate.toUTCString());
    document.cookie = cName + '=' + cValue;
  };

  SA.getCookie = function (cName) {
    var i, x, y;
    var ARRcookies = document.cookie.split(';');
    for (i = 0; i < ARRcookies.length; i++) {
      x = ARRcookies[i].substr(0, ARRcookies[i].indexOf('='));
      y = ARRcookies[i].substr(ARRcookies[i].indexOf('=') + 1);
      x = x.replace(/^\s+|\s+$/g, '');
      if (x === cName) {
        return unescape(y);
      }
    }
  };
})();

// To be put in the girder annotation panel.
// Fast forward skips ahead/back 1/10 of folder.
// However, I want to use callbacks to make this more general.

(function () {
  'use strict';

  function GirderNavigationWidget (parent, itemId) {
    this.InitializeItemId(itemId);
    this.ChangeItemCallback = undefined;
    this.ItemIndex = -1;
    this.FolderItemIds = undefined;

    var self = this;
    var size = '40px';
    if (SAM.detectMobile()) {
      // fake a tab
      this.Tab = {};
      this.Tab.Panel = $('<div>')
            .appendTo(parent)
            .hide()
            // .addClass("sa-view-navigation-div ui-responsive");
            .addClass('ui-responsive')
            .css({'position': 'absolute',
              'right': '150px',
              'bottom': '20px',
              'z-index': '5'});
      var panel = this.Tab.Panel;
      this.Tab.show = function () { panel.show(); };
      this.Tab.hide = function () {
        panel.hide();
      };
      // SA.OnStartInteraction( function () { panel.hide();} );
    } else {
      this.Tab = new SA.Tab(parent, SA.ImagePathUrl + 'nav.png', 'navigationTab');
      // this.Tab.Div.prop('title', 'Navigation');
      this.Tab.Div
        // .addClass('sa-view-navigation-div')
        .css({
          'box-sizing': 'border-box',
          '`position': 'absolute',
          'bottom': '0px',
          'right': '150px',
          'z-index': '200'});
      this.Tab.Panel
        .addClass('sa-view-navigation-panel')
        .css({'overflow': 'hidden'});

      // Put the stack display in the navigation button
      this.NoteDisplay = $('<div>')
            .appendTo(this.Tab.Div)
            .addClass('sa-view-note')
            .html('');
    }

    this.PreviousSlideButton =
        $('<img>').appendTo(this.Tab.Panel)
        .addClass('sa-view-navigation-button')
        .attr('src', SA.ImagePathUrl + 'previousSlide.png')
        // .prop('title', 'Previous Slide. (page-up)')
        .click(function () { self.PreviousSlide(); });

    this.PreviousNoteButton =
        $('<img>').appendTo(this.Tab.Panel)
        .addClass('sa-view-navigation-button')
        .attr('src', SA.ImagePathUrl + 'previousNote.png')
        // .prop('title', 'Previous Note. (p)')
        .click(function () { self.PreviousNote(); });

    this.NextNoteButton =
        $('<img>').appendTo(this.Tab.Panel)
        .addClass('sa-view-navigation-button')
        .attr('src', SA.ImagePathUrl + 'nextNote.png')
        // .prop('title', 'Next Note, (n, space)')
        .click(function () { self.NextNote(); });

    this.NextSlideButton =
        $('<img>').appendTo(this.Tab.Panel)
        .addClass('sa-view-navigation-button')
        .attr('src', SA.ImagePathUrl + 'nextSlide.png')
        // .prop('title', 'Next Slide. (page-down)')
        .css({'z-index': '100'})
        .click(function () { self.NextSlide(); });
    this.NextSlideButton
        .on('touchend', function (event) {
          self.NextSlide();
          return false;
        });

    this.NameLabel = $('<div>')
      .appendTo(this.Tab.Panel)
      .css({
        'font-size': '10px',
        'position': 'relative',
        'top': '-3px'});

    // TODO: Fix the main css file for mobile.  Hack this until fixed.
    if (SAM.MOBILE_DEVICE) {
      size = '80px';
      if (SAM.MOBILE_DEVICE === 'iPhone') {
        size = '100px';
      }
      this.PreviousSlideButton
            .css({'height': size,
              'width': size,
              'opacity': '0.8'})
            .on('touchend', function () { self.PreviousSlide(); });
      this.PreviousNoteButton
            .css({'height': size,
              'width': size,
              'opacity': '0.8'})
            .on('touchend', function () { self.PreviousNote(); });
      this.NextNoteButton
            .css({'height': size,
              'width': size,
              'opacity': '0.8'})
            .on('touchend', function () { self.NextNote(); });
      this.NextSlideButton
            .css({'height': size,
              'width': size,
              'opacity': '0.8'});
    }

    // this.CopyrightWrapper =
    //    $('<div>').appendTo(parent)
    //    .css({
    //      'width': '100%',
    //      'text-align': 'center'
    //    }).html();
  }

  GirderNavigationWidget.prototype.SetChangeItemCallback = function (callback) {
    this.ChangeItemCallback = callback;
  };

  GirderNavigationWidget.prototype.ChangeItem = function () {
    window.history.pushState(this.ItemId, 'SlideAtlas viewer ' + this.ItemId,
                             '/#item/' + this.ItemId);

    if (this.ChangeItemCallback) {
      (this.ChangeItemCallback)(this.ItemId);
    }
  };

  GirderNavigationWidget.prototype.InitializeItemId = function (itemId) {
    // Get the item object so we can find the folder id.
    this.ItemId = itemId;
    var self = this;
    girder.rest.restRequest({
      url: 'item/' + itemId,
      method: 'GET'
    }).done(function (data) {
      if (data && data.folderId) {
        self.InitializeFolderId(data.folderId);
      } else {
        console.log('Could not find item ' + itemId);
      }
    });
  };

  GirderNavigationWidget.prototype.InitializeFolderId = function (folderId) {
    // Load the folder so we can create a list to iterate over.
    var self = this;
    girder.rest.restRequest({
      url: 'item?folderId=' + folderId + '&limit=5000&sort=lowerName&sortdir=1',
      method: 'GET'
    }).done(function (data) {
      self.LoadFolderItems(data);
    });
  };

  GirderNavigationWidget.prototype.LoadFolderItems = function (data) {
    this.ItemIndex = -1;
    this.FolderItemIds = [];
    this.FolderItemNames = [];
    for (var i = 0; i < data.length; ++i) {
      var itemId = data[i]._id;
      if (itemId === this.ItemId) {
        this.ItemIndex = i;
      }
      this.FolderItemIds.push(itemId);
      this.FolderItemNames.push(data[i].name);
    }
    this.Update();
  };

  GirderNavigationWidget.prototype.SetInteractionEnabled = function (flag) {
    var self = this;
    if (flag) {
      this.Display.Parent.on(
            'keydown.navigation',
            function (event) {
              return self.HandleKeyDown(event);
            });
    } else {
      this.Display.Parent.off('keydown.navigation');
    }
  };

  GirderNavigationWidget.prototype.HandleKeyDown = function (event) {
    var keyCode = event.keyCode;
    // 34=page down, 78=n, 32=space
    if (keyCode === 34) {
      this.NextSlide();
      return false;
    }
    if (keyCode === 78 || keyCode === 32) {
      this.NextNote();
      return false;
    }
    // 33=page up, 80=p
    if (keyCode === 33) {
      this.PreviousSlide();
      return false;
    }
    if (keyCode === 80) {
      this.PreviousNote();
      return false;
    }

    return true;
  };

  GirderNavigationWidget.prototype.ToggleVisibility = function () {
    this.SetVisibility(!this.Visibility);
  };

  // Used on mobile.
  GirderNavigationWidget.prototype.SetVisibility = function (v) {
    this.Visibility = v;
    if (v) {
      this.Tab.show();
    } else {
      this.Tab.hide();
    }
  };

  // Change which buttons are active based on the current index.
  GirderNavigationWidget.prototype.Update = function () {
    this.ItemName = this.FolderItemNames[this.ItemIndex];
    this.NameLabel.text(this.ItemIndex.toString() + ':' + this.ItemName);

    // Disable and enable prev/next slide buttons so we cannot go past the end.
    if (!this.FolderItemIds || this.ItemIndex <= 0) {
      this.PreviousNoteButton.removeClass('sa-active');
      this.PreviousSlideButton.removeClass('sa-active');
    } else {
      this.PreviousNoteButton.addClass('sa-active');
      this.PreviousSlideButton.addClass('sa-active');
    }
    if (!this.FolderItemIds || this.ItemIndex >= this.FolderItemIds.length - 1) {
      this.NextNoteButton.removeClass('sa-active');
      this.NextSlideButton.removeClass('sa-active');
    } else {
      this.NextNoteButton.addClass('sa-active');
      this.NextSlideButton.addClass('sa-active');
    }
  };

  GirderNavigationWidget.prototype.PreviousNote = function () {
    if (!this.FolderItemIds) { return; }
    // Make sure user notw changes are not pending to be saved.
    // if (SA.notesWidget) { SA.notesWidget.Flush(); }
    if (this.ItemIndex <= 0) {
      return;
    }
    this.ItemIndex -= 1;
    this.ItemId = this.FolderItemIds[this.ItemIndex];
    this.ChangeItem();
    this.Update();
  };

  GirderNavigationWidget.prototype.NextNote = function () {
    if (!this.FolderItemIds) { return; }
    // Make sure user not changes are not pending to be saved.
    // if (SA.notesWidget) { SA.notesWidget.Flush(); }
    if (this.ItemIndex >= this.FolderItemIds.length) {
      return;
    }

    this.ItemIndex += 1;
    this.ItemId = this.FolderItemIds[this.ItemIndex];
    this.ChangeItem();
    this.Update();
  };

  GirderNavigationWidget.prototype.GetFastIncrement = function () {
    var inc = this.FolderItemIds.length / 20;
    if (inc < 5) {
      return 5;
    }
    var tmp;
    for (tmp = 10; tmp <= 50; tmp += 10) {
      if (inc < tmp) {
        return tmp;
      }
    }
    for (tmp = 100; tmp <= 500; tmp += 100) {
      if (inc < tmp) {
        return tmp;
      }
    }
    return 1000;
  };

  GirderNavigationWidget.prototype.PreviousSlide = function () {
    if (!this.FolderItemIds) { return; }
    // Make sure user notw changes are not pending to be saved.
    // if (SA.notesWidget) { SA.notesWidget.Flush(); }

    if (this.ItemIndex <= 0) {
      return;
    }
    var inc = this.GetFastIncrement();

    this.ItemIndex -= inc;
    if (this.ItemIndex < 0) {
      this.ItemIndex = 0;
    }
    this.ItemId = this.FolderItemIds[this.ItemIndex];
    this.ChangeItem();
    this.Update();
  };

  GirderNavigationWidget.prototype.NextSlide = function () {
    if (!this.FolderItemIds) { return; }
    // Make sure user notw changes are not pending to be saved.
    // if (SA.notesWidget) { SA.notesWidget.Flush(); }

    if (this.ItemIndex >= this.FolderItemIds.length) {
      return;
    }
    var inc = this.GetFastIncrement();

    this.ItemIndex += inc;
    if (this.ItemIndex >= this.FolderItemIds.length) {
      this.ItemIndex = this.FolderItemIds.length - 1;
    }
    this.ItemId = this.FolderItemIds[this.ItemIndex];
    this.ChangeItem();
    this.Update();
  };

  SA.GirderNavigationWidget = GirderNavigationWidget;
})();

window.SA = window.SA || {};

(function () {
  'use strict';

  window.requestAnimationFrame =
        window.requestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.msRequestAnimationFrame;

  // TODO: Merge this with cache.SetTileSource.
  SA.TileSourceToCache = function (tileSource) {
    var w = tileSource.width;
    var h = tileSource.height;
    if (!tileSource.bounds) {
      tileSource.bounds = [0, w - 1, 0, h - 1];
    }
    var cache = new SA.Cache();
    cache.TileSource = tileSource;
    // Make an id for the image so it can be reused.
    var image = {levels: tileSource.maxLevel + 1,
      dimensions: [w, h],
      bounds: tileSource.bounds,
      units: tileSource.units,
      spacing: tileSource.spacing,
      _id: new ObjectId().toString()};

    if (tileSource.tileHeight) {
      image.TileHeight = tileSource.tileHeight;
    }

    if (tileSource.tileWidth) {
      image.TileWidth = tileSource.tileWidth;
    }

    if (tileSource.filename) {
      image.filename = tileSource.filename;
      image.label = tileSource.filename;
    } else {
      image.label = image._id;
    }
    cache.SetImageData(image);
    return cache;
  };

  // TODO: Clean up dependency on notes.
  // Girder make a viewer record from a tile source so the rest of slide
  // atlas works.
  SA.TileSourceToViewerRecord = function (tileSource) {
    var w = tileSource.width;
    var h = tileSource.height;
    if (!tileSource.bounds) {
      tileSource.bounds = [0, w - 1, 0, h - 1];
    }
    var cache = SA.TileSourceToCache(tileSource);
    // Make an id for the image so it can be reused.
    var image = cache.Image;
    var record = new SA.ViewerRecord();
    record.Image = image;
    record.OverViewBounds = tileSource.bounds;
    var bds = tileSource.bounds;
    record.Camera = {
      FocalPoint: [(bds[0] + bds[1]) / 2, (bds[2] + bds[3]) / 2],
      Roll: 0,
      Height: bds[3] - bds[2]};
    return record;
  };

  // Girder make a dummy note from a tile source so the rest of slide
  // atlas works.
  SA.TileSourceToNote = function (tileSource) {
    var note = new SA.Note();
    var record = SA.TileSourceToViewerRecord(tileSource);
    note.ViewerRecords.push(record);
    return note;
  };

    // Put the user note text and annotions it the viewer without changing
    // the camera.  THis has the side effect of reloading the primary note
    // annotations, so the caller should record any new annotations in the
    // viewer before calling this.
  SA.UpdateUserNotes = function () {
    if (SA.notesWidget) {
      SA.notesWidget.UpdateUserNotes();
    }
    if (SA.display) {
      SA.display.UpdateUserNotes();
    }
  };

    // So many optional items have a SetNote(note) method, I decided to
    // have a global method to check each.
  SA.SetNote = function (note) {
    if (SA.notesWidget) {
      SA.notesWidget.SetNote(note);
    }
    if (SA.navigationWidget) {
      SA.navigationWidget.SetNote(note);
    }
    if (SA.display) {
      SA.display.SetNote(note);
    }
  };

  SA.SetNoteFromId = function (noteId) {
    var note = SA.GetNoteFromId(noteId);
    if (!note) {
      note = new SA.Note();
      note.LoadViewId(
                noteId,
                function () {
                  SA.SetNote(note);
                });
      return note;
    }
    SA.SetNote(note);
    return note;
  };

  // Firefox does not set which for mouse move events.
  SA.FirefoxWhich = function (event) {
    if (event.which !== undefined) {
      return;
    }
    event.which = event.buttons;
    if (event.which === 2) {
      event.which = 3;
    } else if (event.which === 3) {
      event.which = 2;
    }
    console.log('firefox which = ' + event.which);
  };

  SA.Debug = function (msg) {
    console.log(msg);
  };

  SA.ZERO_PAD = function (i, n) {
    var s = '0000000000' + i.toFixed();
    return s.slice(-n);
  };

  // This file contains some global variables and misc procedures to
  // initials shaders and some buffers we need and to render.
  // Main function called by the default view.html template
  // SA global will be set to this object.

  // For managing progress with multiple ajax calls.
  SA.ProgressCount = 0;

  // How can we distribute the initialization of these?
  // TODO: Many of these are not used anymore. Clean them up.

  SA.Caches = [];

  SA.StartInteractionListeners = [];

  SA.PushProgress = function () {
    $('body').css({'cursor': 'progress'});
    SA.ProgressCount += 1;
  };

  SA.PopProgress = function () {
    SA.ProgressCount -= 1;
    if (SA.ProgressCount <= 0) {
      $('body').css({'cursor': 'default'});
    }
  };

  // Main function called by the default view.html template
  // SA global will be set to this object.
  SA.Run = function () {
    var self = SA;
    if (SA.SessionId) {
      $.ajax({
        type: 'get',
        url: SA.SessionUrl + '?json=true&sessid=' + SA.SessionId,
        success: function (data, status) {
          self.Session = data;
          self.HideAnnotations = data.hide;
          // TODO: fix this serialization.
          self.Run2();
        },
        error: function () {
          SA.Debug('AJAX - error() : session');
          self.Run2();
        }
      });
    } else {
      SA.Run2();
    }
  };

    // Now we have the session (if the id was passed in).
  SA.Run2 = function () {
    // Get the root note.
    if (SA.ViewId === '' || SA.ViewId === 'None') {
      delete SA.ViewId;
    }
    if (SA.SessionId === '' || SA.SessionId === 'None') {
      delete SA.SessionId;
    }

    // We need to get the view so we know how to initialize the app.
    var rootNote = new SA.Note();

    // Hack to create a new presenation.
    if (SA.ViewId === 'presentation') {
      var title = window.prompt('Please enter the presentation title.',
                                      'SlideShow');
      if (title === null) {
                // Go back in browser?
        return;
      }
      rootNote.Title = title;
      rootNote.HiddenTitle = title;
      rootNote.Text = '';
      rootNote.Type = 'HTML';

      Main(rootNote);
    } else {
      if (SA.ViewId === '') {
        SA.Debug('Missing view id');
        return;
      }
      // Sort of a hack that we rely on main getting called after SA
      // method returns and other variables of SA are initialize.
      rootNote.LoadViewId(SA.ViewId,
                            function () { Main(rootNote); });
    }
  };

  // Stack editing stuff (should not be in the global class).
  // It used to be in the event manager.  Skipping the focus stuff.
  // TODO:
  // Modifier could be handled better with keypress events.
  SA.HandleKeyDownStack = function (event) {
    if (SA.ContentEditableHasFocus) { return true; }

    if (event.keyCode === 16) {
      // Do not forward modifier keys events to objects that consume keypresses.
      return true;
    }
    if (event.keyCode === 17) {
      // Control key modifier.
      SA.ControlKeyPressed = true;
      return true;
    }

    // Handle undo and redo (cntrl-z, cntrl-y)
    if (SA.ControlKeyPressed && event.keyCode === 90) {
      // Function in recordWidget.
      SA.recorderWidget.UndoState();
      return false;
    } else if (SA.ControlKeyPressed && event.keyCode === 89) {
      // Function in recordWidget.
      SA.recorderWidget.RedoState();
      return false;
    }

    if (SA.presentation) {
      SA.presentation.HandleKeyDown(event);
      return true;
    }

    return true;
  };

  SA.HandleKeyUpStack = function (event) {
    if (SA.ContentEditableHasFocus) { return true; }

    // For debugging deformable alignment in stacks.
    if (event.keyCode === 90) { // z = 90
      if (event.shiftKey) {
        SA.DeformableAlignViewers(false);
        return true;
      }
    }
    if (event.keyCode === 89) { // y = 89
      if (event.shiftKey) {
        SA.DeformableAlignViewers(true);
        return true;
      }
    }

        // It is sort of a hack to check for the cursor mode here, but it
        // affects both viewers.
    if (event.keyCode === 88) { // x = 88
            // I am using the 'x' key to display to focal point cursor
            // SA.StackCursorFlag = false;
            // what a pain.  Holding x down sometimes blocks mouse events.
            // Have to change to toggle.
      SA.StackCursorFlag = !SA.StackCursorFlag;
      if (event.shiftKey && SA.StackCursorFlag) {
        SA.testAlignTranslation();
        var self = SA;
        window.setTimeout(function () { self.StackCursorFlag = false; }, 1000);
      }

      SA.display.EventuallyRender();
      return false;
    }

    if (event.keyCode === 16) {
      // Shift key modifier.
      // SA.StackCursorFlag = false;
    } else if (event.keyCode === 17) {
      // Control key modifier.
      SA.ControlKeyPressed = false;
    }

        // Is SA really necessary?
        // TODO: Try to remove SA and test presentation stuff.
    if (SA.presentation) {
      SA.presentation.HandleKeyUp(event);
      return true;
    }

    return true;
  };

    // TODO: SA should be in viewer.
  SA.OnStartInteraction = function (callback) {
    SA.StartInteractionListeners.push(callback);
  };

  SA.TriggerStartInteraction = function () {
    if (!SA.StartInteractionListeners) { return; }
    for (var i = 0; i < SA.StartInteractionListeners.length; ++i) {
      var callback = SA.StartInteractionListeners[i];
      callback();
    }
  };

    // TODO: These should be moved to viewer-utils so they can be used
    // separately from SlideAtlas.
    // Helper function: Looks for a key phase in the text.
    // first === true: Look only at the start. Returns true if found.
    // first === false: return index of tag or -1;
  SA.TagCompare = function (tag, text, first) {
    if (first) {
      return (tag.toUpperCase() ===
                    text.substring(0, tag.length).toUpperCase());
    }
    return text.toUpperCase().search(tag.toUpperCase());
  };

    // Process HTML to add standard tags.
    // Returns the altered html.
    // I am writting SA to be safe to call multiple times.
    // Depth first traversal of tree.
  SA.AddHtmlTags = function (item) {
    var container;
    var tags = [{string: 'History:', class: 'sa-history'},
                    {string: 'Diagnosis:', class: 'sa-diagnosis'},
                    {string: 'Differential Diagnosis:', class: 'sa-differential-diagnosis'},
                    {string: 'Teaching Points:', class: 'sa-teaching-points'},
                    {string: 'Compare with:', class: 'sa-compare'},
                    {string: 'Notes:', class: 'sa-notes'}];

        // Since text concatinates children,
        // containers only have to consume siblings.
    var children = item.children();
    var i;
    var j;
    var tag;
    var foundTag;
    var grandChildren;
    for (i = 0; i < children.length; ++i) {
      var child = $(children[i]);

      // Look for an existing class from our set.
      // If we find one, terminate processing for the item and ites children.
      // Terminate the container collecting items.
      for (j = 0; j < tags.length; ++j) {
        if (child.hasClass(tags[j].class)) {
          foundTag = tags[j];
        }
      }
      if (foundTag) {
        container = undefined;
        continue;
      }

      // special (one line tag)
      if (child.hasClass('sa-ssc-title')) {
        container = undefined;
        continue;
      }

      // Look for a tag string inthe text
      var text = child.text();
      // Special case: treat the title as a single line.
      if (SA.TagCompare('SSC', text, true) && !child.hasClass('sa-ssc-title')) {
        child.addClass('sa-ssc-title');
      }

      // Make sure tags are not grouped.
      // SA is a bit of a hack.  THere are too many ways html can be formatted.
      if (child.children().length > 1) {
        for (j = 0; j < tags.length; ++j) {
          tag = tags[j];
          if (SA.TagCompare(tag.string, text, false) > 0) {
            grandChildren = child.children();
            grandChildren.remove();
            grandChildren.insertAfter(child);
            children = item.children();
            text = child.text();
            break;
          }
        }
      }

      // These tags consume children followint the tag.
      foundTag = false;
      for (j = 0; j < tags.length; ++j) {
        tag = tags[j];
        if (SA.TagCompare(tag.string, text, true)) {
          foundTag = tag;
          break;
        }
      }

      if (foundTag) {
        // If the outer is a div,  reuse it for the container.
        // There was a bug with diagnosis in the history container.
        // This will ungroup multiple tags. However recursion may be
        // needed.
        if (child[0].tagName === 'DIV') {
          grandChildren = child.children();

          // child.empty() // looses text that is not a child.
          // child.contents()[0] gets it. Maybe make a span and
          // put it after 'child'.
          child.children().remove();

          grandChildren.insertAfter(child);
          children = item.children();
          container = child;
          ++i;
          child = $(children[i]);
        } else {
          // Start a new container.
          container = $('<div>')
                        .insertBefore(child);
          children = item.children();
          // Manipulating a list we are traversing is a pain.
          ++i;
        }
        container.addClass(foundTag.class);
      }

            // If we have a container, it consumes all items after it.
      if (container) {
                // Remove the item and add it to the container.
        child.remove();
        child.appendTo(container);
        children = item.children();
                // Manipulating a list we are traversing is a pain.
        --i;
      }
    }
  };

    // Useful utility to get selected text / the position of the cursor.
    // Get the selection in div.  Returns a range.
    // If not, the range is collapsed at the
    // end of the text and a new line is added.
    // div is a jquery parent.
  SA.GetSelectionRange = function (div) {
    var sel = window.getSelection();
    var range;
    var parent = null;

        // Two conditions when we have to create a selection:
        // nothing selected, and something selected in wrong parent.
        // use parent as a flag.
    if (sel.rangeCount > 0) {
            // Something is selected
      range = sel.getRangeAt(0);
      range.noCursor = false;
            // Make sure the selection / cursor is in this editor.
      parent = range.commonAncestorContainer;
            // I could use jquery .parents(), but I bet this is more efficient.
      while (parent && parent !== div[0]) {
                // if ( ! parent) {
                // I believe this happens when outside text is selected.
                // We should we treat this case like nothing is selected.
                // console.log("Wrong parent");
                // return;
                // }
        if (parent) {
          parent = parent.parentNode;
        }
      }
    }
    if (!parent) {
      return null;
            // returnSA.MakeSelectionRange(div);
    }

    return range;
  };

    // When we are inserting at the end and nothing is selected, we need to
    // add a div with a break at the end and select the break. This keeps the
    // cursor after the inserted item. This returns the range.
  SA.MakeSelectionRange = function (div) {
        // When nothing is select, I am trying to make the cursor stay
        // after the question inserted with the range we return.
        // TODO: change this so that the div is added after the dialog
        // apply. Cancel should leave div unchanged.(AddQuestion)
    var sel = window.getSelection();

    div[0].focus();
    var br = $('<br>').appendTo(div);
    var range = document.createRange();
    range.selectNode(br[0]);
    sel.removeAllRanges();
    sel.addRange(range);
    return range;
  };

  SA.GetUser = function () {
    if (typeof (SA.User) !== 'undefined') {
      return SA.User;
    }
        // Happens with girder plugin.
        // SA.Debug("Could not find user");
    return '';
  };

  SA.initWebGL = function (view) {
    // if (view.imageProgram) { return; }
    // Defined in HTML
    // initShaderPrograms(view.gl);
    // initOutlineBuffers(view.gl);
    initImageTileBuffers(view);
  };

  function getShader (gl, type, str) {
    var shader;
    shader = gl.createShader(type);
    gl.shaderSource(shader, str);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      SA.Debug(gl.getShaderInfoLog(shader));
      return null;
    }

    return shader;
  }

// Not used because annotations are all canvas.
// Might be useful in the future.
/*
<script id="shader-poly-fs" type="x-shader/x-fragment">
  precision mediump float;
  uniform vec3 uColor;
  void main(void) {
   gl_FragColor = vec4(uColor, 1.0);
   //gl_FragColor = vec4(0.5, 0.0, 0.0, 1.0);
  }
</script>
<script id="shader-poly-vs" type="x-shader/x-vertex">
  attribute vec3 aVertexPosition;
  uniform mat4 uMVMatrix;
  uniform mat4 uPMatrix;
  void main(void) {
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
  }
</script>

<script id="shader-text-fs" type="x-shader/x-fragment">
  precision mediump float;

  varying vec2 vTextureCoord;
  uniform sampler2D uSampler;
  uniform vec3 uColor;

  void main(void) {
    vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
    // Use the image pixel value as transparency.
    gl_FragColor = vec4(uColor, textureColor.rgb[0]);
  }
</script>
<script id="shader-text-vs" type="x-shader/x-vertex">
  attribute vec3 aVertexPosition;
  attribute vec2 aTextureCoord;

  uniform mat4 uMVMatrix;
  uniform mat4 uPMatrix;

  varying vec2 vTextureCoord;
  void main(void) {
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    vTextureCoord = aTextureCoord;
  }

  function initShaderPrograms (view, gl) {
    // Test threshold value for alpha.
    var heatMapTestFragmentShaderString =
            'precision highp float;' +
            'uniform sampler2D uSampler;' +
            'varying vec2 vTextureCoord;' +
            'void main(void) {' +
            '   vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));' +
            '   highp float value = textureColor.rgb[1] + textureColor.rgb[1] +textureColor.rgb[2];' +
            '   if (value < 0.3 || value > 2.5) {' +
            '     textureColor[0] = textureColor[1] = textureColor[2] = textureColor[3] = 0.0;' +
            '   }' +
            '   gl_FragColor = textureColor;' +
            ' }';
    // Test red->alpha, greed->hue
    var heatMapHueFragmentShaderString =
            'precision highp float;' +
            'uniform sampler2D uSampler;' +
            'varying vec2 vTextureCoord;' +
            'void main(void) {' +
            '  vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));' +
            '  textureColor[3] = textureColor[0];' +
            '  highp float h = textureColor[1] * 6.0;' +
            '  if (h < 1.0) {' +
            '    textureColor[0] = 1.0;' +
            '    textureColor[1] = h;' +
            '    textureColor[3] = 0.0;' +
            '  } else if (h < 2.0) {' +
            '    textureColor[0] = 2.0-h;' +
            '    textureColor[1] = 1.0;' +
            '    textureColor[3] = 0.0;' +
            '  } else if (h < 3.0) {' +
            '    textureColor[0] = 0.0;' +
            '    textureColor[1] = 1.0;' +
            '    textureColor[3] = h-2.0;' +
            '  } else if (h < 4.0) {' +
            '    textureColor[0] = 0.0;' +
            '    textureColor[1] = 4.0-h;' +
            '    textureColor[3] = 1.0;' +
            '  } else if (h < 5.0) {' +
            '    textureColor[0] = h-4.0;' +
            '    textureColor[1] = 0.0;' +
            '    textureColor[3] = 1.0;' +
            '  } else if (h < 6.0) {' +
            '    textureColor[0] = 1.0;' +
            '    textureColor[1] = 0.0;' +
            '    textureColor[3] = 6.0-h;' +
            '  }' +
            '  gl_FragColor = textureColor;' +
            '}';
    // Test red->alpha, constant color set externally
    var heatMapFragmentShaderString =
            'precision highp float;' +
            'uniform sampler2D uSampler;' +
            'uniform vec3 uColor;' +
            'varying vec2 vTextureCoord;' +
            'void main(void) {' +
            '  vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t)).rgba;' +
            '  textureColor = vec4(uColor, textureColor[0]);' +
            '  gl_FragColor = textureColor;' +
            '}';
    var fragmentShaderString =
            'precision highp float;' +
            'uniform sampler2D uSampler;' +
            'varying vec2 vTextureCoord;' +
            'void main(void) {' +
            '   vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));' +
            '   gl_FragColor = textureColor;' +
            ' }';
    var vertexShaderString =
            'attribute vec3 aVertexPosition;' +
            'attribute vec2 aTextureCoord;' +
            'uniform mat4 uMVMatrix;' +
            'uniform mat4 uPMatrix;' +
            'uniform mat3 uNMatrix;' +
            'varying vec2 vTextureCoord;' +
            'void main(void) {' +
            '  gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition,1.0);' +
            '  vTextureCoord = aTextureCoord;' +
            '}';

    // SA.imageProgram = SA.createWebGlProgram(fragmentShaderString, vertexShaderString, gl);
    view.imageProgram = SA.createWebGlProgram(heatMapFragmentShaderString, vertexShaderString, gl);
    // Texture coordinate attribute and texture image uniform
    view.imageProgram.textureCoordAttribute =
        gl.getAttribLocation(view.imageProgram, 'aTextureCoord');
    gl.enableVertexAttribArray(view.imageProgram.textureCoordAttribute);
    view.imageProgram.samplerUniform = gl.getUniformLocation(view.imageProgram, 'uSampler');
    view.imageProgram.colorUniform = gl.getUniformLocation(view.imageProgram, 'uColor');

    // polyProgram = SA.createWebGlProgram("shader-poly-fs", "shader-poly-vs", gl);
    // polyProgram.colorUniform = gl.getUniformLocation(polyProgram, "uColor");

    // textProgram = SA.createWebGlProgram("shader-text-fs", "shader-text-vs", gl);
    // textProgram.textureCoordAttribute
    //    = gl.getAttribLocation(textProgram, "aTextureCoord");
    // gl.enableVertexAttribArray(textProgram.textureCoordAttribute);
    // textProgram.samplerUniform
    //    = gl.getUniformLocation(textProgram, "uSampler");
    // textProgram.colorUniform = gl.getUniformLocation(textProgram, "uColor");
  }
*/

  SA.createWebGlProgram = function (fragmentShaderString, vertexShaderString, gl) {
    var fragmentShader = getShader(gl, gl.FRAGMENT_SHADER, fragmentShaderString);
    var vertexShader = getShader(gl, gl.VERTEX_SHADER, vertexShaderString);

    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      SA.Debug('Could not initialise shaders');
    }

    program.vertexPositionAttribute = gl.getAttribLocation(program, 'aVertexPosition');
    gl.enableVertexAttribArray(program.vertexPositionAttribute);

        // Camera matrix
    program.pMatrixUniform = gl.getUniformLocation(program, 'uPMatrix');
        // Model matrix
    program.mvMatrixUniform = gl.getUniformLocation(program, 'uMVMatrix');

    return program;
  };
  /*
  function initOutlineBuffers (gl) {
    // Outline Square
    var vertices = [
      0.0, 0.0, 0.0,
      0.0, 1.0, 0.0,
      1.0, 1.0, 0.0,
      1.0, 0.0, 0.0,
      0.0, 0.0, 0.0];
    SA.squareOutlinePositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, SA.squareOutlinePositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    SA.squareOutlinePositionBuffer.itemSize = 3;
    SA.squareOutlinePositionBuffer.numItems = 5;

    // Filled square
    SA.squarePositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, SA.squarePositionBuffer);
    vertices = [
      1.0, 1.0, 0.0,
      0.0, 1.0, 0.0,
      1.0, 0.0, 0.0,
      0.0, 0.0, 0.0
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    SA.squarePositionBuffer.itemSize = 3;
    SA.squarePositionBuffer.numItems = 4;
  }
  */
  // ==============================================================================

  function initImageTileBuffers (view) {
    if (view.tileVertexTextureCoordinateBuffer) { return; }

    var gl = view.gl;
    var vertexPositionData = [];
    var textureCoordData = [];

    // Make 4 points
    textureCoordData.push(0.0);
    textureCoordData.push(0.0);
    vertexPositionData.push(0.0);
    vertexPositionData.push(0.0);
    vertexPositionData.push(0.0);

    textureCoordData.push(1.0);
    textureCoordData.push(0.0);
    vertexPositionData.push(1.0);
    vertexPositionData.push(0.0);
    vertexPositionData.push(0.0);

    textureCoordData.push(0.0);
    textureCoordData.push(1.0);
    vertexPositionData.push(0.0);
    vertexPositionData.push(1.0);
    vertexPositionData.push(0.0);

    textureCoordData.push(1.0);
    textureCoordData.push(1.0);
    vertexPositionData.push(1.0);
    vertexPositionData.push(1.0);
    vertexPositionData.push(0.0);

        // Now create the cell.
    var cellData = [];
    cellData.push(0);
    cellData.push(1);
    cellData.push(2);

    cellData.push(2);
    cellData.push(1);
    cellData.push(3);

    view.tileVertexTextureCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, view.tileVertexTextureCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordData), gl.STATIC_DRAW);
    view.tileVertexTextureCoordBuffer.itemSize = 2;
    view.tileVertexTextureCoordBuffer.numItems = textureCoordData.length / 2;

    view.tileVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, view.tileVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), gl.STATIC_DRAW);
    view.tileVertexPositionBuffer.itemSize = 3;
    view.tileVertexPositionBuffer.numItems = vertexPositionData.length / 3;

    view.tileCellBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, view.tileCellBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cellData), gl.STATIC_DRAW);
    view.tileCellBuffer.itemSize = 1;
    view.tileCellBuffer.numItems = cellData.length;
  }

    // TODO: Get rid of this as legacy.
    // I put an eveutallyRender method in the viewer, but have not completely
    // converted code yet.
    // Stuff for drawing
    // var RENDER_PENDING = false;
    // function eventuallyRender() {
    //    if (! RENDER_PENDING) {
    //      RENDER_PENDING = true;
    //      requestAnimFrame(tick);
    //    }
    // }

    // function tick() {
    //    //console.timeEnd("system");
    //    RENDER_PENDING = false;
    //    draw();
    //    //console.time("system");
    // }

    // ==============================================================================
    // Alternative to webgl, HTML5 2d canvas

  function initGC () {
    SAM.detectMobile();
  }

  // ----------------------------------------------------------
  // Log to track down iPad bug.  Console does not log until
  // debugger is running.  Bug does not occur when debugger
  // is running.

  var LOGGING = false;
  var DEBUG_LOG = [];

  function StartLogging (message) { // eslint-disable-line no-unused-vars
    if (LOGGING) {
      return;
    }
    LOGGING = true;
    // alert("Error: Check log");
  }

  function LogMessage (message) { // eslint-disable-line no-unused-vars
    if (LOGGING) {
      DEBUG_LOG.push(message);
    }
  }

  // ----------------------------------------------------------
  // In an attempt to simplify the view.html template file, I am putting
  // as much of the javascript from that file into this file as I can.
  // As I abstract viewer features, these variables and functions
  // should migrate into objects and other files.

  // ==============================================================================

  // TODO:  Get rid of this function.
  function handleResize () {
    $('window').trigger('resize');
  }

  // TODO: Move these out of the global SLideAtlas object.
  function handleKeyDown (event) {
    return SA.HandleKeyDownStack(event);
  }
  function handleKeyUp (event) {
    return SA.HandleKeyUpStack(event);
  }

  SA.cancelContextMenu = function (e) {
    // alert("Try to cancel context menu");
    if (e && e.stopPropagation) {
      e.stopPropagation();
    }
    return false;
  };

  // Call back from NotesWidget.
  function NotesModified () {
    if (SA.Edit && SA.SaveButton) {
      SA.SaveButton.attr('src', SA.ImagePathUrl + 'save.png');
    }
  }

  function NotesNotModified () {
    if (SA.Edit && SA.SaveButton) {
      SA.SaveButton.attr('src', SA.ImagePathUrl + 'save22.png');
    }
  }

  // This function gets called when the save button is pressed.
  function SaveCallback () {
    // TODO: This is no longer called by a button, so change its name.
    SA.notesWidget.SaveCallback(
            function () {
              // finished
              SA.SaveButton.attr('src', SA.ImagePathUrl + 'save22.png');
            });
  }

  // This serializes loading a bit, but we need to know what type the note is
  // so we can coustomize the webApp.  The server could pass the type to us.
  // It might speed up loading.
  // Note is the same as a view.
  function Main (rootNote) {
    SA.RootNote = rootNote;

    if (rootNote.Type === 'Presentation' ||
            rootNote.Type === 'HTML') {
      SA.presentation = new SA.Presentation(rootNote, SA.Edit);
      return;
    }

    SAM.detectMobile();
    $('body').addClass('sa-view-body');
    // Just to see if webgl is supported:
    // var testCanvas = document.getElementById("gltest");

    // I think the webgl viewer crashes.
    // Maybe it is the texture leak I have seen in connectome.
    // Just use the canvas for now.
    // I have been getting crashes I attribute to not freeing texture
    // memory properly.
    // NOTE: I am getting similar crashes with the canvas too.
    // Stack is running out of some resource.
    // initGL(); Sets CANVAS and GL global variables
    initGC();

    if (SAM.detectMobile() && SA.MOBILE_ANNOTATION_WIDGET) {
      SA.MOBILE_ANNOTATION_WIDGET = new SA.MobileAnnotationWidget();
    }

    SA.MainDiv = $('<div>')
            .appendTo('body')
            .css({
              'position': 'fixed',
              'left': '0px',
              'width': '100%'})
            .saFullHeight();
        // .addClass("sa-view-canvas-panel")

        // Left panel for notes.
    SA.resizePanel = new SA.ResizePanel(SA.MainDiv);
    SA.display = new SA.DualViewWidget(SA.resizePanel.MainDiv);
    SA.notesWidget = new SA.NotesWidget(SA.resizePanel.PanelDiv,
                                            SA.display);

    if (rootNote.Type === 'Stack') {
      SA.display.SetNumberOfViewers(2);
    }

    SA.notesWidget.SetModifiedCallback(NotesModified);
    SA.notesWidget.SetModifiedClearCallback(NotesNotModified);
        // Navigation widget keeps track of which note is current.
        // Notes widget needs to access and change this.
    SA.notesWidget.SetNavigationWidget(SA.display.NavigationWidget);
    if (SA.display.NavigationWidget) {
      SA.display.NavigationWidget.SetInteractionEnabled(true);
    }

    SA.recorderWidget = new SA.RecorderWidget(SA.display);

        // Do not let guests create favorites.
        // TODO: Rework how favorites behave on mobile devices.
    if (SA.User !== '' && !SAM.detectMobile()) {
      if (SA.Edit) {
                // Put a save button here when editing.
        SA.SaveButton = $('<img>')
                    .appendTo(SA.resizePanel.MainDiv)
                    .css({'position': 'absolute',
                      'bottom': '4px',
                      'left': '10px',
                      'height': '28px',
                      'z-index': '5'})
                    .prop('title', 'save to databse')
                    .addClass('editButton')
                    .attr('src', SA.ImagePathUrl + 'save22.png')
                    .click(SaveCallback);
                // for (var i = 0; i < SA.display.Viewers.length; ++i) {
                // SA.display.Viewers[i].OnInteraction(function () {});
                // }
      } else {
                // Favorites when not editing.
        SA.FAVORITES_WIDGET = new SA.FavoritesWidget(SA.MainDiv, SA.display);
                // SA.FAVORITES_WIDGET.HandleResize(CANVAS.innerWidth());
      }
    }

    if (SAM.MOBILE_DEVICE && SA.DualDisplay &&
            SA.DualDisplay.NavigationWidget) {
      SA.DualDisplay.NavigationWidget.SetVisibility(false);
    }
    if (SAM.MOBILE_DEVICE && SA.MOBILE_ANNOTATION_WIDGET) {
      SA.MOBILE_ANNOTATION_WIDGET.SetVisibility(false);
    }

        // CONFERENCE_WIDGET = new SA.ConferenceWidget();

        // The event manager still handles stack alignment.
        // This should be moved to a stack helper class.
        // Undo and redo too.
    document.onkeydown = handleKeyDown;
    document.onkeyup = handleKeyUp;

        // Keep the browser from showing the left click menu.
    document.oncontextmenu = SA.cancelContextMenu;

    if (!SAM.MOBILE_DEVICE) {
            // Hack for all viewer edit menus to share browser.
      SA.VIEW_BROWSER = new SA.ViewBrowser($('body'));

            // TODO: See if we can get rid of this, or combine it with
            // the view browser.
      SA.InitSlideSelector(SA.MainDiv); // What is this?
      SA.viewMenu1 = new SA.ViewEditMenu(SA.display.Viewers[0],
                                         SA.display.Viewers[1]);
      SA.viewMenu2 = new SA.ViewEditMenu(SA.display.Viewers[1],
                                         SA.display.Viewers[0]);
      SA.display.UpdateGui();

            // ==============================
            // Experiment wit combining transparent webgl ontop of canvas.
            /*
            var imageObj = {prefix:"/tile?img=560b4011a7a1412197c0cc76&db=5460e35a4a737abc47a0f5e3&name=",
                            levels:     12,
                            dimensions: [419168, 290400, 1],
                            bounds: [0,419167, 0, 290399, 0,0],
                            spacing: [0.1,0.1,1.0],
                            origin : [100, 10000]};
            var heatMapSource = new SA.SlideAtlasSource();
            heatMapSource.Prefix = imageObj.prefix;
            var heatMapCache = new SA.Cache();
            heatMapCache.TileSource = heatMapSource;
            heatMapCache.SetImageData(imageObj);

            SA.heatMap1 = new SA.HeatMap(viewer1.Div);
            SA.heatMap1.SetCache(heatMapCache);
            viewer1.AddLayer(SA.heatMap1);
            */
            /*
            SA.heatMap1.SetImageData(
                {prefix:"/tile?img=560b4011a7a1412197c0cc76&db=5460e35a4a737abc47a0f5e3&name=",
                 levels:     12,
                 dimensions: [419168, 290400, 1],
                 bounds: [0,419167, 0, 290399, 0,0],
                 spacing: [0.1,0.1,1.0],
                 origin : [100, 10000]});
            viewer1.AddLayer(SA.heatMap1);
            */
            /*

            SA.heatMap2 = new SA.HeatMap(viewer1.Div);
            SA.heatMap2.Color = [0.0, 0.0, 0.7];
            SA.heatMap2.SetImageData(
                {prefix:"/tile?img=560b4011a7a1412197c0cc76&db=5460e35a4a737abc47a0f5e3&name=",
                 levels:     12,
                 dimensions: [419168, 290400, 1],
                 bounds: [0,419167, 0, 290399, 0,0],
                 spacing: [0.15,0.15,1.0],
                 origin : [20000, 20000]});
            viewer1.AddLayer(SA.heatMap2);

            SA.heatMap3 = new SA.HeatMap(viewer2.Div);
            SA.heatMap3.Color = [0.0, 0.0, 0.7];
            SA.heatMap3.Window = -1.0;
            SA.heatMap3.Gama = 0.2;
            SA.heatMap3.SetImageData(
                {prefix:"/tile?img=560b4011a7a1412197c0cc76&db=5460e35a4a737abc47a0f5e3&name=",
                 levels:     12,
                 dimensions: [419168, 290400, 1],
                 bounds: [0,419167, 0, 290399, 0,0],
                 spacing: [0.15,0.15,1.0],
                 origin : [2000, 10000]});
            viewer2.AddLayer(SA.heatMap3);
            */
    }

    SA.SetNote(rootNote);

    $(window).bind('orientationchange', function (event) {
      handleResize();
    });

    $(window).resize(function () {
      handleResize();
    }).trigger('resize');

    if (SA.display) {
      SA.display.Draw();
    }
  }
})();

// It seems I cannot control the order these files are loaded.
window.SA = window.SA || {};

// TODO:
//  ShowViewBrowser();});
// get rid of these.

// function ComparisonSaveAnnotations() {} (used wrongly in text widget.)
// function ShowViewerEditMenu(viewer) {

// Empty
// ViewEditMenu.prototype.SessionAdvanceAjax = function() {

(function () {
  'use strict';

// Other viewer is a hack for copy camera.
// parent is for the view browser.
  function ViewEditMenu (viewer, otherViewer) {
    var self = this; // trick to set methods in callbacks.
    this.Viewer = viewer;
    // Other viewer is a hack for copy camera.
    this.OtherViewer = otherViewer;
    this.Tab = new SA.Tab(viewer.GetDiv(), SA.ImagePathUrl + 'Menu.jpg', 'editTab');
    this.Tab.Div
        .css({'position': 'absolute',
          'right': '47px',
          'bottom': '0px',
          'z-index': '200'})
        .prop('title', 'View Menu');

    this.Tab.Panel.addClass('sa-view-edit-panel');

    if (SA.VIEW_BROWSER) {
      $('<button>')
            .appendTo(this.Tab.Panel)
            .text('Load Slide')
            .addClass('sa-view-edit-button')
            .click(
                function () {
                  self.Tab.PanelOff();
                  SA.VIEW_BROWSER.Open(self.Viewer);
                });
    }
    if (SA.Edit) {
      $('<button>')
            .appendTo(this.Tab.Panel)
            .text('Save View')
            .addClass('sa-view-edit-button')
            .click(function () { self.SaveView(); });
    }
    if (SA.notesWidget) {
      $('<button>')
            .appendTo(this.Tab.Panel)
            .text('Download Image')
            .addClass('sa-view-edit-button')
            .click(function () {
              self.Tab.PanelOff();
              DownloadImage(self.Viewer);
            });

      $('<button>')
            .appendTo(this.Tab.Panel)
            .text('Slide Info')
            .addClass('sa-view-edit-button')
            .click(function () { self.ShowSlideInformation(); });

      if (SA.recorderWidget.TimeLine) {
            // Test for showing coverage of view histor.
        this.HistoryMenuItem = $('<button>')
                .appendTo(this.Tab.Panel)
                .text('History On')
                .addClass('sa-view-edit-button')
                .click(function () { self.ToggleHistory(); });
      }
        // Hack until we have some sort of scale.
      if (this.OtherViewer) {
        this.CopyZoomMenuItem = $('<button>')
                .appendTo(this.Tab.Panel)
                .text('Copy Zoom')
                .hide()
                .addClass('sa-view-edit-button')
                .click(function () { self.CopyZoom(); });
      }

      $('<button>').appendTo(this.Tab.Panel)
            .text('Flip Horizontal')
            .addClass('sa-view-edit-button')
            .click(function () { self.FlipHorizontal(); });
        /* cutout widget dialog is broken.
        $('<button>').appendTo(this.Tab.Panel)
            .text("Download image from server")
            .addClass("sa-view-edit-button")
            .click(function(){
                self.Tab.PanelOff();
                // When the circle button is pressed, create the widget.
                if ( ! self.Viewer) { return; }
                new SA.CutoutWidget(parent, self.Viewer);
            });
        // color threshold is also broken
        for(var plugin in window.PLUGINS) {
            var that = this;
            if(window.PLUGINS[plugin].button_text) {
                (function (plugin) {
                    // console.log("Adding menu for " + plugin);
                    $('<button>').appendTo(that.Tab.Panel)
                        .text(window.PLUGINS[plugin].button_text)
                        .addClass("sa-view-edit-button")
                        .click(function () {
                            window.PLUGINS[plugin].Init();
                        });
                })(plugin);
            }
        }
        */

        // I need some indication that the behavior id different in edit mode.
        // If the user is authorized, the new bounds are automatically saved.
      if (SA.Edit) {
        $('<button>').appendTo(this.Tab.Panel)
                .text('Save OverView Bounds')
                .addClass('sa-view-edit-button')
                .click(function () { self.SetViewBounds(); });
      } else {
        $('<button>').appendTo(this.Tab.Panel)
                .text('Set OverView Bounds')
                .addClass('sa-view-edit-button')
                .click(function () { self.SetViewBounds(); });
      }
    }
  }

  ViewEditMenu.prototype.SetVisibility = function (flag) {
    if (flag) {
      this.Tab.show();
    } else {
      this.Tab.hide();
    }
  };

  ViewEditMenu.prototype.ToggleHistory = function () {
    this.Tab.PanelOff();

    this.Viewer.HistoryFlag = !this.Viewer.HitoryFlag;
    if (this.Viewer.HistoryFlag) {
      this.HistoryMenuItem.text('History Off');
    } else {
      this.HistoryMenuItem.text('History On');
    }
    SA.display.EventuallyRender();
  };

// Record the viewer into the current note and save into the database.
  ViewEditMenu.prototype.SaveView = function () {
    this.Tab.PanelOff();
    if (SA.notesWidget) {
      SA.notesWidget.SaveCallback();
    }
  };

  ViewEditMenu.prototype.GetViewerBounds = function (viewer) {
    var cam = viewer.GetCamera();
    var fp = cam.GetWorldFocalPoint();
    var halfWidth = cam.GetWidth() / 2;
    var halfHeight = cam.GetHeight() / 2;
    return [fp[0] - halfWidth, fp[0] + halfWidth, fp[1] - halfHeight, fp[1] + halfHeight];
  };

// Add bounds to view to overide image bounds.
  ViewEditMenu.prototype.SetViewBounds = function () {
    this.Tab.PanelOff();
    var bounds = this.GetViewerBounds(this.Viewer);
    var note = SA.display.GetNote();
    // Which view record?
    var viewerRecord = note.ViewerRecords[this.Viewer.RecordIndex];

    viewerRecord.OverViewBounds = bounds;
    // Set the image bounds so the new bounds are used immediately.
    viewerRecord.Image.bounds = viewerRecord.OverViewBounds;
    this.Viewer.OverView.Camera.SetWorldFocalPoint([(bounds[0] + bounds[1]) / 2,
      (bounds[2] + bounds[3]) / 2]);
    this.Viewer.OverView.Camera.SetHeight(bounds[3] - bounds[2]);
    this.Viewer.OverView.Camera.ComputeMatrix();
    this.Viewer.eventuallyRender();

    // Save automatically if user has permission.
    var self = this;
    if (SA.Edit) {
        // I cannot do this because it first sets the viewer record and bounds are lost.
        // SA.notesWidget.SaveCallback();
        // Lets try just setting this one note.
      var noteObj = JSON.stringify(note.Serialize(true));
      var d = new Date();
      $.ajax({
        type: 'post',
        url: 'webgl-viewer/saveviewnotes',
        data: {'note': noteObj,
          'date': d.getTime()},
        success: function (data, status) {
          self.Viewer.EventuallyRender();
        },
        error: function () { SA.Debug('AJAX - error() : saveviewnotes (bounds)'); }
      });
    }
  };

// Add bounds to view to overide image bounds.
  ViewEditMenu.prototype.SetImageBounds = function () {
    this.Tab.PanelOff();

    var viewer = this.Viewer;
    var imageDb = viewer.GetCache().Image.database;
    var imageId = viewer.GetCache().Image._id;
    var bounds = this.GetViewerBounds(viewer);

    // Set the image bounds so the new bounds are used immediately.
    viewer.GetCache().Image.bounds = bounds;
    viewer.OverView.Camera.SetWorldFocalPoint([(bounds[0] + bounds[1]) / 2,
      (bounds[2] + bounds[3]) / 2]);
    viewer.OverView.Camera.SetHeight(bounds[3] - bounds[2]);
    viewer.OverView.Camera.ComputeMatrix();
    viewer.EventuallyRender();

    $.ajax({
      type: 'post',
      url: 'webgl-viewer/set-image-bounds',
      data: {'img': imageId,
        'imgdb': imageDb,
        'bds': JSON.stringify(bounds)},
      success: function (data, status) {},
      error: function () {
        SA.Debug('AJAX - error() : saveusernote 1');
      }
    });
  };

// ==============================================================================
// Create and manage the menu to edit dual views.

// hack: Find the other viewer to copy.
  ViewEditMenu.prototype.CopyZoom = function () {
    this.Tab.PanelOff();

    var cam = this.Viewer.GetCamera();
    var copyCam = this.OtherViewer.GetCamera();

    this.Viewer.AnimateCamera(cam.GetWorldFocalPoint(),
                              cam.GetWorldRoll(), copyCam.Height);
  };

  ViewEditMenu.prototype.ShowSlideInformation = function () {
    this.Tab.PanelOff();
    var imageObj = this.Viewer.MainView.Section.Caches[0].Image;
    SA.SlideInformation.Open(imageObj, this.Viewer);
  };

// Mirror image
  ViewEditMenu.prototype.FlipHorizontal = function () {
    this.Tab.PanelOff();
    // When the circle button is pressed, create the widget.
    if (!this.Viewer) { return; }

    var cam = this.Viewer.GetCamera();
    this.Viewer.ToggleMirror();
    this.Viewer.SetCamera(cam.GetWorldFocalPoint(),
                          cam.GetRotation() + 180.0, cam.Height);
    SA.RecordState();
  };

// Stuff that should be moved to some other file.

// Make the download dialog / function a module.
  var DownloadImage = (function () {
    // Dialogs require an object when accept is pressed.
    var DOWNLOAD_WIDGET;

    function DownloadImage (viewer) {
        // Use a global so apply callback can get the viewer.
      SA.VIEWER = viewer;

      if (!DOWNLOAD_WIDGET) {
        InitializeDialogs();
      }

        // Setup default dimensions.
      var viewport = viewer.GetViewport();
      var d = DOWNLOAD_WIDGET.DimensionDialog;
      d.PxWidthInput.val(viewport[2]);
      d.PxHeightInput.val(viewport[3]);
      var pixelsPerInch = parseInt(d.SizeResInput.val());
      d.SizeWidthInput.val((viewport[2] / pixelsPerInch).toFixed(2));
      d.SizeHeightInput.val((viewport[3] / pixelsPerInch).toFixed(2));
      d.AspectRatio = viewport[2] / viewport[3];

        // Hide or show the stack option.
      if (SA.display.GetNote().Type === 'Stack') {
        DOWNLOAD_WIDGET.DimensionDialog.StackDiv.show();
      } else {
        DOWNLOAD_WIDGET.DimensionDialog.StackDiv.hide();
      }

      DOWNLOAD_WIDGET.DimensionDialog.Show(1);
    }

    function InitializeDialogs () {
      DOWNLOAD_WIDGET = {};

        // Two dialogs.
        // Dialog to choose dimensions and initiate download.
        // A dialog to cancel the download while waiting for tiles.
      var CancelDownloadCallback = function () {
        if (DOWNLOAD_WIDGET.Viewer) {
                // We are in the middle of rendering.
                // This method was called by the cancel dialog.
          DOWNLOAD_WIDGET.Viewer.CancelLargeImage();
          DOWNLOAD_WIDGET.Viewer = undefined;
                // The dialog hides itself.
        }
      };
      var StartDownloadCallback = function () {
            // Trigger the process to start rendering the image.
        DOWNLOAD_WIDGET.Viewer = SA.VIEWER;
        var width = parseInt(DOWNLOAD_WIDGET.DimensionDialog.PxWidthInput.val());
        var height = parseInt(DOWNLOAD_WIDGET.DimensionDialog.PxHeightInput.val());
        var stack = DOWNLOAD_WIDGET.DimensionDialog.StackCheckbox.prop('checked');

            // Show the dialog that empowers the user to cancel while rendering.
        DOWNLOAD_WIDGET.CancelDialog.Show(1);
            // We need a finished callback to hide the cancel dialog.
        if (stack) {
          DOWNLOAD_WIDGET.CancelDialog.StackMessage.show();
        } else {
          DOWNLOAD_WIDGET.CancelDialog.StackMessage.hide();
        }
        SA.VIEWER.SaveLargeImage('slide-atlas.png', width, height, stack,
                                  function () {
                                      // Rendering has finished.
                                      // The user can no longer cancel.
                                    DOWNLOAD_WIDGET.Viewer = undefined;
                                    DOWNLOAD_WIDGET.CancelDialog.Hide();
                                  });
      };

      var d = new SAM.Dialog(StartDownloadCallback);
      d.Body.css({'margin': '1em 2em',
                    // Hack no time to figure out layout with border box option.
        'padding-bottom': '2em',
        'padding-right': '3em'});
      DOWNLOAD_WIDGET.DimensionDialog = d;
      d.Title.text('Download Image');

        // Pixel Dimensions
      d.PxDiv = $('<div>')
            .appendTo(d.Body)
            .css({'border': '1px solid #555',
              'margin': '15px',
              'padding-left': '5px'});
      d.PxLabel =
            $('<div>')
            .appendTo(d.PxDiv)
            .text('Dimensions:')
            .css({'position': 'relative',
              'top': '-9px',
              'display': 'inline-block',
              'background-color': 'white'});

      d.PxWidthDiv =
            $('<div>')
            .appendTo(d.PxDiv)
            .css({'display': 'table-row'});

      d.PxWidthLabel =
            $('<div>')
            .appendTo(d.PxWidthDiv)
            .text('Width:')
            .css({'display': 'table-cell',
              'text-align': 'right',
              'width': '6em'});
      d.PxWidthInput =
            $('<input type="number">')
            .appendTo(d.PxWidthDiv)
            .val('1900')
            .css({'display': 'table-cell',
              'width': '100px',
              'margin': '5px'})
            .change(function () { PxWidthChanged(); });
      d.PxWidthUnits =
            $('<div>')
            .appendTo(d.PxWidthDiv)
            .text('Pixels')
            .css({'display': 'table-cell',
              'text-align': 'left'});

      d.PxHeightDiv =
            $('<div>')
            .appendTo(d.PxDiv)
            .css({'display': 'table-row',
              'margin': '5px'});
      d.PxHeightLabel =
            $('<div>')
            .appendTo(d.PxHeightDiv)
            .text('Height:')
            .css({'display': 'table-cell',
              'text-align': 'right'});
      d.PxHeightInput =
            $('<input type="number">')
            .appendTo(d.PxHeightDiv)
            .val('1080')
            .css({'display': 'table-cell',
              'width': '100px',
              'margin': '5px'})
            .change(function () { PxHeightChanged(); });

      d.PxHeightUnits =
            $('<div>')
            .appendTo(d.PxHeightDiv)
            .text('Pixels')
            .css({'display': 'table-cell',
              'text-align': 'left'});

        // Document Size
      d.SizeDiv = $('<div>')
            .appendTo(d.Body)
            .css({'border': '1px solid #555',
              'margin': '15px',
              'padding-left': '5px'});
      d.SizeLabel =
            $('<div>')
            .appendTo(d.SizeDiv)
            .text('Document Size:')
            .css({'position': 'relative',
              'top': '-9px',
              'display': 'inline-block',
              'background-color': 'white'});

      d.SizeWidthDiv =
            $('<div>')
            .appendTo(d.SizeDiv)
            .css({'display': 'table-row',
              'margin': '5px'});
      d.SizeWidthLabel =
            $('<div>')
            .appendTo(d.SizeWidthDiv)
            .text('Width:')
            .css({'display': 'table-cell',
              'text-align': 'right',
              'width': '6em'});
      d.SizeWidthInput =
            $('<input type="number">')
            .appendTo(d.SizeWidthDiv)
            .val('1900')
            .css({'display': 'table-cell',
              'width': '100px',
              'margin': '5px'})
            .change(function () { SizeWidthChanged(); });

      d.SizeWidthUnits =
            $('<div>')
            .appendTo(d.SizeWidthDiv)
            .text('Inches')
            .css({'display': 'table-cell',
              'text-align': 'left'});

      d.SizeHeightDiv =
            $('<div>')
            .appendTo(d.SizeDiv)
            .css({'display': 'table-row',
              'margin': '5px'});
      d.SizeHeightLabel =
            $('<div>')
            .appendTo(d.SizeHeightDiv)
            .text('Height:')
            .css({'display': 'table-cell',
              'text-align': 'right'});
      d.SizeHeightInput =
            $('<input type="number">')
            .appendTo(d.SizeHeightDiv)
            .val('1900')
            .css({'display': 'table-cell',
              'width': '100px',
              'margin': '5px'})
            .change(function () { SizeHeightChanged(); });

      d.SizeHeightUnits =
            $('<div>')
            .appendTo(d.SizeHeightDiv)
            .text('Inches')
            .css({'display': 'table-cell',
              'text-align': 'left'});

      d.SizeResDiv =
            $('<div>')
            .appendTo(d.SizeDiv)
            .css({'display': 'table-row',
              'margin': '5px'});
      d.SizeResLabel =
            $('<div>')
            .appendTo(d.SizeResDiv)
            .text('Resolution:')
            .css({'display': 'table-cell',
              'text-align': 'right'});
      d.SizeResInput =
            $('<input type="number">')
            .appendTo(d.SizeResDiv)
            .val('72')
            .css({'display': 'table-cell',
              'width': '100px',
              'margin': '5px'})
            .change(function () { ResChanged(); });

      d.SizeResUnits =
            $('<div>')
            .appendTo(d.SizeResDiv)
            .text('Pixels/Inch')
            .css({'display': 'table-cell',
              'text-align': 'left'});

      d.ProportionsDiv =
            $('<div>')
            .appendTo(d.Body)
            .css({'margin': '15px',
              'padding-left': '5px'});
      d.ProportionsLabel =
            $('<div>')
            .appendTo(d.ProportionsDiv)
            .text('Constrain Proportions:')
            .css({'display': 'inline'});
      d.ProportionsCheckbox =
            $('<input type="checkbox">')
            .appendTo(d.ProportionsDiv)
            .css({'display': 'inline'})
            .prop('checked', true);

      d.StackDiv =
            $('<div>')
            .appendTo(d.Body)
            .css({'margin': '15px',
              'padding-left': '5px'})
            .hide();
      d.StackLabel =
            $('<div>')
            .appendTo(d.StackDiv)
            .text('All stack sections:')
            .css({'display': 'inline'});
      d.StackCheckbox =
            $('<input type="checkbox">')
            .appendTo(d.StackDiv)
            .css({'display': 'inline'})
            .prop('checked', false);

      d.AspectRatio = 1.0;

        // A dialog to cancel the download before we get all the tiles
        // needed to render thie image.
      d = new SAM.Dialog(CancelDownloadCallback);
      DOWNLOAD_WIDGET.CancelDialog = d;
      d.Title.text('Processing');

      d.WaitingImage = $('<img>')
            .appendTo(d.Body)
            .attr('src', SA.ImagePathUrl + 'circular.gif')
            .attr('alt', 'waiting...')
            .css({'width': '40px'});

      d.StackMessage = $('<div>')
            .appendTo(d.Body)
            .text("Downloading multiple images.  Turn off browser's prompt-on-download option.")
            .hide();

      d.ApplyButton.text('Cancel');
    }

    function PxWidthChanged () {
      var d = DOWNLOAD_WIDGET.DimensionDialog;
      var pixelsPerInch = parseInt(d.SizeResInput.val());
      var width = parseInt(d.PxWidthInput.val());
      d.SizeWidthInput.val((width / pixelsPerInch).toFixed(2));
      var height;
      if (d.ProportionsCheckbox.prop('checked')) {
        height = width / d.AspectRatio;
        d.PxHeightInput.val(height.toFixed());
        d.SizeHeightInput.val((height / pixelsPerInch).toFixed(2));
      } else {
        height = parseInt(d.PxHeightInput.val());
        d.AspectRatio = width / height;
      }
    }

    function PxHeightChanged () {
      var d = DOWNLOAD_WIDGET.DimensionDialog;
      var pixelsPerInch = parseInt(d.SizeResInput.val());
      var height = parseInt(d.PxHeightInput.val());
      d.SizeHeightInput.val((height / pixelsPerInch).toFixed(2));
      var width;
      if (d.ProportionsCheckbox.prop('checked')) {
        width = height * d.AspectRatio;
        d.PxWidthInput.val(width.toFixed());
        d.SizeWidthInput.val((width / pixelsPerInch).toFixed(2));
      } else {
        width = parseInt(d.PxWidthInput.val());
        d.AspectRatio = width / height;
      }
    }

    function SizeWidthChanged () {
      var d = DOWNLOAD_WIDGET.DimensionDialog;
      var pixelsPerInch = parseInt(d.SizeResInput.val());
      var width = parseInt(d.SizeWidthInput.val());
      d.PxWidthInput.val((width * pixelsPerInch).toFixed());
      var height;
      if (d.ProportionsCheckbox.prop('checked')) {
        height = width / d.AspectRatio;
        d.SizeHeightInput.val(height.toFixed(2));
        d.PxHeightInput.val((height * pixelsPerInch).toFixed());
      } else {
        height = parseInt(d.SizeHeightInput.val());
        d.AspectRatio = width / height;
      }
    }

    function SizeHeightChanged () {
      var d = DOWNLOAD_WIDGET.DimensionDialog;
      var pixelsPerInch = parseInt(d.SizeResInput.val());
      var height = parseInt(d.SizeHeightInput.val());
      d.PxHeightInput.val((height * pixelsPerInch).toFixed());
      var width;
      if (d.ProportionsCheckbox.prop('checked')) {
        width = height * d.AspectRatio;
        d.SizeWidthInput.val(width.toFixed(2));
        d.PxWidthInput.val((width * pixelsPerInch).toFixed());
      } else {
        width = parseInt(d.SizeWidthInput.val());
        d.AspectRatio = width / height;
      }
    }

    function ResChanged () {
      var d = DOWNLOAD_WIDGET.DimensionDialog;
      var pixelsPerInch = parseInt(d.SizeResInput.val());
      var height = parseInt(d.SizeHeightInput.val());
      var width = parseInt(d.SizeWidthInput.val());
      d.PxHeightInput.val((height * pixelsPerInch).toFixed());
      d.PxWidthInput.val((width * pixelsPerInch).toFixed());
    }

    return DownloadImage;
  })();

// Create a selection list of sessions.
// This does not belong here.
  SA.InitSlideSelector = function (parent) {
    $('<div>')
        .appendTo(parent)
        .css({
          'background-color': 'white',
          'border-style': 'solid',
          'border-width': '1px',
          'border-radius': '5px',
          'position': 'absolute',
          'top': '35px',
          'left': '35px',
          'width': '500px',
          'height': '700px',
          'overflow': 'auto',
          'z-index': '4',
          'color': '#303030',
          'font-size': '20px' })
        .attr('id', 'sessionMenu').hide()
        .mouseleave(function () { $(this).fadeOut(); });
    $('<ul>').appendTo('#sessionMenu').attr('id', 'sessionMenuSelector');

    // Create a selector for views.
    $('<div>')
        .appendTo(parent)
        .css({
          'background-color': 'white',
          'border-style': 'solid',
          'border-width': '1px',
          'border-radius': '5px',
          'position': 'absolute',
          'top': '135px',
          'left': '135px',
          'width': '500px',
          'height': '700px',
          'overflow': 'auto',
          'z-index': '4',
          'color': '#303030',
          'font-size': '20px' })
        .attr('id', 'viewMenu').hide()
        .mouseleave(function () { $(this).fadeOut(); });
    $('<ul>').appendTo('#viewMenu').attr('id', 'viewMenuSelector'); // <select> for drop down

    SA.SlideInformation = new ImageInformationDialog(parent, SA.Edit);
  };

  function ImageInformationDialog (parent, editable) {
    var self = this;

    this.Editable = editable;

    this.Body = $('<div>')
        .appendTo(parent)
        .css({
          'background-color': 'white',
          'border-style': 'solid',
          'border-width': '1px',
          'border-radius': '5px',
          'position': 'absolute',
          'top': '30%',
          'left': '30%',
          'width': '40%',
          'height': '40%',
          'overflow': 'auto',
          'padding': '10px',
          'z-index': '4',
          'color': '#303030',
          'font-size': '20px'})
        .hide()
        .mouseleave(function () { self.Close(); });

    this.TitleInput =
        $('<div>')
        .css({'width': '100%',
          'cursor': 'text',
          'white-space': 'nowrap',
          'margin-bottom': '5px'})
        .appendTo(this.Body)
        .keypress(function (event) { return event.keyCode !== 13; });
    if (editable) {
      this.TitleInput
            .attr('contenteditable', 'true')
            .css({'background': '#f0f0ff'});
    }

    this.CopyrightDiv =
        $('<div>')
        .css({'width': '100%',
          'display': 'inline-block'})
        .appendTo(this.Body)
        .addClass('sa-view-annotation-modal-div');
    this.CopyrightLabel =
        $('<div>')
        .appendTo(this.CopyrightDiv)
        .text('Copyright:');
    this.CopyrightInput =
        $('<div>')
        .css({'width': '300px',
          'cursor': 'text'})
        .appendTo(this.CopyrightDiv)
        .keypress(function (event) { return event.keyCode !== 13; });
    if (editable) {
      this.CopyrightInput
            .attr('contenteditable', 'true')
            .css({'background': '#f0f0ff'});
    }

    this.ResolutionDiv =
        $('<div>')
        .appendTo(this.Body)
        .addClass('sa-view-annotation-modal-div');
    this.ResolutionLabel =
        $('<div>')
        .appendTo(this.ResolutionDiv)
        .text('Resolution:')
        .addClass('sa-view-annotation-modal-input-label');
    this.ResolutionInput =
        $('<div>')
        .appendTo(this.ResolutionDiv);
    this.ResolutionUnitsInput =
        $('<div>')
        .appendTo(this.ResolutionDiv);
    if (editable) {
      this.ResolutionInput
            .attr('contenteditable', 'true')
            .css({'background': '#f0f0ff',
              'cursor': 'text'})
            .keypress(function (event) { return event.keyCode !== 13; });
      this.ResolutionUnitsInput
            .attr('contenteditable', 'true')
            .css({'background': '#f0f0ff',
              'cursor': 'text'})
            .attr('contenteditable', 'true')
            .keypress(function (event) { return event.keyCode !== 13; });
    }

    // Non editable strings.
    this.FileNameDiv =
        $('<div>')
        .appendTo(this.Body)
        .addClass('sa-view-annotation-modal-div');
    this.CreatedDiv =
        $('<div>')
        .appendTo(this.Body)
        .addClass('sa-view-annotation-modal-div');
    this.DimensionsDiv =
        $('<div>')
        .appendTo(this.Body)
        .addClass('sa-view-annotation-modal-div');
    this.LevelsDiv =
        $('<div>')
        .appendTo(this.Body)
        .addClass('sa-view-annotation-modal-div');
  }

  ImageInformationDialog.prototype.Open = function (imageObj, viewer) {
    this.Viewer = viewer;

    // Save so we can modify it on close.
    this.ImageObj = imageObj;
    this.TitleInput.text(imageObj.label);
    this.FileNameDiv.text('File Name: ' + imageObj.filename);
    this.CreatedDiv.text('Created: ' + imageObj.uploaded_at);
    this.DimensionsDiv.text('Dimensions: ' +
                            imageObj.dimensions[0] + ', ' +
                            imageObj.dimensions[1]);
    this.LevelsDiv.text('Levels: ' + imageObj.levels);
    this.CopyrightInput.text(imageObj.copyright);

    var spacing;
    if (imageObj.units) {
      spacing = {value: imageObj.spacing[0],
        units: imageObj.units};
    } else {
      spacing = {value: 0.25,
        units: '\xB5m'}; // um / micro meters
    }

    SAM.ConvertForGui(spacing);
    this.ResolutionInput.text(spacing.value.toString());
    this.ResolutionUnitsInput.text(spacing.units.toString());

    this.Body.show();
  };

  ImageInformationDialog.prototype.Close = function () {
    if (this.Editable) {
      this.ImageObj.label = this.TitleInput.text();
      this.ImageObj.copyright = this.CopyrightInput.text();
      var spacing = {value: parseFloat(this.ResolutionInput.text()),
        units: this.ResolutionUnitsInput.text()};
      SAM.ConvertToMeters(spacing);
      this.ImageObj.spacing[0] = this.ImageObj.spacing[1] = spacing.value;
      this.ImageObj.units = spacing.units;
    }

    this.Body.fadeOut();

    if (!this.Editable) {
      return;
    }

    if (this.ImageObj.dimensions.length < 3) {
      this.ImageObj.dimensions.push(1);
    }

    var imageObj = {
      _id: this.ImageObj._id,
      database: this.ImageObj.database,
      label: this.ImageObj.label,
      copyright: this.ImageObj.copyright,
      spacing: this.ImageObj.spacing,
      units: this.ImageObj.units};

    // Save the image meta data.
    var self = this;
    $.ajax({
      type: 'post',
      url: 'webgl-viewer/saveimagedata',
      data: {'metadata': JSON.stringify(imageObj)},
      success: function (data, status) {
        if (self.Viewer) { self.Viewer.EventuallyRender(); }
      },
      error: function () { SA.Debug('AJAX - error() : saveimagedata'); }
    });
  };

  SA.ViewEditMenu = ViewEditMenu;
})();

// It seems I cannot control the order these files are loaded.
window.SA = window.SA || {};

// ==============================================================================
// Create and manage the menu to browse and select views.
// I am changing this to be more about selecting an image.
// I am also making this into a dialog object. (not based on the dialog class).

// It may be better to undock and redock

(function () {
  'use strict';

  function ViewBrowser (parent) {
    var self = this;
    // A view browser (short cut menu) for the text input.
    this.Div = $('<div>')
        .appendTo(parent)
        .hide().css({
          'position': 'absolute',
          'top': '5%',
          'height': '80%',
          'left': '10%',
          'width': '70%',
          'padding': '5%',
          'z-index': '1007',
          'text-align': 'left',
          'color': '#303030'})
        .mouseleave(function () { self.Div.fadeOut(); });

    this.TabbedDiv = new SA.TabbedDiv(this.Div);
    this.BrowserDiv = this.TabbedDiv.NewTabDiv('Browser');
    this.BrowserDiv.css({'overflow-y': 'auto'});
    this.SearchDiv = this.TabbedDiv.NewTabDiv('Search');
    this.ClipboardDiv = this.TabbedDiv.NewTabDiv('Clipboard');

    this.BrowserPanel = new BrowserPanel(
        this.BrowserDiv,
        function (viewObj) {
          self.SelectView(viewObj);
        });

    this.SearchPanel = new SA.SearchPanel(
        this.SearchDiv,
        function (imageObj) {
          self.SelectImage(imageObj);
        });

    this.ClipboardPanel = new SA.ClipboardPanel(
        this.ClipboardDiv,
        function (viewObj) {
          self.SelectView(viewObj);
        });

    this.Viewer = null;
  }

  ViewBrowser.prototype.SelectView = function (viewObj) {
    if (viewObj === null) {
      this.Viewer.SetCache(null);
      this.Viewer.eventuallyRender();
    }

    // This will get the camera and the annotations too.
    var record = new SA.ViewerRecord();
    record.Load(viewObj.ViewerRecords[0]);
    this.Viewer.SetViewerRecord(record);
    // this.SelectImage(viewObj.ViewerRecords[0].Image);
  };

  ViewBrowser.prototype.SelectImage = function (imgobj) {
    this.Div.fadeOut();
    var source = SA.FindCache(imgobj);

    // We have to get rid of annotation which does not apply to the new image.
    this.Viewer.Reset();
    this.Viewer.SetCache(source);

    SA.RecordState();

    this.Viewer.eventuallyRender();
  };

// Open the dialog. (ShowViewBrowser).
  ViewBrowser.prototype.Open = function (viewer) {
    this.Viewer = viewer;
    if (!viewer) { return; }

    this.Div.show();
  };

// ==============================================================================
// Open close item
  function BrowserFolder (parent, label, data, initCallback) {
    var self = this;
    this.Data = data;
    this.InitializeCallback = initCallback;
    // Bad name for this div because it contains the bullet too.
    // TODO: Change the name.
    this.TitleDiv = $('<div>')
        .css({'position': 'relative'})
        .appendTo(parent);
    this.Bullet = $('<span>')
        .appendTo(this.TitleDiv)
        .css({'position': 'absolute',
          'left': '0px',
          'top': '1px',
          'opacity': '0.75'})
        .addClass('ui-icon ui-icon-plus')
        .on('click.open',
            function () {
              self.OpenCallback();
            })
        .addClass('saButton'); // for hover highlighting

    this.Title = $('<div>')
        .appendTo(this.TitleDiv)
        .css({'margin-left': '20px'});
    this.Label = $('<div>')
        .appendTo(this.Title)
        .css({'display': 'block'})
        .text(label);
    this.List = $('<ul>')
        .appendTo(parent)
        .addClass('sa-ul')
        .hide();
  }

  BrowserFolder.prototype.OpenCallback = function () {
    var self = this;
    if (this.InitializeCallback) {
      (this.InitializeCallback)(this);
      delete this.InitializeCallback;
    }
    // Remove the binding.
    // Setup next click to close.
    this.Bullet.off('click.open')
        .removeClass('ui-icon-plus')
        .addClass('ui-icon-minus')
        .on(
            'click.close',
            function () {
              self.CloseCallback();
            });
    this.List.show();
  };

  BrowserFolder.prototype.CloseCallback = function () {
    var self = this;
    // Setup next click to open.
    this.Bullet.off('click.close')
        .removeClass('ui-icon-minus')
        .addClass('ui-icon-plus')
        .on(
            'click.open',
            function () {
              self.OpenCallback();
            });
    this.List.hide();
  };

// ==============================================================================

  function BrowserPanel (browserDiv, callback) {
    this.BrowserDiv = browserDiv;
    this.SelectView = callback;

    this.BrowserInfo = null;
    this.ReloadViewBrowserInfo();
    this.ProgressCount = 0;
  }

// I have the same functionality in the SlideAtlas object.
// I am leaving this because this only displays progress in the browser.
  BrowserPanel.prototype.PushProgress = function () {
    this.BrowserDiv.css({'cursor': 'progress'});
    this.ProgressCount += 1;
  };

  BrowserPanel.prototype.PopProgress = function () {
    this.ProgressCount -= 1;
    if (this.ProgressCount <= 0) {
      this.BrowserDiv.css({'cursor': 'default'});
    }
  };

  BrowserPanel.prototype.LoadGUI = function () {
    var self = this;
    var data = this.BrowserInfo;
    this.BrowserDiv.empty();
    var groupList = $('<ul>')
        .addClass('sa-ul')
        .appendTo(this.BrowserDiv);

    for (var i = 0; i < data.sessions.length; ++i) {
      var groupItem = $('<li>')
            .appendTo(groupList);
      var group = data.sessions[i];
      var groupFolder = new BrowserFolder(groupItem, group.rule);
        // Initialize immediately.
      var sessionList = groupFolder.List;
      for (var j = 0; j < group.sessions.length; ++j) {
        var session = group.sessions[j];
        var sessionData = {'db': session.sessdb, 'sessid': session.sessid};
        var sessionItem = $('<li>')
                .appendTo(sessionList);

        new BrowserFolder( // eslint-disable-line no-new
                sessionItem, session.label, sessionData,
                function (folder) {
                  self.RequestSessionViews(folder);
                });
      }
    }
  };

  BrowserPanel.prototype.ReloadViewBrowserInfo = function () {
    var self = this;
    // Get the sessions this user has access to.

    this.PushProgress();
    $.get('/sessions?json=true',
          function (data, status) {
            self.PopProgress();
            if (status === 'success') {
              self.BrowserInfo = data;
                  // I might want to open a session to avoid an extra click.
                  // I might want to sort the sessions to put the recent at the top.
              self.LoadGUI(data);
            } else {
              SA.Debug('ajax failed.');
            }
          });
  };

  BrowserPanel.prototype.RequestSessionViews = function (sessionFolder) {
    var self = this;
    this.PushProgress();
    var sessId = sessionFolder.Data.sessid;
    $.get('/sessions?json=true' + '&sessid=' + sessId,
          function (data, status) {
            self.PopProgress();
            if (status === 'success') {
              self.AddSessionViews(sessionFolder, data);
            } else { SA.Debug('ajax failed.'); }
          });
  };

  BrowserPanel.prototype.AddSessionViews = function (sessionFolder, sessionData) {
    var self = this;
    var viewList = sessionFolder.List;
    for (var i = 0; i < sessionData.images.length; ++i) {
      var image = sessionData.images[i];
      var viewFolder = self.AddViewFolder(viewList, image.label, image.view);
      this.RequestViewChildren(viewFolder);
    }
  };

// NOTE: It would be cleaner to wait for the view data before creating the folder.
// However, we might loose the order of the views in a session.
  BrowserPanel.prototype.AddViewFolder = function (viewList, label, viewId) {
    var self = this;
    var item = $('<li>')
        .appendTo(viewList);
    // We do not know if views have subviews until we get the viewObj.
    // Just make them all folders for now.
    var viewData = {viewid: viewId};
    var viewFolder = new BrowserFolder(item, label, viewData);
    viewFolder.Bullet.hide();
    viewFolder.Title
        .click(function () { self.ViewClickCallback(viewFolder); })
        .addClass('saButton'); // for hover highlighting

    return viewFolder;
  };

  BrowserPanel.prototype.RequestViewChildren = function (viewFolder) {
    var self = this;
    this.PushProgress();
    var viewId = viewFolder.Data.viewid;
    $.ajax({
      type: 'get',
      url: '/webgl-viewer/getview',
      data: {'viewid': viewId},
      success: function (data, status) {
        self.PopProgress();
        self.LoadViewChildren(viewFolder, data);
      },
      error: function () {
        SA.Debug('AJAX - error() : getview');
        self.PopProgress();
      }
    });
  };

  BrowserPanel.prototype.LoadViewChildren = function (viewFolder, data) {
    // Replace image with thumb?
    if (data.Type === 'HTML') {
        // Add a small slide html page.
      var div1 = $('<div>')
            .appendTo(viewFolder.Title)
            .css({'position': 'relative',
              'height': '100px',
              'width': '134px',
              'margin-bottom': '2px',
              'overflow': 'hidden',
              'border': '1px solid #AAA'});
      var div = $('<div>')
            .appendTo(div1)
            .saPresentation({aspectRatio: 1.3333});
      div.saHtml(data.Text);
      div.trigger('resize');
      div.find('.sa-element').saElement({editable: false, interactive: false});
        // hack,  This should be off by default.
      div.find('.sa-viewer').saElement({hideCopyright: true});
        // Look for an alternative label.
      if (!data.Title || data.Title === '') {
        var titleDiv = div.find('.sa-presentation-title');
        if (titleDiv.length > 0) {
          viewFolder.Label.text(titleDiv.text());
        }
      }
    } else if (data.ViewerRecords && data.ViewerRecords.length > 0) {
        // Add the image to the label.
      var image = data.ViewerRecords[0].Image;
      $('<img>')
            .appendTo(viewFolder.Title)
            .attr('src', '/thumb?db=' + image.database + '&img=' + image._id)
            .css({'height': '50px',
              'display': 'block'});
    }

    if (!data.Children || data.Children.length < 1) { return; }
    viewFolder.Bullet.show();
    for (var i = 0; i < data.Children.length; ++i) {
      var child = data.Children[i];
      var childFolder = this.AddViewFolder(viewFolder.List, child.Title,
                                             child._id);

      this.LoadViewChildren(childFolder, child);
    }
  };

  BrowserPanel.prototype.ViewClickCallback = function (viewFolder) {
    var self = this;

    // null implies the user wants an empty view. ?????????????????
    // if (obj === null) {
    //    this.SelectView(null);
    //    return;
    // }

    // TODO: Get rid of this arg.
    var viewid = viewFolder.Data.viewid;

    // "sessid": $(obj).attr('sessid'),
    // Ok, so we only have the viewId at this point.
    // We need to get the view object to get the image id.
    this.PushProgress();
    $.ajax({
      type: 'get',
      url: '/webgl-viewer/getview',
      data: {'viewid': viewid},
      success: function (data, status) {
        self.PopProgress();
        self.SelectView(data);
      },
      error: function () {
        self.PopProgress();
        SA.Debug('AJAX - error() : getview (browser)');
      }
    });
  };

  SA.BrowserPanel = BrowserPanel;
  SA.ViewBrowser = ViewBrowser;
})();

// It seems I cannot control the order these files are loaded.
window.SA = window.SA || {};

// Interface for ViewerSet
// GetNumberOfViewers();

// Does not have to abide.
// SetNumberOfViewers(n);

// GetViewer(idx);

// Create and respond to the dual / single view toggle button.
// How the window is derived between viewer1 and viewer1.
// Default: viewer1 uses all available space.

(function () {
  'use strict';

  // TODO: Get rid of these global variable.
  SA.VIEWERS = [];

  function DualViewWidget (parent) {
    var self = this;
    this.Viewers = []; // It would be nice to get rid of this.
    this.ViewerDivs = [];

    // Rather than getting the current note from the NotesWidget, keep a
    // reference here.  SlideShow can have multiple "displays".
    // We might consider keep a reference in the dua
    this.saNote = null;
    this.saNoteStartIndex = 0;

    this.Parent = parent;
    parent.addClass('sa-dual-viewer');
    // I need relative position but should not modify parent.
    this.TopDiv = $('<div>')
      .appendTo(parent)
      .css({'position': 'relative',
        'width': '100%',
        'height': '100%'});

    for (var i = 0; i < 2; ++i) {
      var viewerDiv = $('<div>')
        .appendTo(this.TopDiv)
        .css({'position': 'absolulute',
          'top': '0px'})
        .saViewer({overview: true, zoomWidget: true})
        .addClass('sa-view-canvas-div');

      this.ViewerDivs[i] = viewerDiv;
      this.Viewers[i] = viewerDiv[0].saViewer;
      // TODO: Get rid of this.
      // I believe the note should sets this, and we do not need to do it
      // here..
      this.Viewers[i].RecordIndex = i;
    }

        // TODO: Get rid of these.
    SA.VIEWERS = this.Viewers;
    SA.VIEWER1 = this.Viewers[0];
    SA.VIEWER2 = this.Viewers[1];

    this.DualView = false;
    this.Viewer1Fraction = 1.0;
    // It would be nice to integrate all animation in a flexible utility.
    this.AnimationLastTime = 0;
    this.AnimationDuration = 0;
    this.AnimationTarget = 0;

    // DualViewer is the navigation widgets temporary home.
    // SlideShow can have multiple navigation widgets so it is no
    // longer a singleton.
    // This is for moving through notes, session views and stacks.
    // It is not exactly related to dual viewer. It is sort of a child
    // of the dual viewer.
    this.NavigationWidget = new SA.NavigationWidget(this.TopDiv, this);

    if (!SAM.MOBILE_DEVICE) { // || SAM.MOBILE_DEVICE === 'iPad') {
            // Todo: Make the button become more opaque when pressed.
      $('<img>')
        .appendTo(this.ViewerDivs[0])
        .css({'position': 'absolute',
          'right': '0px',
          'top': '0px'})
        .addClass('sa-view-dualview-div')
        .attr('id', 'dualWidgetLeft')
        .attr('src', SA.ImagePathUrl + 'dualArrowLeft2.png')
        .click(function () { self.ToggleDualView(); })
        .attr('draggable', 'false')
        .on('dragstart', function () {
          return false;
        });

      $('<img>')
        .appendTo(this.TopDiv)
        .appendTo(this.ViewerDivs[1])
        .css({'position': 'absolute',
          'left': '0px',
          'top': '0px'})
        .hide()
        .addClass('sa-view-dualview-img')
        .attr('id', 'dualWidgetRight')
        .attr('src', SA.ImagePathUrl + 'dualArrowRight2.png')
        .click(function () { self.ToggleDualView(); })
        .attr('draggable', 'false')
        .on('dragstart', function () {
          return false;
        });
    } else {
      this.NavigationWidget.SetVisibility(false);
    }
  }

  DualViewWidget.prototype.EventuallyRender = function () {
    for (var i = 0; i < this.Viewers.length; ++i) {
      this.GetViewer(i).EventuallyRender(false);
    }
  };

  // Abstracting saViewer  for viewer and dualViewWidget.
  // Save viewer state in a note.
  DualViewWidget.prototype.Record = function (note, startViewIdx) {
    if (startViewIdx) {
      note.StartIndex = startViewIdx;
    }
    startViewIdx = startViewIdx || 0;
    // TODO: Deal with multiple  windows consistently.
    // Now num viewRecords indicates the number of views in the display,
    // but not for stacks.  We have this start index which implies stack behavior.
    if (note.Type !== 'Stack') {
      if (!this.DualView && note.ViewerRecords.length > 1) {
        note.ViewerRecords = [note.ViewerRecords[0]];
      }
      if (this.DualView && note.ViewerRecords.length < 2) {
        while (note.ViewerRecords.length < 2) {
          note.ViewerRecords.push(new SA.ViewerRecord());
        }
      }
    }

    for (var i = 0; i < this.GetNumberOfViewers(); ++i) {
      if (i + startViewIdx < note.ViewerRecords.length) {
        this.GetViewer(i).Record(note, i + startViewIdx);
      }
    }
  };

  // Abstracting the saViewer class to support dual viewers and stacks.
  DualViewWidget.prototype.ProcessArguments = function (args) {
    if (args.note) {
      // TODO: DO we need both?
      this.SetNote(args.note, args.viewIndex);
      // NOTE: TempId is legacy
      this.Parent.attr('sa-note-id', args.note.Id || args.note.TempId);
    }

    if (args.tileSource) {
      var w = args.tileSource.width;
      var h = args.tileSource.height;
      var cache = new SA.Cache();
      cache.TileSource = args.tileSource;
      // Use the note tmp id as an image id so the viewer can index the
      // cache.
      var note = new SA.Note();
      var image = {levels: args.maxLevel + 1,
        dimensions: [w, h],
        bounds: [0, w - 1, 0, h - 1],
        _id: note.TempId};
      var record = new SA.ViewerRecord();
      record.Image = image;
      record.OverViewBounds = [0, w - 1, 0, h - 1];
      record.Camera = {FocalPoint: [w / 2, h / 2],
        Roll: 0,
        Height: h};
      note.ViewerRecords.push(record);
      cache.SetImageData(image);
      this.SetNote(args.note, args.viewIndex);
    }

    for (var i = 0; i < this.Viewers.length; ++i) {
      var viewer = this.Viewers[i];

      if (args.hideCopyright !== undefined) {
        viewer.SetCopyrightVisibility(!args.hideCopyright);
      }
      if (args.overview !== undefined) {
        viewer.SetOverViewVisibility(args.overview);
      }
      if (args.navigation !== undefined) {
        this.NavigationWidget.SetVisibility(args.navigation);
      }
      if (args.dualWidget !== undefined) {
        this.HideHandles = !args.dualWidget;
        this.UpdateGui();
      }
      if (args.zoomWidget !== undefined) {
        viewer.SetZoomWidgetVisibility(args.zoomWidget);
      }
      if (args.drawWidget !== undefined) {
        viewer.SetAnnotationWidgetVisibility(args.drawWidget);
      }
      if (args.rotatable !== undefined) {
        viewer.SetRotatable(args.rotatable);
      }
      // The way I handle the viewer edit menu is messy.
      // TODO: Find a more elegant way to add tabs.
      // Maybe the way we handle the anntation tab shouodl be our pattern.
      if (args.menu !== undefined) {
        if (!viewer.Menu) {
          viewer.Menu = new SA.ViewEditMenu(viewer, null);
        }
        viewer.Menu.SetVisibility(args.menu);
      }

      if (args.interaction !== undefined) {
        viewer.SetInteractionEnabled(args.interaction);
        if (this.NavigationWidget) {
          this.NavigationWidget.SetInteractionEnabled(args.interaction);
        }
      }
    }
  };

  DualViewWidget.prototype.RecordAnnotations = function () {
    // Aggressively record annotations.  User still needs to hit the
    // save button.
    if (SA.Edit && this.saNote) {
      this.saNote.RecordAnnotations(this);
    }
  };

  DualViewWidget.prototype.SetNote = function (note) {
    // NOTE: Even when this.saNote === note, we still need to set the
    // camera and annotations because the user might have changed these.

    // If the note is not loaded, request the note, and call this method
    // when the note is finally loaded.
    var self = this;
    if (note && note.LoadState !== 2) {
      note.LoadViewId(
                note.Id,
                function () {
                  self.SetNote(note);
                });
      return;
    }

    this.saNote = note;
    this.saNoteStartIndex = note.StartIndex;
    var viewIdx = note.StartIndex || 0;

    if (!note || viewIdx < 0 || viewIdx >= note.ViewerRecords.length) {
      console.log('Cannot set viewer record of note');
      return;
    }
    this.saViewerIndex = viewIdx;
    if (this.NavigationWidget) {
      this.NavigationWidget.SetNote(note);
      // this.NavigationWidget.Update(); // not sure if this is necessary
    }
    this.DisplayNote(note);
    if (note.Type === 'Stack') {
      // TODO: Can I move this logic into the display? SetNote maybe?
      // Possibly nagivationWidget (we need to know which viewer is referecne.
      // Select only gets called when the stack is first loaded.
      this.GetViewer(0).OnInteraction(function () {
        self.SynchronizeViews(0, note);
      });
      this.GetViewer(1).OnInteraction(function () {
        self.SynchronizeViews(1, note);
      });
      note.DisplayStack(this);
      // First view is set by viewer record camera.
      // Second is set relative to the first.
      this.SynchronizeViews(0, note);
    }
  };

  DualViewWidget.prototype.MatrixMultiply = function (M, p) {
    var x = p[0] * M[0] + p[1] * M[1] + M[2];
    var y = p[0] * M[3] + p[1] * M[4] + M[5];
    var k = p[0] * M[6] + p[1] * M[7] + M[8];
    p[0] = x / k;
    p[1] = y / k;
  };

  DualViewWidget.prototype.InitializeSynchronousViewsWithPoints = function (p1a, p2a, p1b, p2b, p1c, p2c) {
        // Just fashoin a not for now.
    var note = new SA.Note();
    var viewerRecord1 = new SA.ViewerRecord();
    viewerRecord1.Transform = new SA.PairTransformation(); // not necessary
    var viewerRecord2 = new SA.ViewerRecord();
    viewerRecord2.Transform = new SAM.MatrixTransformation();
    viewerRecord2.Transform.InitializeWithPoints(p1a, p2a, p1b, p2b, p1c, p2c);

    var pt;
    var p1 = p1a;
    var p2 = p2a;
    pt = viewerRecord2.Transform.ForwardTransformPoint(p1);
    console.log(p2[0] + ',' + p2[1] + ':' + pt[0] + ',' + pt[1]);
    p1 = p1b;
    p2 = p2b;
    pt = viewerRecord2.Transform.ForwardTransformPoint(p1);
    console.log(p2[0] + ',' + p2[1] + ':' + pt[0] + ',' + pt[1]);
    p1 = p1c;
    p2 = p2c;
    pt = viewerRecord2.Transform.ForwardTransformPoint(p1);
    console.log(p2[0] + ',' + p2[1] + ':' + pt[0] + ',' + pt[1]);

    note.ViewerRecords = [viewerRecord1, viewerRecord2];
    note.StartIndex = 0;
    note.Type = 'Stack';

    this.saNote = note;
    this.saNoteStartIndex = note.StartIndex;
    this.saViewerIndex = 0;

    var self = this;
    this.GetViewer(0).OnInteraction(function () {
      self.SynchronizeViews(0, note);
    });
    this.GetViewer(1).OnInteraction(function () {
      self.SynchronizeViews(1, note);
    });

        // First view is set by viewer record camera.
        // Second is set relative to the first.
    this.SynchronizeViews(0, note);
  };
  DualViewWidget.prototype.InitializeSynchronousViews = function (camModel1, camModel2) {
        // Just fashoin a not for now.
    var note = new SA.Note();
    var viewerRecord1 = new SA.ViewerRecord();
    viewerRecord1.Transform = new SA.PairTransformation(); // not necessary
    var viewerRecord2 = new SA.ViewerRecord();
    viewerRecord2.Transform = new SAM.MatrixTransformation(camModel1, camModel2);

    var pt;
    pt = viewerRecord2.Transform.ForwardTransformPoint([259, 656]);
    console.log('(345,261):' + pt[0] + ',' + pt[1]);
    pt = viewerRecord2.Transform.ForwardTransformPoint([285, 8896]);
    console.log('(167,7265):' + pt[0] + ',' + pt[1]);
    pt = viewerRecord2.Transform.ForwardTransformPoint([9406, 16]);
    console.log('(7789,306):' + pt[0] + ',' + pt[1]);
    pt = viewerRecord2.Transform.ForwardTransformPoint([7977, 6215]);
    console.log('(6689,5510):' + pt[0] + ',' + pt[1]);

    note.ViewerRecords = [viewerRecord1, viewerRecord2];
    note.StartIndex = 0;
    note.Type = 'Stack';

    this.saNote = note;
    this.saNoteStartIndex = note.StartIndex;
    this.saViewerIndex = 0;

    var self = this;
    this.GetViewer(0).OnInteraction(function () {
      self.SynchronizeViews(0, note);
    });
    this.GetViewer(1).OnInteraction(function () {
      self.SynchronizeViews(1, note);
    });

    // First view is set by viewer record camera.
    // Second is set relative to the first.
    this.SynchronizeViews(0, note);
  };

  // Display Note
  // Set the state of the WebGL viewer from this notes ViewerRecords.
  // Lock camera is for when the user note updates and we only want to
  // update the annotations.
  DualViewWidget.prototype.DisplayNote = function (note, lockCamera) {
    var numViewers = this.GetNumberOfViewers();
    if (numViewers === 0) { return; }
    if (note.Type === 'Stack') {
      // Stack display needs to keep both viewers up to date.
      numViewers = 2;
    }

    // We could have more than two in the future.
    if (note.Type !== 'Stack') {
      // I want the single view (when set by the user) to persist for rthe stack.
      numViewers = note.ViewerRecords.length;
      this.SetNumberOfViewers(numViewers);
    }

    var idx = note.StartIndex;
    for (var i = 0; i < numViewers; ++i) {
      var viewer = this.GetViewer(i);

      if (i + idx < note.ViewerRecords.length) {
        viewer.SetViewerRecord(note.ViewerRecords[idx + i], lockCamera);
        // This is for synchronizing changes in the viewer back to the note.
        viewer.RecordIndex = i;
      }
    }
  };

  // User notes are load on demand and will show up after the root note.
  // When we add the user note annotations, We cannot reset the camera.
  DualViewWidget.prototype.UpdateUserNotes = function () {
    // Where do we record annotations before wiping the viewer
    // annotations out?
    var note = this.saNote;
    this.DisplayNote(note, true);
  };

  DualViewWidget.prototype.GetNote = function () {
    return this.saNote;
  };

  DualViewWidget.prototype.GetRootNote = function () {
    var note = this.saNote;
    while (note.Parent) {
      note = note.Parent;
    }
    return note;
  };

  DualViewWidget.prototype.SetNoteFromId = function (noteId) {
    var note = SA.GetNoteFromId(noteId);
    if (!note) {
      note = new SA.Note();
    }
    if (note.LoadState !== 2) {
      var self = this;
      note.LoadViewId(
                noteId,
                function () {
                  self.SetNote(note);
                });
      return note;
    }

    this.SetNote(note);
    return note;
  };

  // API for ViewerSet
  DualViewWidget.prototype.GetNumberOfViewers = function () {
    if (this.DualView) {
      return 2;
    }

    return 1;
  };

  // API for ViewerSet
  DualViewWidget.prototype.GetViewer = function (idx) {
    return this.Viewers[idx];
  };

  // Called programmatically. No animation.
  DualViewWidget.prototype.SetNumberOfViewers = function (numViews) {
    this.DualView = (numViews > 1);

    if (this.DualView) {
      this.Viewer1Fraction = 0.5;
    } else {
      this.Viewer1Fraction = 1.0;
    }

    this.UpdateSize();
    this.UpdateGui();
  };

  DualViewWidget.prototype.ToggleDualView = function () {
    this.DualView = !this.DualView;

    if (this.DualView) {
            // If there is no image in the second viewer, copy it from the first.
      if (!this.Viewers[1].GetCache()) {
        this.Viewers[1].SetCache(this.Viewers[0].GetCache());
        this.Viewers[1].GetCamera().DeepCopy(this.Viewers[0].GetCamera());
      }
      this.AnimationCurrent = 1.0;
      this.AnimationTarget = 0.5;
            // Edit menu option to copy camera zoom between views.
            // I do not call update gui here because I want
            // the buttons to appear at the end of the animation.
      $('#dualViewCopyZoom').show();
            // Animation takes care of switching the buttons
    } else {
      this.AnimationCurrent = 0.5;
      this.AnimationTarget = 1.0;
      this.UpdateGui();
    }

    SA.RecordState();

    this.AnimationLastTime = new Date().getTime();
    this.AnimationDuration = 1000.0;
    this.AnimateViewToggle();
  };

  DualViewWidget.prototype.UpdateGui = function () {
    if (this.HideHandles) {
      $('#dualWidgetLeft').hide();
      $('#dualWidgetRight').hide();
      return;
    }
        // Now swap the buttons.
    if (this.DualView) {
      $('#dualWidgetLeft').hide();
      $('#dualWidgetRight').show();
            // Edit menu option to copy camera zoom between views.
      $('#dualViewCopyZoom').show();
    } else {
      $('#dualWidgetRight').hide();
      $('#dualViewCopyZoom').hide();
      $('#dualWidgetLeft').show();
            // Edit menu option to copy camera zoom between views.
    }
  };

  DualViewWidget.prototype.AnimateViewToggle = function () {
    var timeStep = new Date().getTime() - this.AnimationLastTime;
    if (timeStep > this.AnimationDuration) {
            // end the animation.
      this.Viewer1Fraction = this.AnimationTarget;
      this.UpdateSize();
      this.UpdateGui();
      this.Draw();
      return;
    }

    var k = timeStep / this.AnimationDuration;

        // update
    this.AnimationDuration *= (1.0 - k);
    this.Viewer1Fraction += (this.AnimationTarget - this.Viewer1Fraction) * k;

    this.UpdateSize();
        // 2d canvas does not draw without this.
    this.Draw();
    var self = this;
    window.requestAnimationFrame(function () { self.AnimateViewToggle(); });
  };

  DualViewWidget.prototype.CreateThumbnailImage = function (height) {
    var canvas = document.createElement('canvas'); // create
    var ctx = canvas.getContext('2d');
    var img1 = this.Viewers[0].MainView.CaptureImage();
    var scale = height / img1.height;
    var width1 = Math.round(img1.width * scale);
    var height1 = Math.round(img1.height * scale);
    if (this.DualView) {
      var img2 = this.Viewers[2].MainView.CaptureImage();
      var width2 = Math.round(img2.width * scale);
      var height2 = Math.round(img2.height * scale);
      canvas.width = width1 + width2;
      canvas.height = Math.max(height1, height2);
      ctx.drawImage(img2, 0, 0, img2.width, img2.height,
                          width1, 0, width2, height2);
    } else {
      canvas.width = width1;
      canvas.height = height1;
    }
    ctx.drawImage(img1, 0, 0, img1.width, img1.height,
                      0, 0, width1, height1);

    var url = canvas.toDataURL('image/jpeg', 0.8);
    var thumb = document.createElement('img'); // create
    thumb.src = url;

    return thumb;
  };

  DualViewWidget.prototype.Draw = function (gl) {
    if (gl) {
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    }

    if (this.saNote && this.saNote.WaterMark) {
      SA.WaterMark = true;
    } else {
      SA.WaterMark = false;
    }

        // This just changes the camera based on the current time.
    if (this.Viewers[0]) {
      this.Viewers[0].Animate();
      if (this.DualView) { this.Viewers[1].Animate(); }
      this.Viewers[0].Draw();
    }
    if (this.Viewers[1] && this.DualView) { this.Viewers[1].Draw(); }
  };

  DualViewWidget.prototype.UpdateSize = function () {
    var percent = this.Viewer1Fraction * 100;
    if (this.ViewerDivs[0]) {
      this.ViewerDivs[0].css({'left': '0%',
        'width': percent + '%',
        'height': '100%'});
      this.Viewers[0].UpdateSize();
    }
    if (this.ViewerDivs[1]) {
      this.ViewerDivs[1].css({'left': percent + '%',
        'width': (100 - percent) + '%',
        'height': '100%'});
      this.Viewers[1].UpdateSize();
    }

    if (percent >= 90) {
      this.Viewers[1].Hide();
    } else {
      this.Viewers[1].Show();
    }

    // This looks problematic.
    // TODO: Try to get rid of it.
    // $(window).trigger('resize');
  };

  DualViewWidget.prototype.AnnotationWidgetOn = function () {
    for (var i = 0; i < this.Viewers.length; ++i) {
      this.Viewers.AnnotationWidgetOn();
    }
  };

  DualViewWidget.prototype.AnnotationWidgetOff = function () {
    for (var i = 0; i < this.Viewers.length; ++i) {
      this.Viewers.AnnotationWidgetOff();
    }
  };

  // refViewerIdx is the viewer that changed and other viewers need
  // to be updated to match that reference viewer.
  DualViewWidget.prototype.SynchronizeViews = function (refViewerIdx, note) {
    // We allow the viewer to go one past the end.
    if (refViewerIdx + note.StartIndex >= note.ViewerRecords.length) {
      return;
    }

    // Special case for when the shift key is pressed.
    // Translate only one camera and modify the tranform to match.
    if (SA.Edit && SA.StackCursorFlag) {
      var trans = note.ViewerRecords[note.StartIndex + 1].Transform;
      if (!note.ActiveCorrelation && trans.Correlations) {
        if (!trans) {
          alert('Missing transform');
          return;
        }
                // Remove all correlations visible in the window.
        var cam = this.GetViewer(0).GetCamera();
        var bds = cam.GetBounds();
        var idx = 0;
        while (idx < trans.Correlations.length) {
          var cor = trans.Correlations[idx];
          if (cor.point0[0] > bds[0] && cor.point0[0] < bds[1] &&
                        cor.point0[1] > bds[2] && cor.point0[1] < bds[3]) {
            trans.Correlations.splice(idx, 1);
          } else {
            ++idx;
          }
        }

        // Now make a new replacement correlation.
        note.ActiveCorrelation = new SA.PairCorrelation();
        trans.Correlations.push(note.ActiveCorrelation);
      }
      var cam0 = this.GetViewer(0).GetCamera();
      var cam1 = this.GetViewer(1).GetCamera();
      note.ActiveCorrelation.SetPoint0(cam0.GetWorldFocalPoint());
      note.ActiveCorrelation.SetPoint1(cam1.GetWorldFocalPoint());
      // I really do not want to set the roll unless the user specifically changed it.
      // It would be hard to correct if the wrong value got set early in the aligment.
      var deltaRoll = cam1.GetWorldRoll() - cam0.GetWorldRoll();
      if (trans.Correlations && trans.Correlations.length > 1) {
        deltaRoll = 0;
        // Let roll be set by multiple correlation points.
      }
      note.ActiveCorrelation.SetWorldRoll(deltaRoll);
      note.ActiveCorrelation.SetHeight(0.5 * (cam1.Height + cam0.Height));
      return;
    } else {
      // A round about way to set and unset the active correlation.
      // Note is OK, because if there is no interaction without the shift key
      // the active correlation will not change anyway.
      note.ActiveCorrelation = undefined;
    }

    // No shift modifier:
    // Synchronize all the cameras.
    // Hard coded for two viewers (recored 0 and 1 too).
    // First place all the cameras into an array for code simplicity.
    // Cameras used for preloading.
    if (!note.PreCamera) { note.PreCamera = new SAM.Camera(); }
    if (!note.PostCamera) { note.PostCamera = new SAM.Camera(); }
    var cameras = [note.PreCamera,
      this.GetViewer(0).GetCamera(),
      this.GetViewer(1).GetCamera(),
      note.PostCamera];
    var refCamIdx = refViewerIdx + 1; // An extra to account for PreCamera.
    // Start with the reference section and move forward.
    // With two sections, the second has the transform.

    var i;
    var transIdx;
    for (i = refCamIdx + 1; i < cameras.length; ++i) {
      transIdx = i - 1 + note.StartIndex;
      if (transIdx < note.ViewerRecords.length) {
        note.ViewerRecords[transIdx].Transform
                    .ForwardTransformCamera(cameras[i - 1], cameras[i]);
      } else {
        cameras[i] = undefined;
      }
    }

    // Start with the reference section and move backward.
    // With two sections, the second has the transform.
    for (i = refCamIdx; i > 0; --i) {
      transIdx = i + note.StartIndex - 1;
      if (transIdx > 0) { // First section does not have a transform
        note.ViewerRecords[transIdx].Transform
                    .ReverseTransformCamera(cameras[i], cameras[i - 1]);
      } else {
        cameras[i - 1] = undefined;
      }
    }

    // Preload the adjacent sections.
    var cache;
    var tiles;
    if (cameras[0]) {
      cache = SA.FindCache(note.ViewerRecords[note.StartIndex - 1].Image);
      cameras[0].SetViewport(this.GetViewer(0).GetViewport());
      tiles = cache.ChooseTiles(cameras[0], 0, []);
      for (i = 0; i < tiles.length; ++i) {
        tiles[i].LoadQueueAdd();
      }
      SA.LoadQueueUpdate();
    }
    if (cameras[3]) {
      cache = SA.FindCache(note.ViewerRecords[note.StartIndex + 2].Image);
      cameras[3].SetViewport(this.GetViewer(0).GetViewport());
      tiles = cache.ChooseTiles(cameras[3], 0, []);
      for (i = 0; i < tiles.length; ++i) {
        tiles[i].LoadQueueAdd();
      }
      SA.LoadQueueUpdate();
    }

    // OverView cameras need to be updated.
    if (refViewerIdx === 0) {
      this.GetViewer(1).UpdateCamera();
      this.GetViewer(1).EventuallyRender(false);
    } else {
      this.GetViewer(0).UpdateCamera();
      this.GetViewer(0).EventuallyRender(false);
    }

    // Synchronize annotation visibility.
    var refViewer = this.GetViewer(refViewerIdx);
    for (i = 0; i < 2; ++i) {
      if (i !== refViewerIdx) {
        var viewer = this.GetViewer(i);
        if (viewer.AnnotationWidget && refViewer.AnnotationWidget) {
          viewer.AnnotationWidget.SetVisibility(
                        refViewer.AnnotationWidget.GetVisibility());
        }
      }
    }
  };

  // Called from the console for renal stack.
  // For every polyline in the left viewer, try to find a corresponding
  // polyline in the right viewer. If found, change its color to match.
  DualViewWidget.prototype.MatchPolylines = function (color, tolerance) {
    tolerance = tolerance || 0.5;
    var widgets0 = this.Viewers[0].GetAnnotationLayer().GetWidgets();
    var widgets1 = this.Viewers[1].GetAnnotationLayer().GetWidgets();
    var note = this.saNote;

    var trans = note.ViewerRecords[note.StartIndex + 1].Transform;

    for (var i = 0; i < widgets0.length; ++i) {
      var w0 = widgets0[i];
      if (w0.Polyline) {
        var polyline0 = w0.Polyline;
        var r = Math.floor(polyline0.OutlineColor[0] * 255);
        var g = Math.floor(polyline0.OutlineColor[1] * 255);
        var b = Math.floor(polyline0.OutlineColor[2] * 255);
        if (r !== color[0] || g !== color[1] || b !== color[2]) {
          continue;
        }
        console.log('Matched color ' + i);

                // get the center and area.
        var center0 = [(polyline0.Bounds[0] + polyline0.Bounds[1]) * 0.5,
          (polyline0.Bounds[2] + polyline0.Bounds[3]) * 0.5];
        var size = Math.abs(polyline0.Bounds[1] - polyline0.Bounds[0]) +
                   Math.abs(polyline0.Bounds[3] - polyline0.Bounds[2]);

        var area0 = polyline0.ComputeArea();
        var bestMatch;
        var bestPolyline;
        var bestIdx = -1;
        for (var j = 0; j < widgets1.length; ++j) {
          var w1 = widgets1[j];
          if (w1.Polyline) {
            var polyline1 = w1.Polyline;
            // get the center and area.
            var center0b = trans.ForwardTransform(center0, size); // sigma);

            var center1 = [(polyline1.Bounds[0] + polyline1.Bounds[1]) * 0.5,
              (polyline1.Bounds[2] + polyline1.Bounds[3]) * 0.5];
            var area1 = polyline1.ComputeArea();
            var dx = center1[0] - center0b[0];
            var dy = center1[1] - center0b[1];
            var match = (dx * dx + dy * dy + Math.abs(area1 - area0)) / area0;
            if (bestIdx === -1 || match < bestMatch) {
              bestMatch = match;
              bestPolyline = w1;
              bestIdx = j;
            }
          }
        }

        if (bestIdx === -1) {
          // Should not happen
          console.log('+++ No candidates: Widget' + i);
        } else if (bestMatch < tolerance) {
          bestPolyline.Polyline.OutlineColor =
                        w0.Polyline.OutlineColor.slice(0);
          console.log('+++ Match: Widget ' + i + ' = ' + bestIdx + ', (' + bestMatch + ')');
        } else {
          console.log('--- No match: Widget ' + i + ', Closest ' + bestIdx + ', (' + bestMatch + ')');
        }
      }
    }

    this.EventuallyRender();
  };

  // For debugging called from console.
  // Resets the colors of the poly lines lin viewer 2 so we can see what
  // has changed when we run MatchPolylines
  // color is an array [1,1,1]
  DualViewWidget.prototype.SetPolylineColor = function (color) {
    var widgets1 = this.Viewers[1].GetAnnotationLayer().GetWidgets();

    for (var i = 0; i < widgets1.length; ++i) {
      var w1 = widgets1[i];
      if (w1.Polyline) {
        w1.Polyline.OutlineColor = color.slice(0);
      }
    }

    this.EventuallyRender();
  };

  SA.DualViewWidget = DualViewWidget;
})();

// ==============================================================================
// Is it time to switch to lowercase?  No.  I still like lower case for
// local variables. Upper case for instance variables

(function () {
  'use strict';

  function TabbedDiv (parent) {
    // Default css can be changed by the caller.
    this.Div = $('<div>')
        .appendTo(parent)
        .css({'position': 'relative',
          'width': '100%',
          'height': '100%'});
    // div for the tab buttons.
    this.TabDiv = $('<div>')
        .appendTo(this.Div)
        .css({'position': 'absolute',
          'width': '100%',
          'height': '30px'});
    // div for the tab bodies.
    this.BodyDiv = $('<div>')
        .appendTo(this.Div)
        .css({'position': 'absolute',
          'width': '100%',
          'top': '30px',
          'bottom': '0px'});

    this.TabPanels = [];
    this.CurrentTabPanel = null;
  }

// I want to hide the TabPanel object, so I return the div.
  TabbedDiv.prototype.NewTabDiv = function (label, helpString) {
    var tabPanel = new TabPanel(this, label);
    if (helpString) {
      tabPanel.Tab.prop('title', helpString);
    }
    this.TabPanels.push(tabPanel);
    // First panel added should be open by default.
    if (this.TabPanels.length === 1) {
      this.OpenTabPanel(tabPanel);
    }

    return tabPanel.Div;
  };

// Private
  TabbedDiv.prototype.OpenTabPanel = function (tabPanel) {
    if (!tabPanel) { return; }
    // close to previous tab
    // NOTE: If we only close the previous panel, tab buttons wrap to the next line
    for (var i = 0; i < this.TabPanels.length; ++i) {
      var panel = this.TabPanels[i];
      panel.Div.hide();
        // The z-index does not seem to be working.
        // When the panel is zoomed, Tab looks like it is on top.
      panel.Tab.css({'color': '#AAA',
        'z-index': '4',
        'border-color': '#BBB'});
    }
    // open the new tab.
    tabPanel.Div.show();
    tabPanel.Tab.css({'color': '#000',
      'z-index': '6',
      'border-color': '#BBB #BBB #FFF #BBB'});
    this.CurrentTabPanel = tabPanel;
    // The FillDiv callback does not work when the editor is hidden.
    // Trigger onResize after the text tab is made visible.
    $(window).trigger('resize');
  };

  TabbedDiv.prototype.GetCurrentDiv = function () {
    if (!this.CurrentTabPanel) {
      return undefined;
    }
    return this.CurrentTabPanel.Div;
  };

// Internal helper method
  TabbedDiv.prototype.GetTabPanelFromDiv = function (tabDiv) {
    for (var i = 0; i < this.TabPanels.length; ++i) {
      var tabPanel = this.TabPanels[i];
      if (tabPanel.Div === tabDiv) {
        return tabPanel;
      }
    }
    return null;
  };

// Internal helper method
  TabbedDiv.prototype.GetTabPanelFromIndex = function (index) {
    if (index < 0 || index >= this.TabPanels.length) {
      console.log('GetTabPanelFromIndex(' + index + '): error');
      return null;
    }
    return this.TabPanels[index];
  };

  TabbedDiv.prototype.ShowTabDiv = function (tabDiv) {
    this.OpenTabPanel(this.GetTabPanelFromDiv(tabDiv));
  };

  TabbedDiv.prototype.ShowTabIndex = function (index) {
    this.OpenTabPanel(this.GetTabPanelFromIndex(index));
  };

  TabbedDiv.prototype.EnableTabDiv = function (tabDiv) {
    var panel = this.GetTabPanelFromDiv(tabDiv);
    panel.Enabled = true;
    panel.Tab.show();
  };

  TabbedDiv.prototype.DisableTabDiv = function (tabDiv) {
    var panel = this.GetTabPanelFromDiv(tabDiv);
    if (!panel) { return; }

    panel.Enabled = false;
    if (panel === this.CurrentTabPanel) {
      this.CurrentTabPanel = null;
        // Find another panel to display.
      for (var i = 0; i < this.TabPanels.length; ++i) {
        if (this.TabPanels[i].Enabled) {
          this.OpenTabPanel(this.TabPanel[i]);
          break;
        }
      }
    }

    panel.Tab.css({'color': '#AAA',
      'z-index': '4',
      'border-color': '#BBB'});
    panel.Div.hide();
    panel.Tab.hide();
  };

// ==============================================================================

  function TabPanel (tabbedDiv, title) {
    var self = this;
    this.Enabled = true;
    this.Tab = $('<div>')
        .appendTo(tabbedDiv.TabDiv)
        .text(title)
        .css({'color': '#AAA',
          'border-color': '#BBB',
          'position': 'relative',
          'bottom': '-2px',
          'padding': '2px 7px 2px 7px',
          'margin': '5px 0px 0px 5px',
          'display': 'inline-block',
          'border-width': '1px',
          'border-style': 'solid',
          'border-radius': '5px 5px 0px 0px',
          'z-index': '6',
          'background': 'white'})
        .click(function () {
          tabbedDiv.OpenTabPanel(self);
        });
    this.Div = $('<div>')
        .hide()
        .appendTo(tabbedDiv.BodyDiv)
        .css({'position': 'absolute',
          'top': '0px',
          'bottom': '3px',
          'left': '3px',
          'right': '3px',
          'border-width': '1px',
          'border-style': 'solid',
          'border-color': '#BBB',
          'z-index': '5',
          'background': 'white'});
  }

// ==============================================================================

  SA.TabbedDiv = TabbedDiv;
  SA.TabPanel = TabPanel;
})();

// ------------------------------------------------------------------------------
// Note object (maybe will be used for views and sessions too).

// TODO: Remove GUI from this file.

(function () {
  'use strict';

  // Note load states.
  var INVALID = 0; // just an id
  var REQUESTED = 1;    // Load request and waiting for the callback
  var SYNCHRONIZED = 2; // Same as database

  // Globals
  // The client creates the real and permanent id, so this works even if
  // the note has not been added to the database.
  SA.GetNoteFromId = function (id) {
    for (var i = 0; i < SA.Notes.length; ++i) {
      var note = SA.Notes[i];
      if (note.Id && note.Id === id) {
        return note;
      }
    }
    return null;
  };
  SA.GetUserNoteFromImageId = function (id) {
    for (var i = 0; i < SA.Notes.length; ++i) {
      var note = SA.Notes[i];
      if (note.Type === 'UserNote' && note.Parent === id) {
        return note;
      }
    }
    return null;
  };
    // When a note fails to load, we need to remove it from the global list
    // of notes. We also delete recorder notes.  Once saved, we never user
    // them again.
  SA.DeleteNote = function (note) {
    var idx = SA.Notes.indexOf(note);
    if (idx !== -1) {
      SA.Notes.splice(idx, 1);
    }
  };

  function Note () {
    if (!SA.Notes) {
            // data is the object retrieved from mongo (with string ids)
            // Right now we expect bookmarks, but it will be generalized later.
      SA.Notes = [];
    }

        // A global list of notes so we can find a note by its id.
        // TODO: Legacy.  Get rid of TempId.
    this.Id = this.TempId = new ObjectId().toString();
    SA.Notes.push(this);

    var self = this;
        // 0: just an id
        // 1: requested
        // 2: received
    this.LoadState = INVALID;

    this.User = SA.GetUser(); // Reset by flask.
    var d = new Date();
    this.Date = d.getTime(); // Also reset later.
    this.Type = 'Note';
    this.Mode = '';

    this.Title = '';
    this.Text = '';
    this.Modified = false;

        // Upto two for dual view.
    this.ViewerRecords = [];

        // ParentNote (it would be nice to make the session a note too).
    this.Parent = null;

        // Sub notes
    this.Children = [];
    this.ChildrenVisibility = true;

        // GUI elements.
    this.Div = $('<li>')
            .attr({'class': 'note'});

    this.TitleDiv = $('<div>')
            .css({'position': 'relative'})
            .appendTo(this.Div);

    this.SortHandle = $('<span>')
            .appendTo(this.TitleDiv)
            .css({'position': 'absolute',
              'left': '0px',
              'top': '0px',
              'opacity': '0.5'})
            .addClass('ui-icon ui-icon-bullet');

    this.ButtonsDiv = $('<div>')
            .appendTo(this.TitleDiv)
            .css({'float': 'right'})
            .hide();
    this.TitleEntry = $('<div>')
            .css({'margin-left': '20px'})
            .appendTo(this.TitleDiv)
            .text(this.Title)
            .addClass('sa-title');
    if (this.Mode === 'answer-hide' || this.Mode === 'answer-interactive') {
      this.TitleEntry.text('-');
    }

    if (SA.Edit) {
      this.AddButton = $('<img>')
                .appendTo(this.ButtonsDiv)
                .attr('src', SA.ImagePathUrl + 'page_add.png')
                .addClass('editButton')
                .prop('title', 'add view')
                .css({
                  'width': '12px',
                  'height': '12px',
                  'opacity': '0.5'});
      this.LinkButton = $('<img>')
                .appendTo(this.ButtonsDiv)
                .attr('src', SA.ImagePathUrl + 'link.png')
                .prop('title', 'show url')
                .addClass('editButton')
                .css({
                  'width': '12px',
                  'height': '12px',
                  'opacity': '1.0'});
      this.RemoveButton = $('<img>')
                .appendTo(this.ButtonsDiv)
                .hide()
                .attr('src', SA.ImagePathUrl + 'remove.png')
                .prop('title', 'delete')
                .addClass('editButton')
                .css({
                  'width': '12px',
                  'height': '12px',
                  'opacity': '0.5'});
    }

    if (SA.HideAnnotations || this.Mode === 'answer-hide' ||
            this.Mode === 'answer-interactive') {
      this.TitleEntry.text('-');
    }

    if (SA.Edit) {
      this.Modified = false;
      if (this.Mode === 'answer-hide' && this.Mode !== 'answer-interactive') {
        this.TitleEntry
                    .attr('contenteditable', 'true');
      }
    }

        // The div should attached even if nothing is in it.
        // A child may appear and UpdateChildrenGui called.
        // If we could tell is was removed, UpdateChildGUI could append it.
    this.ChildrenDiv = $('<ul>')
            .addClass('sa-ul')
            .appendTo(this.Div);

    if (SA.Edit) {
      this.ChildrenDiv
                .sortable({update: function (event, ui) { self.SortCallback(); },
                  handle: '.ui-icon'});
    } else {
      this.ChildrenDiv
                .disableSelection();
    }

        // This is for stack notes (which could be a subclass).
        // It looks like the stack will start on this index when it first
        // is loaded.  This changes when navigating the stack.
    this.StartIndex = 0;
    this.ActiveCorrelation = undefined;
    this.StackDivs = [];
  }

    // For copy slide in presentations
  Note.prototype.DeepCopy = function (note) {
        // I tried serialize / load, but the image changed to a string id.
    this.Image = Note.Image; // not really deep.
    this.Children = [];
    for (var i = 0; i < note.Children.length; ++i) {
      var child = new SA.Note();
      child.DeepCopy(note.Children[i]);
      this.Children.push(child);
    }
    this.Parent = note.Parent;
    this.StartIndex = note.StartIndex;
        // Replace old note id with new in HTML.
    var oldId = note.Id;
    var newId = this.Id;
    this.Text = note.Text.replace(oldId, newId);
    this.Title = note.Title;
    this.Type = note.Type;
    this.User = note.User;
        // this.UserText = note.UserText;
    this.ViewerRecords = [];
    for (i = 0; i < note.ViewerRecords.length; ++i) {
      var record = new SA.ViewerRecord();
      record.DeepCopy(note.ViewerRecords[i]);
      this.ViewerRecords.push(record);
    }
  };

    // So this is a real pain.  I need to get the order of the notes from
    // the childrenDiv jquery element.
  Note.prototype.SortCallback = function () {
    var newChildren = [];
    var children = this.ChildrenDiv.children();
    for (var newIndex = 0; newIndex < children.length; ++newIndex) {
      var oldIndex = $(children[newIndex]).data('index');
      var note = this.Children[oldIndex];
      note.Div.data('index', newIndex);
      newChildren.push(note);
    }

    this.Children = newChildren;
    this.UpdateChildrenGUI();
    if (SA.notesWidget) {
      SA.notesWidget.MarkAsModified();
    }
  };

  // When the note is deleted, this clear associated text links.
  // However, it does not remove the span id.
  Note.prototype.ClearHyperlink = function () {
    if (this.Id) {
      // I think is will be best to seelct the element and then replace
      // it with text.
      this.SelectHyperlink();
      var sel = window.getSelection();
      document.execCommand('insertText', sel.toString());
    }
  };

  // Pragmatically select the hyper link (when the note is selected).
  Note.prototype.SelectHyperlink = function () {
    if (this.Id) {
      var el = document.getElementById(this.Id);
      if (el) {
        var range = document.createRange();
                // range.selectNodeContents(el);
        range.selectNode(el);
        var sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
      }
    }
  };

  // Pragmatically select the hyper link (when the note is selected).
  Note.prototype.UnselectHyperlink = function () {
    if (this.Id) {
      var el = document.getElementById(this.Id);
      if (el) {
        var range = document.createRange();
        range.collapse(true);
        var sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
      }
    }
  };

  Note.prototype.SetParent = function (parent) {
    this.Parent = parent;
    if (parent && SA.Edit) {
      this.RemoveButton.show();
    }
  };

  Note.prototype.TitleFocusInCallback = function () {
        // Keep the viewer from processing arrow keys.
    SA.ContentEditableHasFocus = true;
    SA.SetNote(this);
  };

  Note.prototype.TitleFocusOutCallback = function () {
    if (this.Modified) {
            // Move the Title from the GUI to the note.
      this.Modified = false;
      if (this.Mode !== 'answer-hide' && this.Mode !== 'answer-interactive') {
        this.Title = this.TitleEntry.text();
      }
      if (SA.notesWidget) {
        SA.notesWidget.MarkAsModified();
      }
    }
        // Allow the viewer to process arrow keys.
    SA.ContentEditableHasFocus = false;
    if (!this.Modified) { return; }
    this.Modified = false;
    if (this.Mode !== 'answer-hide' && this.Mode !== 'answer-interactive') {
      var text = this.TitleEntry.text();
      if (this.Title !== text && !SA.HideAnnotations) {
        this.Title = text;
        this.Save();
      }
    }
  };

  Note.prototype.LinkCallback = function () {
    if (!SA.LinkDiv) { return; }
    var text = 'slide-atlas.org/webgl-viewer?view=' + this.Id;
    SA.LinkDiv.html(text);
    SA.LinkDiv.show();
        // Select the text so it is easy to copy.
    var range = document.createRange();
    range.selectNodeContents(SA.LinkDiv[0]);
    var sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);

        // Try to copy to the clipboard.
    document.execCommand('copy', false, null);
  };

  Note.prototype.DeleteCallback = function () {
    if (this.Type === 'UserNote') {
            // User notes have a parent, but are also roots.
      return;
    }
    var parent = this.Parent;
    if (parent === null) {
      return;
    }

    this.ClearHyperlink();

    if (this.Type !== 'view') {
      if (SA.display && SA.display.NavigationWidget &&
                SA.display.NavigationWidget.GetNote() === this) {
                // Move the current note off this note.
                // There is always a previous.
        SA.display.NavigationWidget.PreviousNote();
      }
    }

        // Get rid of the note.
    var index = parent.Children.indexOf(this);
    parent.Children.splice(index, 1);
    this.Parent = null;

        // Redraw the GUI.
    parent.UpdateChildrenGUI();
    if (SA.notesWidget) {
      SA.notesWidget.MarkAsModified();
    }
  };

    // User notes are associated with images. They should be referenced by
    // the viewer record.  THis method is only used by presentations.
    // TODO: Fix this.
  Note.prototype.SetUserNote = function (userNote) {
    var parentNote = this;
    parentNote.UserNote = userNote;
    userNote.Parent = parentNote;
    userNote.Type = 'UserNote';
  };

  Note.prototype.UserCanEdit = function () {
    return SA.Edit;
  };

  Note.prototype.RecordView = function (display) {
        // TODO: Get rid of VIEWER globals.
    if (display.GetNumberOfViewers() === 0) { return; }

    if (this.Type === 'Stack') {
            // All we want to do is record the default
            // camera of the first section (if we at
            // the start of the stack).
      var viewer0 = display.GetViewer(0);
      if (this.StartIndex === 0) {
        this.ViewerRecords[0].CopyViewer(viewer0);
      }
      return;
    }
    this.ViewerRecords = [];
    for (var i = 0; i < display.GetNumberOfViewers(); ++i) {
      var viewerRecord = new SA.ViewerRecord();
      viewerRecord.CopyViewer(display.GetViewer(i));
      this.ViewerRecords.push(viewerRecord);
    }
  };

  Note.prototype.AddChild = function (childNote, first) {
        // Needed to get the order after a sort.
    childNote.Div.data('index', this.Children.length);

    if (first) {
      this.Children.splice(0, 0, childNote);
    } else {
      this.Children.push(childNote);
    }

    this.UpdateChildrenGUI();
  };

  // TODO: Get the GUI stuff out of note objects.
  Note.prototype.UpdateChildrenGUI = function () {
    // Callback trick
    var i;

    // Clear
    this.ChildrenDiv.empty();

    // Stacks
    if (this.Type === 'Stack') {
      // I want viewer records to look like children for stacks.
      this.StackDivs = [];
      for (i = 0; i < this.ViewerRecords.length; ++i) {
        var sectionDiv = $('<div>')
                    .addClass('note')
                    .appendTo(this.ChildrenDiv);
        if (SA.HideAnnotations) {
          sectionDiv.text(i.toString());
        } else {
          sectionDiv.text(this.ViewerRecords[i].Image.label);
        }
        this.StackDivs.push(sectionDiv);
        if (i === this.StartIndex) {
          sectionDiv.css({'background-color': '#BBB'});
        }
      }
      return;
    }

    // Notes
    if (this.Children.length === 0) {
      return;
    }

    // Move all the views to the end.  They do not take part in the notes
    // gui. They are for text links.  They may mess up drag ordering.
    var newChildren = [];
    for (i = 0; i < this.Children.length; ++i) {
      if (this.Children[i].Type === 'Note') {
        newChildren.push(this.Children[i]);
      }
    }
    for (i = 0; i < this.Children.length; ++i) {
      if (this.Children[i].Type !== 'Note') {
        newChildren.push(this.Children[i]);
      }
    }
    this.Children = newChildren;

    for (i = 0; i < this.Children.length; ++i) {
      if (this.Children[i].Type === 'Note') {
        this.Children[i].DisplayGUI(this.ChildrenDiv);
        // Indexes used for sorting.
        this.Children[i].Div.data('index', i);
        if (this.Children.length > 1) {
          this.Children[i].SortHandle.addClass('sa-sort-handle');
        } else {
          this.Children[i].SortHandle.removeClass('sa-sort-handle');
        }
      }
    }
  };

  Note.prototype.NewIterator = function () {
    return new SA.NoteIterator(this);
  };

  Note.prototype.Contains = function (decendent) {
    for (var i = 0; i < this.Children.length; ++i) {
      var child = this.Children[i];
      if (child === decendent) {
        return true;
      }
      if (child.Contains(decendent)) {
        return true;
      }
    }
    return false;
  };

    // Create a new note,  add it to the parent notes children at index "childIdx".
    // The new note is not automatically selected.
  Note.prototype.NewChild = function (childIdx, title) {
        // Create a new note.
    var childNote = new SA.Note();
    childNote.Title = title;
    var d = new Date();
    childNote.Date = d.getTime(); // Temporary. Set for real by server.

        // Now insert the child after the current note.
    this.Children.splice(childIdx, 0, childNote);
    childNote.SetParent(this);

    return childNote;
  };

    // Save the note in the database and set the note's id if it is new.
    // callback function can be set to execute an action with the new id.
  Note.prototype.Save = function (callback, excludeChildren) {
    console.log('Save note ' + this.Id + ' ' + this.Title);

    var self = this;
        // Save this users notes in the user specific collection.
    var noteObj = JSON.stringify(this.Serialize(excludeChildren));
    var d = new Date();
    SA.PushProgress();
    $.ajax({
      type: 'post',
      url: '/webgl-viewer/saveviewnotes',
      data: {'note': noteObj,
        'date': d.getTime()},
      success: function (data, status) {
        SA.PopProgress();
        if (callback) {
          (callback)(self);
        }
        self.LoadState = SYNCHRONIZED;
      },
      error: function () {
        SA.PopProgress();
        SA.Debug('AJAX - error() : saveviewnotes');
      }
    });
  };

  Note.prototype.HasAnnotations = function () {
    for (var i = 0; i < this.ViewerRecords.length; ++i) {
      if (this.ViewerRecords.Annotations.length > 0) {
        return true;
      }
    }
    return false;
  };

    // TODO: Method only used by presentations.  Move this to viewer
    // record.
    // This takes the state of the GUI and updates the notes to match
  Note.prototype.RecordAnnotations = function (display) {
        // This is ok, because user notes do not have user notes of their own.
    if (this.UserNote) {
            // UserNote annotations are kept separate from other annotations.
      this.UserNote.RecordAnnotations(display);
            // Save it to the database aggresively.
            // If the note has annotations, they might be new.
            // If it was loaded, the annotations might have been deleted.
      if (this.UserNote.HasAnnotations() ||
                this.UserNote.LoadState !== INVALID) {
        this.UserNote.Save();
      }
    }

        // A bit confusing.  This executes for both normal notes and user
        // notes. Each saves a different subset of the annotations.
    for (var i = 0; i < display.GetNumberOfViewers(); ++i) {
      if (this.ViewerRecords.length > this.StartIndex + i) {
        var viewerRecord = this.ViewerRecords[this.StartIndex + i];
        viewerRecord.CopyAnnotations(
                    display.GetViewer(i), (this.Type === 'UserNote'));
      }
    }
  };

    // No clearing.  Just draw this notes GUI in a div.
  Note.prototype.DisplayGUI = function (div) {
    var self = this;
    this.Div.appendTo(div);

    if (this.Mode !== 'answer-hide' && this.Mode !== 'answer-interactive') {
      this.TitleEntry
                .click(function () {
                  SA.SetNote(self);
                  self.ButtonsDiv.show();
                })
                .bind('input', function () {
                  self.Modified = true;
                })
                .focusin(function () { self.TitleFocusInCallback(); })
                .focusout(function () { self.TitleFocusOutCallback(); })
                .mouseleave(function () {
                  if (self.Modified) {
                    self.Modified = false;
                    self.Title = self.TitleEntry.text();
                    if (SA.notesWidget) { SA.notesWidget.MarkAsModified(); }
                  }
                });
      this.TitleDiv
                .hover(
                    function () {
                      self.TitleEntry.css({'color': '#33D'});
                      if (SA.notesWidget && SA.notesWidget.SelectedNote === self) {
                        self.ButtonsDiv.show();
                      }
                    },
                    function () {
                      self.TitleEntry.css({'color': '#3AF'});
                      self.ButtonsDiv.hide();
                    });
      this.TitleEntry.text(this.Title);
    } else {
      this.TitleEntry.text('-');
    }

        // Changing a div "parent/appendTo" removes all event bindings like click.
        // I would like to find a better solution to redraw.
    if (SA.Edit) {
            // Removing and adding removes the callbacks.
      this.AddButton
                .click(function () {
                  if (SA.notesWidget) { SA.notesWidget.NewCallback(); }
                });
      this.LinkButton
                .click(function () {
                  self.LinkCallback();
                });
      this.RemoveButton
                .click(function () {
                  self.DeleteCallback();
                });
    }

    this.UpdateChildrenGUI();
  };

  Note.prototype.Serialize = function (excludeChildren) {
    var obj = {};
    obj.SessionId = localStorage.sessionId;
    obj.Type = this.Type;
    obj.Mode = this.Mode;
    obj.User = this.User;
    obj.Date = this.Date;
    if (this.WaterMark) {
      obj.WaterMark = this.WaterMark;
    }

    // user data to customize note types
    // I needed this for background color and apsect ratio of presentations.
    if (this.TypeData) {
      obj.TypeData = this.TypeData;
    }

    if (this.NotesPanelOpen) {
      obj.NotesPanelOpen = true;
    }

    if (this.Id) {
      obj._id = this.Id;
      delete this._id;
    }
    // I would like to put the session as parent, but this would be an inclomplete reference.
    // A space is not a valid id. Niether is 'false'. Lets leave it blank.
    if (this.Parent) {
      if (typeof (this.Parent) === 'string') {
        // When the parent is an image.
        obj.ParentId = this.Parent;
      }
      if (typeof (this.Parent) === 'object' && this.Parent.Id) {
        // When the parent is a note.
        obj.ParentId = this.Parent.Id;
      }
      // These snuck into the database.
      delete this.ParentId;
    }
    obj.Title = this.Title;
    obj.HiddenTitle = this.HiddenTitle;

    obj.Text = this.Text;
    // The server handles copying views and the code is a pain.
    // I would rather have the client copy notes since is can now
    // save them one by one and get ids for new notes.
    // However,  until I make this change, I need a simple way of copying
    // a note and not messing up the references in the text.
    // Code the links in the html as indexes.
    // for (var i = 0; i < this.Children.length; ++i) {
    //    var Child
    // }

    // We should probably serialize the ViewerRecords too.
    obj.ViewerRecords = [];

    // The database wants an image id, not an embedded iamge object.
    //  The server should really take care of this since if
    for (var i = 0; i < this.ViewerRecords.length; ++i) {
      if (!this.ViewerRecords[i].Image) continue;
      var record = this.ViewerRecords[i].Serialize();
      obj.ViewerRecords.push(record);
    }

    // upper left pixel
    obj.CoordinateSystem = 'Pixel';

    // Will this erase children if includeChildren is off?
    if (!excludeChildren) {
      obj.Children = [];
      for (i = 0; i < this.Children.length; ++i) {
        obj.Children.push(this.Children[i].Serialize(excludeChildren));
      }
    }

    return obj;
  };

  // This method of loading is causing a pain.
  // Children are saved separately now, so the pain should be gone.
  Note.prototype.Load = function (obj) {
    // Received
    this.LoadState = SYNCHRONIZED;

    var ivar;
    for (ivar in obj) {
      this[ivar] = obj[ivar];
    }
    // I am not sure blindly copying all of the variables is a good idea.
    if (this._id) {
      this.Id = this._id;
      delete this._id;
    }

    // It would be better not to set the ParentId of user notes in the
    // first place. userNote.Parent is set to the id of the image.
    if (this.Type !== 'UserNote' && this.ParentId) {
      this.Parent = SA.GetNoteFromId(this.ParentId);
      delete this.ParentId;
    }

    if (SA.HideAnnotations || this.Mode === 'answer-hide' ||
            this.Model === 'answer-interactive') {
      this.TitleEntry.text('-');
    } else {
      this.TitleEntry.text(this.Title);
    }

    for (var i = 0; i < this.Children.length; ++i) {
      var child = this.Children[i];
      var childNote = new SA.Note();
      childNote.SetParent(this);
      if (typeof (child) === 'string') {
        // Asynchronous.  This may cause problems (race condition)
        // We should have a load state in note.
        // childNote.LoadViewId(child);
        childNote.Id = child;
      } else {
        childNote.Load(child);
      }
      this.Children[i] = childNote;
      childNote.Div.data('index', i);
    }

    // Only used by presentations.
    if (this.UserNote) {
      // Make the user not into a real object.
      obj = this.UserNote;
      this.UserNote = new SA.Note();
      this.UserNote.Load(obj);
    }

    for (i = 0; i < this.ViewerRecords.length; ++i) {
      if (this.ViewerRecords[i]) {
        obj = this.ViewerRecords[i];
        // It would be nice to have a constructor that took an object.
        this.ViewerRecords[i] = new SA.ViewerRecord();
        this.ViewerRecords[i].Load(obj);
        if (i < 3) {
          // Delay requesting the user notes for a long stack.
          this.ViewerRecords[i].RequestUserNote();
        }
      }
    }
  };

  // Making this handle callbacks added after original load call.
  // Will not reload. I am not really sure this feature is actually
  // needed. I will keep it to be safe.
  var HACK_LOAD_CALLBACKS = [];
  Note.prototype.LoadViewId = function (viewId, callback) {
    if (this.LoadState === SYNCHRONIZED) {
      // no realoading (could be done with an extra arg).
      (callback)();
      return;
    }
    if (this.LoadState === REQUESTED) {
      // Waiting for an ajax call to return.
      // Add the new callback to any already pending.
      // HACK + LOAD_CALLBACKS.push({note: this, callback: callback});
      return;
    }

    var self = this;
    this.LoadState = REQUESTED;

    SA.PushProgress();

    $.ajax({
      type: 'get',
      url: '/webgl-viewer/getview',
      data: {'viewid': viewId},
      success: function (data, status) {
        SA.PopProgress();
        self.Load(data);
        if (callback) {
          (callback)();
        }
        // Look for anycallbacks added after the ajax call.
        // This feature may nt be used, but it is safe.
        // I have been having problems with views note display in
        // presentations.
        var tmp = [];
        for (var i = 0; i < HACK_LOAD_CALLBACKS.length; ++i) {
          var tmp2 = HACK_LOAD_CALLBACKS[i];
          if (tmp2.note === self) {
            (tmp2.callback)();
          } else {
            tmp.push(tmp2);
          }
        }
        HACK_LOAD_CALLBACKS = tmp;
      },
      error: function () {
        SA.PopProgress();
        SA.Debug('AJAX - error() : getview');
      }
    });
  };

  Note.prototype.Collapse = function () {
    this.ChildrenVisibility = false;
    if (this.Contains(SA.notesWidget.SelectedNote)) {
      // Selected note should not be in collapsed branch.
      // Make the visible ancestor active.
      SA.SetNote(this);
    }
    this.UpdateChildrenGUI();
    SA.display.NavigationWidget.Update();
  };

  Note.prototype.Expand = function () {
    this.ChildrenVisibility = true;
    this.UpdateChildrenGUI();
    SA.display.NavigationWidget.Update();
  };

  // Extra stuff for stack.
  Note.prototype.DisplayStack = function (display) {
    // SA.SetNote(this);
    // For editing correlations
    if (SA.Edit && this.StartIndex + 1 < this.ViewerRecords.length) {
      var trans = this.ViewerRecords[this.StartIndex + 1].Transform;
      if (trans) {
        display.GetViewer(0).StackCorrelations = trans.Correlations;
        display.GetViewer(1).StackCorrelations = trans.Correlations;
      }
    }
    // Indicate which section is being displayed in viewer 1
    for (var i = 0; i < this.StackDivs.length; ++i) {
      if (i === this.StartIndex) {
        this.StackDivs[i].css({'background-color': '#BBB'});
      } else {
        this.StackDivs[i].css({'background-color': '#FFF'});
      }
    }
  };

  // Creates default transforms for Viewer Records 1-n
  // (if they do not exist already).  Uses cameras focal point.
  Note.prototype.InitializeStackTransforms = function () {
    for (var i = 1; i < this.ViewerRecords.length; ++i) {
      if (!this.ViewerRecords[i].Transform) {
        var cam0 = this.ViewerRecords[i - 1].Camera;
        var cam1 = this.ViewerRecords[i].Camera;
        var dRoll = cam1.GetWorldRoll() - cam0.GetWorldRoll();
        if (dRoll < 0.0) { dRoll += 2 * Math.PI; }
        var trans = new SA.PairTransformation();
        trans.AddCorrelation(cam0.GetWorldFocalPoint(), cam1.GetWorldFocalPoint(), dRoll,
                             0.5 * (cam0.Height + cam1.Height));
        this.ViewerRecords[i].Transform = trans;
      }
    }
  };

  SA.Note = Note;
})();

// A potential problem with user notes.  User note is created when a note
// is loaded.  It will not be possible to add user text right after a note
// is created.  I should disable usernote tab in this case. I do not think
// it is worthwile to create a user not earlier because I would have to
// merge user notes or indicate that a note is new and will never be loaded.
// that possibly share a superclass.

// Notes can be nested (tree structure) to allow for student questions, comments or discussion.
// Sessions could be notes.
// Notes within the same level are ordered.
// Question answers can be sub notes.

// Students can save comments that are not seen by other students.
// Student notes are stored as "favorites".
// Notes keep an ID of their parent in the database.
// The recording API is used to save the state of viewers (ViewerRecord)
// Notes just add a tree structure on top of these states (with GUI).

// Right now we are loading the view and bookmarks as notes.
// Bookmarks have two notes: Question and a child answer.
// I need to change this to be more like the origin open layers presentation.

// TODO:
// Highlight icon on hover.
// Drag notes to change the order.
// Show the user "favorite" notes.
// Allow user to delete the favorite note (even if edit is not on).

// HTML:
// Students like the HTML Text and would like to see hyperlinks to
// annotation and cameras.  The Scheme is not setup for this because
// children have their own text.  I am going to change the behavior so
// that children that do not have their own text, show the text of their
// parent.  I will probably hide children without text in the top display.
// TODO:
// Bug: Tabs do not look right (bottom should be white / z_index?)
// Bug: only the last child added can be selected by the title.
//      only the last child added shows the delete and camera buttons.
//      This only happens when editing.  Loading a saved view/note works
//      fine.
// Bug: Note title not being saved.
// Bug: Type "test" reload (not saved).

// Deleting a note should delete the usernote.
// Deleting a hyper link should delete its note. (test)

// Maybe have a "Add" at the bottom of the link list.
// Move deleted links to trash instead of deleting. (Undo delete)
// A way to get permalink to notes. (for Brown) (LinkCallback)
// Indicate the current note in the text.
// Save notes panel state (opened, closed, width) in mongo.
// ??? Link notes better in html ??? Saving edited html is the problem here.
// Make browser back arrow undo link (will this cause tiles to reload (note
//     panel to disapear?)

// NOTE:
// - !!!!!!!!!!!!!!!!!!!!!! Copy note needs to change ids in html !!!!!!!!!!!!!!!
// -I Could not highlight hyperlink when note is selected.
//     Text cannot be selected when hidden.  I would have to select the
//     text when Text tabe is clicked.....
// -Hyperlink selection background color (and color) should not be saved in
//     the note / database.

// ==============================================================================

(function () {
  'use strict';

    // TODO: put this class in its own file.
    // Links that open a separate window use this.
    // It has a gui to choose the window location and will reposition other
    // windows so they do not overlap.  Modeling after MS Windows snap
    // assist.

  function WindowManager () {
    var self = this;

    this.Windows = new Array(3);
    this.Windows[0] = new Array(3);
    this.Windows[1] = new Array(3);
    this.Windows[2] = new Array(3);

        // A model of the screen
    this.ScreenRectangle = $('<div>')
            .appendTo('body')
            .css({'position': 'absolute',
              'background': '#06F',
              'opacity': '0.5',
              'z-index': '100'})
            .hide();
        // hack to get dotted lines
    this.HorizontalLine = $('<div>')
            .appendTo(this.ScreenRectangle)
            .css({'position': 'absolute',
              'left': '0px',
              'width': '100%',
              'top': '50%',
              'height': '1px',
              'background': '#FFF',
              'opacity': '0.4'});
    this.VerticalLine = $('<div>')
            .appendTo(this.ScreenRectangle)
            .css({'position': 'absolute',
              'top': '0px',
              'height': '100%',
              'left': '50%',
              'width': '1px',
              'background': '#FFF',
              'opacity': '0.4'});
        // Feedback of where the window will be created
    this.WindowRectangle = $('<div>')
            .appendTo(this.ScreenRectangle)
            .css({'position': 'absolute',
              'box-sizing': 'border-box',
              'background': '#AAA',
              'border': '1px solid #FFF',
              'opacity': '0.7'});

        // Hiding does not get rid of the bound events.
    this.ScreenRectangle
            .bind('mousemove',
                  function (e) { self.HandleMouseMove(e); });
    this.ScreenRectangle
            .bind('mouseup',
                  function (e) { self.HandleMouseUp(e); });
    this.ScreenRectangle
            .bind('mouseleave',
                  function (e) { self.HandleMouseLeave(e); });

    $(window).bind('beforeunload', function () {
      for (var x = 0; x < 3; ++x) {
        for (var y = 0; y < 3; ++y) {
          var w = self.Windows[x][y];
          if (w && !w.closed) {
            w.close();
          }
        }
      }
    });
  }

    // mX,my is the mouse location.  The center of the GUI object will be
    // placed there.
  WindowManager.prototype.Show = function (mx, my, url, title) {
    this.Title = title || 'SlideAtlas';
    this.Url = url;

    this.AvailableLeft = screen.availLeft || 0;
    this.AvailableTop = screen.availTop || 0;
    this.AvailableWidth = screen.availWidth || screen.width || 1000;
    this.AvailableHeight = screen.availHeight || screen.height || 800;

    var w = this.AvailableWidth / 10;
    var h = this.AvailableHeight / 10;
    var x = mx - (w / 2);
    var y = my - (h / 2);
    if (x < 0) { x = 0; }
    if (y < 0) { y = 0; }

    this.Partition = [1, 1];
    this.WindowRectangle
            .css({'left': '3%',
              'top': '3%',
              'width': '94%',
              'height': '94%'});

    this.ScreenRectangle
            .css({'left': x + 'px',
              'top': y + 'px',
              'width': w + 'px',
              'height': h + 'px'})
            .show();
  };

  WindowManager.prototype.HandleMouseLeave = function (event) {
    this.ScreenRectangle.hide();
  };

  WindowManager.prototype.HandleMouseUp = function (event) {
    var xIdx = this.Partition[0];
    var yIdx = this.Partition[1];
    var w = this.Windows[xIdx][yIdx];
    if (w && !w.closed) {
      w.location.href = this.Url;
            // change the title
      w.document.title = this.Title;
      return;
    }

    var x = this.AvailableLeft;
    var y = this.AvailableTop;
    w = this.AvailableWidth;
    var h = this.AvailableHeight;

    if (xIdx !== 1) {
      w = w / 2;
    }
    if (yIdx !== 1) {
      h = h / 2;
    }
    if (xIdx === 2) {
      x = x + w;
    }
    if (yIdx === 2) {
      y = y + h;
    }
        // inner vs outer?
    w = w - 27;
    h = h - 100;
        // Two windows cannot have the same title.
    var title = this.Title + ' ' + xIdx + ' ' + yIdx;
    this.Windows[this.Partition[0]][this.Partition[1]] =
            window.open(this.Url, title,
                        'alwaysRaised=yes,titlebar=no,menubar=no,toolbar=no,dependent=yes,left=' + x + ',top=' + y + ',width=' + w + ',height=' + h);
    this.ScreenRectangle.hide();
  };

  WindowManager.prototype.HandleMouseMove = function (event) {
    var w = this.ScreenRectangle.width();
    var h = this.ScreenRectangle.height();
    var x = event.offsetX;
    var y = event.offsetY;

        // offsetX is relative to the source div which can be the
        // WindowRectangle. Change it to be relative to the
        // ScreenRectangle.
    var src = $(event.originalEvent.srcElement);
    while (src[0] !== this.ScreenRectangle[0]) {
      var pos = src.position();
      x += pos.left;
      y += pos.top;
      src = src.parent();
      if (!src) {
        return;
      }
    }

    if (x < w / 3) {
      this.Partition[0] = 0;
      this.WindowRectangle
                .css({'left': '3%',
                  'width': '44%'});
    } else if (x > 2 * w / 3) {
      this.Partition[0] = 2;
      this.WindowRectangle
                .css({'left': '53%',
                  'width': '44%'});
    } else {
      this.Partition[0] = 1;
      this.WindowRectangle
                .css({'left': '3%',
                  'width': '94%'});
    }
    if (y < h / 3) {
      this.Partition[1] = 0;
      this.WindowRectangle
                .css({'top': '3%',
                  'height': '44%'});
    } else if (y > 2 * h / 3) {
      this.Partition[1] = 2;
      this.WindowRectangle
                .css({'top': '53%',
                  'height': '44%'});
    } else {
      this.Partition[1] = 1;
      this.WindowRectangle
                .css({'top': '3%',
                  'height': '94%'});
    }
  };

  SA.WindowManager = WindowManager;
})();

(function () {
  'use strict';

    // TODO: Merge this with the text editor in viewer-utils.
    // Gray out buttons when no text is selected.
    // Remove options to insert link if no text is selected.

  function TextEditor (parent, display) {
    this.Header = $('<div>')
            .appendTo(parent)
            .css({'width': '100%'});

    this.Body = $('<div>')
            .appendTo(parent)
            .css({'width': '100%',
              'position': 'absolute',
              'top': '90px',
              'bottom': '0px'});

        // Add a call back to have the text editor fill available verticle space.
    var self = this;
    this.Header.saOnResize(
            function () {
              var top = self.Header.height();
              if (top === 0) {
                    // Hack because height not set yet.
                setTimeout(function () { self.Header[0].onresize(); }, 250);
                return;
              }
              self.Body.css({'top': top + 'px'});
            });

    this.Display = display;
    this.Parent = parent;
        // I do not want the text editable until the note is set.
    this.Editable = true;
    this.Edit = true;
        // The user can set this to save the note automatically.
    this.ChangeCallback = null;

    this.EditButtons = [];
    this.AddEditButton(SA.ImagePathUrl + 'camera.png', 'link view',
                           function () { self.InsertCameraLink(); });
    this.AddEditButton(SA.ImagePathUrl + 'link.png', 'link URL',
                           function () { self.InsertUrlLink(); });
    this.AddEditButton(SA.ImagePathUrl + 'font_bold.png', 'bold',
                           function () { document.execCommand('bold', false, null); });
    this.AddEditButton(SA.ImagePathUrl + 'text_italic.png', 'italic',
                           function () { document.execCommand('italic', false, null); });
    this.AddEditButton(SA.ImagePathUrl + 'edit_underline.png', 'underline',
                           function () { document.execCommand('underline', false, null); });
    this.AddEditButton(SA.ImagePathUrl + 'list_bullets.png', 'unorded list',
                           function () { document.execCommand('InsertUnorderedList', false, null); });
    this.AddEditButton(SA.ImagePathUrl + 'list_numbers.png', 'ordered list',
                           function () { document.execCommand('InsertOrderedList', false, null); });
    this.AddEditButton(SA.ImagePathUrl + 'indent_increase.png', 'indent',
                           function () { document.execCommand('indent', false, null); });
    this.AddEditButton(SA.ImagePathUrl + 'indent_decrease.png', 'outdent',
                           function () { document.execCommand('outdent', false, null); });
    this.AddEditButton(SA.ImagePathUrl + 'alignment_left.png', 'align left',
                           function () { document.execCommand('justifyLeft', false, null); });
    this.AddEditButton(SA.ImagePathUrl + 'alignment_center.png', 'align center',
                           function () { document.execCommand('justifyCenter', false, null); });
    this.AddEditButton(SA.ImagePathUrl + 'edit_superscript.png', 'superscript',
                           function () { document.execCommand('superscript', false, null); });
    this.AddEditButton(SA.ImagePathUrl + 'edit_subscript.png', 'subscript',
                           function () { document.execCommand('subscript', false, null); });
    this.AddEditButton(SA.ImagePathUrl + 'font_increase.png', 'large font',
                           function () {
                             document.execCommand('fontSize', false, '5');
                             self.ChangeBulletSize('1.5em');
                           });
    this.AddEditButton(SA.ImagePathUrl + 'font_decrease.png', 'small font',
                           function () {
                             document.execCommand('fontSize', false, '2');
                             self.ChangeBulletSize('0.9em');
                           });

    this.AddEditButton(SA.ImagePathUrl + 'question.png', 'add question',
                           function () {
                             self.AddQuestion();
                           });

    this.InitializeHomeButton(this.Header);

    this.TextEntry = $('<div>')
            .appendTo(this.Body)
            .attr('contenteditable', 'true')
            .removeAttr('readonly')
            .css({'box-sizing': 'border-box',
              'width': '100%',
              'height': '100%',
              'overflow': 'auto',
              'resize': 'none',
              'border-style': 'inset',
              'font-size': '10pt',
              'font-family': 'Century Gothic',
              'background': '#f5f8ff'})
            .bind('input', function () {
                // Leave events are not triggering.
              self.EventuallyUpdate();
            })
            .focusin(function () {
              SA.ContentEditableHasFocus = true;
            })
            .focusout(function () {
              SA.ContentEditableHasFocus = false;
              self.Update();
            })
        // Mouse leave events are not triggering.
            .mouseleave(function () { // back button does not cause loss of focus.
              self.Update();
            });

    this.UpdateTimer = null;
        // this.RecordViewTimer = null;

        // Do not enable editing until the Note is set.
    this.EditOff();
    this.Note = null;
  }

  TextEditor.prototype.HomeCallback = function () {
    if (!this.Note) {
      return;
    }
    SA.SetNote(this.Note);
  };

    // Home button is a link.  The link menu is used for other links too.
  TextEditor.prototype.InitializeHomeButton = function (parent) {
    var self = this;
    this.HomeButton = $('<div>')
            .appendTo(parent)
            .text('Home')
            .css({'text-align': 'center',
              'border': '1px solid #666666',
              'border-radius': '10px',
              'margin': '2px',
              'color': '#29C',
              'background': 'white'})
            .hover(function () { $(this).css('color', 'blue'); },
                   function () { $(this).css('color', '#29C'); });
    this.HomeButton.contextmenu(function () { return false; });
    this.HomeButton.mousedown(function (e) {
      if (e.button === 0) {
        self.HomeCallback();
        return false;
      }
      if (e.button === 2) {
        self.LinkMenuObject = {Link: self.HomeButton,
          Note: self.Note};
                // Position and show the properties menu.
        var pos = $(this).position();
                // Cannot delete the root note.
        self.DeleteLinkButton.hide();
        self.LinkMenu
                    .css({'left': (25 + pos.left) + 'px',
                      'top': (pos.top) + 'px'})
                    .show();
        return false;
      }
      return true;
    });

        // When a link is right clicked, the object {Link: ..., Note: ...} is set and the
        // menu is made visible.
    this.LinkMenuObject = undefined;
    this.LinkMenu = $('<div>')
            .appendTo(parent)
            .hide()
            .mouseleave(function () { $(this).hide(); })
            .css({'position': 'absolute',
              'background-color': '#FFFFFF',
              'border': '1px solid #666666',
              'box-sizing': 'border-box',
              'left': '-78px',
              'width': '100px',
              'padding': '0px 2px'});
    $('<button>')
            .appendTo(this.LinkMenu)
            .text('Save View')
            .css({'margin': '2px 0px',
              'width': '100%'})
            .prop('title', 'Replace Annotation')
            .click(
                function () {
                  self.SaveLink(self.LinkMenuObject.Link,
                                  self.LinkMenuObject.Note);
                  self.LinkMenu.hide();
                });
    this.DeleteLinkButton = $('<button>')
            .appendTo(this.LinkMenu)
            .text('Delete')
            .css({'margin': '2px 0px',
              'width': '100%'})
            .click(
                function () {
                  self.DeleteLink(self.LinkMenuObject.Link,
                                    self.LinkMenuObject.Note);
                  self.LinkMenu.hide();
                });
  };

  TextEditor.prototype.StartWindowManagerTimer = function (linkNote, x, y) {
        // I think motion is a better trigger for the window manager.
    this.WindowManagerX = x;
    this.WindowManagerY = y;
        // hint for mouse up (text editor handles the event).
    this.LinkWindowLocation = 0;
        // Start a timer.
    var self = this;
    this.WindowManagerTimer = setTimeout(function () {
      self.WindowManagerTimer = undefined;
      self.ShowWindowManager(linkNote, x, y);
    }, 1000);
  };

  TextEditor.prototype.ShowWindowManager = function (linkNote, x, y) {
    if (this.WindowMangerTimer) {
      clearTimeout(this.WindowManagerTimer);
      this.WindowManagerTimer = undefined;
    }
    if (!SA.windowManager) {
      SA.windowManager = new SA.WindowManager();
    }
    SA.windowManager.Show(x, y,
                              '/webgl-viewer?view=' + linkNote.Id,
                              linkNote.Title);
        // Hack to keep mouse up from loading the note.
    this.LinkWindowLocation = 1;
  };

    // Every time the "Text" is loaded, they hyper links have to be setup.
    // TODO: Do we need to turn off editable?
  TextEditor.prototype.FormatLink = function (linkNote) {
    var self = this;
    var link = document.getElementById(linkNote.Id);
    if (link) {
      $(link)
                .css({'color': '#29C',
                  'background': 'white'})
                .hover(function () { $(this).css('color', 'blue'); },
                       function () { $(this).css('color', '#29C'); })
                .attr('contenteditable', 'false');

      $(link).contextmenu(function () { return false; });
      $(link).mousedown(function (e) {
        if (e.button === 0) {
          self.StartWindowManagerTimer(linkNote, e.pageX, e.pageY);
          return false;
        }
        if (e.button === 2) {
          self.LinkMenuObject = {Link: $(link),
            Note: linkNote};
                    // Position and show the properties menu.
          var pos = $(this).position();
          self.DeleteLinkButton.show();
          self.LinkMenu
                        .css({'left': (25 + pos.left) + 'px',
                          'top': (pos.top) + 'px'})
                        .show();
          return false;
        }
        return true;
      });
      $(link).mousemove(function (e) {
        if (e.which === 1) {
          var dx = e.pageX - self.WindowManagerX;
          var dy = e.pageY - self.WindowManagerY;
          if (Math.abs(dx) + Math.abs(dy) > 5) {
            self.ShowWindowManager(linkNote, e.pageX, e.pageY);
          }
        }
      });

      $(link).mouseup(function (e) {
        if (e.button === 0) {
          if (self.WindowManagerTimer) {
            clearTimeout(self.WindowManagerTimer);
            self.WindowManagerTimer = undefined;
          }
          if (self.LinkWindowLocation === 0) {
            SA.SetNote(linkNote);
            return false;
          }
        }
        return true;
      });
    }
  };

  TextEditor.prototype.SaveLink = function (link, note) {
    note.RecordView(this.Display);
    note.Save();
  };

  TextEditor.prototype.DeleteLink = function (link, note) {
        // TODO: Keep the old text.
    var text = link.text();
    $(document.createTextNode(text)).insertAfter(link);
    link.remove();
    note.DeleteCallback();
    this.UpdateNote();
    this.Note.Save();
  };

  TextEditor.prototype.Change = function (callback) {
    this.ChangeCallback = callback;
  };

  TextEditor.prototype.EventuallyUpdate = function () {
    if (this.UpdateTimer) {
      clearTimeout(this.UpdateTimer);
      this.UpdateTimer = null;
    }
    var self = this;
    this.UpdateTimer = setTimeout(function () { self.UpdateNote(); }, 5000);
  };

  TextEditor.prototype.Update = function () {
    if (this.UpdateTimer) {
      clearTimeout(this.UpdateTimer);
      this.UpdateTimer = null;
    } else {
            // I am using the timer as a modified flag.
            // Call update note to force an update.
      return;
    }
    this.UpdateNote();
  };

  TextEditor.prototype.EditOff = function () {
    if (!this.Edit) { return; }
    this.Edit = false;

    for (var i = 0; i < this.EditButtons.length; ++i) {
      this.EditButtons[i].hide();
    }

    this.TextEntry
            .attr('contenteditable', 'false')
            .attr('spellcheck', 'false')
            .css({'border-style': 'outset',
              'background': '#ffffff'})
            .unbind('input')
            .unbind('focusin')
            .unbind('focusout')
            .unbind('mouseleave')
            .blur();
  };

  TextEditor.prototype.EditableOff = function () {
    this.EditOff();
    this.Editable = false;
  };

  TextEditor.prototype.EditOn = function () {
    var self = this;
    if (!this.Editable) { return; }
    if (this.Edit) { return; }
    this.Edit = true;

    for (var i = 0; i < this.EditButtons.length; ++i) {
      this.EditButtons[i].show();
    }

    this.TextEntry
            .attr('contenteditable', 'true')
            .removeAttr('readonly')
            .css({'border-style': 'inset',
              'background': '#f5f8ff'})
            .bind('input', function () {
              self.Modified = true;
              self.EventuallyUpdate();
            })
            .focusin(function () {
              SA.ContentEditableHasFocus = true;
            })
            .focusout(function () {
              SA.ContentEditableHasFocus = false;
              self.Update();
            })
            .mouseleave(function () { // back button does not cause loss of focus.
              self.Update();
            });
  };

  TextEditor.prototype.AddEditButton = function (src, tooltip, callback) {
    var button = $('<img>');
    if (tooltip) {
            // button = $('<img title="'+tooltip+'">')
      button.prop('title', tooltip);
    }
    button
      .appendTo(this.Header)
      .addClass('editButton')
      .attr('src', src)
      .click(callback);
    this.EditButtons.push(button);
  };

  TextEditor.prototype.AddQuestion = function () {
    var bar = $('<div>')
            .css({'position': 'relative',
              'margin': '3%',
              'width': '90%',
              'background': '#FFF',
              'border': '1px solid #AAA',
              'padding': '1% 1% 1% 1%'}) // top right bottom left
            .attr('contenteditable', 'false')
            .saQuestion({editable: SA.Edit,
              position: 'static'});

        // Need to get the range here because the dialog changes it.
    var self = this;
    var range = SA.GetSelectionRange(this.TextEntry);
        // Try to initialize the dialog with the contents of the range.
    if (!range.collapsed) {
      var clone = range.cloneContents();
      bar.saQuestion('SetQuestionText', clone.firstChild.textContent);
      if (clone.childElementCount > 1) {
                // var answers = clone.querySelectorAll('li');
        var answers = [];
        var first = 0;
        var li = clone.querySelector('li');
        if (li) {
                    // Answers are in a list.
          answers = li.parentElement;
        } else if (clone.childElementCount > 2) {
          answers = clone;
          first = 1;
        } else {
          answers = clone.children[1];
        }
        for (var i = first; i < answers.childElementCount; ++i) {
          var answer = answers.children[i];
          var bold = (answer.style.fontWeight === 'bold') ||
                        ($(answer).find('b').length > 0);
          bar.saQuestion('AddAnswerText',
                                   answer.textContent,
                                   bold);
        }
      }
    }

    bar.saQuestion('OpenDialog',
                       function () {
                         if (range) {
                           range.deleteContents();
                           range.insertNode(document.createElement('br'));
                         } else {
                           range = SA.MakeSelectionRange(self.TextEntry);
                         }
                         range.insertNode(bar[0]);
                           // Some gymnasitcs to keep the cursor after the question.
                         range.collapse(false);
                         var sel = window.getSelection();
                         sel.removeAllRanges();
                         sel.addRange(range);
                         self.TextEntry[0].focus();
                         self.UpdateNote();
                       });
  };

    // execCommand fontSize does change bullet size.
    // This is a work around.
  TextEditor.prototype.ChangeBulletSize = function (sizeString) {
    // This call will clear the selected text if it is not in this editor.
    var range = SA.GetSelectionRange(this.TextEntry);
    range = range || SA.MakeSelectionRange(this.TextEntry);
    var listItems = $('li');
    for (var i = 0; i < listItems.length; ++i) {
      var item = listItems[i];
      if (range.isPointInRange(item, 0) ||
                range.isPointInRange(item, 1)) {
        $(item).css({'font-size': sizeString});
      }
    }
  };

  TextEditor.prototype.InsertUrlLink = function () {
    var self = this;
    var sel = window.getSelection();
        // This call will clear the selected text if it is not in this editor.
    var range = SA.GetSelectionRange(this.TextEntry);
    var selectedText = sel.toString();

    if (!this.UrlDialog) {
      var dialog = new SAM.Dialog(function () {
        self.InsertUrlLinkAccept();
      });
      dialog.Body.css({'margin': '1em 2em'});
      this.UrlDialog = dialog;
      dialog.Dialog.css({'width': '40em'});
      dialog.Title.text('Paste URL link');
      dialog.TextDiv =
                $('<div>')
                .appendTo(dialog.Body)
                .css({'display': 'table-row',
                  'width': '100%'});
      dialog.TextLabel =
                $('<div>')
                .appendTo(dialog.TextDiv)
                .text('Text to display:')
                .css({'display': 'table-cell',
                  'height': '2em',
                  'text-align': 'left'});
      dialog.TextInput =
                $('<input>')
                .appendTo(dialog.TextDiv)
                .val('#30ff00')
                .css({'display': 'table-cell',
                  'width': '25em'});

      dialog.UrlDiv =
                $('<div>')
                .appendTo(dialog.Body)
                .css({'display': 'table-row'});
      dialog.UrlLabel =
                $('<div>')
                .appendTo(dialog.UrlDiv)
                .text('URL link:')
                .css({'display': 'table-cell',
                  'text-align': 'left'});
      dialog.UrlInput =
                $('<input>')
                .appendTo(dialog.UrlDiv)
                .val('#30ff00')
                .css({'display': 'table-cell',
                  'width': '25em'})
                .bind('input', function () {
                  var url = self.UrlDialog.UrlInput.val();
                  if (self.UrlDialog.LastUrl === self.UrlDialog.TextInput.val()) {
                        // The text is same as the URL. Keep them synchronized.
                    self.UrlDialog.TextInput.val(url);
                  }
                  self.UrlDialog.LastUrl = url;
                    // Deactivate the apply button if the url is blank.
                  if (url === '') {
                    self.UrlDialog.ApplyButton.attr('disabled', true);
                  } else {
                    self.UrlDialog.ApplyButton.attr('disabled', false);
                  }
                });
    }

        // We have to save the range/selection because user interaction with
        // the dialog clears the text entry selection.
    this.UrlDialog.SelectionRange = range;
    this.UrlDialog.TextInput.val(selectedText);
    this.UrlDialog.UrlInput.val('');
    this.UrlDialog.LastUrl = '';
    this.UrlDialog.ApplyButton.attr('disabled', true);
    this.UrlDialog.Show(true);
  };

  TextEditor.prototype.InsertUrlLinkAccept = function () {
    var sel = window.getSelection();
    var range = this.UrlDialog.SelectionRange;
    range = range || SA.MakeSelectionRange(this.TextEntry);

        // Simply put a span tag around the text with the id of the view.
        // It will be formated by the note hyperlink code.
    var link = document.createElement('a');
    link.href = this.UrlDialog.UrlInput.val();
    link.target = '_blank';

        // Replace or insert the text.
    if (!range.collapsed) {
            // Remove the seelcted text.
      range.extractContents(); // deleteContents(); // cloneContents
      range.collapse(true);
    }
    var linkText = this.UrlDialog.TextInput.val();
    if (linkText === '') {
      linkText = this.UrlDialog.UrlInput.val();
    }
    link.appendChild(document.createTextNode(linkText));

    range.insertNode(link);
    if (range.noCursor) {
      // Leave the selection the same as we found it.
      // Ready for the next link.
      sel.removeAllRanges();
    }
    this.UpdateNote();
  };

  // TODO: Untangle view links from the note.
  TextEditor.prototype.InsertCameraLink = function () {
        // Create a child note.
    var parentNote = this.Note;
    if (!parentNote) {
      parentNote = SA.display.GetRootNote();
    }

    // TODO: I think an icon as a default view link would look nicer.
    var text = '(view)';
    // Create a new note to hold the view.
    // Put the new note at the end of the list.
    var childIdx = parentNote.Children.length;
    // var childIdx = 0; // begining
    var childNote = parentNote.NewChild(childIdx, text);
    // Setup and save
    childNote.RecordView(this.Display);
    // Block subnotes and separate text.
    childNote.Type = 'View';

    var range = SA.GetSelectionRange(this.TextEntry);
    if (!range) {
      range = SA.MakeSelectionRange(this.TextEntry);
    } else if (!range.collapsed) {
      text = range.toString();
    }
    childNote.Title = text;
    range.deleteContents();

    // Simply put a span tag around the text with the id of the view.
    // It will be formated by the note hyperlink code.
    var span = document.createElement('span');
        // This id identifies the span as a hyperlink to this note.
        // The note will format the link and add callbacks later.
    span.id = childNote.Id;
    $(span).attr('contenteditable', 'false');
    span.appendChild(document.createTextNode(text));
    range.insertNode(span);
        // Let the note format it.
    this.FormatLink(childNote);

        // Some gymnasitcs to keep the cursor after the question.
    range.collapse(false);
    var sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
    this.TextEntry[0].focus();
        // NOTE: This may not be necesary no that text note "views" are
        // issolated from notes in views tab.
    this.UpdateNote();

    this.Note.Save();
        // Need this because the save button was overwriting the root note
        // view when a camera link was just inserted.
    SA.SetNote(childNote);
  };

  TextEditor.prototype.Resize = function (width, height) {
    var pos;
    pos = this.TextEntry.offset();
    this.TextEntry.height(height - pos.top - 5);
  };

    // No one seems to call this.
  TextEditor.prototype.SetHtml = function (html) {
    console.log("Something called 'TextEditor::SetHtml'");
    if (this.UpdateTimer) {
      clearTimeout(this.UpdateTimer);
      this.Update();
    }
    this.Note = null; // ??? Editing without a note
    this.EditOn();
    this.TextEntry.html(html);

    if (SA.Edit) {
      var items = this.TextEntry.find('.sa-question');
      items.saQuestion({editable: true,
        position: 'static'});
    }

        // Note needed here long term.
        // this looks for keywords in text and makes tags.
    SA.AddHtmlTags(this.TextEntry);
  };

  TextEditor.prototype.GetHtml = function () {
    return this.TextEntry.html();
  };

    // TODO: Editor should not become active until it has a note.
    // This probably belongs in a subclass.
    // Or in the note.
  TextEditor.prototype.LoadNote = function (note) {
    if (this.UpdateTimer) {
      clearTimeout(this.UpdateTimer);
      this.Update();
    }
    this.Note = note;

        // Make the home button highlight like the view links.
    this.HomeButton[0].id = note.Id;
        // .....$('#'+note.Id).css({'background':'#e0e0ff'});

    this.TextEntry.html(note.Text);
        // Note needed here long term.
        // this looks for keywords in text and makes tags.
    SA.AddHtmlTags(this.TextEntry);

    this.UpdateMode(note.Mode);

        // TODO: Hide this.  Maybe use saHtml.
    if (SA.Edit) {
      var items = this.TextEntry.find('.sa-question');
      items.saQuestion({editable: true,
        position: 'static'});
    }

        // TODO: Make the hyper link the same pattern as questions.
    for (var i = 0; i < note.Children.length; ++i) {
            // In the future we can only call this on type "View"
      this.FormatLink(note.Children[i]);
    }

    this.MakeLinksClickable();
    if (SA.Edit) {
      this.EditOn();
    }
        // Bug fix: Next slide button was not showing text because it's
        // the editor's height was 0.
    this.TextEntry.trigger('resize');
  };

    // This gets called when the note's mode changes.
  TextEditor.prototype.UpdateMode = function (mode) {
    if (mode === 'answer-show' && this.Note && this.Note.Title) {
      this.HomeButton.text(this.Note.Title);
    } else {
      this.HomeButton.text('Home');
    }

        // TODO: change this to apply only to the textEntry window.
    if (mode === 'answer-show') {
      $('.sa-note').show();
      $('.sa-notes').show();
      $('.sa-diagnosis').show();
      $('.sa-differential-diagnosis').show();
      $('.sa-teaching-points').show();
      $('.sa-compare').show();
      $('.sa-question').saQuestion('SetMode', mode);
    } else if (mode === 'answer-hide' || mode === 'answer-interactive') {
      $('.sa-note').hide();
      $('.sa-notes').hide();
      $('.sa-diagnosis').hide();
      $('.sa-differential-diagnosis').hide();
      $('.sa-teaching-points').hide();
      $('.sa-compare').hide();
      $('.sa-question').saQuestion('SetMode', mode);
    }
  };

    // Copy the text entry text back into the note
    // (when the textEntry changes).
    // It saves the note too.
  TextEditor.prototype.UpdateNote = function () {
    this.UpdateTimer = null;
    if (!this.Note) {
      return;
    }
    this.Note.Text = this.TextEntry.html();
    if (this.ChangeCallback) {
      (this.ChangeCallback)();
    }

    this.MakeLinksClickable();
  };

    // Link are not active in content editable divs.
    // Work around this.
  TextEditor.prototype.MakeLinksClickable = function () {
    if (SA.Edit) {
            // This is only necesary when div is editable.
            // Links work the same in both situations with this.
      var links = $('a');
      for (var i = 0; i < links.length; ++i) {
        var link = links[i];
        $(link)
                    .click(function () {
                      window.open(this.href, '_blank');
                    });
      }
    }
  };

  SA.TextEditor = TextEditor;
})();

    // ==============================================================================

(function () {
  'use strict';

  function NotesWidget (parent, display) {
    this.ModifiedCallback = null;
    // This is a hack.  I do not know when to save the camera.
    // The save button will save the camera for the last note displayed.
    // This may be different that the selected note because of camera links
    // in text that do not change the text.
    this.DisplayedNote = null;

    // Popup div to display permalink.
    SA.LinkDiv =
            $('<div>')
            .appendTo('body')
            .css({'top': '30px',
              'left': '10%',
              'position': 'absolute',
              'width': '80%',
              'height': '50px',
              'z-index': '3',
              'background-color': '#FFF',
              'border': '1px solid #777',
              'border-radius': '8px',
              'text-align': 'center',
              'padding-top': '26px'})
            .hide()
            .mouseleave(function () { SA.LinkDiv.fadeOut(); });

    // There is not option to show the link when SA.Edit is not on,
    // so this really does nothing.  Editable is probably necessary
    // for selection to copy.
    if (SA.Edit) {
      SA.LinkDiv.attr('contenteditable', 'true');
    }

    var self = this;
    this.Display = display;

    this.Modified = false;
    this.Window = $('<div>')
            .appendTo(parent)
            .css({
              'background-color': 'white',
              'position': 'absolute',
              'top': '0%',
              'left': '0%',
              'height': '100%',
              'width': '100%',
              'z-index': '2'})
            .attr('draggable', 'false')
            .on('dragstart', function () { return false; })
            .attr('id', 'NoteWindow');

    // --------------------------------------------------------------------------

    // GUI elements
    this.TabbedWindow = new SA.TabbedDiv(this.Window);
    this.TextDiv = this.TabbedWindow.NewTabDiv('Text');

    this.UserTextDiv = this.TabbedWindow.NewTabDiv('Notes', 'private notes');
    this.LinksDiv = this.TabbedWindow.NewTabDiv('Views');
    this.LinksRoot = $('<ul>')
            .addClass('sa-ul')
            .css({'padding-left': '0px'})
            .appendTo(this.LinksDiv);

    // for (var i = 0; i < this.Display.GetNumberOfViewers(); ++i) {
    //    this.Display.GetViewer(i).OnInteraction(function (){self.RecordView();});
    // }

    this.LinksDiv
            .css({'overflow': 'auto',
              'text-align': 'left',
              'color': '#303030',
              'font-size': '18px'})
            .attr('id', 'NoteTree');

    // no longer needed, but interesting: 'box-sizing': 'border-box'

    // This is the button for the links tab div.
    if (SA.Edit) {
      this.AddViewButton = $('<button>')
                .appendTo(this.LinksDiv)
                .css({'border-radius': '4px',
                  'margin': '1em'})
                .text('+ New View');
    }

    // Show hidden content to non administrator.
    // Do not show this unless not is interactive.
    this.QuizButton = $('<div>')
            .appendTo(this.TextDiv)
            .addClass('editButton')
            .css({'float': 'right',
              'font-size': 'small',
              'margin-top': '4px',
              'padding-left': '2px',
              'padding-right': '2px',
              'border': '1px solid #AAA',
              'border-radius': '2px'})
            .text('show')
            .hide();

    // Now for the text tab:
    if (SA.Edit) {
            // TODO: Encapsulate this menu (used more than once)
      this.QuizDiv = $('<div>')
                .appendTo(this.TextDiv);
      this.QuizMenu = $('<select name="quiz" id="quiz">')
                .appendTo(this.QuizDiv)
                .css({'float': 'right',
                  'margin': '3px'})
                .change(function () {
                  if (!self.RootNote) { return; }
                  if (this.value === 'review') {
                    self.RootNote.Mode = 'answer-show';
                  } else if (this.value === 'hidden') {
                    self.RootNote.Mode = 'answer-hide';
                  } else if (this.value === 'interactive') {
                    self.RootNote.Mode = 'answer-interactive';
                  }
                  self.UpdateQuestionMode();
                });
      this.QuizLabel = $('<div>')
                .appendTo(this.TextDiv)
                .css({'float': 'right',
                  'font-size': 'small',
                  'margin-top': '4px'})
                .text('quiz');
      $('<option>')
                .appendTo(this.QuizMenu)
                .text('review');
      $('<option>')
                .appendTo(this.QuizMenu)
                .text('hidden');
      $('<option>')
                .appendTo(this.QuizMenu)
                .text('interactive');
            // Set the question mode
      this.QuizMenu.val('review');
    }

    this.TextEditor = new SA.TextEditor(this.TextDiv, this.Display);

    if (!SA.Edit) {
      this.TextEditor.EditableOff();
    } else {
      this.TextEditor.Change(
                function () {
                  self.MarkAsModified();
                });
    }
        // Private notes.
    this.UserTextEditor = new SA.TextEditor(this.UserTextDiv, this.Display);

    this.UserTextEditor.Change(
            function () {
              self.UserTextEditor.Note.Save();
            });
  }

  // TODO: THese methods do not belong in this class.
  // Trying to save user notes quietly.
  // Sort of hackish.
  NotesWidget.prototype.EventuallySaveUserNote = function () {
    if (this.UserNoteTimerId) {
      clearTimeout(this.UserNoteTimerId);
    }
    var self = this;
    this.UserNoteTimerId = setTimeout(function () {
      self.SaveUserNote();
    }, 2000);
  };
  NotesWidget.prototype.Flush = function () {
    if (this.UserNoteTimerId) {
      clearTimeout(this.UserNoteTimerId);
      this.UserNoteTimerId = false;
      this.SaveUserNote();
    }
  };
  // Hackish.
  NotesWidget.prototype.SaveUserNote = function () {
    this.UserNoteTimerId = false;
    var note = SA.notesWidget.GetCurrentNote();
    if (!note || note.ViewerRecords.length === 0) {
      return;
    }
    var userNote = note.ViewerRecords[note.StartIndex].UserNote;

    // TODO: Fix this hack.
    // Make a method in display to record, the save them all.
    if (SA && SA.display) {
      // TODO: Fix: This will not work because previous widgets will
      // be in both widgets, but new widgets will only be in one.
      // I do not want to duplicate widgets in the note.
      // for (var i = 0; i < SA.display,GetNumberOfViewers(); ++i) {
      for (var i = 0; i < 1; ++i) {
        userNote.ViewerRecords[0].CopyAnnotations(SA.display.GetViewer(i), true);
      }
    }

    if (userNote.ViewerRecords[0].Annotations.length > 0 ||
            userNote.LoadState === 2) {
      userNote.Save();
    }
  };

  // Needed so administrators can create usernotes.
  NotesWidget.prototype.IsUserTextTabOpen = function () {
    if (this.TabbedWindow.GetCurrentDiv() === this.UserTextDiv) {
      return true;
    }
    return false;
  };

  NotesWidget.prototype.UpdateQuestionMode = function () {
    // Set the question mode
    if (!this.RootNote) {
      return;
    }

    if (!this.RootNote.Mode) {
      this.RootNote.Mode = 'answer-show';
    }

    if (this.QuizMenu) {
      if (this.RootNote.Mode === 'answer-hide') {
        this.QuizMenu.val('hidden');
      } else if (this.RootNote.Mode === 'answer-interactive') {
        this.QuizMenu.val('interactive');
      } else {
                // this.RootNote.Mode = 'answer-show';
        this.QuizMenu.val('review');
      }
    }
    if (this.RootNote.Mode === 'answer-interactive') {
      var self = this;
      this.QuizButton
                .show()
                .css('background-color', '')
                .click(function () {
                  self.SetAnswerVisibility('answer-show');
                  self.QuizButton.css({'background-color': '#AAAAAA'});
                });
    } else {
      this.QuizButton.hide();
    }

    this.SetAnswerVisibility(this.RootNote.Mode);
  };

  NotesWidget.prototype.SetAnswerVisibility = function (mode) {
        // make sure tags have been decoded.
    SA.AddHtmlTags(this.TextEditor.TextEntry);

    this.TextEditor.UpdateMode(mode);
  };

  NotesWidget.prototype.SetNavigationWidget = function (nav) {
    this.NavigationWidget = nav;
  };

  NotesWidget.prototype.SetModifiedCallback = function (callback) {
    this.ModifiedCallback = callback;
  };

  NotesWidget.prototype.SetModifiedClearCallback = function (callback) {
    this.ModifiedClearCallback = callback;
  };

    // Two types of select.  This one is from the views tab.
    // It sets the text from the note.
    // There has to be another from text links.  That does not set the
    // text.
  NotesWidget.prototype.SetNote = function (note) {
        // NOTE: Even if note === this.SelectedNote we still need to add the
        // user note annotations because display resets the annotations of
        // the view. this user may have changed annotations without
        // changing the note.

    var ancestor = note;
    while (ancestor !== this.RootNote &&
               ancestor.Parent &&
               ancestor.Type !== 'UserNote') {
      ancestor = ancestor.Parent;
    }

        // Check to see if we have to set a new root note.
        // If note is not in the root note's family, set a new root.
        // Avoid decendants of user notes.
    if (ancestor !== this.RootNote && ancestor.Type !== 'UserNote') {
            // This will call SetNote again when root note is set.
      this.SetRootNote(ancestor);
      return;
    }

        // This should method should be split between Note and NotesWidget
        // Make the permalink window fade out if it is visible.
    if (SA.LinkDiv.is(':visible')) { SA.LinkDiv.fadeOut(); }

        // If the note is a view link, use the text of the parent.
    if (ancestor.Type !== 'UserNote') {
      var textNote = note;
      while (textNote && textNote.Type === 'View') {
        textNote = textNote.Parent;
      }
      if (textNote) {
        this.TextEditor.LoadNote(textNote);
      }
    }

    if (note === this.SelectedNote) {
      return;
    }

        // Handle the note that is being unselected.
        // Clear the selected background of the deselected note.
    if (this.SelectedNote) {
      this.SelectedNote.TitleEntry.css({'background': 'white'});
            // Make the old hyper link normal color.
      $('#' + this.SelectedNote.Id).css({'background': 'white'});
    }

    this.SelectedNote = note;

        // Display the user note text.
    this.UpdateUserNotes();

        // Indicate which note is selected in the Views tab
    note.TitleEntry.css({'background': '#f0f0f0'});
        // Probably does nothing.
        // note.SelectHyperlink();

        // Indicate which note / view link is selected in the text.
    $('#' + note.Id).css({'background': '#e0e0ff'});
  };

  NotesWidget.prototype.MarkAsModified = function () {
    if (this.ModifiedCallback) {
      this.ModifiedCallback();
    }
    this.Modified = true;
  };

  NotesWidget.prototype.MarkAsNotModified = function () {
    if (this.ModifiedClearCallback) {
      this.ModifiedClearCallback();
    }
    this.Modified = false;
  };

  NotesWidget.prototype.SetRootNote = function (rootNote) {
    if (this.UpdateTimer) {
      clearTimeout(this.UpdateTimer);
      this.Update();
    }
        // this.Display.SetNote();

    this.RootNote = rootNote;
    this.DisplayRootNote();

    this.UpdateQuestionMode();
  };

    // TODO:
    // Hmmmm.  I do not think this is used yet.
    // SA.SaveButton setup should not be here though.
  NotesWidget.prototype.EditOn = function () {
    SA.SaveButton
            .prop('title', 'save to database')
            .attr('src', SA.ImagePathUrl + 'save22.png')
            .click(function () { self.SaveCallback(); });
    this.AddViewButton.show();
    this.TextEditor.EditOn();
  };

  NotesWidget.prototype.EditOff = function () {
    SA.SaveButton
            .prop('title', 'edit view')
            .attr('src', SA.ImagePathUrl + 'text_edit.png')
            .click(function () { self.EditOn(); });
    this.AddViewButton.hide();
    this.TextEditor.EditOff();

        /*
          .. note camera buttons....
          .. note title entry (content editable.) ....
          .. note remove button ...
          .. link and delete button ...
          .. Stack stuff ...
        */
  };

  NotesWidget.prototype.SaveCallback = function (finishedCallback) {
        // Process containers for diagnosis ....
    SA.AddHtmlTags(this.TextEditor.TextEntry);

    SA.display.RecordAnnotations();

    var note = this.GetCurrentNote();
    if (note) {
            // Lets try saving the camera for the current note.
            // This is a good comprise.  Do not record the camera
            // every time it moves, but do record it when the save button
            // is pressed.  This is ok, now that view links are visibly
            // selected. However, It is still not really obvious what will happen.
      note.RecordView(this.Display);
            // Record view does this too.
            // note.RecordAnnotations(this.Display);
    }

        // Root saves all the children with it.
        // There is always a root note.  Being over cautious.
        // May need to save text of the root note because it is displayed
        // even when view/camera links are the current note.
    if (this.RootNote) {
      note = this.RootNote;
    }
    note.NotesPanelOpen = (SA.resizePanel && SA.resizePanel.Visibility);
    var self = this;
    note.Save(function () {
      self.Modified = false;
      if (finishedCallback) {
        finishedCallback();
      }
    });
  };

    // ------------------------------------------------------------------------------

  NotesWidget.prototype.GetCurrentNote = function () {
    return this.Display.GetNote();
  };

  NotesWidget.prototype.SaveBrownNote = function () {
    // Create a new note.
    var note = new SA.Note();
    note.RecordView(this.Display);

    // This is not used and will probably be taken out of the scheme,
    note.SetParent(this.GetCurrentNote());
  };

    // Randomize the order of the children
  NotesWidget.prototype.RandomCallback = function () {
    var note = this.GetCurrentNote();
    note.Children.sort(function (a, b) { return Math.random() - 0.5; });
    note.UpdateChildrenGUI();
  };

    // Called when a new slide/view is loaded.
  NotesWidget.prototype.DisplayRootNote = function () {
    if (!this.RootNote) { return; }

        // Set the state of the notes widget.
        // Should we ever turn it off?
    if (SA.resizePanel) {
      SA.resizePanel.SetVisibility(this.RootNote.NotesPanelOpen, 0.0);
    }

    this.TextEditor.LoadNote(this.RootNote);
    this.LinksRoot.empty();
    this.RootNote.DisplayGUI(this.LinksRoot);
    this.SetNote(this.RootNote);

        // Add an obvious way to add a link / view to the root note.
    if (SA.Edit) {
      var self = this;
      this.AddViewButton
                .appendTo(this.LinksDiv)
                .click(function () {
                  var parentNote = SA.notesWidget.RootNote;
                  var childIdx = parentNote.Children.length;
                  var childNote = parentNote.NewChild(childIdx, 'New View');
                    // Setup and save
                  childNote.RecordView(self.Display);
                    // We need to save the note to get its Id (for the link div).
                  childNote.Save();
                  parentNote.UpdateChildrenGUI();
                  this.Display.SetNote(childNote);
                    // self.SetNote(childNote);
                });
    }
        // Default to old style when no text exists (for backward compatability).
    if (this.RootNote.Text === '') {
      this.TabbedWindow.ShowTabDiv(this.LinksDiv);
    } else {
      this.TabbedWindow.ShowTabDiv(this.TextDiv);
    }
  };

    // Add a user note to the currently selected notes children.
  NotesWidget.prototype.NewCallback = function () {
    var note = this.GetCurrentNote();
    var childIdx = 0;
    if (note.Parent) {
      var idx = note.Children.indexOf(note);
      if (idx >= 0) {
        childIdx = idx + 1;
        note = note.Parent;
      }
    }
        // Create a new note.
    var childNote = note.NewChild(childIdx, 'New View');
        // Setup and save
    childNote.RecordView(this.Display);
        // childNote.Save();
    note.UpdateChildrenGUI();

    note.Save();
        // this.SetNote(childNote);
    this.Display.SetNote(childNote);
  };

    // TODO: Make sure method names are consistent.  Update shoud be for
    // updating the GUI. Record should be for moving gui changes to notes.
    // Display the user notes text.
    // We have only one text editor so only display the text form the first
    // user note.
  NotesWidget.prototype.UpdateUserNotes = function () {
        // Even if the userNote did not change, we still need to render the annotation.
        // User notes are always editable. Unless it this the demo account.
    if (SA.User !== '' && SA.VIEWER1) {
      this.UserTextEditor.EditOn();
    }

    var note = this.SelectedNote;
    if (note && note.ViewerRecords.length > 0) {
      var userNote = note.ViewerRecords[note.StartIndex].UserNote;

            // Must display the text.
      this.UserTextEditor.LoadNote(userNote);
    }
  };

  SA.NotesWidget = NotesWidget;
})();

// Tabbed gui.

// Closure namespace
(function () {
  var Tabs = [];

    // If a tabbed object is specified, only one tab for the object
    // will be allowed open at a time.
  function Tab (parent, imageSrc, tabID) {
    var self = this; // trick to set methods in callbacks.
    if (!parent) { alert('null parent: tab'); }
    parent = parent || SA.MainDiv;

    this.Div = $('<div>')
            .appendTo(parent)
            .attr('id', tabID)
            .addClass('sa-view-div');

        // Button has to have the border (not the tab) to be covered by Div.
    this.Button = $('<img>')
            .appendTo(this.Div)
            .attr('type', 'image')
            .attr('src', imageSrc)
            .addClass('sa-view-button')
            .on('click touchstart', function () { self.TogglePanel(); })
            .attr('draggable', 'false')
            .on('dragstart', function () {
              return false;
            });

    this.Panel = $('<div>')
            .appendTo(this.Div)
            .hide()
            .addClass('sa-view-panel');

    Tabs.push(this);

        // I need to maintain this state even when the whole tab is not
        // visible.
    this.PanelOpen = false;
  }

  Tab.prototype.show = function () {
    this.Div.show();
  };
  Tab.prototype.hide = function () {
    this.Div.hide();
  };

  Tab.prototype.TogglePanel = function () {
    if (this.PanelOpen) {
      this.PanelOff();
    } else {
      this.PanelOn();
    }
  };

  Tab.prototype.PanelOn = function () {
    if (this.PanelOpen) { return; }
    this.PanelOpen = true;

        // position returns 0 if panel is hidden.
    this.Panel.show();

        // Close tabs that overlap.
    var minX0 = this.Panel.offset().left;
    var maxX0 = minX0 + this.Panel.outerWidth();
    for (var i = 0; i < Tabs.length; ++i) {
      if (Tabs[i] !== this) {
        var minX1 = Tabs[i].Panel.offset().left;
        var maxX1 = minX1 + Tabs[i].Panel.outerWidth();
                // Overlap
        minX1 = Math.max(minX0, minX1);
        maxX1 = Math.min(maxX0, maxX1);
        if (minX1 < maxX1) {
          Tabs[i].PanelOff();
        }
      }
    }

        // Make the tab look like it is part of the panel.
    this.Button.addClass('sa-active');
  };

  Tab.prototype.PanelOff = function () {
    this.PanelOpen = false;
    this.Panel.hide();
    this.Button.removeClass('sa-active');
  };

    // Export the tab object.
  SA.Tab = Tab;
})();

// Annotation widget toggles annotation visibility and also shows the drawing tools.
// Each view will need its own widget.
// I am less happy about this than the right click menu implementation.
// It would be nice to expand the drawing tools on hover, but
// the toggle for annotation visibility naturally suggests
// the same state should show drawing tool palette.

// Todo:
// - Make an object out of it to support two views.
// - Change behavior of text widget to first drag an arrow when created.
// - eliminate polyLine vertices when they are dragged on top of another vertex.
// or maybe the delete key.

(function () {
  'use strict';

  var ANNOTATION_OFF = 0;
  var ANNOTATION_ON = 2;

  function AnnotationWidget (layer, viewer) {
    var self = this; // trick to set methods in callbacks.
    this.Viewer = viewer;
    this.Layer = layer;
    layer.AnnotationWidget = this;

    SAM.detectMobile();
    this.Tab = new SA.Tab(layer.GetParent(),
                       SA.ImagePathUrl + 'pencil3Up.png',
                       'annotationTab');
    this.Tab.Div
        .css({'box-sizing': 'border-box',
          'position': 'absolute',
          'bottom': '0px',
          'right': '110px'});
        // .prop('title', 'Annotation');

    this.Tab.Panel.addClass('sa-view-annotation-panel');
    this.VisibilityDiv = $('<div>')
        .appendTo(this.Tab.Panel)
        .addClass('sa-view-annotation-vis')
        // .prop('title', 'Visibility')
        .on('click touchstart', function () { self.ToggleVisibility(); });
    this.VisibilityImage = $('<img>')
        .appendTo(this.VisibilityDiv)
        .addClass('sa-view-annotation-vis-img')
        .addClass('sa-active')
        .attr('type', 'image')
        .attr('src', SA.ImagePathUrl + 'toggleswitch.jpg');

    this.TextButton = $('<img>')
        .appendTo(this.Tab.Panel)
        .addClass('sa-view-annotation-button sa-flat-button-active')
        .addClass('sa-active')
        .attr('type', 'image')
        .attr('src', SA.ImagePathUrl + 'Text.png')
        // .prop('title', 'Text')
        .on('click touchstart', function () { self.NewText(); });
    this.CircleButton = $('<img>')
        .appendTo(this.Tab.Panel)
        .addClass('sa-view-annotation-button sa-flat-button-active')
        .addClass('sa-active')
        .attr('type', 'image')
        .attr('src', SA.ImagePathUrl + 'Circle.png')
        // .prop('title', 'Circle')
        .on('click touchstart', function () { self.NewCircle(); });
    this.RectButton = $('<img>')
        .appendTo(this.Tab.Panel)
        .addClass('sa-view-annotation-button sa-flat-button-active')
        .addClass('sa-active')
        .attr('type', 'image')
        .attr('src', SA.ImagePathUrl + 'rectangle.gif')
        // .prop('title', 'Rectangle')
        .on('click touchstart', function () { self.NewRect(); });
    this.GridButton = $('<img>')
        .appendTo(this.Tab.Panel)
        .addClass('sa-view-annotation-button sa-flat-button-active')
        .addClass('sa-active')
        .attr('type', 'image')
        .attr('src', SA.ImagePathUrl + 'grid.png')
        // .prop('title', 'Grid')
        .on('click touchstart', function () { self.NewGrid(); });
    this.PolylineButton = $('<img>')
        .appendTo(this.Tab.Panel)
        .addClass('sa-view-annotation-button sa-flat-button-active')
        .addClass('sa-active')
        .attr('type', 'image')
        .attr('src', SA.ImagePathUrl + 'FreeForm.gif')
        // .prop('title', 'Polygon')
        .on('click touchstart', function () { self.NewPolyline(); });
    this.PencilButton = $('<img>')
        .appendTo(this.Tab.Panel)
        .addClass('sa-view-annotation-button sa-flat-button-active')
        .addClass('sa-active')
        .attr('type', 'image')
        // .prop('title', 'Pencil')
        .attr('src', SA.ImagePathUrl + 'Pencil-icon.jpg')
        .on('click touchstart', function () { self.NewPencil(); });
    this.LassoButton = $('<img>')
        .appendTo(this.Tab.Panel)
        .addClass('sa-view-annotation-button sa-flat-button-active')
        .addClass('sa-active')
        .attr('type', 'image')
        .attr('src', SA.ImagePathUrl + 'select_lasso.png')
        // .prop('title', 'Lasso')
        .on('click touchstart', function () { self.NewLasso(); });
    if (window.SA && this.Viewer) {
      this.SectionsButton = $('<img>')
            .appendTo(this.Tab.Panel)
            .addClass('sa-view-annotation-button sa-flat-button-active')
            .addClass('sa-active')
            .attr('type', 'image')
            .attr('src', SA.ImagePathUrl + 'sections.png')
            // .prop('title', 'Segment')
            .on('click touchstart', function () { self.DetectSections(); });
    }
    /*
    this.FillButton = $('<img>')
        .appendTo(this.Tab.Panel)
        .css({'height': '28px',
              'opacity': '0.6',
              'margin': '1px',
              'border-style': 'outset',
              'border-radius': '4px',
              'border-thickness':'2px'})
        .attr('type','image')
        .attr('src',SA.ImagePathUrl+"brush1.jpg")
        .on('click touchstart', function(){self.NewFill();});
        */
  }

// Show hide the tool tab button
  AnnotationWidget.prototype.show = function () {
    this.Tab.show();
  };

  AnnotationWidget.prototype.hide = function () {
    this.Tab.hide();
  };

  AnnotationWidget.prototype.SetVisibility = function (visibility) {
    if (this.Layer.GetVisibility() === visibility) {
      return;
    }

    // Hack to make all stack viewers share a single annotation visibility
    // flag.
    if (SA.notesWidget) {
      var note = SA.notesWidget.GetCurrentNote();
      if (note && note.Type === 'Stack') {
        for (var i = 0; i < note.ViewerRecords.length; ++i) {
          note.ViewerRecords[i].AnnotationVisibility = visibility;
        }
      }
    }

    if (this.VisibilityImage) {
      if (visibility === ANNOTATION_OFF) {
        this.VisibilityImage.css({'top': '-30px'});
      } else {
        this.VisibilityImage.css({'top': '1px'});
      }
    }

    this.Layer.SetVisibility(visibility);
    this.Layer.EventuallyDraw();
  };

  AnnotationWidget.prototype.GetVisibility = function () {
    return this.Layer.GetVisibility();
  };

  AnnotationWidget.prototype.ToggleVisibility = function () {
    var vis = this.GetVisibility();
    if (vis === ANNOTATION_OFF) {
      vis = ANNOTATION_ON;
    } else {
      vis = ANNOTATION_OFF;
    }
    this.SetVisibility(vis);
    if (window.SA) { SA.RecordState(); }
  };

  AnnotationWidget.prototype.TogglePanel = function () {
    this.Panel.toggle();
    if (this.Panel.is(':visible')) {
      this.TabButton.addClass('sa-active');
    } else {
        // Should we deactivate any active widget tool?
      this.TabButton.removeClass('sa-active');
    }
  };

// I would like to change the behavior of this.
// First slide the arrow, then pop up the dialog to set text.
  AnnotationWidget.prototype.NewText = function () {
    var button = this.TextButton;
    var widget = this.ActivateButton(button, SAM.TextWidget);
    // The dialog is used to set the initial text.
    widget.ShowPropertiesDialog();
  };

// Probably want a singleton pencil.
  AnnotationWidget.prototype.NewPencil = function () {
    var button = this.PencilButton;
    this.ActivateButton(button, SAM.PencilWidget);
  };

  AnnotationWidget.prototype.NewLasso = function () {
    var button = this.LassoButton;
    this.ActivateButton(button, SAM.ImageWidget);
  };

  AnnotationWidget.prototype.NewPolyline = function () {
    var button = this.PolylineButton;
    this.ActivateButton(button, SAM.PolylineWidget);
  };

  AnnotationWidget.prototype.NewCircle = function () {
    var button = this.CircleButton;
    this.ActivateButton(button, SAM.CircleWidget);
  };

  AnnotationWidget.prototype.NewRect = function () {
    var button = this.RectButton;
    this.ActivateButton(button, SAM.RectWidget);
  };

  AnnotationWidget.prototype.NewGrid = function () {
    var button = this.GridButton;
    var widget = this.ActivateButton(button, SAM.GridWidget);
    var cam = this.Layer.GetCamera();
    var fp = cam.GetWorldFocalPoint();
    // Square grid elements determined by height
    widget.Grid.Origin = [fp[0], fp[1], 0.0];
    widget.Grid.Orientation = cam.GetWorldRotation();
    this.Layer.DeactivateWidget(widget);
  };

  AnnotationWidget.prototype.NewFill = function () {
    var button = this.FillButton;
    var widget = this.ActivateButton(button, SAM.FillWidget);
    widget.Initialize();
  };

// Boilerplate code that was in every "newWidget" method.
  AnnotationWidget.prototype.ActivateButton = function (button, WidgetFunction) {
    var widget = this.Layer.ActiveWidget;
    if (widget) {
      if (button.Pressed) {
            // The user pressed the button again (while it was active).
        widget.Deactivate();
        return;
      }
        // This call sets pressed to false as a side action..
      widget.Deactivate();
    }
    button.Pressed = true;
    button.addClass('sa-active');

    this.SetVisibility(ANNOTATION_ON);
    widget = new WidgetFunction(this.Layer, true);
    this.Layer.ActivateWidget(widget);

    // Button remains "pressed" until the circle deactivates.
    widget.DeactivateCallback =
        function () {
          button.removeClass('sa-active');
          widget.DeactivateCallback = undefined;
          button.Pressed = false;
        };
    // Keep track of annotation created by students
    // without edit
    // permission.
    if (!SA.Edit) {
      this.UserNoteFlag = true;
    }
    if (SA.notesWidget && SA.notesWidget.IsUserTextTabOpen()) {
      widget.UserNoteFlag = true;
    }
    return widget;
  };

  AnnotationWidget.prototype.DetectSections = function () {
    if (!window.SA) { return; }

    var widget = this.Layer.GetActiveWidget();
    var button = this.SectionsButton;
    if (widget) {
      if (button.Pressed) {
        // The user pressed the button again (while it was active).
        widget.Deactivate();
        return;
      }
      // This call sets pressed to false as a side action.
      widget.Deactivate();
    }
    button.Pressed = true;
    button.addClass('sa-active');

    // See if a SectionsWidget already exists.
    widget = null;
    var widgets = this.Layer.GetWidgets();
    for (var i = 0; i < widgets.length && widget == null; ++i) {
      var w = widgets[i];
      // if (w instanceOf SectionsWidget) {
      if (w.Type === 'sections') {
        widget = w;
      }
    }
    if (widget == null) {
      // Find sections to initialize sections widget.
      widget = new SA.SectionsWidget(this.Layer, this.Viewer, false);
      widget.ComputeSections(this.Viewer);
      if (widget.IsEmpty()) {
        this.Layer.RemoveWidget(widget);
        button.removeClass('sa-active');
        button.Pressed = false;
        return;
      }
    }

    widget.SetActive(true);
    widget.DeactivateCallback =
      function () {
        button.removeClass('sa-active');
        widget.DeactivateCallback = undefined;
        button.Pressed = false;
      };
  };

  SA.AnnotationWidget = AnnotationWidget;
})();

// This "widget" implements undo and redo as well as saving states in the database for a recording of a session.
// I save the recording state as a cookie so that the user can change slides or even sessions.
// I am going to have a separate recording collection.
// Each recording will be a single object.
// They will be tagged with start time, end time, user ID and a name (autogenerated or entered by user).

// NOTES:
// I will have to think about this ...
// save state vs. save delta state.
// State is simple .... Supports undo better .... Start with this.

// Maybe students can link to the instructor recording session.  The could add notes which are added to the recording.

// It might be nice to know where the mouse is pointing at all times.  We need a pointing tool. That is many events though.  LATER....

// Design issue:
// Should I save the state at the end of a move or the beginning?  I chose end.  Although beginning is easier,
// I like just popping the last state off the TIME_LINE and pushing to the REDO_STACK

// ------------------------------------------------------------------------------
// Records are now being used for notes.  Since page record may contain
// information about current note, I am using ViewerRecord as a shared object.

(function () {
  'use strict';

  SA.RECORDER_WIDGET = null;

  function ViewerRecord () {
    this.AnnotationVisibility = 0;
    this.Annotations = [];
    // UserNotes are bound to image ids so the need to be stored in
    // viewer records. They will always have one viewer record of the
    // their own. They may have children links ....
    this.UserNote = null;
  }

    // For copy slide in presentatations.  Serialize / load messup image.
  ViewerRecord.prototype.DeepCopy = function (source) {
    this.AnnotationVisibility = source.AnnotationVisibility;
    this.Annotations = JSON.parse(JSON.stringify(source.Annotations));
    this.Camera = new SAM.Camera();
    this.Camera.DeepCopy(source.Camera);
    this.Image = source.Image;
    this.OverViewBounds = source.OverViewBounds.slice(0);
    this.UserNote = source.UserNote;
  };

  // I am still trying to figure out a good pattern for loading
  // objects from mongo.
  // Cast to a ViewerObject by setting its prototype does not work on IE
  ViewerRecord.prototype.Load = function (obj) {
    if (!obj.Image.units && obj.Image.filename) {
      var tmp = obj.Image.filename.split('.');
      var ext = tmp[tmp.length - 1];
      if (ext === 'ptif') {
        obj.Image.spacing = [0.25, 0.25, 1.0];
        obj.Image.units = '\xB5m'; // um / micro meters
      }
    }

    if (!obj.Camera) {
      var bds = obj.Image.bounds;
      if (bds) {
        obj.Camera = {FocalPoint: [(bds[0] + bds[1]) / 2, (bds[2] + bds[3]) / 2],
          Height: bds[3] - bds[2],
          Width: bds[1] - bds[0],
          Roll: 0};
      }
    }

    for (var ivar in obj) {
      this[ivar] = obj[ivar];
    }
    if (this.OverviewBounds) {
      this.OverViewBounds = obj.OverviewBounds;
      delete this.OverviewBounds;
    }

    if (this.Camera.Width === undefined) {
      this.Camera.Width = this.Camera.Height * 1.62;
    }

    if (!this.OverViewBounds) {
      this.OverViewBounds = this.Image.bounds;
    }

    if (this.Annotations) {
      for (var i = 0; i < this.Annotations.length; ++i) {
        var a = this.Annotations[i];
        if (a && a.color) {
          a.color = SAM.ConvertColor(a.color);
        }
      }
    }

    if (this.Transform) {
      var t = new SA.PairTransformation();
      t.Load(this.Transform);
      this.Transform = t;
    }

    // Anytime thie image changes, we have to set the user note.
    if (this.UserNote) {
      // Will this ever happen?
      // Should we save the old if it does?
      // For now, let the caller worry about it.
      console.log('Loading over a user note');
    }

    if (!this.UserFlag) {
      if (!this.UserNote || this.UserNote.Parent !== this.Image._id) {
        // This returns a note if it has already been loaded.
        this.UserNote = SA.GetUserNoteFromImageId(this.Image._id);
        if (!this.UserNote) {
          this.UserNote = new SA.Note();
          this.UserNote.Parent = this.Image._id;
          // Copy the camera.
          var record = new SA.ViewerRecord();
          record.Camera = new SAM.Camera();
          record.Camera.DeepCopy(this.Camera);
          record.Image = this.Image;
          record.OverViewBounds = this.OverViewBounds.slice(0);
                    // Records of usernotes should not have usernotes
          record.UserFlag = true;
          this.UserNote.ViewerRecords = [record];
          this.UserNote.Type = 'UserNote';
          // User notes slowing down stack loading.
          // Make them load on demand.
        }
      }
    }
  };

  // Move to note.js
  ViewerRecord.prototype.RequestUserNote = function () {
    if (!this.UserNote) {
      return;
    }
    if (this.UserNote.LoadState !== 0) {
      return;
    }

    // TODO: Move this to note.js
    this.UserNote.LoadState = 1; // REQUESTED

    var self = this;
    $.ajax({
      type: 'get',
      url: '/webgl-viewer/getusernotes',
      data: {'imageid': this.UserNote.Parent},
      success: function (data, status) { self.LoadUserNote(data); },
      error: function () {
        SA.Debug('AJAX - error() : getusernotes');
        if (self.UserNote) {
          // TODO: Do not add notes to the SA.Notes
          // array until they are loaded.  Figure out
          // why this ajax call is failing for HM stack.
          SA.DeleteNote(self.UserNote);
          delete self.UserNote;
        }
      }
    });
  };

  // Move to note.js
  ViewerRecord.prototype.LoadUserNote = function (data) {
    if (data.Notes.length === 0) {
      return;
    }

    var userNote = this.UserNote;
    var noteData = data.Notes[0];

    // This should not happen, but if it does, merge notes as best as possible.
    if (data.Notes.length > 1) {
      SA.Debug('Warning: More than one user note for the same image..');
      for (var i = 1; i < data.Notes.length; ++i) {
                // TODO: line break.
                // TODO: Remove the duplicate note in the database.
        noteData.Text += '<br>' + data.Notes[i].Text;
        noteData.ViewerRecords[0].Annotations =
                    noteData.ViewerRecords[0].Annotations.concat(
                        data.Notes[i].ViewerRecords[0].Annotations);
      }
    }
    // If in the rare case that the user note took a long time to load
    // and user text or annotations were added while waiting, merge
    // them.
    if (userNote.Text !== '') {
      noteData.Text = userNote.Text + '<br>' + noteData.Text;
    }
    if (userNote.ViewerRecords[0].Annotations.length > 0) {
      noteData.ViewerRecords[0].Annotations =
                noteData.ViewerRecords[0].Annotations.concat(
                        userNote.ViewerRecords[0].Annotations);
    }

    userNote.Load(noteData);

    // The new notes need to be displayed.
    // I do not like that this is global. We could have callbacks????
    SA.UpdateUserNotes();
  };

  ViewerRecord.prototype.CopyViewer = function (viewer) {
    var cache = viewer.GetCache();
    if (!cache) {
      this.Camera = null;
      this.AnnotationVisibility = false;
      this.Annotations = [];
      return;
    }

    this.OverViewBounds = viewer.GetOverViewBounds();

    this.OverViewBounds = viewer.GetOverViewBounds();
    this.Image = cache.Image;
    this.UserNote = SA.GetUserNoteFromImageId(this.Image._id);
    this.Camera = viewer.GetCamera().Serialize();

    // TODO: get rid of this hack somehow. Generalize layers?
    var annotationLayer = viewer.Layers[0];
    if (!annotationLayer) { return; }

    this.AnnotationVisibility = annotationLayer.GetVisibility();
    this.Annotations = [];

    var widgets = annotationLayer.GetWidgets();
    for (var i = 0; i < widgets.length; ++i) {
      this.Annotations.push(widgets[i].Serialize());
    }
  };

  // For stacks.  A reduced version of copy view.
  ViewerRecord.prototype.CopyAnnotations = function (viewer, userNoteFlag) {
    this.Annotations = [];
    // TODO: get rid of this hack somehow. Generalize layers?
    if (viewer.Layers.length === 0) { return; }
    var annotationLayer = viewer.Layers[0];
    if (!annotationLayer) { return; }
    var widgets = viewer.Layers[0].GetWidgets();
    for (var i = 0; i < widgets.length; ++i) {
      var widget = widgets[i];
      // Keep user note annotations separate from other annotations
      // if ((userNoteFlag && widget.UserNoteFlag)) ||
      //    (!userNoteFlag && !widget.UserNoteFlag)){ // ! exclusive or.
      widget.UserNoteFlag = widget.UserNoteFlag || false;
      if (userNoteFlag === widget.UserNoteFlag) { // ! exclusive or.
        var o = widgets[i].Serialize();
        if (o) {
          this.Annotations.push(o);
        }
      }
    }
  };

  // I am not sure we need to serialize.
  // The annotations are already in database form.
  // Possibly we need to restrict which ivars get into the database.
  ViewerRecord.prototype.Serialize = function () {
    var rec = {};
    rec.Image = this.Image._id;
    rec.Database = this.Image.database;
    rec.NumberOfLevels = this.Image.levels;
    rec.Camera = this.Camera;
        // deep copy
    if (this.Annotations) {
      rec.Annotations = JSON.parse(JSON.stringify(this.Annotations));
    }
    rec.AnnotationVisibility = this.AnnotationVisibility;

    if (this.OverViewBounds) {
      rec.OverViewBounds = this.OverViewBounds;
    }

    if (this.Transform) {
      rec.Transform = this.Transform.Serialize();
    }

    return rec;
  };

  // This is a helper method to start preloading tiles for an up coming view.
  ViewerRecord.prototype.LoadTiles = function (viewport) {
    var cache = SA.FindCache(this.Image);
    // TODO:  I do not like the fact that we are keeping a serialized
    // version of the camera in the record object.  It should be a real
    // camera that is serialized when it is saved.
    var cam = new SAM.Camera();
    cam.Load(this.Camera);
    cam.SetViewport(viewport);
    cam.ComputeMatrix();

        // Load only the tiles we need.
    var tiles = cache.ChooseTiles(cam, 0, []);
    for (var i = 0; i < tiles.length; ++i) {
      SA.LoadQueueAddTile(tiles[i]);
    }
  };

  // legacy
  SA.RecordState = function () {
    if (SA.RECORDER_WIDGET) {
      SA.RECORDER_WIDGET.RecordState();
    }
  };

  // display is a set of viewers (like DualViewWidet)
  var RecorderWidget = function (display) {
    if (!SA.RECORDER_WIDGET) {
      SA.RECORDER_WIDGET = this;
    }

    var self = this;
    this.Display = display;
    this.RecordTimerId = 0;

    this.TimeLine = [];
    this.RedoStack = [];
    this.Recording = true;
    this.RecordingName = '';

    // The recording button indicates that recording is in
    // progress and also acts to stop recording.
    this.RecordButton = $('<img>')
            .appendTo('body')
            .css({
              'opacity': '0.5',
              'position': 'absolute',
              'height': '20px',
              'bottom': '120px',
              'right': '20px',
              'z-index': '1'})
            .attr('src', SA.ImagePathUrl + 'stopRecording2.png')
            .hide()
            .click(function () { self.RecordingStop(); });

    // Optional buttons.  Exposed for testing.
    // Undo (control z) and redo (control y) keys work,
    this.UndoButton = $('<img>').appendTo('body')
            .css({
              'opacity': '0.5',
              'position': 'absolute',
              'height': '30px',
              'bottom': '5px',
              'right': '100px',
              'z-index': '1'})
            .attr('src', SA.ImagePathUrl + 'undo.png')
            .hide()
            .click(function () { alert('undo'); });
    this.RedoButton = $('<img>').appendTo('body').css({
      'opacity': '0.5',
      'position': 'absolute',
      'height': '30px',
      'bottom': '5px',
      'right': '70px',
      'z-index': '1'})
            .attr('src', SA.ImagePathUrl + 'redo.png')
            .hide()
            .click(function () { alert('REDO'); });

    this.RecordingName = SA.getCookie('SlideAtlasRecording');
    if (this.RecordingName !== undefined && this.RecordingName !== 'false') {
      this.Recording = true;
      this.UpdateGUI();
    }

    // We have to start with one state (since we are recording states at the end of a move).
    this.RecordState();
  };

  // Should we name a recording?
  RecorderWidget.prototype.UpdateGUI = function () {
    if (this.Recording) {
      this.RecordButton.show();
    } else {
      this.RecordButton.hide();
    }
  };

  // Should we name a recording?
  RecorderWidget.prototype.RecordingStart = function () {
    if (this.Recording) { return; }
    this.Recording = true;
    // Generate a recording name as a placeholder.
    // User should be prompted for a name when recording stops.
    var d = new Date();
    this.RecordingName = 'Bev' + d.getTime();
    SA.setCookie('SlideAtlasRecording', this.RecordingName, 1);
    this.UpdateGUI();
        // Create a new recording object in the database.
    this.RecordState();
  };

  RecorderWidget.prototype.RecordingStop = function () {
    if (!this.Recording) { return; }
    this.Recording = false;
    SA.setCookie('SlideAtlasRecording', 'false', 1);
    this.UpdateGUI();

    // Prompt for a name and if the user want to keep the recording.
  };

  RecorderWidget.prototype.RecordStateCallback = function () {
    if (this.Display.GetNumberOfViewers() === 0) { return; }

    // Timer called this method.  Timer id is no longer valid.
    this.RecordTimerId = 0;
    // Redo is an option after undo, until we save a new state.
    this.RedoStack = [];

    // Create a new note.
    var note = new SA.Note();
    note.Type = 'Record';
    // This will probably have to be passed the viewers.
    note.RecordView(this.Display);

    // The note will want to know its context
    // The stack viewer does not have  notes widget.
    if (SA.display) {
      var parentNote = SA.display.GetNote();
      if (!parentNote || !parentNote.Id) {
        //  Note is not loaded yet.
        // Wait some more
        this.RecordState();
        return;
      }
      // ParentId should be depreciated.
      note.ParentId = parentNote.Id;
      note.SetParent(parentNote);
    }
    // Save the note in the admin database for this specific user.
    $.ajax({
      type: 'post',
      url: '/webgl-viewer/saveusernote',
      data: {'note': JSON.stringify(note.Serialize(true)),
        'col': 'tracking',
        'type': 'Record'},
      success: function (data, status) {
        note.Id = data;
      },
      error: function () {
        // SA.Debug( "AJAX - error() : saveusernote" );
      }
    });

    this.TimeLine.push(note);
    // Remove it from the serachable global list.
    // "Delete" recorder notes.  Once saved, we never user
    // them again. I do not think tileline will be an issue.
    SA.DeleteNote(note);
  };

  // Create a snapshot of the current state and push it on the TIME_LINE stack.
  // I still do not compress scroll wheel zoom, so I am putting a timer event
  // to collapse recording to lest than oner per second.
  RecorderWidget.prototype.RecordState = function () {
    if (this.Display.GetNumberOfViewers() === 0) { return; }
        // Delete the previous pending record timer
    if (this.RecordTimerId) {
      clearTimeout(this.RecordTimerId);
      this.RecordTimerId = 0;
    }
        // Start a record timer.
    var self = this;
    this.RecordTimerId = setTimeout(
            function () { self.RecordStateCallback(); },
            1000);
  };

  RecorderWidget.prototype.GetRecords = function () {
    var self = this;
    $.ajax({
      type: 'get',
      url: '/webgl-viewer/getfavoriteviews',
      data: {'col': 'tracking'},
      success: function (data, status) {
        self.Records = data.viewArray;
      },
      error: function () {
        SA.Debug('AJAX - error() : get records');
      }
    });
  };

  // Create a snapshot of the current state and push it on the TIME_LINE stack.
  // I still do not compress scroll wheel zoom, so I am putting a timer event
  // to collapse recording to lest than oner per second.
  RecorderWidget.prototype.RecordState = function () {
    // Delete the previous pending record timer
    if (this.RecordTimerId) {
      clearTimeout(this.RecordTimerId);
      this.RecordTimerId = 0;
    }
    // Start a record timer.
    var self = this;
    this.RecordTimerId = setTimeout(function () { self.RecordStateCallback(); }, 1000);
  };

  // Move the state back in time.
  RecorderWidget.prototype.UndoState = function () {
    if (this.TimeLine.length > 1) {
      // We need at least 2 states to undo.  The last state gets removed,
      // the second to last get applied.
      var recordNote = this.TimeLine.pop();
      this.RedoStack.push(recordNote);

      // Get the new end state
      recordNote = this.TimeLine[this.TimeLine.length - 1];
      // Now change the page to the state at the end of the timeline.
      SA.SetNote(recordNote);
    }
  };

  // Move the state forward in time.
  RecorderWidget.prototype.RedoState = function () {
    if (this.RedoState.length === 0) {
      return;
    }
    var recordNote = this.RedoStack.pop();
    this.TimeLine.push(recordNote);

    // Now change the page to the state at the end of the timeline.
    recordNote.DisplayView();
  };

  SA.ViewerRecord = ViewerRecord;
  SA.RecorderWidget = RecorderWidget;
})();

// VCR like buttons to get to next/previous note/slide.
// entwined with the notes widget at the moment.

(function () {
  'use strict';

// ------------------------------------------------------------------------------
// I intend to have only one object
  function NavigationWidget (parent, display) {
    this.Display = display;

    // Load the session slides from the localStorage
    this.SlideIndex = 0;
    this.Session = [];
    this.NoteIterator = new SA.NoteIterator();

    var self = this;
    var size = '40px';
    if (SAM.detectMobile()) {
      // fake a tab
      this.Tab = {};
      this.Tab.Panel = $('<div>')
            .appendTo(display.GetViewer(0).GetDiv())
            .hide()
            // .addClass("sa-view-navigation-div ui-responsive");
            .addClass('ui-responsive')
            .css({'position': 'absolute',
              'left': '50px',
              'bottom': '20px',
              'z-index': '5'});
      var panel = this.Tab.Panel;
      this.Tab.show = function () { panel.show(); };
      this.Tab.hide = function () {
        panel.hide();
      };
      // SA.OnStartInteraction( function () { panel.hide();} );
    } else {
      this.Tab = new SA.Tab(parent, SA.ImagePathUrl + 'nav.png', 'navigationTab');
      // this.Tab.Div.prop('title', 'Navigation');
      this.Tab.Div.addClass('sa-view-navigation-div');
      this.Tab.Panel.addClass('sa-view-navigation-panel');

      // Put the stack display in the navigation button
      this.NoteDisplay = $('<div>')
            .appendTo(this.Tab.Div)
            .addClass('sa-view-note')
            .html('');
    }

    this.PreviousSlideButton =
        $('<img>').appendTo(this.Tab.Panel)
        .addClass('sa-view-navigation-button')
        .attr('src', SA.ImagePathUrl + 'previousSlide.png')
        // .prop('title', 'Previous Slide. (page-up)')
        .click(function () { self.PreviousSlide(); });

    this.PreviousNoteButton =
        $('<img>').appendTo(this.Tab.Panel)
        .addClass('sa-view-navigation-button')
        .attr('src', SA.ImagePathUrl + 'previousNote.png')
        // .prop('title', 'Previous Note. (p)')
        .click(function () { self.PreviousNote(); });

    this.NextNoteButton =
        $('<img>').appendTo(this.Tab.Panel)
        .addClass('sa-view-navigation-button')
        .attr('src', SA.ImagePathUrl + 'nextNote.png')
        // .prop('title', 'Next Note, (n, space)')
        .click(function () { self.NextNote(); });

    this.NextSlideButton =
        $('<img>').appendTo(this.Tab.Panel)
        .addClass('sa-view-navigation-button')
        .attr('src', SA.ImagePathUrl + 'nextSlide.png')
        // .prop('title', 'Next Slide. (page-down)')
        .css({'z-index': '100'})
        .click(function () { self.NextSlide(); });
    this.NextSlideButton
        .on('touchend', function (event) {
          self.NextSlide();
          return false;
        });

    // TODO: Fix the main css file for mobile.  Hack this until fixed.
    if (SAM.MOBILE_DEVICE) {
      size = '80px';
      if (SAM.MOBILE_DEVICE === 'iPhone') {
        size = '100px';
      }
      this.PreviousSlideButton
            .css({'height': size,
              'width': size,
              'opacity': '0.8'})
            .on('touchend', function () { self.PreviousSlide(); });
      this.PreviousNoteButton
            .css({'height': size,
              'width': size,
              'opacity': '0.8'})
            .on('touchend', function () { self.PreviousNote(); });
      this.NextNoteButton
            .css({'height': size,
              'width': size,
              'opacity': '0.8'})
            .on('touchend', function () { self.NextNote(); });
      this.NextSlideButton
            .css({'height': size,
              'width': size,
              'opacity': '0.8'});
    }

    this.CopyrightWrapper =
        $('<div>').appendTo(parent)
        .css({
          'width': '100%',
          'text-align': 'center'
        }).html();
  }

// Making a stack navigator. Starting to abstract an interface.
  NavigationWidget.prototype.GetNote = function () {
    return this.NoteIterator.GetNote();
  };

  NavigationWidget.prototype.SetInteractionEnabled = function (flag) {
    var self = this;
    if (flag) {
      this.Display.Parent.on(
            'keydown.navigation',
            function (event) {
              return self.HandleKeyDown(event);
            });
    } else {
      this.Display.Parent.off('keydown.navigation');
    }
  };

  NavigationWidget.prototype.HandleKeyDown = function (event) {
    var keyCode = event.keyCode;
    // 34=page down, 78=n, 32=space
    if (keyCode === 34) {
      this.NextSlide();
      return false;
    }
    if (keyCode === 78 || keyCode === 32) {
      this.NextNote();
      return false;
    }
    // 33=page up, 80=p
    if (keyCode === 33) {
      this.PreviousSlide();
      return false;
    }
    if (keyCode === 80) {
      this.PreviousNote();
      return false;
    }

    return true;
  };

  NavigationWidget.prototype.SetNote = function (note) {
    if (this.GetNote() === note) {
      return;
    }

    var self = this;
    // Initialize the session neede to get the next slide.
    if (!this.SessionId) {
      if (SA.Session) {
        this.Session = SA.Session.session.views;
        this.SessionId = SA.Session.sessid;
        this.Update();
      } else if (note.SessionId && SA.RootNote.Type !== 'HTML') {
        this.SessionId = note.SessionId;
        $.ajax({
          type: 'get',
          url: SA.SessionUrl + '?json=true&sessid=' + this.SessionId,
          success: function (data, status) {
            if (self.SessionId !== data.sessid) {
                        // This will never happen.
              console.log('expecting a second session to load.');
              return;
            }
            self.Session = data.session.views;
            self.Update();
          },
          error: function () {
            SA.Debug('AJAX - error() : session');
          }
        });
      }
    } else {
      // Correct an error.  SessionId's are wrong because the
      // notes sessionId is not being updated when a session is
      // copied.
      note.SessionId = this.SessionId;
    }

    this.NoteIterator.SetNote(note);
    this.Update();
  };

  NavigationWidget.prototype.ToggleVisibility = function () {
    this.SetVisibility(!this.Visibility);
  };

  // Used on mobile.
  NavigationWidget.prototype.SetVisibility = function (v) {
    this.Visibility = v;
    if (v) {
      this.Tab.show();
    } else {
      this.Tab.hide();
    }
  };

  NavigationWidget.prototype.Update = function () {
    // Disable prev/next note buttons by default.
    this.PreviousNoteButton.removeClass('sa-active');
    this.NextNoteButton.removeClass('sa-active');
    var note = this.GetNote();
    if (note) {
      for (var i = 0; i < this.Session.length; ++i) {
        if (this.Session[i].id === note.Id) {
          this.SlideIndex = i;
        }
      }

      if (note.Type === 'Stack') {
        // Next note refers to ViewerRecords.
        if (note.StartIndex > 0) {
          note.ViewerRecords[note.StartIndex - 1].LoadTiles([0, 0, 200, 150]);
          this.PreviousNoteButton.addClass('sa-active');
        }
        if (note.StartIndex < note.ViewerRecords.length - 1) {
          note.ViewerRecords[note.StartIndex + 1].LoadTiles([0, 0, 200, 150]);
          this.NextNoteButton.addClass('sa-active');
        }
        if (note.StartIndex < note.ViewerRecords.length - 2) {
          note.ViewerRecords[note.StartIndex + 2].LoadTiles([0, 0, 200, 150]);
        }
      } else {
        // Next note refers to children.
        if (!this.NoteIterator.IsStart()) {
          this.PreviousNoteButton.addClass('sa-active');
        }
        if (!this.NoteIterator.IsEnd()) {
          this.NextNoteButton.addClass('sa-active');
        }
      }
    }

    // Disable and enable prev/next slide buttons so we cannot go past the end.
    if (this.SlideIndex <= 0) {
      this.PreviousSlideButton.removeClass('sa-active');
    } else {
      this.PreviousSlideButton.addClass('sa-active');
    }
    if (this.SlideIndex >= this.Session.length - 1) {
      this.NextSlideButton.removeClass('sa-active');
    } else {
      this.NextSlideButton.addClass('sa-active');
    }

    // Hack because next slide does not with presentations.
    if (SA.RootNote && SA.RootNote.Type === 'HTML') {
      this.PreviousSlideButton.removeClass('sa-active');
      this.NextSlideButton.removeClass('sa-active');
    }
  };

  NavigationWidget.prototype.PreviousNote = function () {
    SA.StackCursorFlag = false;

    // Make sure user not changes are not pending to be saved.
    if (SA.notesWidget) { SA.notesWidget.Flush(); }

    var current = this.GetNote();
    if (current.Type === 'Stack') {
      if (current.StartIndex <= 0) { return; }
      // Move camera
      // Hardcoded for dual display
      var viewer1 = this.Display.GetViewer(1);
      var viewer0 = this.Display.GetViewer(0);
      var cam = viewer0.GetCamera();
      var fp = cam.GetWorldFocalPoint();
      var rot = cam.GetWorldRotation();
      var height = cam.GetHeight();

      this.Display.RecordAnnotations();
      --current.StartIndex;
      // It was too slow to request a long stack of user notes when the
      // stack wasa first loaded.
      current.ViewerRecords[current.StartIndex].RequestUserNote();

      // We need to skip setting the camera.
      SA.display = this.Display;
      SA.SetNote(current);
      SA.UpdateUserNotes();
      // Set the camera after the note has been applied.
      viewer1.SetCamera(fp, rot, height);

      current.DisplayStack(this.Display);
      this.Display.SynchronizeViews(1, current);
      // activate or deactivate buttons.
      this.Update();
      if (this.NoteDisplay) {
        this.NoteDisplay.html('' + current.StartIndex);
      }
      return;
    }

    if (this.NoteIterator.IsStart()) {
      // if not previous notes move to the previous slide
      this.PreviousSlide();
      return;
    }

    SA.display.RecordAnnotations();
    var note = this.NoteIterator.Previous();
    this.SetNote(note);
    this.Update();
    // TODO: Check to make sure the call to this.SetNote(note) does nothing.
    // Hack for presentaitons. Global not set.
    SA.display = this.Display;
    SA.display.RecordAnnotations();
    SA.SetNote(note);
    SA.UpdateUserNotes();
  };

  NavigationWidget.prototype.NextNote = function () {
    SA.StackCursorFlag = false;

    // Make sure user not changes are not pending to be saved.
    if (SA.notesWidget) { SA.notesWidget.Flush(); }

    var current = this.GetNote();
    if (current.Type === 'Stack') {
      if (current.StartIndex >= current.ViewerRecords.length - 1) {
        return;
      }
      // Move camera
      // Hard coded for dual display.
      var viewer0 = this.Display.GetViewer(0);
      var viewer1 = this.Display.GetViewer(1);
      var cam = viewer1.GetCamera();
      var fp = cam.GetWorldFocalPoint();
      var rot = cam.GetWorldRotation();
      var height = cam.GetHeight();

      this.Display.RecordAnnotations();
      ++current.StartIndex;
      // It was too slow to request a long stack of user notes when the
      // stack wasa first loaded.
      current.ViewerRecords[current.StartIndex].RequestUserNote();

      // We need to skip setting the camera.
      SA.display = this.Display;
      SA.SetNote(current);
      SA.UpdateUserNotes();
      // Set the camera after the note has been applied.
      viewer0.SetCamera(fp, rot, height);
      current.DisplayStack(this.Display);
      this.Display.SynchronizeViews(0, current);
      // activate or deactivate buttons.
      this.Update();
      if (this.NoteDisplay) {
        this.NoteDisplay.html('' + current.StartIndex);
      }
      return;
    }

    if (this.NoteIterator.IsEnd()) {
        // If we have no more notes, then move to the next slide.
      this.NextSlide();
      return;
    }

    var note = this.NoteIterator.Next();
    this.Update();
    // TODO: Check to make sure the call to this.SetNote(note) does nothing.
    // Hack for presentaitons. Global not set.
    SA.display = this.Display;
    SA.display.RecordAnnotations();
    SA.SetNote(note);
    SA.UpdateUserNotes();
  };

  NavigationWidget.prototype.PreviousSlide = function () {
    // Make sure user not changes are not pending to be saved.
    if (SA.notesWidget) { SA.notesWidget.Flush(); }

    SA.StackCursorFlag = false;
    // Find the previous slide ( skip presentations)
    var prevSlideIdx = this.SlideIndex - 1;
    while (prevSlideIdx >= 0 &&
           this.Session[prevSlideIdx].Type === 'Presentation') {
      --prevSlideIdx;
    }
    if (prevSlideIdx < 0) { return; }

    var check = true;
    if (SA.notesWidget && SA.notesWidget.Modified && SA.Edit) {
      check = confirm('Unsaved edits will be lost.  Are you sure you want to move to the next slide?');
    }
    if (check) {
      // TODO: Improve the API here.  Get rid of global access.
      if (SA.notesWidget) { SA.notesWidget.MarkAsNotModified(); }
      this.SlideIndex = prevSlideIdx;
      SA.SetNoteFromId(this.Session[this.SlideIndex].id);

      if (this.NoteDisplay) {
        this.NoteDisplay.html('');
      }
    }
  };

  NavigationWidget.prototype.NextSlide = function () {
    // Make sure user not changes are not pending to be saved.
    if (SA.notesWidget) { SA.notesWidget.Flush(); }

    SA.StackCursorFlag = false;
    // Find the next slide ( skip presentations)
    var nextSlideIdx = this.SlideIndex + 1;
    while (nextSlideIdx < this.Session.length &&
           this.Session[nextSlideIdx].Type === 'Presentation') {
      ++nextSlideIdx;
    }
    if (nextSlideIdx >= this.Session.length) { return; }
    var check = true;
    if (SA.notesWidget && SA.notesWidget.Modified) {
      check = confirm('Unsaved edits will be lost.  Are you sure you want to move to the next slide?');
    }
    if (check) {
      if (SA.notesWidget) { SA.notesWidget.MarkAsNotModified(); }
      this.SlideIndex = nextSlideIdx;
      SA.SetNoteFromId(this.Session[this.SlideIndex].id);

      if (this.NoteDisplay) {
        this.NoteDisplay.html('');
      }
    }
  };

// ==============================================================================

// ------------------------------------------------------------------------------
// Iterator to perform depth first search through note tree.
// Collapsed branches (children not visible) are not traversed.
// This iterator is a bit over engineered.  I made it so we can subclasses
// that iterate over internal states.  However, internal states require
// notes so I made an array of answers (which are hidden).
  function NoteIterator (note) {
    this.Note = note;
    this.ChildIterator = null;
  }

  // Because of sorting, the child array gets reset on us.
  // I need a dynamic way to get the Children array based on the state.
  NoteIterator.prototype.GetChildArray = function () {
    if (!this.Note) {
      return [];
    }
    return this.Note.Children;
  };

  // Because of sorting, I have to make the index dynamic
  // and it cannot be stored as an ivar.
  NoteIterator.prototype.GetChildIndex = function () {
    if (this.ChildIterator === null) {
      return -1;
    }
    return this.GetChildArray().indexOf(this.ChildIterator.Note);
  };

  // Get the parent note of the current note.
  // Notes do not keep a pointer to parents.
  // The iterator has this information for active notes.
  NoteIterator.prototype.GetParentNote = function () {
    if (this.ChildIterator === null) {
      // We are at the current note.  Let the caller supply the parent.
      return null;
    }

    var parent = this.ChildIterator.GetParentNote();
    if (parent === null) {
      // This level contains the parent.
      parent = this.Note;
    }

    return parent;
  };

// We use this to see (peek) if next or previous should be disabled.
  NoteIterator.prototype.IsStart = function () {
    if (this.ChildIterator === null) {
      return true;
    }
    return false;
  };

  NoteIterator.prototype.IsEnd = function () {
    if (!this.Note) { return true; }

    // Case note is active.
    if (this.ChildIterator === null) {
      if (this.Note.Children.length > 0 && this.Note.ChildrenVisibility) {
        return false;
      }
      return true;
    }

    // sub answer is active.
    var childIndex = this.GetChildIndex();

    // sub child is active
    if (childIndex === this.GetChildArray().length - 1) {
      return this.ChildIterator.IsEnd();
    }
    return false;
  };

// Parent note is traversed before children.
// Move forward one step.  Return the new note. At end the last note returned again.
// IsEnd method used to detect terminal case.
  NoteIterator.prototype.Next = function () {
    if (!this.Note) { return; }

    // Case 1:  Iterator is on its own node.
    if (this.ChildIterator === null) {
      // Next check for children notes
      if (this.Note.Children.length > 0 && this.Note.ChildrenVisibility) {
        // Move to the first child.
        this.ChildIterator = this.GetChildArray()[0].NewIterator();
        return this.ChildIterator.GetNote();
      }
      // No answers or children: we are at the end.
      return this.Note;
    }

    // Try to advance the child iterator.
    if (!this.ChildIterator.IsEnd()) {
      return this.ChildIterator.Next();
    }

    // Child iterator is finished.
    // Try to create a new iterator with the next child in the array.
    var childIndex = this.GetChildIndex();
    if (childIndex < this.GetChildArray().length - 1) {
      this.ChildIterator = this.GetChildArray()[childIndex + 1].NewIterator();
      return this.ChildIterator.GetNote();
    }

    // We are at the end of the children array.
    return this.ChildIterator.GetNote();
  };

  // Move backward one step.  See "Next" method comments for description of tree traversal.
  NoteIterator.prototype.Previous = function () {
    if (!this.Note) { return; }

    if (this.ChildIterator === null) {
      // At start.
      return this.Note;
    }
    if (!this.ChildIterator.IsStart()) {
      return this.ChildIterator.Previous();
    }

    // Move to the previous child.
    var childIndex = this.GetChildIndex() - 1;
    if (childIndex >= 0) {
      this.ChildIterator = this.GetChildArray()[childIndex].NewIterator();
      this.ChildIterator.ToEnd();
      return this.ChildIterator.GetNote();
    }

    // No more sub notes left.  Move to the root.
    this.ChildIterator = null;
    return this.Note;
  };

  // Move the iterator to the start.
  NoteIterator.prototype.ToStart = function () {
    if (this.ChildIterator) {
      this.ChildIterator = null;
    }
  };

  // Move the iterator to the end. Used in Previous method.
  NoteIterator.prototype.ToEnd = function () {
    if (!this.Note) { return; }

    if (this.Note.Children.length > 0 && this.Note.ChildrenVisibility) {
      this.ChildArray = this.Note.Children;
      var childIndex = this.ChildArray.length - 1;
      this.ChildIterator = this.ChildArray[childIndex].NewIterator();
      return this.ChildIterator.ToEnd();
    }
    // leaf note
    this.ChildArray = null;
    this.ChildIterator = null;
    return this.Note;
  };

  // If the note is not in the tree, Set the note as root.
  // Otherwise, point the iterator to the note in the tree.
  NoteIterator.prototype.SetNote = function (note) {
    if (this.GetNote() === note) { return; }
    // See if the note is in the tree.
    this.ToStart();
    while (true) {
      if (this.GetNote() === note) {
        // Found the note in the tree.
        return;
      }
      if (this.IsEnd()) {
        // not found.  New tree.
        this.ToStart();
        this.Note = note;
        // BIG Hack here.
        // I got rid of a special SetRootNote call too soon.
        // if (SA.notesWidget) {
        //    SA.notesWidget.SetRootNote(note);
        // }
        return;
      }
      this.Next();
    }
  };

  NoteIterator.prototype.GetNote = function () {
    if (this.ChildIterator !== null) {
      return this.ChildIterator.GetNote();
    }
    return this.Note;
  };

  SA.NoteIterator = NoteIterator;
  SA.NavigationWidget = NavigationWidget;
})();

// Testing annotation widget with touch events.

(function () {
  'use strict';

// ------------------------------------------------------------------------------
// I intend to have only one object
  function MobileAnnotationWidget () {
    var size = '80px';
    if (SAM.detectMobile() === 'iPhone') {
      size = '100px';
    }

    // TODO: The css style is not working for mobile devices. fix it.
    // for now, hack back in the size dependancies.

    var self = this;
    this.Div =
        $('<div>').appendTo(SA.VIEWERS[0].GetDiv())
        .css({'position': 'absolute',
          'right': '0px',
          'bottom': '0px',
          'z-index': '5'});

    // .addClass("sa-view-annotation-div ui-responsive")

    // I cannot get touch events that start in the image to continue in
    // the document / viewer.  Press to place, then interact to position.
    this.CircleButton = $('<img>')
        .appendTo(this.Div)
        .css({'height': size,
          'width': size,
          'opacity': '0.6',
          'margin': '1px',
          'padding': '5px'})
        // .addClass("sa-view-annotation-button")
        .attr('src', SA.ImagePathUrl + 'Circle128.jpg')
        .on('touchend', function () { self.CircleCallback(); });
    this.CircleButton.prop('title', 'Circle Annotation');

    this.TextButton = $('<img>')
        .appendTo(this.Div)
        .css({'height': size,
          'width': size,
          'opacity': '0.6',
          'margin': '1px',
          'padding': '5px'})
        // .addClass("sa-view-annotation-button")
        .attr('src', SA.ImagePathUrl + 'Text128.jpg')
        .on('touchend', function () { self.TextCallback(); });
    this.TextButton.prop('title', 'Text Annotation');

    this.Visibility = false;

    // SA.OnStartInteraction( function () { self.SetVisibility(false);} );
  }

  MobileAnnotationWidget.prototype.CircleCallback = function () {
    console.log('New circle');

    // Hard code only a single view for now.
    this.Layer = SA.VIEWERS[0].GetAnnotationLayer();

    if (this.Layer.ActiveWidget !== undefined) {
      this.Layer.ActiveWidget.Deactivate();
    }
    var widget = new SAM.CircleWidget(this.Layer, false);
    var cam = this.Layer.GetCamera();
    var fp = cam.GetWorldFocalPoint();

    widget.Shape.Origin = fp;
    widget.Shape.Radius = cam.Height / 4.0;
    widget.Shape.UpdateBuffers(this.Layer.AnnotationView);
    this.Layer.EventuallyDraw();

    this.Layer.SetVisibility(true);
  };

  MobileAnnotationWidget.prototype.TextCallback = function () {
    this.Layer = SA.VIEWERS[0].GetAnnotationLayer();
    var widget = this.Layer.ActiveWidget;
    if (widget) {
      widget.Deactivate();
    }

    this.Layer.SetVisibility(true);
    widget = new SAM.TextWidget(this.Layer, '');
    var cam = this.Layer.GetCamera();
    var fp = cam.getWorldFocalPoint();
    widget.Text.Anchor = fp;
    this.Layer.EventuallyDraw();

    this.Layer.ActivateWidget(widget);

    // The dialog is used to set the initial text.
    widget.ShowPropertiesDialog();
  };

// Show the tool gui.
  MobileAnnotationWidget.prototype.SetVisibility = function (v) {
    this.Visibility = v;
    if (v) {
      this.Div.show();
    } else {
      this.Div.hide();
    }
  };

// Toggle the tool gui.
  MobileAnnotationWidget.prototype.ToggleVisibility = function () {
    this.SetVisibility(!this.Visibility);
  };

  SA.MobileAnnotationWidget = MobileAnnotationWidget;
})();


// ==============================================================================
// saElement: borders, shadow, drag and resize
// saRectangle: BackgroundColor / gradient.
// saText: padding, textSize, Line spacing, (in future font)
// saLightBox, click to expand.
// saLightBoxViewer, expand to a viewer. Manage turning events on and off.

// Abstracting the question.  It will not be editable text, but can be
// changed from a properties dialog. Subclass of rectangle.
// TODO:
// Bug: Pasting into textEditor leaves edit buttons hanging around.

// Clean up the whole editable / clickable / lock state.
//    Browser slides are completely passive.

// Modes:
// Edit:
//    Editable: on, off
//    draggable, deletable, properties menu, resizable, record viewer, text
//    click to edit, cursor changing.
// Student:
//    Interactive: on, off.
//    Click to expand viewer and image.
//    Interactive border.
// Thumb:
//    Both Editable and Interactive off.

// Insert / copy html note into presentation.
// Display html note "Text" in the view browser.
// LoadViewChildren has to tolerate notes with no viewer record (get rid of
//   image db stuff?

// make sure html notes still work.
// Copyright management not working for dual display.
// Open dual viewer: overview bounds different (foot)
// Open lightbox viewers do not consume key events.
// Save changes to a stack.
// Resize puts edit buttons in the wrong location.

// bug: question buttons div are active on load

// Make sure the active border stays on during resize.
// Finish pan zoom of presentation.
// Stack viewer / lightbox
// Question: Interactive

// Edit questions/
// Convert text to an SaElement.
// Option to hide with answers.
// Interactive question.
// Shuffle questions as note Text. No shuffle when answers are off.

// Replace an image. presesntation will not save.Intertent
//   WHen you delete an image, the next image should go where the last was.
// Menu when not logged in.

// ==============================================================================
// Sort of a superclass for all presentation elements.
// Start with draggable, resizable, deletable and click.
// Highlight border to indicate an active element.
// args = {click: function (dom) {...}
//         delete: function (dom) {...}
//         editable: true,
//         interactive: true,
//         aspectRatio: false}
// args = "dialog" => open the dialog.

(function () {
  'use strict';

  jQuery.prototype.saElement = function (arg1) { // 'arguments' handles extras.
    for (var i = 0; i < this.length; ++i) {
      if (!this[i].saElement) {
        var helper = new SaElement($(this[i]));
            // Add the helper as an instance variable to the dom object.
        this[i].saElement = helper;
        $(this[i]).addClass('sa-element');
      }
      this[i].saElement.ProcessArguments(arguments);
    }
    return this;
  };

  // TODO: Rename Edit
  function SaElement (div) {
    var self = this;

    this.Position = 'absolute';
    this.Editable = false;
    this.Interactive = true;
    this.Div = div;
    this.ClickCallback = null;
    this.DeleteCallback = null;
    // Hack to keep the element active.
    this.LockActive = false;
    this.Div
        .css({'overflow': 'hidden'}) // for borderRadius
        .hover(
            function () { self.ActiveOn(); },
            function () { self.ActiveOff(); });

    // I cannot move this to EditOn because we need the mouse down event
    // to detect clicks.
    this.Div
        .on('mousedown.element',
              function (event) {
                return self.HandleMouseDown(event);
              })
        .on('tap.element',
            function (event) {
              if (this.ClickCallback) {
                (this.ClickCallback)(this.Div[0]);
                return false;
              }
              return true;
            });

    // I could not get the key events working.  I had to restart the browser.
    this.ButtonDiv = $('<div>')
        .addClass('sa-edit-gui') // Remove before saHtml save.
        .css({'height': '20px',
          'position': 'absolute',
          'top': '0px',
          'left': '0px',
          'cursor': 'auto',
          'z-index': '1000'})
        // Block the expand event when the delete button is pressed.
        .mousedown(function () { return false; });
    this.DeleteButton = $('<img>')
        .appendTo(this.ButtonDiv)
        .addClass('editButton')
        .css({'height': '16px',
              // static put the buttons out of parent???????
              // Hack the positions with absolute
          'position': 'absolute',
          'top': '0px',
          'left': '0px'})
        .attr('src', SA.ImagePathUrl + 'remove.png')
        .prop('title', 'delete');
    this.MenuButton = $('<img>')
        .appendTo(this.ButtonDiv)
        .addClass('editButton')
        .css({'height': '16px',
              // static put the buttons out of parent???????
              // Hack the positions with absolute
          'position': 'absolute',
          'top': '0px',
          'left': '20px'})
        .attr('src', SA.ImagePathUrl + 'Menu.jpg')
        .prop('title', 'properties');

    this.InitializeDialog();
  }

  // This changes the border to active color.
  SaElement.prototype.ActiveOn = function () {
    var self = this;
    if (!this.Interactive) { return true; }
    if (!this.SavedBorder) {
      this.SavedBorder = this.Div[0].style.border;
    }
    this.Div.css({'border-color': '#7BF'});
    if (this.Editable) {
      this.ButtonDiv.appendTo(this.Div);
        // Remove an element destroys bindings.
      this.MenuButton
            .on('mousedown',
                function () {
                  self.OpenDialog();
                  return false;
                });
      this.DeleteButton
            .on('mousedown',
                function () {
                  if (self.DeleteCallback) {
                    (self.DeleteCallback)(self.Div[0]);
                  }
                  self.Div.remove();
                  return false;
                });
    }
  };

  SaElement.prototype.ActiveOff = function () {
    if (!this.Interactive) { return true; }
    if (this.SavedBorder) {
      this.Div[0].style.border = this.SavedBorder;
      delete this.SavedBorder;
    }
    this.ButtonDiv.remove();
  };

  SaElement.prototype.InitializeDialog = function () {
    var self = this;
    this.Dialog = new SAM.Dialog(function () { self.DialogApplyCallback(); });
    this.Dialog.Title.text('Properties');
    // Open callbacks allow default values to be set in the dialog.
    this.DialogInitializeFunctions = [];
    this.DialogApplyFunctions = [];

    // Indicate that this item should be hidden when in quize mode.
    this.Dialog.QuizPanel = this.AddAccordionTab(
        'Quiz',
        function () {
          self.Dialog.QuizCheck.prop('checked', self.Div.hasClass('sa-quiz-hide'));
        },
        function () {
          if (self.Dialog.QuizCheck.is(':checked')) {
            self.Div.addClass('sa-quiz-hide');
          } else {
            self.Div.removeClass('sa-quiz-hide');
          }
        });
    this.Dialog.QuizLabel = $('<div>')
        .appendTo(this.Dialog.QuizPanel)
        .css({'display': 'inline-block'})
        .text('Hide for quiz:');
    this.Dialog.QuizCheck = $('<input type="checkbox">')
        .appendTo(this.Dialog.QuizPanel);

    // Initialize the dialog with properties of border and shadow.
    // Border
    this.Dialog.BorderPanel = this.AddAccordionTab(
        'Border',
        function () { self.DialogInitialize(); },
        function () { self.DialogApply(); });

    // Border width and color.
    this.Dialog.BorderLine1 = $('<div>')
        .appendTo(this.Dialog.BorderPanel)
        .css({'width': '100%'});
    this.Dialog.BorderCheck = $('<input type="checkbox">')
        .appendTo(this.Dialog.BorderLine1)
        .change(function () {
          if ($(this).is(':checked')) {
            self.Dialog.BorderWidth.prop('disabled', false);
            self.Dialog.BorderColor.spectrum('enable');
          } else {
            self.Dialog.BorderWidth.prop('disabled', true);
            self.Dialog.BorderColor.spectrum('disable');
          }
        });
    this.Dialog.BorderWidthLabel = $('<div>')
        .appendTo(this.Dialog.BorderLine1)
        .css({'display': 'inline-block',
          'padding': '0px 5px',
          'width': '4em',
          'height': '20px',
          'text-align': 'right'})
        .text('Width');
    this.Dialog.BorderWidth = $('<input type="number">')
        .appendTo(this.Dialog.BorderLine1)
        .addClass('sa-view-annotation-modal-input')
        .css({'display': 'inline-block',
          'width': '3em'})
        .prop('disabled', true)
        .val(1)
        // Consume all events except return
        .keypress(function (event) { return event.keyCode !== 13; });
    this.Dialog.BorderColorDiv = $('<div>')
        .appendTo(this.Dialog.BorderLine1)
        .css({'float': 'right',
          'height': '18px'});
    this.Dialog.BorderColor = $('<input type="text">')
        .appendTo(this.Dialog.BorderColorDiv)
        .spectrum({showAlpha: true});

    // Rounded corners
    this.Dialog.BorderLine2 = $('<div>')
        .appendTo(this.Dialog.BorderPanel)
        .css({'width': '100%'});
    this.Dialog.BorderRadiusCheck = $('<input type="checkbox">')
        .appendTo(this.Dialog.BorderLine2)
        .change(function () {
          if ($(this).is(':checked')) {
            self.Dialog.BorderRadius.prop('disabled', false);
          } else {
            self.Dialog.BorderRadius.prop('disabled', true);
          }
        });
    this.Dialog.BorderRadiusLabel = $('<div>')
        .appendTo(this.Dialog.BorderLine2)
        .css({'display': 'inline-block',
          'padding': '0px 5px',
          'width': '4em',
          'height': '20px',
          'text-align': 'right'})
        .text('Radius');
    this.Dialog.BorderRadius = $('<input type="number">')
        .appendTo(this.Dialog.BorderLine2)
        .addClass('sa-view-annotation-modal-input')
        .prop('disabled', true)
        .css({'display': 'inline-block',
          'width': '3em'})
        .val(5)
        // Consume all events except return
        .keypress(function (event) { return event.keyCode !== 13; });

    // Shadow
    this.Dialog.BorderLine3 = $('<div>')
        .appendTo(this.Dialog.BorderPanel)
        .css({'width': '100%'});
    this.Dialog.ShadowCheck = $('<input type="checkbox">')
        .appendTo(this.Dialog.BorderLine3)
        .change(function () {
          if ($(this).is(':checked')) {
            self.Dialog.ShadowOffset.prop('disabled', false);
            self.Dialog.ShadowBlur.prop('disabled', false);
            self.Dialog.ShadowColor.spectrum('enable');
          } else {
            self.Dialog.ShadowOffset.prop('disabled', true);
            self.Dialog.ShadowBlur.prop('disabled', true);
            self.Dialog.ShadowColor.spectrum('disable');
          }
        });
    this.Dialog.ShadowLabel = $('<div>')
        .appendTo(this.Dialog.BorderLine3)
        .css({'display': 'inline-block',
          'padding': '0px 5px',
          'width': '4em',
          'height': '20px',
          'text-align': 'right'})
        .text('Shadow');
    this.Dialog.ShadowOffset = $('<input type="number">')
        .appendTo(this.Dialog.BorderLine3)
        .addClass('sa-view-annotation-modal-input')
        .prop('disabled', true)
        .css({'display': 'inline-block',
          'width': '3em'})
        .val(10)
        // Consume all events except return
        .keypress(function (event) { return event.keyCode !== 13; });
    this.Dialog.ShadowBlurLabel = $('<div>')
        .appendTo(this.Dialog.BorderLine3)
        .css({'display': 'inline-block',
          'padding': '0px 5px',
          'width': '3em',
          'height': '20px',
          'text-align': 'right'})
        .text('Blur');
    this.Dialog.ShadowBlur = $('<input type="number">')
        .appendTo(this.Dialog.BorderLine3)
        .addClass('sa-view-annotation-modal-input')
        .prop('disabled', true)
        .css({'display': 'inline-block',
          'width': '3em'})
        .val(5)
        // Consume all events except return
        .keypress(function (event) { return event.keyCode !== 13; });
    this.Dialog.ShadowColorDiv = $('<div>')
        .appendTo(this.Dialog.BorderLine3)
        .css({'float': 'right',
          'height': '18px'});
    this.Dialog.ShadowColor = $('<input type="text">')
        .appendTo(this.Dialog.ShadowColorDiv)
        .val('#AAAAAA')
        .prop('disabled', true)
        .css({'float': 'right',
          'height': '18px'})
        .spectrum({showAlpha: true});
  };

  SaElement.prototype.AddAccordionTab = function (title, open, apply) {
    if (open) {
      this.DialogInitializeFunctions.push(open);
    }
    if (apply) {
      this.DialogApplyFunctions.push(apply);
    }

    var tabDiv = $('<div>')
        .appendTo(this.Dialog.Body)
        .attr('title', title)
        .css({'width': '100%'});
    var tab = $('<div>')
        .appendTo(tabDiv)
        .text(title)
        .addClass('sa-accordion-tab');
    var panel = $('<div>')
        .appendTo(tabDiv)
        .css({'width': '100%',
          'padding': '5px',
          'border': '1px solid #AAA',
          'box-sizing': 'border-box'})
        .hide();
    var self = this;
    tab.on('click touchstart',
           function () {
             if (self.OpenAccordionPanel) {
               self.OpenAccordionPanel.hide(200);
             }
             if (self.OpenAccordionPanel === panel) {
               // Just closing the open panel.
               self.OpenAccordionPanel = null;
               return;
             }
             // Opening a new panel.
             panel.show(200);
             self.OpenAccordionPanel = panel;
           });
    // The last tab created is visible by default.
    // This should have worked, but did not.
    // tab.trigger('click');
    if (this.OpenAccordionPanel) {
      this.OpenAccordionPanel.hide();
    }
    this.OpenAccordionPanel = panel;
    panel.show();

    return panel;
  };

  SaElement.prototype.HideAccordionTab = function (title) {
    this.Div[0].saElement.Dialog.Body.children('[title=Quiz]').hide();
  };

  SaElement.prototype.OpenDialog = function (callback) {
    if (!this.DialogInitialized) {
        // Give 'subclasses' a chance to initialize their tabs.
      for (var i = 0; i < this.DialogInitializeFunctions.length; ++i) {
        (this.DialogInitializeFunctions[i])(this.Dialog);
      }
      this.DialogInitialized = true;
    }
    // Keep this onetime callback separate from DialogApplyCallbacks.
    this.OpenDialogCallback = callback;
    this.Dialog.Show(true);
  };

  SaElement.prototype.DialogInitialize = function () {
    // TODO: Does this work when 'border' is used?
    var str = this.Div[0].style.borderWidth;
    if (str !== '') {
      this.Dialog.BorderCheck.prop('checked', true);
      this.Dialog.BorderWidth.prop('disabled', false);
      this.Dialog.BorderColor.spectrum('enable');
      this.Dialog.BorderWidth.val(parseInt(str));
        // Current border is highlighted.  Use the saved color.
        // str = this.Div[0].style.borderColor;
      str = this.SavedBorder;
      if (!str || str === '') {
            // Called programatically
        str = this.Div[0].style.border;
      }
      if (str !== '') {
        str = str.substr(str.indexOf('rgb'));
        this.Dialog.BorderColor.spectrum('set', str);
      }
    }

    // Border Radius
    str = this.Div[0].style.borderRadius;
    if (str !== '') {
      this.Dialog.BorderRadiusCheck.prop('checked', true);
      this.Dialog.BorderRadius.prop('disabled', false);
      this.Dialog.BorderRadius.val(parseInt(str));
    }

    // Shadow
    str = this.Div[0].style.boxShadow;
    if (str !== '') {
      this.Dialog.ShadowCheck.prop('checked', true);
      var idx = str.indexOf(')') + 1;
      var color = str.substr(str.indexOf('rgb'), idx);
      this.Dialog.ShadowColor.spectrum('set', color);
      this.Dialog.ShadowColor.spectrum('enable');
      str = str.substr(idx + 1); // 1 more to skip the space
      var params = str.split(' ');
      this.Dialog.ShadowOffset.prop('disabled', false);
      this.Dialog.ShadowOffset.val(parseInt(params[0]));
      this.Dialog.ShadowBlur.prop('disabled', false);
      this.Dialog.ShadowBlur.val(parseInt(params[2]));
    }
  };

  SaElement.prototype.DialogApplyCallback = function () {
    // Giv 'subclasses' a chance to apply parameters in their tabs.
    for (var i = 0; i < this.DialogApplyFunctions.length; ++i) {
      (this.DialogApplyFunctions[i])(this.Dialog);
    }

    // External callback
    // I am not sure if I should put this here or in DialogApply.
    if (this.OpenDialogCallback) {
      (this.OpenDialogCallback)(this);
      delete this.OpenDialogCallback;
    }
  };

  SaElement.prototype.DialogApply = function () {
    // ActiveOff was setting border back after dialog changed it.
    delete this.SavedBorder;
    var width;
    if (this.Dialog.BorderCheck.is(':checked')) {
      var color = this.Dialog.BorderColor.spectrum('get');
      width = parseFloat(this.Dialog.BorderWidth.val());
      this.Div.css({'border': width + 'px solid ' + color});
    } else {
      this.Div.css('border', '');
    }

    // Border Radius
    if (this.Dialog.BorderRadiusCheck.is(':checked')) {
      width = parseFloat(this.Dialog.BorderRadius.val());
      this.Div.css({'borderRadius': width + 'px'});
    } else {
      this.Div.css('borderRadius', '');
    }

    // Shadow
    if (this.Dialog.ShadowCheck.is(':checked')) {
      var hexcolor = this.Dialog.ShadowColor.spectrum('get');
      var offset = parseInt(this.Dialog.ShadowOffset.val());
      var blur = parseInt(this.Dialog.ShadowBlur.val());
      this.Div.css({'box-shadow': offset + 'px ' + offset + 'px ' + blur + 'px ' + hexcolor});
    } else {
      this.Div.css('box-shadow', '');
    }
  };

  SaElement.prototype.ProcessArguments = function (args) {
    // No superclass

    // aspect ratio does something even with no arguments.
    if (args.length > 0) {
      // generic method call. Give jquery ui access to all this objects methods.
      if (typeof (this[args[0]]) === 'function') {
        // first list item is the method name,
        // the rest are arguments to the method.
        return this[args[0]].apply(this, Array.prototype.slice.call(args, 1));
      }
      // Handle the legacy behavior.
      // One argument: an object (like jqueryUI).
      args = args[0];
    } else {
      // looks like aspect processing with no args ...  Cannot just return?
      args = {};
    }

    if (args.position) {
      this.Position = args.position;
    }

    // It is important to set aspect ratio before EditOn is called.
    // AspectRatio is a boolean.
    if (args.aspectRatio !== undefined) {
      if (args.apsectRatio === '') {
        // Actively remove the aspect ratio.
        delete this.AspectRatio;
        this.Div.removeAttr('sa-aspect-ratio');
      } else {
            // Set a new aspect ratio
        this.AspectRatio = args.aspectRatio;
        this.Div.attr('sa-aspect-ratio', args.aspectRatio);
      }
    } else {
      // try and get a saved aspect ratio.
      this.AspectRatio = this.Div.attr('sa-aspect-ratio');
    }

    if (args.editable !== undefined) {
      if (args.editable) {
        this.EditableOn();
      } else {
        this.EditableOff();
        // hack hack hack (for view browser).
        // Trying to make slide thumbnails completly passive.
        this.Div.attr('contenteditable', 'false')
                .addClass('sa-noselect');
        this.Div.find('div').attr('contenteditable', 'false')
                .addClass('sa-noselect');
      }
    }

    if (args.interactive !== undefined) {
      this.Interactive = args.interactive;
      if (this.Interactive) {
        this.Div.removeClass('sa-noselect');
      } else {
        this.Div.addClass('sa-noselect');
      }
    }

    if (args.click !== undefined) {
      this.ClickCallback = args.click;
      this.Clickable = true;
    }

    if (args.delete !== undefined) {
      this.DeleteCallback = args.delete;
    }

    this.ConvertToPercentages();
  };

  SaElement.prototype.SetClickCallback = function (callback) {
    this.ClickCallback = callback;
    this.Clickable = true;
  };

  // Not the best function name.  Editable => draggable, expandable and deletable.
  SaElement.prototype.EditableOn = function () {
    this.Editable = true;
    this.Clickable = true;
    // I cannot get jqueryUI draggable to work.  Use my own events.
    var self = this;
    this.Div.on(
        'mousewheel.element',
        function (event) {
            // Resize from the middle.
          return self.HandleMouseWheel(event.originalEvent);
        });
    // NOTE: I could not get key events working for delete key.
    // Just had to restart chrome. Delete key is oldschool anyway.

    // Manage the cursor for drag versus resize.
    if (this.Position === 'absolute') {
      this.Div.on(
            'mousemove.elementCursor',
            function (event) {
              return self.HandleMouseMoveCursor(event);
            });
    }
  };

  SaElement.prototype.EditableOff = function () {
    this.Editable = false;
    this.Div.css({'cursor': 'auto'});
    // TODO: Remove wheel event.
    this.Div.off('mousewheel.element');
    this.Div.off('keyup.element');
    this.Div.off('mousemove.elementCursor');

    this.ButtonDiv.remove();
  };

  SaElement.prototype.HandleMouseDown = function (event) {
    if (!this.Interactive) { return true; }
    if (event.which === 1) {
      // Hack tp allow content editable to work with text editor.
      // This event does not let content editable receive events
      // if we return false.
      if (!this.Clickable) {
        return true;
      }

      var self = this;
      // To detect quick click for expansion.
      this.ClickStart = Date.now();
      $('body').on(
            'mouseup.element',
            function (e) {
              return self.HandleMouseUp(e);
            });

      if (this.Editable && this.Position === 'absolute') {
        // Setup dragging.
        this.DragLastX = event.screenX;
        this.DragLastY = event.screenY;
        // Add the event to stop dragging
        $('body').on(
                'mousemove.element',
                function (event) {
                  return self.HandleMouseMove(event);
                });
        $('body').on(
                'mouseleave.element',
                function (e) {
                  return self.HandleMouseUp(e);
                });
        // Hack to keep active even when mouse leaves the div.
        this.Div[0].saElement.LockActive = true;
      }
      return false;
    }
    return true;
  };

  // raise to the top of the draw order.
  // Note: it will not override z-index
  SaElement.prototype.RaiseToTop = function () {
    var parent = this.Div.parent();
    this.Div.detach();
    this.Div.appendTo(parent);
  };

  SaElement.prototype.HandleMouseMoveCursor = function (event) {
    if (!this.Interactive) { return true; }
    SA.FirefoxWhich(event);
    if (event.which === 0) {
      // Is it dangerous to modify the event object?
      while (event.srcElement && event.srcElement !== this.Div[0]) {
        event.offsetX += event.srcElement.offsetLeft;
        event.offsetY += event.srcElement.offsetTop;
        event.srcElement = event.srcElement.parentElement;
      }
      var x = event.offsetX;
      var y = event.offsetY;
      var width = this.Div.outerWidth();
      var height = this.Div.outerHeight();
      var handleSize = (width + height) / 100;
      if (handleSize < 6) {
        handleSize = 6;
      }
      var xMax = width - handleSize;
      var yMax = height - handleSize;
      if (x < handleSize && y < handleSize) {
        this.Div.css({'cursor': 'nwse-resize'});
        this.MoveState = 5;
      } else if (x > xMax && y > yMax) {
        this.Div.css({'cursor': 'nwse-resize'});
        this.MoveState = 6;
      } else if (x < handleSize && y > yMax) {
        this.Div.css({'cursor': 'nesw-resize'});
        this.MoveState = 7;
      } else if (x > xMax && y < handleSize) {
        this.Div.css({'cursor': 'nesw-resize'});
        this.MoveState = 8;
      } else if (x < handleSize) {
        this.Div.css({'cursor': 'ew-resize'});
        this.MoveState = 1;
      } else if (x > xMax) {
        this.Div.css({'cursor': 'ew-resize'});
        this.MoveState = 2;
      } else if (y < handleSize) {
        this.Div.css({'cursor': 'ns-resize'});
        this.MoveState = 3;
      } else if (y > yMax) {
        this.Div.css({'cursor': 'ns-resize'});
        this.MoveState = 4;
      } else {
        this.Div.css({'cursor': 'move'});
        this.MoveState = 0;
      }
    }
    return true;
  };

  SaElement.prototype.HandleMouseMove = function (event) {
    SA.FirefoxWhich(event);
    if (event.which === 1) {
      // Wait for the click duration to start dragging.
      if (Date.now() - this.ClickStart < 200) {
        return true;
      }

      if (!this.Dragging) {
        this.RaiseToTop();
        this.Dragging = true;
      }

      var dx = event.screenX - this.DragLastX;
      var dy = event.screenY - this.DragLastY;
      this.DragLastX = event.screenX;
      this.DragLastY = event.screenY;

      // Maybe we should not let the object leave the page.
      var pos = this.Div.position();
      // It is odd.  First setting width has the same value as getting
      // outerWidth. Now it behaves as expected (consistent outer set / get).
      var width = this.Div.outerWidth();
      var height = this.Div.outerHeight();
      // Hack,  I cannot figure out how jquery deals with box-sizing.
      var sizing = this.Div.css('box-sizing');
      if (this.AspectRatio && typeof (this.AspectRatio) !== 'number') {
        this.AspectRatio = width / height;
      }
      var left;
      var top;
      if (this.MoveState === 0) {
        left = pos.left + dx;
        top = pos.top + dy;
        this.Div[0].style.top = top.toString() + 'px';
        this.Div[0].style.left = left.toString() + 'px';
        return false;
      } else if (this.MoveState === 1) {
        left = pos.left + dx;
        width = width - dx;
        this.Div[0].style.left = left.toString() + 'px';
        if (sizing === 'border-box') {
          this.Div.width(width);
        } else {
          this.Div.outerWidth(width);
        }
        if (this.AspectRatio) {
          this.Div.innerHeight(this.Div.innerWidth / this.AspectRatio);
        }
        this.Div.trigger('resize');
        return false;
      } else if (this.MoveState === 2) {
        width = width + dx;
        if (sizing === 'border-box') {
          this.Div.width(width);
        } else {
          this.Div.outerWidth(width);
        }
        if (this.AspectRatio) {
          this.Div.innerHeight(this.Div.innerWidth() / this.AspectRatio);
        }
        this.Div.trigger('resize');
        return false;
      } else if (this.MoveState === 3) {
        top = pos.top + dy;
        height = height - dy;
        this.Div[0].style.top = top.toString() + 'px';
        if (sizing === 'border-box') {
          this.Div.height(height);
        } else {
          this.Div.outerHeight(height);
        }
        if (this.AspectRatio) {
          this.Div.innerWidth(this.Div.innerHeight() * this.AspectRatio);
        }
        this.Div.trigger('resize');
        return false;
      } else if (this.MoveState === 4) {
        height = height + dy;
        if (sizing === 'border-box') {
          this.Div.height(height);
        } else {
          this.Div.outerHeight(height);
        }
        if (this.AspectRatio) {
          this.Div.innerWidth(this.Div.innerHeight() * this.AspectRatio);
        }
        this.Div.trigger('resize');
        return false;
      } else if (this.MoveState === 5) {
        // upper left corner resize
        left = pos.left + dx;
        top = pos.top + dy;
        width = width - dx;
        height = height - dy;
        this.Div[0].style.top = top.toString() + 'px';
        this.Div[0].style.left = left.toString() + 'px';
        if (sizing === 'border-box') {
          this.Div.width(width);
          this.Div.height(height);
        } else {
          this.Div.outerWidth(width);
          this.Div.outerHeight(height);
        }
        if (this.AspectRatio) {
          this.Div.innerWidth(this.Div.innerHeight() * this.AspectRatio);
        }
        this.Div.trigger('resize');
        return false;
      } else if (this.MoveState === 6) {
        // lower right corner resize
        width = width + dx;
        height = height + dy;
        if (sizing === 'border-box') {
          this.Div.width(width);
          this.Div.height(height);
        } else {
          this.Div.outerWidth(width);
          this.Div.outerHeight(height);
        }
        if (this.AspectRatio) {
          this.Div.innerWidth(this.Div.innerHeight() * this.AspectRatio);
        }
        this.Div.trigger('resize');
        return false;
      } else if (this.MoveState === 7) {
        // lower left corner resize
        left = pos.left + dx;
        width = width - dx;
        height = height + dy;
        this.Div[0].style.left = left.toString() + 'px';
        if (sizing === 'border-box') {
          this.Div.width(width);
          this.Div.height(height);
        } else {
          this.Div.outerWidth(width);
          this.Div.outerHeight(height);
        }
        if (this.AspectRatio) {
          this.Div.innerWidth(this.Div.innerHeight() * this.AspectRatio);
        }
        this.Div.trigger('resize');
        return false;
      } else if (this.MoveState === 8) {
        // upper right corner resize
        top = pos.top + dy;
        width = width + dx;
        height = height - dy;
        this.Div[0].style.top = top.toString() + 'px';
        if (sizing === 'border-box') {
          this.Div.width(width);
          this.Div.height(height);
        } else {
          this.Div.outerWidth(width);
          this.Div.outerHeight(height);
        }
        if (this.AspectRatio) {
          this.Div.innerWidth(this.Div.innerHeight() * this.AspectRatio);
        }
        this.Div.trigger('resize');
        return false;
      }
    }
    return true;
  };

  SaElement.prototype.HandleMouseUp = function (event) {
    // mouse up is not conditional on edit because it
    // is also used tio trigger click callback.
    $('body').off('mouseup.element');

    if (this.Editable) {
      if (this.Dragging) {
        this.Dragging = false;
        this.ConvertToPercentages();
      }
      $('body').off('mousemove.element');
      $('body').off('mouseleave.element');
      // hack
      this.Div[0].saElement.LockActive = false;
      this.Div[0].saElement.ActiveOff();
    }

    // Quick click...
    var clickDuration = Date.now() - this.ClickStart;
    if (clickDuration < 200 && this.ClickCallback) {
      (this.ClickCallback)(this.Div[0]);
    }

    return false;
  };

  SaElement.prototype.HandleMouseWheel = function (event) {
    var width = this.Div.width();
    var height = this.Div.height();
    var dWidth = 0;
    var dHeight = 0;

    var tmp = 0;
    if (event.deltaY) {
      tmp = event.deltaY;
    } else if (event.wheelDelta) {
      tmp = event.wheelDelta;
    }
    // Wheel event seems to be in increments of 3.
    // depreciated mousewheel had increments of 120....
    // Initial delta cause another bug.
    // Lets restrict to one zoom step per event.
    if (tmp > 0) {
      dWidth = 0.05 * width;
      dHeight = 0.05 * height;
    } else if (tmp < 0) {
      dWidth = width * (-0.0476);
      dHeight = height * (-0.0476);
    }

    width += dWidth;
    this.Div[0].style.width = width.toString() + 'px';
    height += dHeight;
    this.Div[0].style.height = height.toString() + 'px';

    // We have to change the top and left ot percentages too.
    // I might have to make my own resizable to get the exact behavior
    // I want.
    var pos = this.Div.position();
    var left = pos.left - (dWidth / 2);
    var top = pos.top - (dHeight / 2);
    this.Div[0].style.top = top.toString() + 'px';
    this.Div[0].style.left = left.toString() + 'px';

    // the resize callback might deal with converting to percentages.
    // this.ConvertToPercentages();
    this.Div.trigger('resize');
    return false;
  };

// Change left, top, widht and height to percentages.
  SaElement.prototype.ConvertToPercentages = function () {
    // I had issues with previous slide shows that had images with no width
    // set. Of course it won't scale right but they will still show up.
    // NOTE: this.Div.width() also misbehaves when the div is not visible.
    // It does not convert percent to pixels (returns percent).
    var width = this.Div[0].style.width;
    if (width.indexOf('%') === -1) {
      width = parseFloat(width);
      width = 100 * width / this.Div.parent().width();
      this.Div[0].style.width = width.toString() + '%';
    }
    var height = this.Div[0].style.height;
    if (height.indexOf('%') === -1) {
      height = parseFloat(height);
      height = 100 * height / this.Div.parent().height();
      this.Div[0].style.height = height.toString() + '%';
    }

    // Note: We cannot use this.Div.position() when the div is hidden.
    var top = this.Div.css('top');
    if (top.indexOf('%') === -1) {
      top = parseFloat(top);
      top = 100 * top / this.Div.parent().height();
      this.Div[0].style.top = top.toString() + '%';
    }
    var left = this.Div.css('left');
    if (left.indexOf('%') === -1) {
      left = parseFloat(left);
      left = 100 * left / this.Div.parent().width();
      this.Div[0].style.left = left.toString() + '%';
    }
  };

// ==============================================================================
// Just editing options to a rectangle.  I could make the text editor a
// "subclass" of this rectangle object.

  jQuery.prototype.saRectangle = function (arg1) { // 'arguments' handles extras.
    // Setup the superclass saElement.
    this.saElement();
    this.addClass('sa-presentation-rectangle');
    for (var i = 0; i < this.length; ++i) {
      var dom = this[i];
      if (!dom.saRectangle) {
        dom.saRectangle = new SaRectangle($(dom));
      }
      dom.saRectangle.ProcessArguments(arguments);
    }

    return this;
  };

  function SaRectangle (div) {
    var self = this;
    this.Div = div;
    var element = div[0].saElement;
    this.BackgroundPanel = element.AddAccordionTab(
        'Background',
        function () { self.DialogInitialize(); },
        function () { self.DialogApply(); });

    // Background with gradient option.
    this.BackgroundLine1 = $('<div>')
        .appendTo(this.BackgroundPanel)
        .css({'width': '100%'});
    this.BackgroundCheck = $('<input type="checkbox">')
        .appendTo(this.BackgroundLine1)
        .change(function () {
          if ($(this).is(':checked')) {
            self.BackgroundColor.spectrum('enable');
          } else {
            self.BackgroundColor.spectrum('disable');
          }
        });
    this.BackgroundColorLabel = $('<div>')
        .appendTo(this.BackgroundLine1)
        .css({'display': 'inline-block',
          'padding': '0px 5px',
          'width': '4em',
          'height': '20px',
          'text-align': 'right'})
        .text('Color');
    this.BackgroundColorDiv = $('<div>')
        .appendTo(this.BackgroundLine1)
        .css({'display': 'inline-block',
          'height': '18px',
          'margin-left': '1em'});
    this.BackgroundColor = $('<input type="text">')
        .appendTo(this.BackgroundLine1)
        .val('#005077')
        .spectrum({showAlpha: true});
    this.BackgroundColor.spectrum('disable');

    // Gradient
    this.BackgroundLine2 = $('<div>')
        .appendTo(this.BackgroundPanel)
        .css({'width': '100%'});
    this.GradientCheck = $('<input type="checkbox">')
        .appendTo(this.BackgroundLine2)
        .change(function () {
          if ($(this).is(':checked')) {
            self.GradientColor.spectrum('enable');
            self.GradientColor.spectrum('show');
          } else {
            self.GradientColor.spectrum('disable');
            self.GradientColor.spectrum('hide');
          }
        });
    this.GradientLabel = $('<div>')
        .appendTo(this.BackgroundLine2)
        .css({'display': 'inline-block',
          'padding': '0px 5px',
          'width': '4em',
          'height': '20px',
          'text-align': 'right'})
        .text('Gradient');
    this.GradientColorDiv = $('<div>')
        .appendTo(this.BackgroundLine2)
        .css({'display': 'inline-block',
          'height': '18px',
          'margin-left': '1em'});
    this.GradientColor = $('<input type="text">')
        .appendTo(this.GradientColorDiv)
        .val('#005077')
        .spectrum({showAlpha: true});
  }

  SaRectangle.prototype.ProcessArguments = function (args) {
    if (args.length === 0) { return; }

    // Superclass
    this.Div[0].saElement.ProcessArguments(args);

    // generic method call. Give jquery ui access to all this objects methods.
    if (typeof (this[args[0]]) === 'function') {
      // first list item is the method name,
      // the rest are arguments to the method.
      return this[args[0]].apply(this, Array.prototype.slice.call(args, 1));
    }
  };

  SaRectangle.prototype.DialogInitialize = function () {
    var color = this.Div[0].style.background;
    if (color === '') {
      color = this.Div[0].style.backgroundColor;
    }
    if (color === '') {
      this.BackgroundCheck.prop('checked', false);
      this.BackgroundColor.spectrum('disable');
      this.GradientCheck.prop('checked', false);
      this.GradientColor.spectrum('disable');
      this.GradientColor.spectrum('hide');
      return;
    }
    if (color.substring(0, 3) === 'rgb') {
      // Single color in background (no 'linear-gradient')
      this.BackgroundCheck.prop('checked', true);
      this.BackgroundColor.spectrum('set', color);
      this.BackgroundColor.spectrum('enable');
      this.GradientCheck.prop('checked', false);
      this.GradientColor.spectrum('disable');
      this.GradientColor.spectrum('hide');
      return;
    }
    // parsing the gradient is a bit harder.
    if (color.substring(0, 15) === 'linear-gradient') {
      var idx0 = color.indexOf('rgb');
      var idx1 = color.indexOf(')') + 1;
      this.BackgroundCheck.prop('checked', true);
      this.BackgroundColor.spectrum('enable');
      this.BackgroundColor.spectrum('set', color.substring(idx0, idx1));
      idx0 = color.indexOf('rgb', idx1);
      idx1 = color.indexOf(')', idx1) + 1;
      this.GradientCheck.prop('checked', true);
      this.GradientColor.spectrum('enable');
      this.GradientColor.spectrum('show');
      this.GradientColor.spectrum('set', color.substring(idx0, idx1));
      return;
    }
    SA.Debug('parse error: ' + color);
  };

  SaRectangle.prototype.DialogApply = function () {
    if (!this.BackgroundCheck.is(':checked')) {
      this.Div.css('background', '');
      return;
    }
    var color = this.BackgroundColor.spectrum('get');
    if (!this.GradientCheck.is(':checked')) {
      this.Div.css({'background': color});
      return;
    }
    var color2 = this.GradientColor.spectrum('get');
    this.Div.css({'background': 'linear-gradient(' + color + ',' + color2 + ')'});
  };

// ==============================================================================
// Text: dialog to set margin, text size, spacing, (font in the future)

  jQuery.prototype.saText = function (arg1) { // 'arguments' handles extras.
    // Setup the superclass saElement.
    this.saRectangle();
    this.addClass('sa-text');
    for (var i = 0; i < this.length; ++i) {
      var dom = this[i];
      if (!dom.saText) {
        dom.saText = new SaText($(dom));
      }
      dom.saText.ProcessArguments(arguments);
    }

    return this;
  };

  function SaText (div) {
    var self = this;
    this.Div = div;
    var element = div[0].saElement;
    this.PaddingPanel = element.AddAccordionTab(
        'Margins',
        function () { self.DialogPaddingInitialize(); },
        function () { self.DialogPaddingApply(); });
    // Padding (text margins)
    // Left
    this.PaddingLeftLine = $('<div>')
        .appendTo(this.PaddingPanel)
        .css({'width': '100%'});
    this.PaddingLeftLabel = $('<div>')
        .appendTo(this.PaddingLeftLine)
        .css({'display': 'inline-block',
          'padding': '0px 5px',
          'width': '4em',
          'height': '20px',
          'text-align': 'right'})
        .text('Left:');
    this.PaddingLeft =
            $('<input type="number">')
            .appendTo(this.PaddingLeftLine)
            .keypress(function (event) { return event.keyCode !== 13; });
    // Top
    this.PaddingTopLine = $('<div>')
        .appendTo(this.PaddingPanel)
        .css({'width': '100%'});
    this.PaddingTopLabel = $('<div>')
        .appendTo(this.PaddingTopLine)
        .css({'display': 'inline-block',
          'padding': '0px 5px',
          'width': '4em',
          'height': '20px',
          'text-align': 'right'})
        .text('Top:');
    this.PaddingTop =
            $('<input type="number">')
            .appendTo(this.PaddingTopLine)
            .keypress(function (event) { return event.keyCode !== 13; });
    // Right
    this.PaddingRightLine = $('<div>')
        .appendTo(this.PaddingPanel)
        .css({'width': '100%'});
    this.PaddingRightLabel = $('<div>')
        .appendTo(this.PaddingRightLine)
        .css({'display': 'inline-block',
          'padding': '0px 5px',
          'width': '4em',
          'height': '20px',
          'text-align': 'right'})
        .text('Right:');
    this.PaddingRight =
            $('<input type="number">')
            .appendTo(this.PaddingRightLine)
            .keypress(function (event) { return event.keyCode !== 13; });
    // Bottom
    this.PaddingBottomLine = $('<div>')
        .appendTo(this.PaddingPanel)
        .css({'width': '100%'});
    this.PaddingBottomLabel = $('<div>')
        .appendTo(this.PaddingBottomLine)
        .css({'display': 'inline-block',
          'padding': '0px 5px',
          'width': '4em',
          'height': '20px',
          'text-align': 'right'})
        .text('Bottom:');
    this.PaddingBottom =
            $('<input type="number">')
            .appendTo(this.PaddingBottomLine)
            .keypress(function (event) { return event.keyCode !== 13; });
  }

  SaText.prototype.ProcessArguments = function (args) {
    if (args.length === 0) { return; }

    // Superclass
    this.Div[0].saRectangle.ProcessArguments(args);

    // generic method call. Give jquery ui access to all this objects methods.
    if (typeof (this[args[0]]) === 'function') {
      // first list item is the method name,
      // the rest are arguments to the method.
      return this[args[0]].apply(this, Array.prototype.slice.call(args, 1));
    }
  };

  SaText.prototype.DialogPaddingInitialize = function () {
    var txt;

    txt = this.Div[0].style.paddingLeft;
    // Convert to something like pixels.
    this.PaddingLeft.val(8 * parseFloat(txt)); // window 800 pixels high

    txt = this.Div[0].style.paddingTop;
    // Convert to something like pixels.
    this.PaddingTop.val(8 * parseFloat(txt)); // window 800 pixels high

    txt = this.Div[0].style.paddingRight;
    // Convert to something like pixels.
    this.PaddingRight.val(8 * parseFloat(txt)); // window 800 pixels high

    txt = this.Div[0].style.paddingBottom;
    // Convert to something like pixels.
    this.PaddingBottom.val(8 * parseFloat(txt)); // window 800 pixels high
  };

  SaText.prototype.DialogPaddingApply = function () {
    this.Div[0].style.paddingLeft = (this.PaddingLeft.val() / 8) + '%';
    this.Div[0].style.paddingTop = (this.PaddingTop.val() / 8) + '%';
    this.Div[0].style.paddingRight = (this.PaddingRight.val() / 8) + '%';
    this.Div[0].style.paddingBottom = (this.PaddingBottom.val() / 8) + '%';
  };

// ==============================================================================
// Questions
//
  jQuery.prototype.saQuestion = function (arg1) { // 'arguments' handles extras.
    // Setup the superclass saRectangle.
    this.saText();
    for (var i = 0; i < this.length; ++i) {
      if (!this[i].saQuestion) {
            // Add the helper as an instance variable to the dom object.
        this[i].saQuestion = new SaQuestion($(this[i]));
        this[i].saElement.HideAccordionTab('Quiz');
      }
      this[i].saQuestion.ProcessArguments(arguments);
    }

    return this;
  };

  function SaQuestion (div) {
    var self = this;
    this.Div = div;
    this.Div.addClass('sa-question');

    var element = div[0].saElement;
    element.Dialog.Dialog.css({'width': '500px'});

    this.QuestionPanel = element.AddAccordionTab(
        'Question',
        function () { self.DialogInitialize(); },
        function () { self.DialogApply(); });

    this.DialogInitialize();
  }

  // Meant to be acll externally.
  // Assumes multiple choice for now.
  SaQuestion.prototype.SetQuestionText = function (text) {
    var question = this.Div.find('.sa-q');
    if (question.length === 0) {
      question = $('<div>').addClass('sa-q').appendTo(this.Div);
    }
    question.text(text);
    this.Div.attr('type', 'multiple-choice');
  };
  SaQuestion.prototype.AddAnswerText = function (text, correct) {
    var answerText = text;
    // get rid of bullets
    if (text[0] === '-') {
      answerText = text.substring(1);
    } else if (text[1] === '.' || text[1] === ':') {
      answerText = text.substring(2);
    }
    // Get rid of whitespace
    answerText = answerText.trim();

    var answers = this.Div.find('ol');
    if (answers.length === 0) {
      answers = $('<ol>').appendTo(this.Div);
    }
    var answer = $('<li>').appendTo(answers).addClass('sa-answer');
    answer.text(answerText);
    if (correct) {
      answer.addClass('sa-true');
    }
  };

  SaQuestion.prototype.ProcessArguments = function (args) {
    if (args.length === 0) { return; }

    // Superclass
    this.Div[0].saText.ProcessArguments(args);

    // generic method call. Give jquery ui access to all this objects methods.
    if (typeof (this[args[0]]) === 'function') {
      // first list item is the method name,
      // the rest are arguments to the method.
      return this[args[0]].apply(this, Array.prototype.slice.call(args, 1));
    }
  };

  SaQuestion.prototype.SetMode = function (mode) {
    // Clear wrong answers selected by user.
    this.Div.find('.sa-answer').css({'color': '#000'});
    if (mode === 'answer-show') {
      this.Div.find('.sa-quiz-hide').show();
      this.Div.find('.sa-true').css({'font-weight': 'bold'});
      this.Div.find('.sa-short-answer')
            .css({'color': '#00C'})
            .show();
    } else {
      this.Div.find('.sa-quiz-hide').hide();
      this.Div.find('.sa-true').css({'font-weight': 'normal'});
      this.Div.find('.sa-short-answer')
            .hide();
    }

    if (mode === 'answer-interactive') {
      // Bind response to the user selecting an answer.
      this.Div.find('.sa-answer')
            .css({'cursor': 'pointer',
              'color': '#057'})
            .hover(function () { $(this).css({'background': '#DDD'}); },
                   function () { $(this).css({'background': '#FFF'}); })
            .on('click.answer',
                function () {
                  if ($(this).hasClass('sa-true')) {
                    $(this).css({'font-weight': 'bold',
                      'color': '#000'});
                  } else {
                    $(this).css({'color': '#C00'});
                  }
                });
    } else {
      this.Div.find('.sa-answer')
            .css({'color': '#000'})
            .css('cursor', '')
            .off('hover')
            .off('click.answer');
    }
  };

  SaQuestion.prototype.AddAnswerTo = function (parent, answerList, text, checked) {
    // Make a new answer box;
    var answerDiv = $('<div>')
        .appendTo(parent)
        .css({'width': '100%',
          'position': 'relative'});
    var check = $('<input type="checkbox">')
        .appendTo(answerDiv);
    var answer = $('<div>')
        .appendTo(answerDiv)
        .css({'border': '1px solid #AAA',
          'position': 'absolute',
          'left': '30px',
          'right': '2px',
          'top': '2px'})
        .attr('contenteditable', 'true');
    check.change(
        function () {
          if ($(this).is(':checked')) {
            answer.css({'font-weight': 'bold'});
          } else {
            answer.css({'font-weight': 'normal'});
          }
        });

    if (text) {
      answer.text(text);
      if (checked) {
        check.attr('checked', 'true');
        answer.css({'font-weight': 'bold'});
      }
    }

    // Answers are complicated enough that I am going to have to break down
    // and create differt gui object.
    var answerObj = {Div: answerDiv,
      Check: check,
      Input: answer};
    answerList.push(answerObj);
    return answerObj;
  };

  SaQuestion.prototype.DialogInitialize = function () {
    var self = this;
    // Create/recreate the question dialog panel.
    var panel = this.QuestionPanel;
    panel.empty();

    this.QuestionTypeSelect = $('<select>')
        .appendTo(panel);
    this.QuestionTypeMultipleChoice = $('<option>')
        .appendTo(this.QuestionTypeSelect)
        .text('Multiple Choice');
    this.QuestionTypeSortAnswer = $('<option>')
        .appendTo(this.QuestionTypeSelect)
        .text('Short Answer');
    // this.QuestionTypeTrueFalse = $('<option>')
    //    .appendTo(this.QuestionTypeSelect)
    //    .text("True or False");
    this.QuestionTypeSelect.change(
        function () {
          if ($(this).val() === 'Multiple Choice') {
            self.MultipleChoiceDiv.show();
            self.TrueFalseDiv.hide();
            self.ShortAnswerDiv.hide();
          }
          if ($(this).val() === 'True or False') {
            self.MultipleChoiceDiv.hide();
            self.TrueFalseDiv.show();
            self.ShortAnswerDiv.hide();
          }
          if ($(this).val() === 'Short Answer') {
            self.MultipleChoiceDiv.hide();
            self.TrueFalseDiv.hide();
            self.ShortAnswerDiv.show();
          }
        });

    this.QuestionLabel = $('<div>')
        .appendTo(panel)
        .text('Question:');
    this.Question = $('<div>')
        .appendTo(panel)
        .css({'border': '1px solid #AAA',
          'margin': '2px'})
        .attr('contenteditable', 'true');

    // The div itself is the answer input.
    this.ShortAnswerDiv = $('<div>')
        .appendTo(panel)
        .css({'border': '1px solid #AAA',
          'width': '100%',
          'height': '3em',
          'margin': '1px'})
        .attr('contenteditable', 'true')
        .hide();

    this.TrueFalseDiv = $('<div>')
        .appendTo(panel)
        .hide();
    this.TrueFalseAnswers = [];
    this.AddAnswerTo(this.TrueFalseDiv, this.TrueFalseAnswers, 'True');
    this.AddAnswerTo(this.TrueFalseDiv, this.TrueFalseAnswers, 'False');

    this.MultipleChoiceDiv = $('<div>')
        .appendTo(panel);
    this.MultipleChoiceAnswerLabel = $('<div>')
        .appendTo(this.MultipleChoiceDiv)
        .addClass('sa-mutliple-choice-answer')
        .text('Answers:');
    this.MultipleChoiceAnswers = [];

    // Initialize the question panel values from a question div (saQuestion).

    // Get the question information from the html.
    var questionDiv = this.Div.find('.sa-q');
    if (questionDiv.length > 0) {
      this.Question.text(questionDiv.text());
      var type = this.Div.attr('type');
      if (type === 'multiple-choice') {
        this.QuestionTypeSelect.val('Multiple Choice');
        var options = this.Div.find('.sa-answer');
        for (var i = 0; i < options.length; ++i) {
          var item = $(options[i]);
          var checked = item.hasClass('sa-true');
          this.AddAnswerTo(this.MultipleChoiceDiv,
                                 this.MultipleChoiceAnswers,
                                 item.text(), checked);
        }
      } else if (type === 'short-answer') {
        this.ShortAnswerDiv.text($('.sa-short-answer').text());
        this.QuestionTypeSelect.val('Short Answer');
        this.ShortAnswerDiv.show();
        this.MultipleChoiceDiv.hide();
      }
    }

    // Empty answer that adds another when it is filled.
    this.AddBlankMultipleChoiceAnswer();
  };

  SaQuestion.prototype.AddBlankMultipleChoiceAnswer = function () {
    var self = this;
    var answerObj = this.AddAnswerTo(this.MultipleChoiceDiv,
                                   this.MultipleChoiceAnswers);
    answerObj.Input.on('focus.answer',
                       function () {
                         self.AddBlankMultipleChoiceAnswer();
                       });
  };

  SaQuestion.prototype.DialogApply = function () {
    this.Div.find('.sa-q').remove();
    this.Div.find('ol').remove();
    this.Div.find('.sa-short-answer').remove();

    var tmp = $('<div>')
        .appendTo(this.Div)
        .addClass('sa-q')
        .text(this.Question.text());

    var i;
    if (this.QuestionTypeSelect.val() === 'Multiple Choice') {
      this.Div.attr('type', 'multiple-choice');
      tmp = $('<ol>')
            .appendTo(this.Div)
            .css({'margin': '0px 0px 0px 0.5em'});

        // Shuffle the answers.
      var shuffled = [];
      var answer;
      var a;
      while (this.MultipleChoiceAnswers.length > 0) {
        var idx = Math.floor(Math.random() * this.MultipleChoiceAnswers.length);
        answer = this.MultipleChoiceAnswers.splice(idx, 1)[0];
        shuffled.push(answer);
      }
      this.MultipleChoiceAnswers = shuffled;

      // Convert to html
      for (i = 0; i < this.MultipleChoiceAnswers.length; ++i) {
        answer = this.MultipleChoiceAnswers[i];
        if (answer.Input.text() !== '') {
          a = $('<li>')
                    .appendTo(tmp)
                    .addClass('sa-answer')
                    .text(answer.Input.text());
          if (answer.Check.is(':checked')) {
            a.css({'font-weight': 'bold'});
            a.addClass('sa-true');
          }
        }
      }
    }
    if (this.QuestionTypeSelect.val() === 'True or False') {
      this.Div.attr('type', 'true-false');
      // TODO: Share code with multiple choice
      // TODO: Make true false be mutually exclusive (radio button).
      tmp = $('<ol>')
            .appendTo(this.Div)
            .css({'margin': '0px 0px 0px 0.5em'});
      for (i = 0; i < this.TrueFalseAnswers.length; ++i) {
        answer = this.TrueFalseAnswers[i];
        if (answer.Input.text() !== '') {
          a = $('<li>')
                    .appendTo(tmp)
                    .addClass('sa-true-false-answer')
                    .text(answer.Input.text());
          if (answer.Check.is(':checked')) {
            a.css({'font-weight': 'bold'});
            a.addClass('sa-true');
          }
        }
      }
    }
    if (this.QuestionTypeSelect.val() === 'Short Answer') {
      this.Div.attr('type', 'short-answer');
      tmp = $('<div>')
            .appendTo(this.Div)
            .css({'color': '#00C'})
            .addClass('sa-short-answer')
            .text(this.ShortAnswerDiv.text());
    }
  };

// ==============================================================================
// Make any div into a text editor.
// Will be used for the presentation html editor.
// Note,  scalable font should be set before text editor if you want scale buttons.
// TODO:
// - The editor is position 'absolute' and is placed with percentages.
//   Make pixel positioning an option

// args: {dialog: true}
  jQuery.prototype.saTextEditor = function (args) {
    for (var i = 0; i < this.length; ++i) {
      if (!this[i].saTextEditor) {
        var textEditor = new SaTextEditor($(this[i]), args);
        // Add the viewer as an instance variable to the dom object.
        this[i].saTextEditor = textEditor;
        // TODO: Hide any dialog tabs?
      }
      this[i].saTextEditor.ProcessArguments(arguments);
    }

    return this;
  };

// TODO: Figure out a way to get rid of this.
// content editable in divs do not consume key events.
// They propagate to parents. i.e. space causes a slide to advance.
// SA.ContentEditableHasFocus = false;

  function SaTextEditor (div) {
    var self = this;
    this.Div = div;
    this.Div.addClass('sa-text-editor');

    div.saText({click: function () {
      self.EditingOn();
    }});

    // Dialog tab
    var element = div[0].saElement;
    this.TextPanel = element.AddAccordionTab(
        'Text',
        function () { self.DialogInitialize(); },
        function () { self.DialogApply(); });

    // Font Size
    this.FontSizeDiv = $('<div>')
        .appendTo(this.TextPanel)
        .css({'height': '32px'})
        .addClass('sa-view-annotation-modal-div');
    this.FontSizeLabel = $('<div>')
        .appendTo(this.FontSizeDiv)
        .text('Font Size:')
        .addClass('sa-view-annotation-modal-input-label');
    this.FontSize = $('<input type="number">')
        .appendTo(this.FontSizeDiv)
        .addClass('sa-view-annotation-modal-input')
        .keypress(function (event) { return event.keyCode !== 13; });

    // Font Color
    this.FontColorDiv = $('<div>')
        .appendTo(this.TextPanel)
        .css({'height': '32px'})
        .addClass('sa-view-annotation-modal-div');
    this.FontColorLabel = $('<div>')
        .appendTo(this.FontColorDiv)
        .text('Color:')
        .addClass('sa-view-annotation-modal-input-label');
    this.FontColor =
        $('<input type="text">')
        .appendTo(this.FontColorDiv)
        .val('#050505')
        .spectrum({showAlpha: true});

    // Line Height
    this.LineHeightDiv = $('<div>')
        .appendTo(this.TextPanel)
        .css({'height': '32px'})
        .addClass('sa-view-annotation-modal-div');
    this.LineHeightLabel = $('<div>')
        .appendTo(this.LineHeightDiv)
        .text('Line Height %:')
        .addClass('sa-view-annotation-modal-input-label');
    this.LineHeight = $('<input type="number">')
        .appendTo(this.LineHeightDiv)
        .addClass('sa-view-annotation-modal-input')
        .val(1)
        .keypress(function (event) { return event.keyCode !== 13; });

    // Create a div for the editor options.
    // These will only become visible when you click / select
    this.Div.css({'overflow': 'visible'}); // so the buttons are not cut off
    this.EditButtonDiv = $('<div>')
        .appendTo(this.Div.parent())
        .addClass('sa-edit-gui') // Remove before saHtml save.
        .css({'height': '20px',
          'position': 'absolute',
          'width': '275px',
          'cursor': 'auto'})
        .hide()
        // Block the saElement click event.
        .mousedown(function () { return false; });

    this.AddButton(SA.ImagePathUrl + 'link.png', 'link URL',
                   function () { self.InsertUrlLink(); });
    this.AddButton(SA.ImagePathUrl + 'font_bold.png', 'bold',
                   function () {
                     document.execCommand('bold', false, null);
                   });
    this.AddButton(SA.ImagePathUrl + 'text_italic.png', 'italic',
                   function () { document.execCommand('italic', false, null); });
    this.AddButton(SA.ImagePathUrl + 'edit_underline.png', 'underline',
                   function () { document.execCommand('underline', false, null); });
    this.AddButton(SA.ImagePathUrl + 'list_bullets.png', 'unorded list',
                   function () { document.execCommand('InsertUnorderedList', false, null); });
    this.AddButton(SA.ImagePathUrl + 'list_numbers.png', 'ordered list',
                   function () { document.execCommand('InsertOrderedList', false, null); });
    this.AddButton(SA.ImagePathUrl + 'indent_increase.png', 'indent',
                   function () { document.execCommand('indent', false, null); });
    this.AddButton(SA.ImagePathUrl + 'indent_decrease.png', 'outdent',
                   function () { document.execCommand('outdent', false, null); });
    this.AddButton(SA.ImagePathUrl + 'alignment_left.png', 'align left',
                   function () { document.execCommand('justifyLeft', false, null); });
    this.AddButton(SA.ImagePathUrl + 'alignment_center.png', 'align center',
                   function () { document.execCommand('justifyCenter', false, null); });
    this.AddButton(SA.ImagePathUrl + 'alignment_full.png', 'align full',
                   function () { document.execCommand('justifyFull', false, null); });
    this.AddButton(SA.ImagePathUrl + 'edit_superscript.png', 'superscript',
                   function () { document.execCommand('superscript', false, null); });
    this.AddButton(SA.ImagePathUrl + 'edit_subscript.png', 'subscript',
                   function () { document.execCommand('subscript', false, null); });
  }

  SaTextEditor.prototype.EditingOn = function () {
    // Keep text editors from stepping on eachothers events.
    // Only one text editor can edit at a time.
    // I could look if body has the binding 'mousedown.textEditor', but the
    // is now a pain.
    if ($('body')[0].saTextEditing) {
      $('body')[0].saTextEditing.EditingOff();
    }
    $('body')[0].saTextEditing = this;

    var offset = 20;
    var pos = this.Div.position();
    var width = this.Div.outerWidth();
    if (width < 275) { width = 275; }
    var height = this.Div.outerHeight() + offset;
    this.EditButtonDiv
        .css({'left': pos.left + 'px',
          'top': (pos.top - offset) + 'px',
          'width': width + 'px',
          'height': height + 'px'})
        .show();

    // mouse up because it should always propagate.
    var self = this;

    $('body').on(
        'mousedown.textEditor',
        function (e) {
          // We do not want click in the text box (or buttons) to turn
          // off editing.
          if (self.Div[0] !== e.srcElement &&
                 self.EditButtonDiv[0] !== e.srcElement &&
                 !$.contains(self.Div[0], e.srcElement) &&
                 !$.contains(self.EditButtonDiv[0], e.srcElement)) {
            self.EditingOff();
          }
        });

    // Bad name. Actually movable.
    // TODO: Change this name.
    // hack
    this.Div[0].saElement.LockActive = true;
    this.SavedMovable = this.Div[0].saElement.Editable;
    this.Div[0].saElement.EditableOff();
    this.Div[0].saElement.Clickable = false;

    this.Div
        .attr('contenteditable', 'true')
        .css({'cursor': 'text'});

    SA.ContentEditableHasFocus = true;
  };

  SaTextEditor.prototype.EditingOff = function () {
    delete $('body')[0].saTextEditing;
    $('body').off('mousedown.textEditor');

    // Convert the line heights of pasted text to percentages.
    // It will over ride line height set in the properties, maybe I can
    // clear the decendant line heights when the text line height is set
    // explicitly.  I could also ally line height to selected text, but
    // that would be messy.
    var decendants = this.Div.find('*');
    for (var i = 0; i < decendants.length; ++i) {
      if (decendants[i].style.lineHeight.indexOf('px') > -1) {
        var percentage = parseFloat(decendants[i].style.lineHeight);
        percentage = 100 * percentage / parseFloat($(decendants[i]).css('font-size'));
        decendants[i].style.lineHeight = percentage.toString() + '%';
      }
    }

    // Grow the parent div to contain the text.
    var textHeight = this.Div[0].scrollHeight;
    if (textHeight > this.Div.outerHeight()) {
      if (this.Div.css('box-sizing') === 'border-box') {
        this.Div.height(textHeight + 4);
      } else {
        this.Div.outerHeight(textHeight + 4);
      }
      // Aspect ratio on TextEditor is not supported.
      this.Div.trigger('resize');
      this.Div[0].saElement.ConvertToPercentages();
    }

    this.EditButtonDiv.hide();
    // hack
    this.Div[0].saElement.LockActive = false;
    this.Div[0].saElement.ActiveOff();

    if (this.SavedMovable) {
      this.Div[0].saElement.EditableOn();
    }
    this.Div[0].saElement.Clickable = true;
    this.Div
        .attr('contenteditable', 'false')
        .off('mouseleave.textEditor')
        .css('cursor', '');

    SA.ContentEditableHasFocus = false;
  };

  SaTextEditor.prototype.AddButton = function (src, tooltip, callback, prepend) {
    var buttonsDiv = this.EditButtonDiv;

    var button = $('<img>')
        .addClass('editButton')
        .css({'height': '16px'})
        .attr('src', src);
    if (callback) {
      button.click(callback);
    }

    if (tooltip) {
      button.prop('title', tooltip);
    }

    if (prepend) {
      button.prependTo(buttonsDiv);
    } else {
      button.appendTo(buttonsDiv);
    }

    return button;
  };

  SaTextEditor.prototype.ProcessArguments = function (args) {
    args = args || {dialog: true};
    this.Div[0].saText.ProcessArguments(args);

    // generic method call. Give jquery ui access to all this objects methods.
    if (typeof (this[args[0]]) === 'function') {
      // first list item is the method name,
      // the rest are arguments to the method.
      return this[args[0]].apply(this, Array.prototype.slice.call(args, 1));
    }
  };

  SaTextEditor.prototype.DialogInitialize = function () {
    var str;

    // iniitalize the values.
    if (this.Div[0].saScalableFont) {
      var scale = this.Div[0].saScalableFont.scale;
      var fontSize = Math.round(scale * 800);
      this.FontSize.val(fontSize);
    }

    var color = '#000000';
    str = this.Div[0].style.color;
    if (str !== '') {
      color = SAM.ConvertColorToHex(str);
    }
    this.FontColor.spectrum('set', color);

    var lineHeight = 120; // default value?
    str = this.Div[0].style.lineHeight;
    if (str !== '') {
      if (str.substring(str.length - 1) === '%') {
        lineHeight = parseFloat(str.substr(0, str.length - 1));
      }
    }
    this.LineHeight.val(lineHeight);
  };

  SaTextEditor.prototype.DialogApply = function () {
    // this.Div.css({'padding'      : '1%',
    //              'border-radius': '3px'});

    if (this.FontSize) {
      var scale = parseFloat(this.FontSize.val()) / 800;
      var jSel = this.Div;
      // It is contained in a parent scalable font, so just set the attribute.
      // jSel.setAttribute('sa-font-scale', scale.toString());
      jSel.saScalableFont({scale: scale});
    }

    if (this.LineHeight) {
      var lineHeight = parseFloat(this.LineHeight.val());
      this.Div[0].style.lineHeight = lineHeight + '%';
    }

    var color;
    if (this.FontColor) {
      color = this.FontColor.spectrum('get');
      this.Div[0].style.color = color;
    }

    color = '#000000';
    var str = this.Div[0].style.color;
    if (str !== '') {
      color = str;
    }
    this.FontColor.spectrum('set', color);
  };

  SaTextEditor.prototype.Delete = function () {
    this.Div.remove();
  };

  SaTextEditor.prototype.InsertUrlLink = function () {
    var self = this;
    var sel = window.getSelection();
    // This call will clear the selected text if it is not in this editor.
    var range = SA.GetSelectionRange(this.Div);
    var selectedText = sel.toString();

    if (!this.UrlDialog) {
      var dialog = new SAM.Dialog(
            function () {
              self.InsertUrlLinkAccept();
            });
      this.UrlDialog = dialog;
      dialog.Dialog.css({'width': '40em'});
      dialog.Title.text('Paste URL link');
      dialog.TextDiv =
            $('<div>')
            .appendTo(dialog.Body)
            .css({'display': 'table-row',
              'width': '100%'});
      dialog.TextLabel =
            $('<div>')
            .appendTo(dialog.TextDiv)
            .text('Text to display:')
            .css({'display': 'table-cell',
              'height': '2em',
              'text-align': 'left'});
      dialog.TextInput =
            $('<input>')
            .appendTo(dialog.TextDiv)
            .val('#30ff00')
            .css({'display': 'table-cell',
              'width': '25em'});

      dialog.UrlDiv =
            $('<div>')
            .appendTo(dialog.Body)
            .css({'display': 'table-row'});
      dialog.UrlLabel =
            $('<div>')
            .appendTo(dialog.UrlDiv)
            .text('URL link:')
            .css({'display': 'table-cell',
              'text-align': 'left'});
      dialog.UrlInput =
            $('<input>')
            .appendTo(dialog.UrlDiv)
            .val('#30ff00')
            .css({'display': 'table-cell',
              'width': '25em'})
            .on('input', function () {
              var url = self.UrlDialog.UrlInput.val();
              if (self.UrlDialog.LastUrl === self.UrlDialog.TextInput.val()) {
                // The text is same as the URL. Keep them synchronized.
                self.UrlDialog.TextInput.val(url);
              }
              self.UrlDialog.LastUrl = url;
              // Deactivate the apply button if the url is blank.
              if (url === '') {
                self.UrlDialog.ApplyButton.attr('disabled', true);
              } else {
                self.UrlDialog.ApplyButton.attr('disabled', false);
              }
            });
    }

    // We have to save the range/selection because user interaction with
    // the dialog clears the text entry selection.
    this.UrlDialog.SelectionRange = range;
    this.UrlDialog.TextInput.val(selectedText);
    this.UrlDialog.UrlInput.val('');
    this.UrlDialog.LastUrl = '';
    this.UrlDialog.ApplyButton.attr('disabled', true);
    this.UrlDialog.Show(true);
  };

  SaTextEditor.prototype.InsertUrlLinkAccept = function () {
    var sel = window.getSelection();
    var range = this.UrlDialog.SelectionRange;
    if (!range) {
      range = SA.MakeSelectionRange(this.Div);
    }

    // Simply put a span tag around the text with the id of the view.
    // It will be formated by the note hyperlink code.
    var link = document.createElement('a');
    link.href = this.UrlDialog.UrlInput.val();
    link.target = '_blank';

    // It might be nice to have an id to get the href for modification.
    // span.id = note.Id;

    // Replace or insert the text.
    if (!range.collapsed) {
      // Remove the seelcted text.
      range.extractContents(); // deleteContents(); // cloneContents
      range.collapse(true);
    }
    var linkText = this.UrlDialog.TextInput.val();
    if (linkText === '') {
      linkText = this.UrlDialog.UrlInput.val();
    }
    link.appendChild(document.createTextNode(linkText));

    range.insertNode(link);
    if (range.noCursor) {
      // Leave the selection the same as we found it.
      // Ready for the next link.
      sel.removeAllRanges();
    }
  };

  // This does not work yet.!!!!!!!!!!!!!!!
  // Returns the jquery object selected.  If a partial object is selected,
  // the dom is split up into fragments.
  SaTextEditor.prototype.GetSelection = function () {
    var sel = window.getSelection();
    var range;
    var parent = null;

    // Two conditions when we just return the top level div:
    // nothing selected, and something selected in wrong parent.
    // use parent as a flag.
    if (sel.rangeCount > 0) {
      // Something is selected
      range = sel.getRangeAt(0);
      range.noCursor = false;
      // Make sure the selection / cursor is in this editor.
      parent = range.commonAncestorContainer;
      // I could use jquery .parents(), but I bet this is more efficient.
      while (parent && parent !== this.Div[0]) {
            // if ( ! parent) {
                // I believe this happens when outside text is selected.
                // We should we treat this case like nothing is selected.
                // console.log("Wrong parent");
                // return;
            // }
        if (parent) {
          parent = parent.parentNode;
        }
      }
    }
    if (!parent) {
      return this.Div;
    }

    // Insert the fragments without a container.
    var children = range.extractContents().children;
    for (var i = 0; i < children.length; ++i) {
      range.insertNode(children[i]);
    }
    return $(children);

    // Create a new span around the fragment.
    // var newNode = document.createElement('span');
    // newNode.appendChild(range.extractContents());
    // range.insertNode(newNode)
    // return $(newNode);
  };

// Set in position in pixels
  SaTextEditor.prototype.SetPositionPixel = function (x, y) {
    if (this.Percentage) {
      x = 100 * x / this.Div.parent().width();
      y = 100 * y / this.Div.parent().height();
      this.Div[0].style.left = x.toString() + '%';
      this.Div[0].style.top = y.toString() + '%';
    } else {
      this.Div[0].style.left = x + 'px';
      this.Div[0].style.top = y + 'px';
    }
  };

// ==============================================================================
// a "subclass" of SaElement.
// Click expands the element.
// TODO:
// Do not expand images larger than their native resolution (double maybe?)
// Change answer to question in the properties menu.
// Camera gets restored on shrink (even in edit mode)
//   Maybe push pin or camera icon to capture changes

  jQuery.prototype.saLightBox = function (arg1) { // 'arguments' handles extras.
    // Superclass constructor.
    this.saElement();
    this.addClass('sa-light-box');
    for (var i = 0; i < this.length; ++i) {
      if (!this[i].saLightBox) {
        var helper = new SaLightBox($(this[i]));
        // Add the helper as an instance variable to the dom object.
        this[i].saLightBox = helper;
      }
      this[i].saLightBox.ProcessArguments(arguments);
    }

    return this;
  };

  function SaLightBox (div) {
    var self = this;
    div[0].saElement.SetClickCallback(function () { self.Expand(true); });

    this.Div = div;
    this.Expanded = false;
    this.ExpandCallback = null;
    this.AspectRatio = false;
    this.Interactive = true;

    // Mask is to gray out background and consume events.
    // All lightbox items in this parent will share a mask.
    var parent = div.parent();
    this.Mask = parent.find('.sa-light-box-mask');
    if (this.Mask.length === 0) {
      this.Mask = $('<div>')
            .appendTo(parent)
            .addClass('sa-light-box-mask') // So it can be retrieved.
            .addClass('sa-edit-gui') // Remove before saHtml save.
            .hide()
            .css({'position': 'absolute',
              'left': '0px',
              'top': '0px',
              'width': '100%',
              'height': '100%',
              'z-index': '99',
              'opacity': '0.5',
              'background-color': '#000'});
    }
  }

  SaLightBox.prototype.ProcessArguments = function (args) {
    if (args.length === 0) { return; }

    // Superclass
    this.Div[0].saElement.ProcessArguments(args);

    // generic method call. Give jquery ui access to all this objects methods.
    if (typeof (this[args[0]]) === 'function') {
      // first list item is the method name,
      // the rest are arguments to the method.
      return this[args[0]].apply(this, Array.prototype.slice.call(args, 1));
    }

    // Handle the legacy behavior.
    // One argument: an object (like jqueryUI).
    args = args[0];

    if (args.aspectRatio !== undefined) {
      this.AspectRatio = args.aspectRatio;
    }

    // lightbox and element editable flags are not always the same.
    // When expanded, The element editable is turned off.
    if (args.editable !== undefined) {
      this.Editable = args.editable;
    }

    // External control of expanding or shrinking.
    if (args.expand !== undefined) {
      this.Expand(args.expand, args.animate);
    }

    if (args.Interactive !== undefined) {
      this.Interactive = args.interactive;
    }

    // Callback when expanded state changes.
    // Viewer interaction is only enabled when the element expands.
    if (args.onExpand) {
      this.ExpandCallback = args.onExpand;
    }

    // generic method call. Give jquery ui access to all this objects methods.
    if (typeof (this[args[0]]) === 'function') {
      // first list item is the method name,
      // the rest are arguments to the method.
      return this[args[0]].apply(this, Array.prototype.slice.call(args, 1));
    }
  };

// I cannot put this directly as a callback because it
// overwrites the viewer resize method.
  SaLightBox.prototype.UpdateSize = function () {
    if (!this.Expanded) { return; }

    var self = this;
    var left = '5%';
    var top = '5%';
    var width = '90%';
    var height = '90%';
    if (this.AspectRatio) {
      // Hack to get expanded images to resize.
      if (!this.Div[0].onresize) {
        this.Div[0].onresize =
                function () {
                  self.UpdateSize();
                };
        this.Div.addClass('sa-resize');
      }

      // Compute the new size.
      var ratio = this.Div.width() / this.Div.height();
      var pWidth = this.Div.parent().width();
      var pHeight = this.Div.parent().height();
      width = Math.floor(pWidth * 0.9);
      height = Math.floor(pHeight * 0.9);
      if (width / height > ratio) {
        width = Math.floor(height * ratio);
      } else {
        height = Math.floor(width / ratio);
      }
      left = Math.floor(0.5 * (pWidth - width)) + 'px';
      top = Math.floor(0.5 * (pHeight - height)) + 'px';
      width = width + 'px';
      height = height + 'px';
    }

    // Make the image big
    // Not resize handles have z-index 1000 !
    // I am close to just implementing my own resize feature.
    this.Div.css({'z-index': '1001'});
    this.Div.css({'left': left,
      'top': top,
      'width': width,
      'height': height});
  };

  SaLightBox.prototype.Expand = function (flag, animate) {
    if (!this.Interactive) { return; }
    if (flag === this.Expanded) { return; }
    var self = this;
    if (flag) {
      this.Div.saElement({editable: false});
      // We have to disable teh expand behavior too.
      this.Expanded = true;

      // Save the current position and size.
      this.SavedTop = this.Div[0].style.top;
      this.SavedLeft = this.Div[0].style.left;
      this.SavedWidth = this.Div[0].style.width;
      this.SavedHeight = this.Div[0].style.height;
      this.SavedZIndex = this.Div[0].style.zIndex;

      // Make the image big
      // Not resize handles have z-index 1000 !
      // I am close to just implementing my own resize feature.
      this.Div.css({'z-index': '1001'});
      this.UpdateSize();
      this.Div.trigger('resize');

      // Show the mask.
      this.Mask.show();
      // Clicking outside the div will cause the div to shrink back to
      // its original size.
      this.Mask.on(
            'mousedown.lightbox',
            function () {
              self.Expand(false, true);
            });
    } else {
      // Reverse the expansion.
      // hide the mask
      this.Mask.hide();
      // remove event to shrink div.
      this.Mask.off('mousedown.lightbox');
      if (animate) {
        this.Div.animate({'top': self.SavedTop,
          'left': self.SavedLeft,
          'width': self.SavedWidth,
          'height': self.SavedHeight,
          'z-index': self.SavedZIndex},
                             {step: function () { self.Div.trigger('resize'); }});
      } else {
        this.Div.css({'top': self.SavedTop,
          'left': self.SavedLeft,
          'width': self.SavedWidth,
          'height': self.SavedHeight,
          'z-index': self.SavedZIndex});
      }
      this.Expanded = false;
      if (this.Editable) {
        this.Div.saElement({editable: true});
      }
    }

    // External changes with editability (viewer interaction).
    if (this.ExpandCallback) {
      (this.ExpandCallback)(flag);
    }
    this.Div.trigger('resize');
  };

// ==============================================================================
// Combination of lightbox and viewer.
// This simply manages the switch betweenlight box interaction and viewer
// interaction.

  jQuery.prototype.saLightBoxViewer = function (args) {
    if (!args.hideCopyright) {
      args.hideCopyright = true;
    }
    // No zoom widget when minimized.
    if (!args.zoomWidget) {
      args.zoomWidget = false;
    }
    if (!args.dualWidget) {
      args.dualWidget = false;
    }
    if (!args.navigation) {
      args.navigation = false;
    }
    if (!args.drawWidget) {
      args.drawWidget = false;
    }
    if (args.interaction === undefined) {
      args.interaction = false;
    }

    // Small viewer does not have overview
    args.overview = false;

    // sa viewer is separate.  We need to pass the args to saLightBoxToo.
    this.saViewer(args);
    // sa viewer is separate.  We need to pass the args to saLightBoxToo.
    args.onExpand =
        function (expanded) {
          this.Div.saViewer({interaction: expanded});
          if (expanded) {
            this.Div.saViewer({overview: true,
              navigation: true,
              menu: true,
              zoomWidget: true,
              dualWidget: true,
              drawWidget: true});
          } else {
            this.Div.saViewer({overview: false,
              navigation: false,
              menu: false,
              zoomWidget: false,
              dualWidget: false,
              drawWidget: false});
                // This is here to restore the viewer to its
                // initial state when it shrinks
                // TODO: Formalize this hack. Viewer formally needs a note.
                // If not editable, restore the note.
            var display = this.Div[0].saViewer;
            var note = display.saNote;
            if (!this.Div[0].saLightBox.Editable && note) {
              var index = display.saViewerIndex || 0;
              display.SetNote(note, index);
            }
          }
        };
    this.saLightBox(args);
    this.addClass('sa-lightbox-viewer');

    return this;
  };

  // ==============================================================================
  // This is legacy and not used anymore.
  // A common parent for all sa buttons (for this element).
  // Handle showing and hiding buttons.  Internal helper.

  // Just for enabling and disabling the edit buttons
  // cmd: "enable" or "disable"

  // Only one set of buttons are visible at a time.
  var SA_BUTTONS_VISIBLE = null;

  jQuery.prototype.saButtons = function (cmd) {
    var i;
    if (cmd === 'enable') {
      for (i = 0; i < this.length; ++i) {
        saButtonsEnable(this[i]);
      }
    }
    if (cmd === 'disable') {
      for (i = 0; i < this.length; ++i) {
        saButtonsDisable(this[i]);
      }
    }
  };

  function saGetButtonsDiv (domElement) {
    if (!domElement.saButtons) {
      // Edit buttons.
      var helper = new SaButtons($(domElement));
      domElement.saButtons = helper;
    }
    return domElement.saButtons.ButtonsDiv;
  }

  function SaButtons (div) {
    this.Enabled = true;
    this.Div = div;
    this.TimerId = -1;
    var pos = div.position();
    this.ButtonsDiv = $('<div>')
        .appendTo(div.parent())
        .addClass('sa-edit-gui') // So we can remove it when saving.
        .hide()
        .css({'position': 'absolute',
          'left': (pos.left + 10) + 'px',
          'top': (pos.top - 20) + 'px',
          'width': '360px', // TODO: see if we can get rid of the width.
          'z-index': '10'});
    // Make it easy to enable and disable these edit buttons.
    this.ButtonsDiv[0].saButtons = this;
    // Show the buttons on hover.
    var self = this;
    this.ButtonsDiv
        .mouseenter(function () { self.ShowButtons(2); })
        .mouseleave(function () { self.HideButtons(); });

    this.Div
        .mouseenter(function () { self.ShowButtons(1); })
        .mouseleave(function () { self.HideButtons(); });
  }

  SaButtons.prototype.PlaceButtons = function () {
    var pos = this.Div.position();
    this.ButtonsDiv
        .css({'left': (pos.left + 10) + 'px',
          'top': (pos.top - 20) + 'px'});
  };

  SaButtons.prototype.ShowButtons = function (level) {
    if (this.TimerId >= 0) {
      clearTimeout(this.TimerId);
      this.TimerId = -1;
    }
    if (this.Enabled) {
      if (SA_BUTTONS_VISIBLE && SA_BUTTONS_VISIBLE !== this.ButtonsDiv) {
        SA_BUTTONS_VISIBLE.fadeOut(200);
        SA_BUTTONS_VISIBLE = this.ButtonsDiv;
      }
      this.PlaceButtons();
      if (level === 1) {
        this.ButtonsDiv
                .fadeIn(400);
        this.ButtonsDiv.children()
                .css({'opacity': '0.4'});
      } else {
        this.ButtonsDiv
                .show();
        this.ButtonsDiv.children()
                .css({'opacity': '1.0'});
      }
    }
  };

  SaButtons.prototype.HideButtons = function () {
    if (this.TimerId < 0) {
      var self = this;
      this.TimerId =
            setTimeout(function () {
              if (SA_BUTTONS_VISIBLE === self.ButtonsDiv) {
                SA_BUTTONS_VISIBLE = null;
              }
              self.ButtonsDiv.fadeOut(200);
            }, 200);
    }
  };

  function saAddButton (domElement, src, tooltip, callback, prepend) {
    var buttonsDiv = saGetButtonsDiv(domElement);

    var button = $('<img>')
        .addClass('editButton')
        .css({'height': '16px'})
        .attr('src', src);
    if (callback) {
      button.on('click touchstart', callback);
    }

    if (tooltip) {
      button.prop('title', tooltip);
    }

    if (prepend) {
      button.prependTo(buttonsDiv);
    } else {
      button.appendTo(buttonsDiv);
    }

    return button;
  }

  // private functions.
  // TODO: Make an api through jquery to do this.
  function saButtonsDisable (element) {
    if (!element.saButtons) { return; }
    element.saButtons.Enabled = false;
    element.saButtons.ButtonsDiv.hide();
  }

  function saButtonsEnable (element) {
    if (!element.saButtons) { return; }
    element.saButtons.Enabled = true;
  }

// Remove the buttons div.
  function saButtonsDelete (element) {
    if (!element.saButtons) { return; }
    element.saButtons.ButtonsDiv.remove();
  }

// ==============================================================================
// Load html into a div just like .html, but setup slide atlas jquery
// extensions.  The state of these extensions is saved in attributes.
// The extension type is saved as a class.

  jQuery.prototype.saHtml = function (string) {
    if (string) {
      this.html(string);
      this.find('.sa-scalable-font').saScalableFont();
      // this.find('.sa-full-window-option').saFullWindowOption();
      // TODO: Move this out of this file.
      this.find('.sa-presentation-rectangle').saRectangle();
      // Change legacy sa-presentation-view into sa-lightbox-viewer
      this.find('.sa-presentation-view')
            .addClass('sa-lightbox-viewer')
            .removeClass('sa-presentation-view');
      // Get rid of the extra handles we no longer use.
      // the ui-resiable was flakey.  It was eaiser just to code the
      // behavior myself.
      this.find('.ui-resizable-handle').remove();
      this.find('.ui-resizable').removeClass('ui-resizable');

      // We need to load the note.
      var viewDivs = this.find('.sa-lightbox-viewer');
      viewDivs.saLightBoxViewer({'hideCopyright': true,
        'interaction': false});

      for (var i = 0; i < viewDivs.length; ++i) {
        var display = viewDivs[i].saViewer;
        var noteId = $(viewDivs[i]).attr('sa-note-id');
        var viewerIdx = $(viewDivs[i]).attr('sa-viewer-index') || 0;
        viewerIdx = parseInt(viewerIdx);
        // var viewerIdx = $(viewDivs[i]).attr('sa-viewer-index') || 0;
        // viewerIdx = parseInt(viewerIdx);
        // TODO: This should not be here.
        // The saViewer should handle this internally.
        if (noteId) {
          display.SetNoteFromId(noteId, viewerIdx);
        }
      }

      if (SA.Edit) {
        var items = this.find('.sa-resizable');
        // temporary to make previous editors draggable.
        items = this.find('.sa-text-editor');
        items.saTextEditor({editable: true});

        items = this.find('.sa-presentation-rectangle');
        items.saRectangle({editable: true});

        items = this.find('.sa-question');
        items.saQuestion({editable: true});

        items = this.find('.sa-presentation-image');
        items.saLightBox({aspectRatio: true,
          editable: true});

        items = this.find('.sa-lightbox-viewer');
        items.saViewer({drawWidget: false});
      } else {
        // I need the text to show when the bounds are too small.
        items = this.find('.sa-text-editor');
        items.css({'overflow': 'visible'});
      }

      return;
    }

    // Shrink any light box elements that are expanded.
    this.find('.sa-light-box').saLightBox({'expand': false, 'animate': false});

    // Items that are not visible loos their position.
    this.find('.sa-quiz-hide').show();
    this.find('.sa-presentation-title').show();

    // Get rid of the <gui elements when returning the html.
    var copy = this.clone();
    copy.find('.sa-edit-gui').remove();
    copy.find('.sa-standin').remove();
    copy.find('.ui-resizable').resizable('destroy');
    // copy.find('.ui-resizable-handle').remove();

    // Get rid of the children of the sa-presentation-view.
    // They will be recreated by viewer when the html is loaded.
    copy.find('.sa-lightbox-viewer').empty();

    return copy.html();
  };

// ==============================================================================
// LEGACY
// Just add the feature of setting width and height as percentages.

  jQuery.prototype.saResizable = function (args) {
    args = args || {};
    args.start = function (e, ui) {
      if (this.saViewer) {
            // Translate events were being triggered in the viewer.
        this.saViewer.DisableInteraction();
      }
    };
    args.stop = function (e, ui) {
      // change the width to a percentage.
      var width = $(this).width();
      width = 100 * width / $(this).parent().width();
      this.style.width = width.toString() + '%';
      // change the height to a percentage.
      var height = $(this).height();
      height = 100 * height / $(this).parent().height();
      this.style.height = height.toString() + '%';

      // We have to change the top and left ot percentages too.
      // I might have to make my own resizable to get the exact behavior
      // I want.
      var pos = $(this).position();
      var top = 100 * pos.top / $(this).parent().height();
      var left = 100 * pos.left / $(this).parent().width();
      this.style.top = top.toString() + '%';
      this.style.left = left.toString() + '%';
    };

    this.addClass('sa-resizable');

    return this;
  };

// ==============================================================================
// Attempting to make the viewer a jqueryUI widget.
// Note:  It does not make sense to call this on multiple divs at once when
//        the note/view is being set.
// args = {interaction:true,
//         overview:true,
//         menu:true,
//         drawWidget:true,
//         zoomWidget:true,
//         viewId:"55f834dd3f24e56314a56b12", note: {...}
//         viewerIndex: 0,
//         hideCopyright: false}
// viewId (which loads a note) or a preloaded note can be specified.
// the viewId has precedence over note if both are given.
// viewerIndex of the note defaults to 0.
// Note: hideCopyright will turn off when a new note is loaded.
  jQuery.prototype.saViewer = function (args) {
    return SAViewer(this, args);
  };
  // Non jquery api
  var SAViewer = function (element, args) {
    // default
    args = args || {};
    if (typeof (args) === 'object') {
      // This is ignored if there is not viewId or note.
      args.viewerIndex = args.viewerIndex || 0;
    }
    // get the note object if an id is specified.
    if (args.viewId) {
      args.note = SA.GetNoteFromId(args.viewId);
      if (args.note === null) {
        // It has not been loaded yet.  Get if from the server.
        args.note = new SA.Note();
        args.note.LoadViewId(
                args.viewId,
                function () {
                  saViewerSetup(arguments);
                });
        return element;
      }
    }

    // User can call a viewer method through thie jquery api.
    // Pass on the return value if it has one.
    if (arguments.length === 0) {
      return saViewerSetup([element, args]) || element;
    }
    return saViewerSetup(arguments) || element;
  };

  // I am struggling for an API to choose between single view and dual view.
  // - I considered saDualViewer, but it is nearly identical to saViewer and
  // saLightBoxViewer does not know which to create because it does not have
  // the note early enough.
  // - I consider hinging it on the existence of sa-viewer-index but that is
  // hidden and not obvious.
  // I choose to pass an argument flag "dual", but am sure how to store the
  // flag in html. I could have an attribute "dual", but I think I like to
  // change the class from sa-viewer to sa-dual-viewer better.
  // TODO: Make the argument calls not dependant on order.
  function saViewerSetup (args) {
    // TODO: Think about making this viewer specific rather than a global.

    var self = args[0];

    // legacy api: params encoded in second arguement object.
    var params;
    if (typeof (args[1]) === 'object') {
      params = args[1];
    }

    if (params && params.prefixUrl) {
      SA.ImagePathUrl = params.prefixUrl;
      SAM.ImagePathUrl = params.prefixUrl;
    }

    $(window)
        .off('resize.sa')
        .on('resize.sa', saResizeCallback);

    for (var i = 0; i < self.length; ++i) {
      if (args[1] === 'destroy') {
        $(self[i]).removeClass('sa-resize');
        // This should not cause a problem.
        // Only one resize element should be using this element.
        $(self[i]).removeClass('sa-resize');
        $(self[i]).removeClass('sa-viewer');
        if (self[i].saViewer) {
          self[i].saViewer.Delete();
          delete self[i].saViewer;
        }
        continue;
      }

      if (!self[i].saViewer) {
        if (params) {
          // look for class name.
          if (self.hasClass('sa-dual-viewer')) {
            params.dual = true;
          }
          // Add the viewer as an instance variable to the dom object.
          if (params.dual) {
            // TODO: dual has to be set on the first call.  Make this
            // order independant. Also get rid of args here. We should
            // use process arguments to setup options.
            self[i].saViewer = new SA.DualViewWidget($(self[i]));
          } else {
            self[i].saViewer = new SA.Viewer($(self[i]));
          }
        }

        // When the div resizes, we need to synch the camera and
        // canvas.
        self[i].onresize =
                function () {
                  this.saViewer.UpdateSize();
                };
        // Only the body seems to trigger onresize.  We need to trigger
        // it explicitly (from the body onresize function).
        $(self[i]).addClass('sa-resize');
      }
      // generic method call. Give jquery ui access to all this objects methods.
      // jquery puts the query results as the first argument.
      var viewer = self[i].saViewer;
      if (viewer && typeof (viewer[args[1]]) === 'function') {
        // first list item is the method name,
        // the rest are arguments to the method.
        return viewer[args[1]].apply(viewer, Array.prototype.slice.call(args, 2));
      }

      if (params) {
        self[i].saViewer.ProcessArguments(params);
      }
      self[i].saViewer.EventuallyRender();
    }
  }

  // This put changes from the viewer in to the note.
  // Is there a better way to do this?
  // Maybe a save method?
  jQuery.prototype.saRecordViewer = function () {
    for (var i = 0; i < this.length; ++i) {
      if (this[i].saViewer && this[i].saViewer.saNote) {
        var idx = this[i].saViewer.saViewerIndex || 0;
        var note = this[i].saViewer.saNote;
        this[i].saViewer.Record(note, idx);
      }
    }
  };

// ==============================================================================
// JQuery items are not responding to resize events.  This fixes the
// problem by using window resize event for all
// NOTE: This depends on saFullSize callbacks.
  jQuery.prototype.saOnResize = function (callback) {
    this.addClass('sa-resize');
    for (var i = 0; i < this.length; ++i) {
      this[i].onresize = callback;
    }

    return this;
  };

  jQuery.prototype.saTriggerResize = function () {
    $(window).trigger('resize');
  };

// ==============================================================================
// jQuery extension for a full window div.
// parent must be the body?  Maybe not.  Lets see if a full height is better.
// I think position should be set to fixed or absolute.

// TODO: Convert the viewer to use this.

  function saResizeCallback () {
    var height = window.innerHeight;
    var items = $('.sa-full-height');
    for (var i = 0; i < items.length; ++i) {
      var item = items[i];
      $(item).css({'top': '0px',
        'height': height + 'px'});
    }
    // Hack until I can figure out why the resize event is not
    // firing for descendants.
    // This did not work.  It also triggered resize on the window
    // causeing infinite recusion.
    // $('.sa-resize').trigger('resize');
    // call onresize manually.
    var elements = $('.sa-resize');
    for (i = 0; i < elements.length; ++i) {
      if (elements[i].onresize) {
        elements[i].onresize();
      }
    }
  }

  // ==============================================================================
  // Non jquery api
  // Building block for an accordian viewer.
  // TODO: open and close callbacks.
  var saAccordianDiv = function (parent, label) {
    var labelDiv = $('<div>')
      .appendTo(parent)
      .css({'display': 'block'});
    var openCloseIcon = $('<img>')
      .appendTo(labelDiv)
      .attr('src', SA.ImagePathUrl + 'plus.png');
    var labelSpan = $('<span>')
      .appendTo(labelDiv)
      .css({'padding-left': '5px'})
      .text(label);
    var contents = $('<div>')
      .appendTo(parent)
      .css({
        'display': 'block',
        'padding-left': '17px'})
      .hide();
    var open = false;
    // Hack?  Still trying to combine objects with jquery api.
    // I want to return the jquery  reference, but also have methods.
    // Attach methods to the dom object.
    contents[0].open = function () {
      open = true;
      contents.slideDown();
      openCloseIcon.attr('src', SA.ImagePathUrl + 'minus.png');
      if (this.openCallback) {
        this.openCallback();
      }
    };
    contents[0].setOpenCallback = function (callback) {
      this.openCallback = callback;
    };

    contents[0].close = function () {
      open = false;
      contents.slideUp();
      openCloseIcon.attr('src', SA.ImagePathUrl + 'plus.png');
    };
    contents[0].getOpen = function () {
      return open;
    };
    contents[0].getLabel = function () {
      return labelSpan;
    };
    openCloseIcon.on('click touchstart',
                     function () {
                       if (open) {
                         contents[0].close();
                       } else {
                         contents[0].open();
                       }
                     });
    return contents;
  };

  // ==============================================================================
  // Non jquery api
  // Give any div the option to go fullscreen. This returns a jquery
  // reference to the full screen button so the user can position in.
  // The user can even choose their own image for the button.
  // TODO: callbacks for start and stop full screen.
  var SAFullScreenButton = function (parent) {
    var fullScreenFlag = false;
    var savedHeight = 'auto';
    var savedParent = parent;

    var fullScreenButton = $('<img>')
        .appendTo(parent)
        .prop('title', 'full screen')
        .addClass('sa-view-button')
        .attr('src', SA.ImagePathUrl + 'fullScreen32.png')
        .css({
          'position': 'absolute',
          'height': '24px',
          'z-index': '300'});

    // Attach variables to the dom button
    var self = fullScreenButton[0];
    fullScreenButton.on(
      'click touchend',
      function (e) {
        e.preventDefault();
        // variable 'this' is probably the same as 'self' here.
        var elem = parent[0];

        if (SAM.MOBILE_DEVICE === 'iPad') {
          fullScreenFlag = !fullScreenFlag;
          if (fullScreenFlag) {
            savedHeight = parent.css('height');

            // just make the viewer fill the body.
            var height = window.innerHeight;
            $(elem).appendTo('body');
            $(elem)
              .css({
                'z-index': '100',
                'background-color': '#fff',
                'position': 'fixed',
                'left': '0',
                'top': '0',
                'width': '100%',
                'height': height + 'px'});
            fullScreenButton.attr('src', SA.ImagePathUrl + 'fullScreenOff32.png');
          } else {
            $(elem)
              .appendTo(savedParent)
              .css({
                'position': 'static',
                'height': savedHeight});
            console.log(savedHeight);
            fullScreenButton.attr('src', SA.ImagePathUrl + 'fullScreen32.png');
          }
          $(window).trigger('resize');
        } else {
          fullScreenFlag = !fullScreenFlag;
          if (fullScreenFlag) {
            var req;
            req = elem.requestFullScreen ||
              elem.webkitRequestFullScreen ||
              elem.mozRequestFullScreen;
            req.call(elem);
          } else {
            if (document.exitFullscreen) {
              document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
              document.webkitExitFullscreen();
            } else if (document.mozCancelFullScreen) {
              document.mozCancelFullScreen();
            } else if (document.msExitFullscreen) {
              document.msExitFullscreen();
            }
          }
        }
        $(window).trigger('resize');
      });

    // detect when we leave full screen.
    parent.on(
        'webkitfullscreenchange mozfullscreenchange fullscreenchange',
        function (e) {
          var state = document.fullScreen || document.mozFullScreen ||
                document.webkitIsFullScreen;
          if (state) {
            // Entering full screen
            savedHeight = parent.css('height');
            fullScreenFlag = true;
            fullScreenButton.attr('src', SA.ImagePathUrl + 'fullScreenOff32.png');
            parent.css({'height': '100%'});
          } else {
            // Exiting full screen
            $(self).show();
            fullScreenFlag = false;
            fullScreenButton.attr('src', SA.ImagePathUrl + 'fullScreen32.png');
            // parent.css({'height': 'auto'});
            parent.css({'height': savedHeight});
            console.log(savedHeight);
          }
          $(window).trigger('resize');
        });
    return fullScreenButton;
  };

  // Args: not used
  jQuery.prototype.saFullHeight = function (args) {
    return SAFullHeight(this, args);
  };

  // ==============================================================================
  // Non jquery api
  // Add resize callbacks that make a jquery element fit the windows height.
  var SAFullHeight = function (element, args) {
    element.css({'top': '0px'});
    element.addClass('sa-full-height');
    for (var i = 0; i < element.length; ++i) {
      // I want to put the resize event on "element[i]",
      // but, I am afraid it might not get trigerend always, or
      // setting the height would cause recursive calls to resize.
      element[i].saFullHeight = args;
    }

    $(window)
        .off('resize.sa')
        .on('resize.sa', saResizeCallback)
        .trigger('resize');

    return element;
  };

  // ==============================================================================
  // Make this window as large as possible in parent, but keep the aspect
  // ratio. This is for presentation windows.
  // Note:  Position of parent has to be not static.
  //        Should I make the position relative rather than absolute?
  jQuery.prototype.saPresentation = function (args) {
    this.addClass('sa-presentation');
    this.addClass('sa-resize');

    $(window)
        .off('resize.sa')
        .on('resize.sa', saResizeCallback)
        .trigger('resize');

    for (var i = 0; i < this.length; ++i) {
      var item = this[i];
      if (!item.saPresentation) {
        item.saPresentation = new SaPresentation($(item), args);
        item.onresize =
                function () {
                  this.saPresentation.Resize();
                };
      }
      // Trouble if their is more than 1.  Maybe trigger
      // a window resize?
      setTimeout(function () { item.saPresentation.Resize(); }, 300);
    }

    return this;
  };

  function SaPresentation (div, args) {
    this.Div = div;
    this.AspectRatio = args.aspectRatio;
    this.Zoom = 1.0;
    this.ShiftX = 0;
    this.ShiftY = 0;

    // Setup events to pan and zoom the presentation window.
    /* var self = this;
    this.Div.on(
        'mousedown.presentation',
        function (e) {
            return self.HandleMouseDown(e);
        });
    */
    // Text is not scaling properly
    /*
    this.Div.on(
        'mousewheel.presentation',
        function(event){
            // Resize from the middle.
            return self.HandleMouseWheel(event.originalEvent);
        });
        */
  }

  SaPresentation.prototype.Resize = function () {
    var ar = this.AspectRatio;
    var parent = this.Div.parent();
    var pWidth = parent.innerWidth();
    var pHeight = parent.innerHeight();
    var width = pWidth;
    var height = pHeight;
    if (width / height > ar) {
      // Window is too wide.
      width = height * ar;
    } else {
      // Window is too tall.
      height = width / ar;
    }
    width = width * this.Zoom;
    height = height * this.Zoom;
    var left = (pWidth - width) * 0.5 + this.ShiftX;
    var top = (pHeight - height) * 0.5 + this.ShiftY;

    this.Div.css({
      'position': 'absolute',
      'top': top + 'px',
      'height': height + 'px',
      'left': left + 'px',
      'width': width + 'px'});
  };

  SaPresentation.prototype.HandleMouseDown = function (event) {
    var self = this;
    // For tap/click rather than drag.
    this.ClickStart = Date.now();

    if (event.which === 1 || event.which === 3) {
      $('body').on(
            'mouseup.presentation',
            function (e) {
              return self.HandleMouseUp(e);
            });
    }

    if (event.which === 1) {
      $('body').on(
            'mousemove.presentation',
            function (e) {
              return self.HandleMouseMove(e);
            });
      $('body').on(
            'mouseleave.presentation',
            function (e) {
              return self.HandleMouseUp(e);
            });
      this.DragLastX = event.screenX;
      this.DragLastY = event.screenY;

      return false;
    }
  };

  // TODO: rethink offset/zoom.  Scale from the middle. Offset should
  // be in percentages maybe
  SaPresentation.prototype.HandleMouseWheel = function (event) {
    var tmp = 0;
    if (event.deltaY) {
      tmp = event.deltaY;
    } else if (event.wheelDelta) {
      tmp = event.wheelDelta;
    }
    if (tmp === 0) { return; }
    // Wheel event seems to be in increments of 3.
    // depreciated mousewheel had increments of 120....
    // Initial delta cause another bug.
    // Lets restrict to one zoom step per event.
    if (tmp > 0) {
      this.Zoom *= 1.01;
    } else if (tmp < 0) {
      this.Zoom *= 0.99;
    }
    this.Resize();

    return false;
  };

  SaPresentation.prototype.HandleMouseMove = function (event) {
    // Wait for the click duration to start dragging.
    if (Date.now() - this.ClickStart < 200) {
      return true;
    }

    if (event.which === 1) {
      var dx = event.screenX - this.DragLastX;
      var dy = event.screenY - this.DragLastY;
      this.DragLastX = event.screenX;
      this.DragLastY = event.screenY;

      this.ShiftX += dx;
      this.ShiftY += dy;
      this.Resize();
      return false;
    }
    return true;
  };

  SaPresentation.prototype.HandleMouseUp = function (event) {
    $('body').off('mouseup.presentation');
    if (event.which === 1) {
      $('body').off('mousemove.presentation');
      $('body').off('mouseleave.presentation');
    }

    return true;
  };

// ==============================================================================
// Font is set as a percentage of the parent height.
// args.size: string i.e. "12%" More work would be needed to make this
// units in pixels.
  jQuery.prototype.saScalableFont = function (args) {
    this.addClass('sa-scalable-font');
    this.addClass('sa-resize');

    $(window)
        .off('resize.sa')
        .on('resize.sa', saResizeCallback);

    for (var i = 0; i < this.length; ++i) {
      var text = this[i];
      if (!text.saScalableFont) {
        text.onresize =
                function () {
                  scale = this.saScalableFont.scale;
                  // Scale it relative to the window.
                  var height = $(this).parent().innerHeight();
                  var fontSize = Math.round(scale * height) + 'px';
                  this.style.fontSize = fontSize;
                  // Getting and setting the html creates text chidlren
                  // with their own font size.
                  $(this).children('font').css({'font-size': fontSize});
                };
        text.saScalableFont = {};
        text.saScalableFont.scale = 0.1;
      }
      var scale = text.saScalableFont.scale;
      // html() saves this attribute.
      // this will restore the scale.
      var scaleStr = text.getAttribute('sa-font-scale');
      if (scaleStr) {
        scale = parseFloat(scaleStr);
      }
      // This overrides the previous two.
      if (args && args.scale) {
        // convert to a decimal.
        scale = args.scale;
        if (typeof (scale) === 'string') {
          if (scale.substring(-1) === '%') {
            scale = parseFloat(scale.substr(0, scale.length - 1)) / 100;
          } else {
            scale = parseFloat(scale);
          }
        }
      }
      // I can either keep this up to date or set it when the
      // saHtml is called. Keeping it set is more local.
      text.setAttribute('sa-font-scale', scale.toString());
      text.saScalableFont.scale = scale;
      text.onresize();
    }

    return this;
  };

// ==============================================================================
// legacy: not used anymore
// draggable with a handle
// TODO: This uses percentages now.  Exxtend with the option to position
// with pixel units.
// args = {grid: [xDivisions, yDivisions]}
  jQuery.prototype.saDraggable = function (args) {
    args = args || {grid: [30, 39]};
    this.addClass('sa-draggable');
    for (var i = 0; i < this.length; ++i) {
      if (!this[i].saDraggable) {
        var helper = new SaDraggable($(this[i]));
        // Add the helper as an instance variable to the dom object.
        this[i].saDraggable = helper;
      }
      this[i].saDraggable.ProcessArguments(args);
    }

    return this;
  };

  function SaDraggable (div) {
    this.XStops = null;
    this.YStops = null;
    this.Percentage = true;
    this.Div = div;

    var self = this;
    var d = saAddButton(div[0], SA.ImagePathUrl + 'fullscreen.png',
                        'drag', null, true);
    d.mousedown(
        function (e) {
          // raise to the top of the layers.
          // this did not work for text boxes on top of views.
          // it did work for mutiple views.
          var parent = self.Div.parent();
          self.Div.detach();
          self.Div.appendTo(parent);

          self.Div.css({'z-index': '5'});

          self.OldX = e.pageX;
          self.OldY = e.pageY;

          var pos = self.Div.position();
          var x = pos.left;
          var y = pos.top;
          var width = self.Div.parent().width();
          var height = self.Div.parent().height();
          if (self.XStops) { self.XStops.Start(x, width); }
          if (self.YStops) { self.YStops.Start(y, height); }
          $('body').on('mousemove.saDrag',
                      function (e) {
                        self.Drag(e.pageX - self.OldX, e.pageY - self.OldY);
                        self.OldX = e.pageX;
                        self.OldY = e.pageY;
                        return false;
                      });
          $('body').on('mouseup.saDrag',
                      function (e) {
                        self.Div.css('z-index', '');
                        $('body').off('mousemove.saDrag');
                        $('body').off('mouseup.saDrag');
                        return false;
                      });
          return false;
        });
  }

  SaDraggable.prototype.ProcessArguments = function (args) {
    if (args.grid) {
      // The grid is not shared.
      this.XStops = new SaStops(args.grid[0]);
      this.YStops = new SaStops(args.grid[1]);
    }

    // generic method call. Give jquery ui access to all this objects methods.
    if (typeof (this[args[0]]) === 'function') {
      // first list item is the method name,
      // the rest are arguments to the method.
      return this[args[0]].apply(this, Array.prototype.slice.call(args, 1));
    }
  };

  // (dx, dy) drag vector in pixels.
  SaDraggable.prototype.Drag = function (dx, dy) {
    var pos = this.Div.position();
    var x = pos.left;
    var y = pos.top;

    var width = this.Div.parent().width();
    var height = this.Div.parent().height();
    var nx = x + dx;
    var ny = y + dy;
    if (this.XStops) {
      nx = this.XStops.Drag(dx);
    }
    if (this.YStops) {
      ny = this.YStops.Drag(dy);
    }

    if (this.Percentage) {
      nx = nx / width;
      ny = ny / height;
      nx = nx * 100;
      ny = ny * 100;
      this.Div[0].style.left = nx + '%';
      this.Div[0].style.top = ny + '%';
    } else {
      this.Div[0].style.left = nx + 'px';
      this.Div[0].style.top = ny + 'px';
    }

    this.Div[0].saButtons.PlaceButtons();
  };

  function SaStops (divisions) {
    // How far do we hve to pass a stop before the item snaps to the mouse.
    this.Threshold = 25;
    // Current Stop
    this.Stopped = false;
    this.Stop = 0;  // TODO: This is not necessary.  Just use last.
    // The amount of drag saved up so far to get out of a stop.
    this.Delta = 0;

    // For speed up factor to account for stopped regions.
    this.Target = 0;
    this.Gap = 100.0;

    // Even positioning of the division.
    this.Divisions = divisions;
    // The current position of the item.
    this.Last = 0;
  }

  SaStops.prototype.Start = function (last, size) {
    this.Stopped = false;
    this.Delta = 0;
    this.Last = last;
    this.Size = size;

    this.Target = last;
    this.Gap = size / this.Divisions;
  };

// last and size could have changed since the last time this was called,
// so pass them in again.
// return:
//   the new position of the item (same units as args).
// arguments (all in the same units):
//   size: width of window
//   last: The current position of the item.
//   delta: The distance the mouse has moved.
  SaStops.prototype.Drag = function (delta) {
    // Put a compensation factor so item follows mouse.
    this.Target += delta;
    delta = delta + 3 * (this.Target - this.Last) / this.Gap;

    // Where we should be without the stop.
    var next = this.Last + delta;

    if (this.Stopped) {
      // Acculilate the movement.
      this.Delta = this.Delta + delta;
      // Have we passed the threshold to exit?
      if (Math.abs(this.Delta) > this.Threshold) {
        // yes
        this.Stopped = false;
        this.Delta = 0;
        this.Last = next;
        return next;
      }
      // no
      return this.Stop;
    }

    // We are note stopped yet.
    // Have we passed a stop?  Get the nearest stop value.
    var stop = this.GetStop(this.Last, next);

    if (stop < this.Last && stop < next) {
      // We did not pass a stop.
      this.Delta = 0;
      this.Last = next;
      return next;
    }
    if (stop > this.Last && stop > next) {
      // We did not pass a stop.
      this.Delta = 0;
      this.Last = next;
      return next;
    }

    // Stop is in middle.  Start the Stopped behavior.
    this.Delta = next - stop;
    this.Last = stop;
    this.Stop = stop;
    this.Stopped = true;

    return stop;
  };

  SaStops.prototype.GetStop = function (last, next) {
    // Put the stops at integer values.
    var last2 = last * this.Divisions / this.Size;
    var next2 = next * this.Divisions / this.Size;
    // transform motion to be positive;
    if (next2 < last2) {
      var tmp = last2;
      last2 = next2;
      next2 = tmp;
    }
    // Find the last stop passed.
    var stop = Math.floor(next2);
    stop = stop * this.Size / this.Divisions;

    return stop;
  };

// ==============================================================================
// DUPLICATE feature
// TODO: remove this
// Option to go full window.  This is intended for viewers, but might be
// made general.

// TODO: We need callbacks when it goes full and back.

// args: "off"  turns full window off.
  jQuery.prototype.saFullWindowOption = function (args) {
    this.addClass('sa-full-window-option');
    for (var i = 0; i < this.length; ++i) {
      if (!this[i].saFullWindowOption) {
        var helper = new SaFullWindowOption($(this[i]));
        // Add the helper as an instance variable to the dom object.
        this[i].saFullWindowOption = helper;
      }
      if (args === 'off') {
        this[i].saFullWindowOption.SetFullWindow($(this[i]), false);
      }
    }

    return this;
  };

  function SaFullWindowOption (div) {
    var self = this;
    this.FullWindowOptionButton = $('<img>')
      .appendTo(div)
      .attr('src', SA.ImagePathUrl + 'fullscreenOn.png')
      .prop('title', 'full window')
      .css({
        'position': 'absolute',
        'width': '12px',
        'left': '-5px',
        'top': '-5px',
        'opacity': '0.5',
        'z-index': '-1'})
      .hover(function () { $(this).css({'opacity': '1.0'}); },
             function () { $(this).css({'opacity': '0.5'}); })
      .on('click touchstart',
          function () {
            self.SetFullWindow(div, true);
          });

    this.FullWindowOptionOffButton = $('<img>')
      .appendTo(div)
      .hide()
      .attr('src', SA.ImagePathUrl + 'fullscreenOff.png')
      .prop('title', 'full window off')
      .css({
        'position': 'absolute',
        'background': '#FFF',
        'width': '16px',
        'left': '1px',
        'top': '1px',
        'opacity': '0.5',
        'z-index': '-1'})
      .hover(function () { $(this).css({'opacity': '1.0'}); },
             function () { $(this).css({'opacity': '0.5'}); })
      .on('click touchstart',
          function () {
            self.SetFullWindow(div, false);
          });
  }

  // TODO: Turn off other editing options: drag, delete, resize.
  SaFullWindowOption.prototype.SetFullWindow = function (div, flag) {
    if (flag) {
      // TODO: Put this in a call back.
      saButtonsDisable(div[0]);
      this.FullWindowOptionOffButton.show();
      this.FullWindowOptionButton.hide();
      // Save the css values to undo.
      this.Left = div[0].style.left;
      this.Width = div[0].style.width;
      this.Top = div[0].style.top;
      this.Height = div[0].style.height;
      this.ZIndex = div[0].style.zIndex;
      div.css({
        'left': '0px',
        'width': '100%',
        'top': '0px',
        'height': '100%',
        'z-index': '10'});
    } else {
      saButtonsEnable(div[0]);
      this.FullWindowOptionOffButton.hide();
      this.FullWindowOptionButton.show();
      div.css({
        'left': this.Left,
        'width': this.Width,
        'top': this.Top,
        'height': this.Height,
        'z-index': this.ZIndex});
    }
    // The viewers need a resize event to change their cameras.
    $(window).trigger('resize');
  };

  // ==============================================================================
  // LEGACY
  // Add a delete button to the jquery objects.

  jQuery.prototype.saDeletable = function (args) {
    this.addClass('sa-deletable');
    for (var i = 0; i < this.length; ++i) {
      var domItem = this[i];
      if (!domItem.saDeletable) {
        // for closure (save element)
        domItem.saDeletable = new SaDeletable(domItem);
      }
    }
    return this;
  };

  // check dom
  function SaDeletable (domItem) {
    this.Button = saAddButton(
        domItem, SA.ImagePathUrl + 'remove.png', 'delete',
        function () {
          // if we want to get rid of the viewer records,
          if (domItem.saViewer) {
            saPruneViewerRecord(domItem.saViewer);
          }
          saButtonsDelete(domItem);
          $(domItem).remove();
        },
        true);
  }

  function saPruneViewerRecord (viewer) {
    // In order to prune, we will need to find the other viewers associated
    // with records in the notes.
    // This is sort of hackish.
    var viewerIdx = viewer.saViewerIndex;
    var note = viewer.saNote;
    var items = $('.sa-lightbox-viewer');
    // Shift all the larger indexes down one.
    for (var i = 0; i < items.length; ++i) {
      if (items[i].saViewer &&
            items[i].saViewer.saNote === note &&
            items[i].saViewer.saViewerIndex > viewerIdx) {
        --items[i].saViewer.saViewerIndex;
      }
    }
    // Remove the viewer record for this viewer.
    note.ViewerRecords.splice(viewerIdx, 1);
  }

// ==============================================================================
// I am having such troubles setting the right panel width to fill.
// Solution is to have this element control too divs (panel and main).
// If the panel overlaps the main, we do not need to manage the main panel.
// It would have to be implemented on the panel div, not the parent div.

// TODO: Verify this works in a stand alone page.
// args
// option to specify the handle.
// option to place panel: left, right, top, bottom.
// Use it for the Notes panel.
// Use it for the presentation edit panel
// use it for dual view.

  function ResizePanel (parent) {
    var self = this;

    // For animating the display of the notes window (DIV).
    this.Width = 353;

    this.PanelDiv = $('<div>').appendTo(parent)
        .css({
          'background-color': 'white',
          'position': 'absolute',
          'top': '0px',
          'bottom': '0px',
          'left': '0px',
          'width': this.Width + 'px'})
        .attr('draggable', 'false')
        .on('dragstart', function () { return false; });
    this.MainDiv = $('<div>').appendTo(parent)
        .css({
          'position': 'absolute',
          'top': '0px',
          'bottom': '0px',
          'left': this.Width + 'px',
          'right': '0px',
          'border-left': '1px solid #AAA'})
        .attr('draggable', 'false')
        .on('dragstart', function () { return false; });

    this.OpenButton = $('<img>')
        .appendTo(this.MainDiv)
        .css({'position': 'absolute',
          'height': '20px',
          'width': '20px',
          'top': '0px',
          'left': '1px',
          'opacity': '0.6',
          '-moz-user-select': 'none',
          '-webkit-user-select': 'none',
          'z-index': '6'})
        .attr('src', SA.ImagePathUrl + 'dualArrowRight2.png')
        .on('click touchstart',
            function () { self.SetVisibility(true); })
        .attr('draggable', 'false')
        .hide()
        .on('dragstart', function () {
          return false;
        });

    // I have no idea why the position right does not work.
    this.CloseButton = $('<img>')
        .appendTo(this.MainDiv)
        .css({'position': 'absolute',
          'height': '20px',
          'top': '0px',
          'left': '-22px',
          'opacity': '0.6',
          '-moz-user-select': 'none',
          '-webkit-user-select': 'none',
          'z-index': '6'})
        // .hide()
        .attr('src', SA.ImagePathUrl + 'dualArrowLeft2.png')
        .on('click touchstart',
            function () { self.SetVisibility(false); })
        .attr('draggable', 'false')
        .on('dragstart', function () {
          return false;
        });

    this.Visibility = true;
    this.Dragging = false;

    this.ResizeEdge = $('<div>')
        .appendTo(parent)
        .css({'position': 'absolute',
          'height': '100%',
          'width': '3px',
          'top': '0px',
          'left': this.Width + 'px',
          'background': '#BDF',
          'z-index': '10',
          'cursor': 'col-resize'})
        .hover(function () { $(this).css({'background': '#9BF'}); },
               function () { $(this).css({'background': '#BDF'}); })
        .mousedown(function () {
          self.StartDrag();
          return false;
        });
  }

  // TODO: Remove reference to body directly
  // Maybe use parent.
  ResizePanel.prototype.StartDrag = function () {
    this.Dragging = true;
    var self = this;
    this.TmpDrag = function (e) { return self.ResizeDrag(e); };
    this.TmpStop = function (e) { return self.ResizeStopDrag(e); };
    $('body').on('mousemove', this.TmpDrag);
    $('body').on('mouseup', this.TmpStop);
    $('body').css({'cursor': 'col-resize'});
  };

  ResizePanel.prototype.ResizeDrag = function (e) {
    this.SetWidth(e.pageX - 1);
    if (this.Width < 200) {
      this.ResizeStopDrag();
      this.SetVisibility(false);
    }

    return false;
  };

  ResizePanel.prototype.ResizeStopDrag = function () {
    $('body').off('mousemove', this.TmpDrag);
    $('body').off('mouseup', this.TmpDrag);
    $('body').css({'cursor': 'auto'});
    return false;
  };

  // TODO: Notes widget should just follow the parent.
  // Get rid of this.
  ResizePanel.prototype.SetWidth = function (width) {
    this.Width = width;
    this.PanelDiv.css({'width': this.Width + 'px'});
    this.MainDiv.css({'left': this.Width + 'px'});
    this.ResizeEdge.css({'left': (this.Width - 2) + 'px'});

    // Needed for viewers to sync canvas size.
    $(window).trigger('resize');
  };

  ResizePanel.prototype.AnimateNotesWindow = function () {
    var animationTime = new Date().getTime() - this.AnimationStartTime;
    if (animationTime > this.AnimationDuration || this.AnimationDuration <= 0) {
      // end the animation.
      this.SetWidth(this.AnimationTarget);

      if (this.Visibility) {
        this.CloseButton.show();
        this.OpenButton.hide();
        this.PanelDiv.fadeIn();
      } else {
        this.CloseButton.hide();
        this.OpenButton.show();
      }
      clearInterval(this.AnimationId);
      delete this.AnimationId;
      delete this.AnimationStartTime;
      delete this.AnimationDuration;
      delete this.AnimationTarget;

      return;
    }

    var k = animationTime / this.AnimationDuration;

    // update
    this.SetWidth(this.Width + (this.AnimationTarget - this.Width) * k);
  };

  // Open and close the panel
  ResizePanel.prototype.SetVisibility = function (visibility, duration) {
    if (duration === undefined) { duration = 1000.0; }
    if (this.Visibility === visibility) { return; }
    this.Visibility = visibility;

    this.AnimationCurrent = this.Width;
    if (this.Visibility) {
      this.AnimationTarget = 353;
    } else {
      this.PanelDiv.hide();
      this.AnimationTarget = 0;
    }

    this.AnimationDuration = duration;
    this.AnimationStartTime = new Date().getTime();
    // NOTE: tiles are not requestAnimationFrame does not let the image tiles get drawn.
    // Do the same animation with setInterval
    var self = this;
    this.AnimationLastTime = new Date().getTime();
    this.AnimationId = setInterval(function () { self.AnimateNotesWindow(); }, 10);
  };

  // Show / hide the panel and handles.
  // I keep the "visibility" state and restore it.
  ResizePanel.prototype.Show = function () {
    this.Visibility = true;
    this.ResizeEdge.show();
    if (this.Visibility) {
      this.Visibility = false; // hack
      this.SetVisibility(true);
    } else {
      this.OpenButton.show();
    }
  };

  ResizePanel.prototype.Hide = function () {
    this.Visibility = false;
    // Do not use "SetVisibility" because we need to instantly close the panel.
    // arg:duration = 0 works but is not perfect.
    this.PanelDiv.hide();
    this.SetWidth(0);
    this.OpenButton.hide();
    this.CloseButton.hide();
    this.ResizeEdge.hide();

    $(window).trigger('resize');
  };

// ==============================================================================

  // args: { label: function, ...}
  jQuery.prototype.saMenuButton = function (args) {
    if (this.length === 0) { return this; }
    var item = this[0];

    if (!item.saMenuButton) {
      item.saMenuButton = new SaMenuButton(args, this);
    }

    return this;
  };

  function SaMenuButton (args, menuButton) {
    this.InsertMenuTimer = 0;
    this.InsertMenu = $('<ul>')
        .appendTo(menuButton)
        // How do I customize the menu location?
        .css({'position': 'absolute',
          'left': '-110px',
          'top': '25px',
          'width': '150px',
          'font-size': '18px',
          'box-shadow': '10px 10px 5px #AAA',
          'z-index': '5'})
        .hide();

    for (var label in args) {
      this.AddMenuItem(label, args[label]);
    }
    // Jquery UI formatting
    this.InsertMenu.menu();

    // Make it easy to select the first item
    var self = this;
    label = Object.keys(args)[0];
    menuButton.on('click touchstart',
                  function () {
                    (args[label])();
                    self.InsertMenu.hide();
                  });

    menuButton.mouseover(
        function () { self.ShowInsertMenu(); });
    this.InsertMenu.mouseover(
        function () { self.ShowInsertMenu(); });

    menuButton.mouseleave(
        function () { self.EventuallyHideInsertMenu(); });
    this.InsertMenu.mouseleave(
        function () { self.EventuallyHideInsertMenu(); });
  }

  SaMenuButton.prototype.AddMenuItem = function (label, callback) {
    var self = this;

    this[label] = $('<li>')
      .appendTo(this.InsertMenu)
      .text(label)
      .addClass('saButton') // for hover effect
      .on('click touchstart', function () {
        (callback)();
        self.InsertMenu.hide();
        return false;
      });
  };

  SaMenuButton.prototype.ShowInsertMenu = function () {
    if (this.InsertMenuTimer) {
      clearTimeout(this.InsertMenuTimer);
      this.InsertMenuTimer = 0;
    }
    this.InsertMenu.show();
  };

  SaMenuButton.prototype.EventuallyHideInsertMenu = function () {
    if (this.InsertMenuTimer) {
      clearTimeout(this.InsertMenuTimer);
      this.InsertMenuTimer = 0;
    }
    var self = this;
    this.InsertMenuTimer = setTimeout(
        function () {
          self.InsertMenuTimer = 0;
          self.InsertMenu.fadeOut();
          this.InsertMenuTimer = 0;
        }, 500);
  };

// ==============================================================================
// Although this is only an option for saViewers,  Make it separate to keep
// it clean. NOTE: .saViewer has to be setup before this call.

// This is not compatable with the dual viewer.  We need two widgets (one
// per viewer).  Legacy now.

// args:
  jQuery.prototype.saAnnotationWidget = function (args) {
    for (var i = 0; i < this.length; ++i) {
      var item = this[i];
      if (!item.saViewer) {
        return this;
      } else if (!item.saAnnotationWidget) {
        $(item).addClass('sa-annotation-widget');
        item.saAnnotationWidget = new SA.AnnotationWidget(item.saViewer);
        item.saAnnotationWidget.SetVisibility(2);
      }
      // This hides and shows the button/tools but does not change the
      // visibility of the annotations in the viewer.
      if (args === 'hide') {
        item.saAnnotationWidget.hide();
      } else if (args === 'show') {
        item.saAnnotationWidget.show();
      }
    }

    return this;
  };

  // I have struggled with the issue of making a second div fill
  // available space when the first div fits its contents with any size.
  // Here is a programmatic solution.

  SA.FillDiv = function (div) {
    div.saOnResize(
      function () {
        var height = div.parent().height() - div.position().top;
        div.height(height);
      });
  };

  SA.ResizePanel = ResizePanel;
  SA.SAFullHeight = SAFullHeight;
  SA.SAViewer = SAViewer;
  SA.SAFullScreenButton = SAFullScreenButton;
  SA.AccordianDiv = saAccordianDiv;
})();

// CME

// Bugs:
// Get short answer questions working.

// Question resizable only after reload.
// Images have a minimum size.

// My feature requests from creating poster:
// Snap to objects.
// Text background options like rectangle (gradient)
//   option to enter css text, or select color gui
// Group objects.
// Copy and paste object or group.
// Select objects.
// Move selected objects with arrow.
// Undo edits
// padding option in text dialog (conversion for px to %?)

// Feature Requests
// Text should selectively resize.
//    This is hard.  I cannot change a selection into a dom that can be manipulated.
// Full window should have overview window and dual view option.
// True false / short answer question.
// Mobile users: first view in session is off the edge.

// Snap
//    to objects.
//    some indication of snap.
//    look at google.
// Slide menu/edit buttons
// Stack and subnotes.
// Improve session browser:
//   Close sessions.
//   Open notes with children.
//   Show multiple viewer records.
//   Choose Images and Notes
//   Merge search with browser.

//   Allow for relative font sizes in a saScalableFontDiv.
// Add GUI to add slides and slide items.
// Background of thumbs should be white.
// Embed option of viewer.

(function () {
  'use strict';

// ==============================================================================
// TODO:
// - Resize the view area to fit the note text.
// - Edit mode: resize views
// - Allow views to go full screen.
// - Sortable slides in slide div.
// - Stop the timer when we leave full screen. Turn editing back on if EDIT.

// ==============================================================================
  function Presentation (rootNote, edit) {
    var self = this;
    this.RootNote = rootNote;
    this.Edit = edit;
    // We need this to know what to return to when a view goes full screen.
    this.FullScreen = false;

    // Setup default global properties.
    if (typeof (rootNote.TypeData) === 'undefined') {
      rootNote.TypeData = {};
    }
    if (!rootNote.TypeData.Background) {
      rootNote.TypeData.Background = '#EEEEEE';
    }
    if (!rootNote.TypeData.AspectRatio) {
      rootNote.TypeData.AspectRatio = 1.3333;
    }

    // Eliminate the GUI in the viewers.
    $('body').css({'overflow-x': 'hidden'});

    this.WindowDiv = $('<div>')
        .appendTo('body')
        .css({
          'position': 'fixed',
          'left': '0px',
          'width': '100%'})
        .saFullHeight();

    // Hack so all viewers will share the same browser.
    // We should really use the brower tab in the left panel.
    SA.VIEW_BROWSER = new SA.ViewBrowser(this.WindowDiv);

    this.ResizePanel = new SA.ResizePanel(this.WindowDiv);

    // this.PresentationDiv = $('<div>')
    //    .appendTo(this.WindowDiv)
    //    .css({'position':'absolute',
    //          'top':'0px',
    //          'left':'0px',
    //          'width':'100%',
    //          'height':'100%'});
    this.PresentationDiv = this.ResizePanel.MainDiv;

    // Wow, really?  Timing caused the swipe bug?
    this.WindowDiv.on(
        'swipeleft',
        function (e) {
          if (self.ResizePanel.Visibility &&
                 e.swipestop.coords[0] < self.ResizePanel.Width) {
            self.ResizePanel.SetVisibility(false);
            return false;
          }
          self.GotoSlide(self.Index + 1);
        });
    this.WindowDiv.on(
        'swiperight',
        function (e) {
          if (!self.ResizePanel.Visibility &&
                 e.swipestart.coords[0] < 10) {
            self.ResizePanel.Show();
            return false;
          }
          self.GotoSlide(self.Index - 1);
        });

    // A window with a constant aspect ratio that fits in
    // the PresentationDiv.
    this.AspectDiv = $('<div>')
        .css({'border': '1px solid #AAA'})
        .appendTo(this.PresentationDiv)
        .saPresentation({aspectRatio: this.RootNote.TypeData.AspectRatio});

    this.LeftPanel = this.ResizePanel.PanelDiv;
    this.InitializeLeftPanel(this.LeftPanel);
    // Left panel is closed by default on mobile devices.
    if (SAM.detectMobile()) {
      this.ResizePanel.Hide();
    }

    // Float the two slide show buttons in the upper right corner.
    this.ShowButton = $('<img>')
        .appendTo(this.PresentationDiv)
        .prop('title', 'present')
        .addClass('editButton')
        .attr('src', SA.ImagePathUrl + 'slide_show.png')
        .css({'position': 'absolute',
          'top': '2px',
          'right': '20px',
          'width': '20px',
          'z-index': '5'})
        .click(function () {
          self.StartFullScreen();
        });
    this.TimerButton = $('<img>')
        .appendTo(this.PresentationDiv)
        .prop('title', 'present timed')
        .addClass('editButton')
        .attr('src', SA.ImagePathUrl + 'timer.png')
        .css({'position': 'absolute',
          'top': '2px',
          'right': '46px',
          'width': '20px',
          'z-index': '5'})
        .click(function () {
          self.StartTimerShow();
        });

    // TODO: Fix this.  At least hide the button for the title page,
    // or get rid of the title page.
    if (edit) {
        // Temporary way to delete a this.
      this.DeleteSlideButton = $('<img>')
            .appendTo(this.AspectDiv)
            .attr('src', SA.ImagePathUrl + 'remove.png')
            .prop('title', 'delete slide')
            .addClass('editButton')
            .css({'position': 'absolute',
              'width': '12px',
              'height': '12px',
              'left': '0px',
              'top': '0px',
              'z-index': '5'})
            .click(function () {
                // Hack to reload viewer records.
              self.DeleteCurentSlide();
            });
    }

    this.TitlePage = new TitlePage(this.AspectDiv, edit);
    this.SlidePage = new SlidePage(this.AspectDiv, edit);
    this.HtmlPage = new HtmlPage(this.AspectDiv, edit,
                                  rootNote.TypeData.Background);

    this.GotoSlide(0);

    // Keep the browser from showing the left click menu.
    document.oncontextmenu = SA.cancelContextMenu;

    $('body').on(
        'keydown',
        function (e) {
          return self.HandleKeyDown(e);
        });

    this.UpdateSlidesTab();
  }

  Presentation.prototype.StartTimerShow = function () {
    var self = this;
    // hack to turn off key events.

    SA.ContentEditableHasFocus = true;
    var dialog = $('<div>')
        .dialog({
          modal: false,
          resizable: false,
          position: {
            my: 'left top',
            at: 'left top',
            of: window
          },
          beforeClose: function () {
            SA.ContentEditableHasFocus = false;
          },
          buttons: {
            'Start': function () {
              self.StartFullScreen();
                    // Change seconds to milliseconds
              var duration = parseInt(self.DurationInput.val()) * 1000;
                    // Also linger on the current slide.
              setTimeout(function () { self.TimerCallback(duration); }, duration);
                    // Should we just close and resuse the dialog?
              $(this).dialog('destroy');
            }
          }
        });
    this.DurationLabel = $('<label>')
        .appendTo(dialog)
        .text('Seconds:');
    this.DurationInput = $('<input type="number" min="1" step="1">')
        .appendTo(dialog)
        .val(30)
        .css({'width': '4em'});
  };

  Presentation.prototype.StartFullScreen = function () {
    var elem = document.body;

    this.ResizePanel.Hide();
    this.EditOff();
    $(window).trigger('resize');
    this.ShowButton.hide();
    this.TimerButton.hide();

    if (elem.requestFullscreen) {
      elem.requestFullscreen();
    } else if (elem.msRequestFullscreen) {
      elem.msRequestFullscreen();
    } else if (elem.mozRequestFullScreen) {
      elem.mozRequestFullScreen();
    } else if (elem.webkitRequestFullscreen) {
      elem.webkitRequestFullscreen();
    }

    this.FullScreen = true;

    // detect when we leave full screen.
    var self = this;
    $(elem).bind(
        'webkitfullscreenchange mozfullscreenchange fullscreenchange',
        function (e) {
          var state = document.fullScreen || document.mozFullScreen ||
                document.webkitIsFullScreen;
            // var event = state ? 'FullScreenOn' : 'FullScreenOff';

          self.FullScreen = state;
          if (!self.FullScreen) {
            self.ResizePanel.Show();
            self.EditOn();
            self.ShowButton.show();
            self.TimerButton.show();
                // TODO: Stop the timer when we leave full screen.
          }
        });
  };

  Presentation.prototype.EditOff = function () {
    if (SA.Edit && this.Edit) {
      this.Edit = false;

      this.SaveButton.hide();
      this.InsertMenuButton.hide();
      this.DeleteSlideButton.hide();
        // QuizMenu / label?
      this.EditTabs.DisableTabDiv(this.BrowserDiv);
      this.EditTabs.DisableTabDiv(this.SearchDiv);
      this.EditTabs.DisableTabDiv(this.ClipboardDiv);

      this.TitlePage.EditOff();
      this.SlidePage.EditOff();
      this.HtmlPage.EditOff();
    }
  };

  Presentation.prototype.EditOn = function () {
    if (this.FullScreen) { return; }
    if (SA.Edit && !this.Edit) {
      this.Edit = true;

      this.SaveButton.show();
      this.InsertMenuButton.show();
      this.DeleteSlideButton.show();
      this.EditTabs.EnableTabDiv(this.BrowserDiv);
      this.EditTabs.EnableTabDiv(this.SearchDiv);
      this.EditTabs.EnableTabDiv(this.ClipboardDiv);

      this.TitlePage.EditOn();
      this.SlidePage.EditOn();
      this.HtmlPage.EditOn();
      this.DeleteSlideButton.show();
    }
  };

  Presentation.prototype.InitializeLeftPanel = function (parent) {
    this.EditTabs = new SA.TabbedDiv(parent);
    this.EditTabs.Div.css({'width': '100%',
      'height': '100%'});

    this.SlidesDiv = this.EditTabs.NewTabDiv('Slides');
    this.SlidesDiv
        .css({'text-align': 'left',
          'color': '#303030',
          'font-size': '18px'});
    // The div that will hold the list of slides.
    this.SlideList = $('<div>')
        .appendTo(this.SlidesDiv)
        .css({'position': 'absolute',
          'width': '100%',
          'top': '32px',
          'bottom': '3px',
          'overflow-y': 'auto'});

    if (SA.Edit) {
      this.BrowserDiv = this.EditTabs.NewTabDiv('Browse');
      this.SearchDiv = this.EditTabs.NewTabDiv('Search');
      this.ClipboardDiv = this.EditTabs.NewTabDiv('Clipboard');
      var self = this;

      this.SaveButton = $('<img>')
            .appendTo(this.SlidesDiv)
            .prop('title', 'save')
            .addClass('editButton')
            .attr('src', SA.ImagePathUrl + 'save22.png')
            .css({'float': 'right'})
            .click(function () { self.Save(); });
      this.InsertMenuButton = $('<div>')
            .appendTo(this.SlidesDiv)
            .addClass('editButton')
            .css({'float': 'right',
              'position': 'relative'})
            .saMenuButton({
              'New Slide': function () {
                self.InsertNewSlide('HTML');
              },
              'Copy Slide': function () { self.InsertSlideCopy(); },
              'Insert Text': function () {
                self.HtmlPage.InsertTextBox()
                        .css({'height': '25%'});
              },
              'Insert Question': function () { self.HtmlPage.InsertQuestion(); },
              'Insert Rectangle': function () {
                self.HtmlPage.InsertRectangle('#073E87', '0%', '60%', '97.5%', '14%');
              },
              'Insert Image': function () { self.InsertImage(); },
              'Insert MP4': function () { self.InsertVideo(); },
              'Embed Youtube': function () { self.InsertYoutube(); }
            });

      $('<img>')
            .appendTo(this.InsertMenuButton)
            .attr('src', SA.ImagePathUrl + 'new_window.png');

      this.QuizMenu = $('<select name="quiz" id="quiz">')
            .appendTo(this.SlidesDiv)
            .css({'float': 'right',
              'margin': '3px'})
            .change(function () {
              if (this.value === 'review') {
                self.RootNote.Mode = 'answer-show';
              } else if (this.value === 'hidden') {
                self.RootNote.Mode = 'answer-hide';
              } else if (this.value === 'interactive') {
                self.RootNote.Mode = 'answer-interactive';
              }
              self.UpdateQuestionMode();
            });
      $('<option>')
            .appendTo(this.QuizMenu)
            .text('review');
      $('<option>')
            .appendTo(this.QuizMenu)
            .text('hidden');
      $('<option>')
            .appendTo(this.QuizMenu)
            .text('interactive');
      this.QuizLabel = $('<div>')
            .appendTo(this.SlidesDiv)
            .css({'float': 'right',
              'font-size': 'small',
              'margin-top': '4px'})
            .text('quiz');
        // Set the question mode
      if (this.RootNote.Mode === 'answer-hide') {
        this.QuizMenu.val('hidden');
      } else if (this.RootNote.Mode === 'answer-interactive') {
        this.QuizMenu.val('interactive');
      } else {
        this.RootNote.Mode = 'answer-show';
        this.QuizMenu.val('review');
      }

      this.BrowserPanel = new SA.BrowserPanel(
            this.BrowserDiv,
            function (viewObj) {
              self.AddViewCallback(viewObj);
            });
      this.BrowserDiv.css({'overflow-y': 'auto'});

      this.SearchPanel = new SA.SearchPanel(
            this.SearchDiv,
            function (imageObj) {
              self.AddImageCallback(imageObj);
            });
      this.ClipboardPanel = new SA.ClipboardPanel(
            this.ClipboardDiv,
            function (viewObj) {
              self.AddViewCallback(viewObj);
            });
    }

    this.UserTextDiv = this.EditTabs.NewTabDiv('Notes', 'private notes');
    // Private notes.
    this.UserNoteEditor = new UserNoteEditor(this.UserTextDiv);

    this.EditTabs.ShowTabDiv(this.SlidesDiv);
  };

// ==============================================================================
// What should i do if the user starts editing before the note loads?
// Editor will not be active until it has a note.
  function UserNoteEditor (parent) {
    this.Modified = false;
    this.UpdateTimer = null;
    this.ParentNote = null;
    // this.UserNote = null;
    this.TextEditor = $('<div>')
        .appendTo(parent)
        .css({'display': 'inline-block',
          'position': 'absolute',
          'overflow-y': 'auto',
          'padding': '5px',
          'fontFamily': 'Verdana,sans-serif',
          'left': '2px',
          'right': '2px',
          'top': '20px',
          'bottom': '2px'});

    var self = this;
    this.TextEditor.attr('contenteditable', 'false')
        .bind('input', function () {
          self.Modified = true;
            // Leave events are not triggering.
          self.EventuallyUpdate();
        })
        .focusin(function () {
          SA.ContentEditableHasFocus = true;
        })
        .focusout(function () {
          SA.ContentEditableHasFocus = false;
          self.UpdateNote();
        })
        // Mouse leave events are not triggering.
        .mouseleave(function () { // back button does not cause loss of focus.
          self.UpdateNote();
        });

    this.TextEditor.change(function () { self.UpdateNote(); });
  }

  UserNoteEditor.prototype.EventuallyUpdate = function () {
    if (this.UpdateTimer) {
      clearTimeout(this.UpdateTimer);
      this.UpdateTimer = null;
    }
    var self = this;
    this.UpdateTimer = setTimeout(function () { self.UpdateNote(); }, 5000);
  };

  UserNoteEditor.prototype.UpdateNote = function () {
    if (this.ParentNote && this.ParentNote.UserNote) {
      var userNote = this.ParentNote.UserNote;
      userNote.Text = this.TextEditor.html();
        // Do not save the user not until the parent has been saved.
      if (this.ParentNote.Id && this.Modified) {
        var self = this;
        userNote.Save(function () { self.Modified = false; });
      }
    }
  };

// The parent not is set.  A user not is retrieved or created, and the
// editor is attached to the user note.
// TODO: Get rid of the local iVar UserNote.
// TODO: Make sure this works with temp note ids.
  UserNoteEditor.prototype.SetNote = function (parentNote) {
    if (this.ParentNote === parentNote) { return; }

    // Save the previous note incase the user is in mid edit
    // TODO: Do not save it has not been modified.
    this.UpdateNote();
    // clear the editor and make not editable until we have another user note.
    this.ParentNote = null;
    // this.UserNote = null;
    this.TextEditor.html('');
    this.TextEditor
        .attr('contenteditable', 'false')
        .css('border', '');

    // Null note means save previous and clear editor and make it no longer editable.
    if (!parentNote) {
      return;
    }

    this.ParentNote = parentNote;

    if (parentNote.UserNote) {
        // this.UserNote = parentNote.UserNote;
      this.TextEditor
            .html(parentNote.UserNote.Text)
            .attr('contenteditable', 'true')
            .css({'border': '2px inset #DDD'});
      return;
    }

    if (!parentNote.Id) {
        // If the parent does not have an id, it must be new and will not
        // have a user note.  Make a new one (do not try to load user note).
        // A new note.  I do not want to save empty user notes for every
        // note.  The check will be in the save method.
      parentNote.SetUserNote(new SA.Note());
      this.TextEditor
            .attr('contenteditable', 'true')
            .css({'border': '2px inset #DDD'});
      return;
    }

    // NOTE: This is probably not necessary because the server embeds user
    // notes when the parent is sent to the client.
    var self = this;
    $.ajax({
      type: 'get',
      url: '/webgl-viewer/getusernotes',
      data: {'parentid': parentNote.Id},
      success: function (data, status) { self.LoadUserNote(data, parentNote.Id); },
      error: function () { SA.Debug('AJAX - error() : getusernotes'); }
    });
  };

  UserNoteEditor.prototype.LoadUserNote = function (data, parentNoteId) {
    if (!this.ParentNote || this.ParentNote.Id !== parentNoteId) {
        // Many things could happen while waiting for the note to load.
      return;
    }

    var parentNote = this.ParentNote;
    parentNote.SetUserNote(new SA.Note());

    if (data.Notes && data.Notes.length > 0) {
      if (data.Notes.length > 1) {
        SA.Debug('Warning: Only showing the first user note.');
      }
      var noteData = data.Notes[0];
      parentNote.UserNote.Load(noteData);
    }

    // Must display the text.
    this.TextEditor.html(parentNote.UserNote.Text);
    this.TextEditor.attr('contenteditable', 'true')
        .css({'border': '2px inset #DDD'});
  };

// ==============================================================================

  Presentation.prototype.UpdateQuestionMode = function () {
    if (!this.RootNote) { return; }
    $('.sa-question').saQuestion('SetMode', this.RootNote.Mode);

    // Do not hide the Title page title
    if (this.RootNote.Mode === 'answer-hide' && this.Index !== 0) {
        // Experiment with hiding titles too.
      var title = $('.sa-presentation-title');
      var standin = title.clone();
      title.hide();
      standin
            .appendTo(title.parent())
            .html('#' + this.Index)
            .addClass('sa-standin')
            .attr('contenteditable', 'false')
            .saScalableFont();
    } else {
        // Experiment with hiding titles too.
      $('.sa-standin').remove();
      $('.sa-presentation-title').show();
    }
    this.UpdateSlidesTab();
  };

  Presentation.prototype.TimerCallback = function (duration) {
    if (this.Index === this.GetNumberOfSlides() - 1) {
        // Stop but stay in full screen mode.
      this.GotoSlide(0);
      SA.ContentEditableHasFocus = false;
      return;
    }

    this.GotoSlide(this.Index + 1);

    // Hack to get rid of anwers.
    // Select everything in the editor.
    var editor = this.SlidePage.List.TextEntry[0];
    $(editor).attr('contenteditable', 'true');
    var sel = window.getSelection();
    var range = document.createRange();
    range.selectNodeContents(editor);
    sel.removeAllRanges();
    sel.addRange(range);
    // remove bold formating
    document.execCommand('bold', false, null);
    document.execCommand('bold', false, null);
    // Hide annotations
    // legacy
    if (this.SlidePage.AnnotationWidget1) {
      this.SlidePage.AnnotationWidget1.SetVisibility(false);
    }
    if (this.SlidePage.AnnotationWidget2) {
      this.SlidePage.AnnotationWidget2.SetVisibility(false);
    }
    // remove the selection
    range.collapse(false);
    // The collapse has no effect without this.
    sel.removeAllRanges();
    sel.addRange(range);
    $(editor).attr('contenteditable', 'false');

    // Wait before advancing.
    var self = this;
    setTimeout(function () { self.TimerCallback(duration); }, duration);
  };

// Adds a view to the current slide.
  Presentation.prototype.AddViewCallback = function (viewObj) {
    if (viewObj.Type === 'HTML') {
        // What will happen if you insert a whole presentation (root)?
        // Insert a new slide
      var idx = this.Index + 1;
      var note = new SA.Note();
      note.Load(viewObj);
        // Record changes in the note before the copy.
      this.HtmlPage.UpdateEdits();

      this.RootNote.Children.splice(idx - 1, 0, note);
      this.GotoSlide(idx);
      this.UpdateSlidesTab();
      return;
    }

    if (this.Note.Type === 'HTML') {
        // TODO: Change this to pass a viewer record of the view.
        //       Maybe show all the records as options.
      this.HtmlPage.InsertView(viewObj);
      return;
    }

    var record = new SA.ViewerRecord();
    record.Load(viewObj.ViewerRecords[0]);
    this.Note.ViewerRecords.push(record);

    this.SlidePage.DisplayNote(this.Note, SA.presentation.Index);
  };

// Callback from search.
  Presentation.prototype.AddImageCallback = function (image) {
    var record = new SA.ViewerRecord();
    record.OverViewBounds = image.bounds;
    record.Image = image;
    record.Camera = {FocalPoint: [(image.bounds[0] + image.bounds[1]) / 2,
      (image.bounds[2] + image.bounds[3]) / 2, 0],
      Roll: 0,
      Height: (image.bounds[3] - image.bounds[2]),
      Width: (image.bounds[1] - image.bounds[0])};

    if (this.Note.Type === 'HTML') {
        // This will be the primar path in the future.
      this.HtmlPage.InsertViewerRecord(record);
      return;
    }
    if (this.Note !== this.RootNote) {
      var note = new SA.Note();
      note.ViewerRecords[0] = record;
      this.SlidePage.InsertViewNote(note);
      return;
    }

    // The root needs a record to show up in the session.
    // never executed because I add a presentation icon
    // NOTE: This might be a problem with the new html title page.
    //       Viewers inthe title pages are stored as records.
    if (this.RootNote.ViewerRecords.length === 0) {
      this.RootNote.ViewerRecords.push(record);
    }
  };

  Presentation.prototype.HandleKeyDown = function (event) {
    // Hack to keep the slides from changing when editing.
    if (SA.ContentEditableHasFocus) {
      return true;
    }

    // I cannot get the browser to paste into a new div
    // First, paste is executed before this callback.
    // Second, the execCommand paste does not appear to work.
    // if (event.keyCode === "86" && ! event.ctrlKey) { // check for control v paste
    //    if (this.Note.Type === "HTML") {
    //        this.HtmlPage.Paste();
    //   }
    // }

    if (event.keyCode === '32' || // space
        event.keyCode === '34' || // page down
        event.keyCode === '78' || // n
        event.keyCode === '39' || // right arrow
        event.keyCode === '40' || // down arrow
        event.keyCode === '13') { // enter
      this.GotoSlide(this.Index + 1);
      return false;
    }
    if (event.keyCode === '80' || // p
        event.keyCode === '37' || // back arrow
        event.keyCode === '38' || // up arrow
        event.keyCode === '33') { // page up
      this.GotoSlide(this.Index - 1);
      return false;
    }
    if (event.keyCode === '36') { // home
      this.GotoSetSlide(0);
      return false;
    }
    if (event.keyCode === '35') { // end
      this.GotoSlide(this.GetNumberOfSlides() - 1);
      return false;
    }
  };

  Presentation.prototype.Save = function () {
    // Get rid of interactive question formating.
    this.HtmlPage.Div.find('.sa-answer')
        .css({'color': '#000'});

    this.TitlePage.UpdateEdits();
    this.SlidePage.UpdateEdits();
    this.HtmlPage.UpdateEdits();

    // NOTE: light boxes are saved as viewerRecords. (but not always?)
    // Insert viewer record versus note?
    // Save the user notes.  They are not saved with the parent notes like
    // the children are.
    for (var i = 0; i < SA.Notes.length; ++i) {
      var note = SA.Notes[i];
      if (note.Type === 'UserNote') {
        if (note.LoadState || note.Text !== '') {
          note.Save();
        }
      }
    }

    // TODO:
    // Fix this. Session page needs every member view to have an image.
    // The root needs a record to show up in the session.
    var rootNote = this.RootNote;
    if (rootNote.ViewerRecords.length < 1) {
      var record = new SA.ViewerRecord();
      record.Load(
        {AnnotationVisibility: 2,
          Annotations: [],
          Camera: {FocalPoint: [510, 519],
            Height: 1009,
            Roll: 0,
            Width: 1066},
          Database: '507f34a902e31010bcdb1366',
          Image: {
            TileWidth: 256,
            TileHeight: 256,
            _id: '55b4e5c03ed65909a84cd938',
            bounds: [0, 1020, 15, 1024],
            components: 3,
            database: '507f34a902e31010bcdb1366',
            dimensions: [1020, 1009],
            filename: 'projection-screen.jpg',
            label: 'projection-screen.jpg',
            levels: 3,
            origin: [0, 0, 0],
            spacing: [1, 1, 1],
            NumberOfLevels: 3,
            OverViewBounds: [0, 1020, 15, 1024]}
        });
      rootNote.ViewerRecords.push(record);
    }

    // this.SaveButton.css({'color':'#F00'});
    // And finally, we can save the presentation.
    this.RootNote.Save();

    // Check to see if the root is in the session. If not, add it.
    var noteInSession = false;
    var session = SA.Session.session.views;
    for (i = 0; i < session.length && !noteInSession; ++i) {
      if (session[i].id === this.RootNote.Id) {
        noteInSession = true;
      }
    }
    if (!noteInSession) {
        // Should we bother making a dummy view?
        // move-view is now smart enough to avoid adding twice.
      session.splice(0, 0, {id: this.RootNote.Id});
        // if this is the first time we are saving the root note, then
        // add it to the session.
      $.ajax({
        type: 'post',
        data: {'to': SA.SessionId,
          'view': this.RootNote.Id},
        url: 'webgl-viewer/move-view',
        success: function (data, status) {
          if (status !== 'Success') {
            SA.Debug(data);
          }
        },
        error: function () {
          SA.Debug('AJAX - error() : session-add-view');
        }
      });
    }
  };

  Presentation.prototype.DeleteSlide = function (index) {
    var maxIdx = this.GetNumberOfSlides() - 1;
    if (index < 1 || index > maxIdx) {
      return;
    }
    this.RootNote.Children.splice(index - 1, 1);
    // The case when we are not deleting the current slide.
    // All slides after the one deleted cahnge their index.
    if (this.Index > index) { this.Index -= 1; }

    // Case where we are deleting the current slide.
    if (index === this.Index) {
        // index becomes the sldie we are going to.
        // Handles the case where we are on the last slide.
        // Move to the previous rather then the next.
      if (index === maxIdx) { --index; }
        // force GotoSlide to
      this.Index = -1;
      this.GotoSlide(index);
    }

    this.UpdateSlidesTab();
  };

  Presentation.prototype.DeleteCurentSlide = function () {
    this.DeleteSlide(this.Index);
  };

  Presentation.prototype.InsertNewSlide = function (type) {
    var idx = this.Index + 1;
    var note = new SA.Note();
    if (type) { note.Type = type; }
    this.RootNote.Children.splice(idx - 1, 0, note);
    note.Parent = this.RootNote;
    this.GotoSlide(idx);
    this.UpdateSlidesTab();
    if (type === 'HTML') {
      this.HtmlPage.InitializeSlidePage();
    }
    this.UpdateQuestionMode();
  };

  Presentation.prototype.InsertSlideCopy = function (type) {
    var idx = this.Index + 1;
    var note = new SA.Note();

    // Record changes in the note before the copy.
    this.HtmlPage.UpdateEdits();
    // Deep copy of note with children.
    note.DeepCopy(this.Note);

    this.RootNote.Children.splice(idx - 1, 0, note);
    this.GotoSlide(idx);
    this.UpdateSlidesTab();
  };

  Presentation.prototype.InsertImage = function () {
    var src = prompt('Image URL', 'https://slide-atlas.org/static/img/SlideAtlas_home.jpg');
    this.HtmlPage.InsertImage(src);
  };

  Presentation.prototype.InsertVideo = function () {
    var src = prompt('Video URL', 'https://slide-atlas.org/api/v2/sessions/53ac02d5a7a14110d929adcc/attachments/55fef0e6a7a14162dfb4da32');
    this.HtmlPage.InsertVideo(src);
  };

  Presentation.prototype.InsertYoutube = function () {
    var src = prompt('Video IFrame URL', '<iframe width="420" height="315" src="https://www.youtube.com/embed/9tCafgGZtxQ" frameborder="0" allowfullscreen></iframe>');
    this.HtmlPage.InsertIFrame(src);
  };

// 0->Root/titlePage
// Childre/slides start at index 1
  Presentation.prototype.GotoSlide = function (index) {
    if (index < 0 || index >= this.GetNumberOfSlides() || index === this.Index) {
      return;
    }

    // Clear previous slides settings.
    this.TitlePage.ClearNote();
    this.SlidePage.ClearNote();
    this.HtmlPage.ClearNote();

    this.AspectDiv.show();
    this.Index = index;
    if (index === 0) { // Title page
      this.Note = this.RootNote;
      if (this.Note.Type === 'Presentation') {
            // legacy
        this.SlidePage.Div.hide();
        this.HtmlPage.Div.hide();
        this.TitlePage.DisplayNote(this.Note);
      } else if (this.Note.Type === 'HTML') {
        this.TitlePage.Div.hide();
        this.SlidePage.Div.hide();
        this.HtmlPage.Div.show();
        this.HtmlPage.DisplayNote(this.Note);
        if (this.Note.Text === '') {
          this.HtmlPage.InitializeTitlePage();
        }
      }
      this.UserNoteEditor.SetNote(this.Note);
    } else { // Slide page
      this.Note = this.GetSlide(index);
      if (this.Note.Type === 'HTML') {
        this.TitlePage.Div.hide();
        this.SlidePage.Div.hide();
        this.HtmlPage.Div.show();
        this.HtmlPage.DisplayNote(this.Note);
        this.UserNoteEditor.SetNote(this.Note);
      } else {
        this.TitlePage.Div.hide();
        this.HtmlPage.Div.hide();
        this.SlidePage.DisplayNote(this.Note, index);
      }
    }
    // Start preloading the next slide.
    if (index < this.RootNote.Children.length) {
      var nextNote = this.RootNote.Children[index];
        // TODO: Better arg for LoadTiles.
        // Should I pass in the jquery selection or viewer.
      if (nextNote.ViewerRecords.length > 0) {
            // Hack: What size viewer will we be using?
        nextNote.ViewerRecords[0].LoadTiles([0, 0, 400, 300]);
      }
      if (nextNote.ViewerRecords.length > 1) {
            // Hack: What size viewer will we be using?
        nextNote.ViewerRecords[1].LoadTiles([0, 0, 400, 300]);
      }
    }

    this.UpdateSlidesTab();
    this.UpdateQuestionMode();

    // Font was not scaling when first loaded.
    $(window).trigger('resize');
  };

  Presentation.prototype.GetNumberOfSlides = function () {
    return this.RootNote.Children.length + 1;
  };

  Presentation.prototype.GetSlide = function (idx) {
    if (idx < 0 || idx > this.RootNote.Children.length) {
      return null;
    }
    if (idx === 0) {
      return this.RootNote;
    }
    return this.RootNote.Children[idx - 1];
  };

  Presentation.prototype.SortCallback = function () {
    // Change the list of GUI items into a list of notes.
    var items = this.SlideList.find('div');
    var newChildren = [];
    var newIndex = 0;
    for (var i = 0; i < items.length; ++i) {
      var idx = parseInt($(items[i]).data('index'));
      if (idx !== 0) { // we have to skip the title page because it is
            // root.
        newChildren.push(this.GetSlide(idx));
      }
      if (this.Index === idx) {
            // If the current slide moved, update the index.
            // Note the offset by one to account for the root / title.
            // length is one more than the notes index.
        newIndex = newChildren.length;
      }
    }
    this.RootNote.Children = newChildren;
    this.Index = newIndex;
    this.UpdateSlidesTab();
  };

  Presentation.prototype.UpdateSlidesTab = function () {
    var self = this;

    if (!this.SlideList) { return; }

    // Add the title page
    this.SlideList.empty();

    if (SA.Edit) {
      this.SlideList
            .sortable({update: function (event, ui) { self.SortCallback(); },
              handle: '.ui-icon'});
    }

    for (var i = 0; i < this.GetNumberOfSlides(); ++i) {
      // get a title
      var note = this.GetSlide(i);
      var title = note.Text;
      var idx = title.indexOf('sa-presentation-text');
      if (idx === -1) {
        title = note.Title;
        if (title === '') {
          // Nothing i the text / html to use as a title.
          title = 'Slide ' + i;
        }
      } else {
        title = title.substring(idx);
        idx = title.indexOf('>');
        title = title.substring(idx + 1);
        idx = title.indexOf('<');
        // We may have other formating blocks.
        // An xml parser would be nice.
        while (idx === 0) {
          idx = title.indexOf('>');
          title = title.substring(idx + 1);
          idx = title.indexOf('<');
        }
        title = title.substring(0, idx);
        if (note.Title === '') {
          note.Title = title;
        }
      }
        // Hide titles
      if (this.RootNote.Mode === 'answer-hide') {
        title = '#' + i;
      }

      var slideDiv = $('<div>')
            .appendTo(this.SlideList)
            .css({'position': 'relative',
              'padding-left': '1.5em',
              'padding-right': '1.5em',
              'margin': '5px',
              'color': '#29C',
              'cursor': 'pointer'})
            .hover(function () { $(this).css('color', 'blue'); },
                   function () { $(this).css('color', '#29C'); })
            .text(title)
            .data('index', i)
            .click(function () {
              SA.presentation.GotoSlide($(this).data('index'));
            });
      var sortHandle = $('<span>')
            .appendTo(slideDiv)
            .css({'position': 'absolute',
              'left': '7px',
              'top': '2px',
              'opacity': '0.5'})
            .addClass('ui-icon ui-icon-bullet');
      if (SA.Edit) {
        sortHandle.addClass('sa-sort-handle');
      }

      if (this.Note === note) {
        slideDiv.css({'background': '#EEE'});
      }
    }
  };

// ==============================================================================
  function SlidePage (parent, edit) {
    var self = this;
    this.FullWindowView = null;
    this.Edit = edit;
    this.Note = null;
    this.Records = []; // views.

    this.Div = $('<div>')
        .appendTo(parent)
        .hide()
        .addClass('sa-resize') // hack to get resize triggered.
        .css({
          'position': 'absolute',
          'width': '100%',
          'height': '100%',
          'border': '1px solid #AAA'});
    this.Div[0].onresize =
        function () {
          self.ResizeViews();
        };

    this.ViewPanel = $('<div>')
            .appendTo(this.Div)
            .css({'background': '#FFF',
              'position': 'absolute',
              'top': '0px',
              'bottom': '300px',
              'left': '0px',
              'width': '100%',
              'height': 'auto'});

    this.BottomDiv = $('<div>')
        .appendTo(this.Div)
        .css({'position': 'absolute',
          'bottom': '0px',
          'width': '100%',
          'height': '300px'});

    this.TitleBar = $('<div>')
        .appendTo(this.BottomDiv)
        .css({'position': 'absolute',
          'top': '0px',
          'height': '80px',
          'line-height': '80px',
          'width': '100%',
          'padding-left': '3.3em',
          'color': 'white',
          'font-size': '160%',
          'background': '#444',
          'font-family': 'Arial'});
    this.Title = $('<span>')
        .appendTo(this.TitleBar)
        .css({'display': 'inline-block',
          'vertical-align': 'middle',
          'line-height': 'normal'})
        .text('Slide: 1');

    this.TextDiv = $('<div>')
        .appendTo(this.BottomDiv)
        .css({'position': 'absolute',
          'padding-left': '2em',
          'height': '210px',
          'bottom': '5px',
          'width': '100%'});
    // List of question answers.
    this.List = new SA.TextEditor(this.TextDiv, SA.VIEWERS);
    if (!edit) {
      this.List.EditOff();
    }

    // Add the viewers.
    this.ViewerDiv1 = $('<div>')
        .appendTo(this.ViewPanel)
        .css({'position': 'absolute',
          'box-shadow': '10px 10px 5px #AAA'});
    // Make the viewer look like jquery
    // this.ViewerDiv1.viewer({overview:false});
    this.ViewerDiv1.saViewer();

    this.ViewerDiv2 = $('<div>')
        .appendTo(this.ViewPanel)
        .css({'position': 'absolute',
          'box-shadow': '10px 10px 5px #AAA'});
    // Make the viewer look like jquery
    this.ViewerDiv2.saViewer();

    if (this.Edit) {
        // TODO: Better API (jquery) for adding widgets.
        // TODO: Better placement control for the widget.

      var viewer = this.ViewerDiv1[0].saViewer;
      this.AnnotationWidget1 = new SA.AnnotationWidget(
            viewer.GetAnnotationLayer(), viewer);
      this.AnnotationWidget1.SetVisibility(2);

      viewer = this.ViewerDiv2[0].saViewer;
      this.AnnotationWidget2 = new SA.AnnotationWidget(
            viewer.GetAnnotationLayer(), viewer);
      this.AnnotationWidget2.SetVisibility(2);

        // TODO: Move this to bind in jquery.  (not sure how to do this yet)
      this.ViewerDiv1[0].saViewer.OnInteraction(function () { self.RecordView1(); });
      this.ViewerDiv2[0].saViewer.OnInteraction(function () { self.RecordView2(); });
      this.RemoveView1Button = $('<img>')
            .appendTo(this.ViewerDiv1)
            .attr('src', SA.ImagePathUrl + 'remove.png')
            .prop('title', 'remove view')
            .addClass('editButton')
            .css({'position': 'absolute',
              'right': '0px',
              'top': '0px',
              'width': '12px',
              'height': '12px',
              'z-index': '5'})
            .click(function () {
              SA.presentation.Note.ViewerRecords.splice(0, 1);
                // Redisplay the viewers
              self.DisplayNote(self.Note, SA.presentation.Index);
            });
      this.RemoveView2Button = $('<img>')
            .appendTo(this.ViewerDiv2)
            .attr('src', SA.ImagePathUrl + 'remove.png')
            .prop('title', 'remove view')
            .addClass('editButton')
            .css({'position': 'absolute',
              'right': '0px',
              'top': '0px',
              'width': '12px',
              'height': '12px',
              'z-index': '5'})
            .click(function () {
              SA.presentation.Note.ViewerRecords.splice(1, 1);
                // Redisplay the viewers
              self.DisplayNote(self.Note, SA.presentation.Index);
            });

        // Setup view resizing.
      this.ViewerDiv1.resizable();
        // For a method to get called when resize stops.
        // Gets call on other mouse ups, but this is ok.
      this.ViewerDiv1
            .mouseup(function () {
              this.saViewer.EnableInteraction();
              self.UpdateEdits();
              $(window).trigger('resize');
            });
      this.ViewerDiv1
            .resize(function () {
              this.saViewer.DisableInteraction();
              var vp = this.saViewer.GetViewport();
              vp[2] = $(this).width();
              vp[3] = $(this).height();
              this.saViewer.SetViewport(vp);
              this.saViewer.EventuallyRender(true);
              return false;
            });

      this.ViewerDiv2.resizable();
        // For a method to get called when resize stops.
        // Gets call on other mouse ups, but this is ok.
      this.ViewerDiv2
            .mouseup(function () {
              this.saViewer.EnableInteraction();
              self.UpdateEdits();
              $(window).trigger('resize');
            });
      this.ViewerDiv2
            .resize(function () {
              this.saViewer.DisableInteraction();
              var vp = this.saViewer.GetViewport();
              vp[2] = $(this).width();
              vp[3] = $(this).height();
              this.saViewer.SetViewport(vp);
              this.saViewer.EventuallyRender(true);
              return false;
            });
    }
    // Give the option for full screen
    // on each of the viewers.
    this.FullWindowView1Button = $('<img>')
        .appendTo(this.ViewerDiv1)
        .attr('src', SA.ImagePathUrl + 'fullscreenOn.png')
        .prop('title', 'full window')
        .css({'position': 'absolute',
          'width': '12px',
          'left': '-5px',
          'top': '-5px',
          'opacity': '0.5',
          'z-index': '-1'})
        .hover(function () { $(this).css({'opacity': '1.0'}); },
               function () { $(this).css({'opacity': '0.5'}); })
        .click(function () {
          self.SetFullWindowView(self.ViewerDiv1);
        });
    this.FullWindowView2Button = $('<img>')
        .appendTo(this.ViewerDiv2)
        .attr('src', SA.ImagePathUrl + 'fullscreenOn.png')
        .prop('title', 'full window')
        .css({'position': 'absolute',
          'width': '12px',
          'left': '-5px',
          'top': '-5px',
          'opacity': '0.5',
          'z-index': '-1'})
        .hover(function () { $(this).css({'opacity': '1.0'}); },
               function () { $(this).css({'opacity': '0.5'}); })
        .click(function () {
          self.SetFullWindowView(self.ViewerDiv2);
        });

    this.FullWindowViewOffButton = $('<img>')
        .appendTo(this.ViewPanel)
        .hide()
        .attr('src', SA.ImagePathUrl + 'fullscreenOff.png')
        .prop('title', 'full window off')
        .css({'position': 'absolute',
          'background': '#FFF',
          'width': '16px',
          'left': '1px',
          'top': '1px',
          'opacity': '0.5',
          'z-index': '1'})
        .hover(function () { $(this).css({'opacity': '1.0'}); },
               function () { $(this).css({'opacity': '0.5'}); })
        .click(function () {
          self.SetFullWindowView(null);
        });
  }

  SlidePage.prototype.SetFullWindowView = function (viewerDiv) {
    if (viewerDiv) {
      SA.presentation.EditOff();
      this.FullWindowViewOffButton.show();
      this.FullWindowView1Button.hide();
      this.FullWindowView2Button.hide();
      this.BottomDiv.hide();
      this.ViewPanel.css({'height': '100%'});
    } else {
      this.FullWindowViewOffButton.hide();
      this.FullWindowView1Button.show();
      this.FullWindowView2Button.show();
      this.BottomDiv.show();
      this.ViewPanel.css({
        'bottom': '300px',
        'height': 'auto'});
      if (SA.Edit) {
        SA.presentation.EditOn();
      }
    }
    this.FullWindowView = viewerDiv;
    this.ResizeViews();
  };

  SlidePage.prototype.RecordView1 = function () {
    if (this.Edit && this.Note &&
        this.Note.ViewerRecords.length > 0 &&
        this.Note.ViewerRecords[0]) {
      this.Note.ViewerRecords[0].CopyViewer(this.ViewerDiv1[0].saViewer);
    }
  };

  SlidePage.prototype.RecordView2 = function () {
    if (this.Edit && this.Note &&
        this.Note.ViewerRecords.length > 1 &&
        this.Note.ViewerRecords[1]) {
      this.Note.ViewerRecords[1].CopyViewer(this.ViewerDiv2[0].saViewer);
    }
  };

  SlidePage.prototype.EditOff = function () {
    if (SA.Edit && this.Edit) {
      this.Edit = false;
      this.Div.css({'width': '100%', 'left': '0px'});
      this.AnnotationWidget1.hide();
      this.AnnotationWidget2.hide();
        // Clear the event callbacks
      this.ViewerDiv1[0].saViewer.OnInteraction();
      this.ViewerDiv2[0].saViewer.OnInteraction();
      this.RemoveView1Button.hide();
      this.RemoveView2Button.hide();
      this.List.EditOff();
        // This causes the viewers to look transparent.
        // SA.VIEWER.MainView.Parent.resizable('disable');
    }
  };

  SlidePage.prototype.EditOn = function () {
    if (SA.Edit && !this.Edit) {
      this.Edit = true;
        // this.Div.css({'width': '100%', 'left': '0px'}); ???
      this.AnnotationWidget1.show();
      this.AnnotationWidget2.show();
        // Set the event callbacks
      var self = this;
      this.ViewerDiv1[0].saViewer.OnInteraction(function () { self.RecordView1(); });
      this.ViewerDiv2[0].saViewer.OnInteraction(function () { self.RecordView2(); });
      this.RemoveView1Button.show();
      this.RemoveView2Button.show();
      this.List.EditOn();
    }
  };

// Adds a margin, and keeps the aspect ratio of view.
  SlidePage.prototype.PlaceViewer = function (viewerDiv, record, viewport) {
    var vWidth = viewport[2] * 0.8;
    var vHeight = viewport[3] * 0.8;
    var cam = record.Camera;
    var scale = vHeight / cam.Height;
    vWidth = scale * cam.Width;
    if (vWidth > viewport[2] * 0.8) {
      vWidth = viewport[2] * 0.8;
      scale = vWidth / cam.Width;
      vHeight = scale * cam.Height;
    }

    var vLeft = viewport[0] + (viewport[2] - vWidth) / 2;
    var vTop = viewport[1] + (viewport[3] - vHeight) / 2;

    if (viewerDiv) {
      viewerDiv[0].saViewer.SetViewport([vLeft, vTop, vWidth, vHeight]);
      viewerDiv[0].saViewer.EventuallyRender(false);
    }
  };

// Records === views.
  SlidePage.prototype.ResizeViews = function () {
    var width = this.ViewPanel.width();
    var height = this.ViewPanel.height();
    if (this.FullWindowView) {
      this.ViewerDiv1[0].saViewer.SetViewport([0, 0, 0, height]);
      this.ViewerDiv2[0].saViewer.SetViewport([0, 0, 0, height]);
      this.FullWindowView[0].saViewer.SetViewport([0, 0, width, height]);
      this.FullWindowView[0].saViewer.EventuallyRender(false);
      return;
    }

    var numRecords = this.Records.length;
    var record;

    if (numRecords === 0) {
        // Poor way to hide a viewer.
      this.ViewerDiv1[0].saViewer.SetViewport([0, 0, 0, height]);
        // Poor way to hide a viewer.
      this.ViewerDiv2[0].saViewer.SetViewport([0, 0, 0, height]);
    }
    if (numRecords === 1) {
      record = this.Records[0];
      this.PlaceViewer(this.ViewerDiv1, record, [0, 0, width, height]);
        // Poor way to hide a viewer.
      this.ViewerDiv2[0].saViewer.SetViewport([0, 0, 0, height]);
    }
    if (numRecords > 1) {
      var halfWidth = width / 2;
      record = this.Records[0];
      this.PlaceViewer(this.ViewerDiv1, record, [0, 0, halfWidth, height]);
      record = this.Records[1];
      this.PlaceViewer(this.ViewerDiv2, record, [halfWidth, 0, halfWidth, height]);
    }
    if (this.Edit) {
      if (numRecords === 0) {
            // TODO: View should have hide/show methods and manage this.
        this.AnnotationWidget1.hide();
        this.AnnotationWidget2.hide();
      }
      if (numRecords === 1) {
        this.AnnotationWidget1.show();
        this.AnnotationWidget2.hide();
      }
      if (numRecords === 2) {
        this.AnnotationWidget1.show();
        this.AnnotationWidget2.show();
      }
    }
  };

  SlidePage.prototype.ClearNote = function () {
    if (this.Edit && this.Note) {
      this.UpdateEdits();
    }
    this.Note = null;
  };

  SlidePage.prototype.DisplayNote = function (note, index) {
    this.Div.show();
    this.Note = note;
    this.ViewerDiv1[0].saViewer.Reset();
    this.ViewerDiv2[0].saViewer.Reset();
    this.Records = note.ViewerRecords; // save this for resizing.

    this.Title.text('Slide: ' + index);
    // Text
    this.List.LoadNote(note);
    // Views
    if (this.Records.length > 0) {
      this.ViewerDiv1[0].saViewer.SetViewerRecord(this.Records[0]);
    }
    if (this.Records.length > 1) {
      this.ViewerDiv2[0].saViewer.SetViewerRecord(this.Records[1]);
    }
    this.ViewerDiv1[0].saViewer.CopyrightWrapper.hide();
    this.ViewerDiv2[0].saViewer.CopyrightWrapper.hide();
    this.ResizeViews();
  };

// We need to copy the annotation (maybe view in the future)
// Interaction does not actach all annotation changes.
  SlidePage.prototype.UpdateEdits = function () {
    if (this.Note &&
        this.Note.ViewerRecords.length > 0 &&
        this.Note.ViewerRecords[0]) {
      this.Note.ViewerRecords[0].CopyViewer(this.ViewerDiv1[0].saViewer);
    }

    if (this.Note &&
        this.Note.ViewerRecords.length > 1 &&
        this.Note.ViewerRecords[1]) {
      this.Note.ViewerRecords[1].CopyViewer(this.ViewerDiv2[0].saViewer);
    }
  };

  SlidePage.prototype.InsertViewNote = function (note) {
    if (note.ViewerRecords.length < 1) { return; }

    // we just use the record for slide pages.
    var record = note.ViewerRecords[0];

    this.Note.ViewerRecords.push(record);

    // Hack: Since GotoSlide copies the viewer to the record,
    // We first have to push the new record to the view.
    if (this.Note.ViewerRecords.length === 1) {
        // TODO: jquery arg
      this.ViewerDiv1[0].saViewer.SetViewerRecord(this.Note.viewerRecords[0]);
    } else if (this.Note.ViewerRecords.length === 2) {
      this.ViewerDiv2[0].saViewer.SetViewerRecord(this.Note.viewerRecords[1]);
    }

    this.DisplayNote(this.Note, SA.presentation.Index);
  };

// ==============================================================================
  function TitlePage (parent, edit) {
    this.Edit = edit;
    this.Note = null;
    this.Div = $('<div>')
        .appendTo(parent)
        .css({
          'background': '#FFF',
          'position': 'absolute',
          'width': '100%',
          'height': '100%',
          'border': '1px solid #AAA'});

    this.TopBar = $('<div>')
        .appendTo(this.Div)
        .css({'position': 'absolute',
          'top': '0%',
          'height': '2%',
          'left': '13%',
          'right': '3%',
          'background': '#DDF1FD'});

    this.Image = $('<img>')
        .appendTo(this.Div)
        .attr('src', 'https://slide-atlas.org/static/img/SlideAtlas_home.jpg')
        .css({'position': 'absolute',
          'top': '46%',
          'height': '50%',
          'left': '13%',
          'box-shadow': '10px 10px 5px #888'});

    this.TitleBar = $('<div>')
        .appendTo(this.Div)
        .css({'position': 'absolute',
          'top': '18%',
          'bottom': '58%',
          'left': '0%',
          'right': '3%',
          'background': '#073E87',
          'color': '#FFF'});
    this.Title = $('<span>')
        .appendTo(this.TitleBar)
        .attr('contenteditable', 'true')
        .css({'position': 'absolute',
          'top': '1em',
              // 'min-height':'3em',
              // 'min-width':'10em',
          'left': '13%'})
        .saScalableFont({scale: '0.3'});

    this.AuthorBar = $('<div>')
        .appendTo(this.Div)
        .css({'position': 'absolute',
          'top': '42%',
          'bottom': '0%',
          'left': '62%',
          'right': '3%',
          'background': '#E9F5FE',
          'color': '#888',
          'padding-left': '2em'});
    this.AuthorText = $('<span>')
        .appendTo(this.AuthorBar)
        .attr('contenteditable', 'true')
        .css({'position': 'absolute',
              // 'minimum-height':'4em',
              // 'minimum-width':'10em',
          'top': '2em'})
        .saScalableFont({scale: '0.1'});

    if (this.Edit) {
      this.Title
            .focusin(function () { SA.ContentEditableHasFocus = true; })
            .focusout(function () { SA.ContentEditableHasFocus = false; });
      this.AuthorText
            .focusin(function () { SA.ContentEditableHasFocus = true; })
            .focusout(function () { SA.ContentEditableHasFocus = false; });
    }
  }

  TitlePage.prototype.EditOff = function () {
    if (SA.Edit && this.Edit) {
      this.Edit = false;
      this.Div.css({'width': '100%', 'left': '0px'});
      this.Title
            .attr('readonly', 'readonly')
            .attr('spellcheck', 'false')
            .unbind('focusin')
            .unbind('focusout')
            .blur();
      this.AuthorText.attr('readonly', 'readonly')
            .attr('readonly', 'readonly')
            .attr('spellcheck', 'false')
            .unbind('focusin')
            .unbind('focusout')
            .blur();
    }
  };

  TitlePage.prototype.EditOn = function () {
    if (SA.Edit && !this.Edit) {
      this.Edit = true;
        // this.Div.css({'width': '100%', 'left': '0px'}); ???
      this.Title
            .attr('contenteditable', 'true')
            .attr('spellcheck', 'true')
            .focusin(function () { SA.ContentEditableHasFocus = true; })
            .focusout(function () { SA.ContentEditableHasFocus = false; });
      this.AuthorText.attr('readonly', 'readonly')
            .attr('contenteditable', 'true')
            .attr('spellcheck', 'true')
            .focusin(function () { SA.ContentEditableHasFocus = true; })
            .focusout(function () { SA.ContentEditableHasFocus = false; });
    }
  };

  TitlePage.prototype.ClearNote = function () {
    if (this.Edit && this.Note) {
      this.UpdateEdits();
    }
    this.Note = null;
  };

  TitlePage.prototype.DisplayNote = function (note) {
    this.Note = note;
    this.Div.show();
    this.Title.html(note.HiddenTitle);
    this.AuthorText.html(note.Text);

    // What is this doing?
    // Select the title?
    var sel = window.getSelection();
    var range;
    range = document.createRange();
    range.noCursor = true;
    range.selectNodeContents(this.Title[0]);
    sel.removeAllRanges();
    sel.addRange(range);
    // Changes it to be bigger and white
    document.execCommand('foreColor', false, '#FFF');
    document.execCommand('fontSize', false, '6');
    document.execCommand('fontName', false, 'Arial');

    // Format the author text.
    // Bad way to format.  Title page should go away and
    // be replaced by HtmlPage.
    range.selectNodeContents(this.AuthorText[0]);
    sel.removeAllRanges();
    sel.addRange(range);

    document.execCommand('fontSize', false, '5');
    document.execCommand('fontName', false, 'Arial');

    sel.removeAllRanges();
    // Remove focus from the two text boxes.
    this.Title.blur();
    this.AuthorText.blur();
  };

  TitlePage.prototype.UpdateEdits = function () {
    if (this.Note) {
      this.Note.Text = this.AuthorText.html();
      this.Note.HiddenTitle = this.Title.html();
    }
  };

// ==============================================================================
// How to save css stuff?
// embedded viewers will be children (what to do about multiple records, stacks?).
// Ignore edit for now.
  function HtmlPage (parent, edit, background) {
    this.Edit = edit;
    this.Note = null;
    // Should I make another div or just use the parent?
    this.Div = $('<div>')
        .appendTo(parent)
        .hide()
        .css({
          'background-color': background,
          'position': 'absolute',
          'width': '100%',
          'height': '100%'});
  }

  HtmlPage.prototype.EditOff = function () {
    if (SA.Edit && this.Edit) {
      this.Edit = false;
      this.Div.css({'width': '100%', 'left': '0px'});
      this.SaEditOff();
    }
  };
  HtmlPage.prototype.EditOn = function () {
    if (SA.Edit && !this.Edit) {
      this.Edit = true;
        // this.Div.css({'width': '100%', 'left': '0px'}); ???
      this.SaEditOn();
    }
  };

// Hide/show the edit gui on all the sa elements
  HtmlPage.prototype.SaEditOff = function () {
    $('.sa-edit-gui').saButtons('disable');
    $('.sa-presentation-text').attr('contenteditable', 'false');
    $('.sa-presentation-rectangle').saElement({'editable': false,
      'interactive': false});
    $('.sa-light-box').saLightBox({'editable': false,
      'interactive': true});
  };

  HtmlPage.prototype.SaEditOn = function () {
    $('.sa-edit-gui').saButtons('enable');
    $('.sa-presentation-text').attr('contenteditable', 'true');
    $('.sa-presentation-rectangle').saElement({'editable': true,
      'interactive': true});
    $('.sa-light-box').saLightBox({'editable': true,
      'interactive': true});
  };

  HtmlPage.prototype.ClearNote = function () {
    if (this.Edit && this.Note) {
      this.UpdateEdits();
    }
    this.Note = null;
  };

  HtmlPage.prototype.DisplayNote = function (note) {
    // Lets record to position of the previous slides viewers to use
    // as the position of any viewers in the new slide.
    this.DefaultViewerPositions = [];
    var lastViewers = $('.sa-lightbox-viewer');
    for (var i = 0; i < lastViewers.length; ++i) {
      this.DefaultViewerPositions.push(
        {left: lastViewers[i].style.left,
          top: lastViewers[i].style.top,
          width: lastViewers[i].style.width,
          height: lastViewers[i].style.height});
    }

    this.Note = note;
    this.Div.show();
    // This version setsup the saTextEditor and other jquery extensions.
    this.Div.saHtml(note.Text);

    if (!this.Edit) {
        // TODO: Reevaulate SaEdit functions.
      this.SaEditOff();
    } else {
      this.SaEditOn();
    }
    // hack
    // Do not let students edit text.
    if (!SA.Edit) {
      $('.sa-text-editor').attr('contenteditable', 'false');
    }

    // Change the edit status of the elements.
    var self = this;
    this.Div.find('.sa-presentation-image')
        .saLightBox({'editable': SA.Edit,
          'aspectRatio': true});
    this.Div.find('.sa-lightbox-viewer')
        .saLightBoxViewer({
          'editable': SA.Edit,
          'delete': function (dom) { self.ViewDeleteCallback(dom); }});
    this.Div.find('.sa-presentation-rectangle')
        .saRectangle({'editable': SA.Edit});
    // Make viewers into lightbox elements.
    // MOVE
    // this.InitializeViews(this.Div.find('.sa-presentation-view'));

    // Set stops.
    $('sa-draggable').saDraggable();
    // still needed for iframes.
    this.BindElements();
    // I do not want to shuffle questions between test and review.
    // if (SA.Edit) {
    //    this.ShuffleQuestion();
    // }
  };

// Add the initial html for a title page.
  HtmlPage.prototype.InitializeTitlePage = function () {
    this.Div.empty();
    this.Div[0].className = 'sa-presentation-title-page';
    // Title bar
    this.InsertRectangle('#073E87', '0%', '31%', '97.5%', '25%');
    // Should everything be have Div as parent?
    // Todo: make this look like jquery.
    this.InsertTextBox(50)
        .addClass('sa-presentation-title')
        .css({'color': 'white',
          'left': '10%',
          'width': '88%',
          'top': '40%'})
        .text('Title');

    this.InsertTextBox(28)
        .css({'left': '10%',
          'width': '88%',
          'top': '59%'})
        .text('Author');

    this.UpdateEdits();
    this.BindElements();
  };

// Add the initial html for a slide page.
  HtmlPage.prototype.InitializeSlidePage = function () {
    this.Div.empty();
    this.Div[0].className = 'sa-presentation-slide-page';

    // Title bar
    this.InsertRectangle('#073E87', '0%', '6%', '97.5%', '14%');

    // Should everything be have Div as parent?
    // Todo: make this look like jquery.
    this.InsertTextBox(42)
        .css({'color': 'white',
          'left': '18%',
          'width': '70%',
          'top': '7.25%',
          'height': '11.5%'})
        .text('Title')
        .addClass('sa-presentation-title');

    this.UpdateEdits();
    this.BindElements();
  };

// TODO: make sa jquery handle this.
  HtmlPage.prototype.InsertImage = function (src) {
    var imgDiv;
    var left = 5 + Math.floor(Math.random() * 10);
    var top = 20 + Math.floor(Math.random() * 10);

    /* // link option
    if (ref !== "") {
        imgDiv = $('<a>')
            .appendTo(this.Div)
            .attr('href', ref)
            .css({'position':'absolute',
                  'left'    :left+'%',
                  'top'     :top+'%',
                  'z-index' :'1'})
            .addClass('sa-presentation-image')
            .saLightBox();
    } else { */
    imgDiv = $('<div>')
        .appendTo(this.Div)
        .css({'position': 'absolute',
          'left': left + '%',
          'top': top + '%',
          'z-index': '1'})
        .saLightBox({aspectRatio: true,
          editable: SA.Edit})
        .addClass('sa-presentation-image');
    var img = $('<img>')
        .appendTo(imgDiv)
        .css({'width': '100%',
          'height': '100%'});
    img[0].onload = function () {
        // Bug.  imgDiv had no style.width
        // Not scalling
      this.parentNode.style.width = this.width + 'px';
      this.parentNode.style.height = this.height + 'px';
      this.parentNode.saElement.ConvertToPercentages();
    };
    img.attr('src', src);

    return imgDiv;
  };

// TODO: Change type based on extension
  HtmlPage.prototype.InsertVideo = function (src) {
    // resizable makes a containing div anyway.
    var vidDiv = $('<div>')
        .appendTo(this.Div)
        .css({'position': 'absolute',
          'left': '10%',
          'top': '30%',
          'z-index': '1'})
        .addClass('sa-presentation-video')
        .saDraggable()
        .saDeletable();

    var vid = $('<video controls>')
        .appendTo(vidDiv);
    src = $('<source type="video/mp4">')
        .appendTo(vid)
        .attr('src', src);

    vid[0].addEventListener('loadeddata', function () {
        // Video is loaded
        // compute the aspect ratio.
      var aRatio = $(this).width() / $(this).height();
      vidDiv.saResizable({
        aspectRatio: aRatio
      });
      vid.css({'height': '100%',
        'width': '100%'});
    }, false);

    return vidDiv;
  };

// Make the title bar movable and resizable.
// left, top, width and height should be in percentages. i.e. '50%'
  HtmlPage.prototype.InsertRectangle = function (color, left, top, width, height) {
    $('<div>')
        .appendTo(this.Div)
        .css({'background-color': color,
          'border': '1px solid rgba(255, 255, 255, 0)',
          'position': 'absolute',
          'left': left,
          'width': width,
          'top': top,
          'height': height})
        .saRectangle({editable: SA.Edit});
  };

// The execCommand paste does not work
  HtmlPage.prototype.Paste = function () {
    // resizable makes a containing div anyway.
    var containerDiv = $('<div>')
        .appendTo(this.Div)
        .css({'position': 'absolute',
          'left': '5%',
          'top': '25%'})
        .text('paste here')
        .saDraggable()
        .saDeletable();

    // Select the container
    containerDiv
        .attr('contenteditable', 'true')
        .focus();

    // Select everything.
    var sel = window.getSelection();
    var range = document.createRange();
    range.noCursor = true;
    range.selectNodeContents(containerDiv[0]);
    sel.removeAllRanges();
    sel.addRange(range);
    // This does not work.
    document.execCommand('paste', false, null);
  };

// Embed youtube.
// '<iframe width="420" height="315" src="https://www.youtube.com/embed/9tCafgGZtxQ" frameborder="0" allowfullscreen></iframe>');
  HtmlPage.prototype.InsertIFrame = function (html) {
    // Youtube size has to be set in the original html string.
    var width, height;
    var start = html.indexOf('width');
    var str;
    var end;
    var tmp;
    if (start !== -1) {
      str = html.substring(start + 7);
      end = str.indexOf('"');
      tmp = str.substr(0, end);
      width = parseInt(tmp) / (800 * 1.333);
      width = Math.round(width * 100);
      width = width + '%';
      html = html.replace(tmp, width);
    }
    start = html.indexOf('height');
    if (start !== -1) {
      str = html.substring(start + 8);
      end = str.indexOf('"');
      tmp = str.substr(0, end);
      height = parseInt(tmp) / 800;
      height = Math.round(height * 100);
      height = height + '%';
      html = html.replace(tmp, height);
    }

    var frame = $(html)
        .appendTo(this.Div)
        .css({'position': 'absolute',
          'display': 'block',
          'left': '5%',
          'top': '5%',
          'z-index': '1'})
        .saDraggable()
        .saDeletable();

    return frame;
  };

  HtmlPage.prototype.InsertURL = function (src) {
    // iframes do not scale with css.  I have to have a resize callback.
    var div = $('<div>')
        .appendTo(this.Div)
        .css({'position': 'absolute',
          'left': '5%',
          'right': '2.5%',
          'top': '25%',
          'bottom': '10%',
          'z-index': '1'})
        .saDraggable()
        .saDeletable()
        .resizable();
    var frame = $('<iframe>')
        .appendTo(div)
        .css({'position': 'absolute',
          'display': 'block',
          'width': '100%',
          'height': '100%'})
        .attr('src', src)
        .attr('scrolling', 'no')
        .addClass('sa-presentation-iframe');

    this.BindElements();
    return frame;
  };

// This could be eliminated and just use the jquery saTextEditor.
// Interactively place the initial box.
// First lets see if we can reposition it.
  HtmlPage.prototype.InsertTextBox = function (size) {
    size = size || 30;

    // Arbitrary height so I do not need to specify
    // text in percentages.
    var scale = size / 800;

    // Should everything be have Div as parent?
    var text = $('<div>')
        // note: parent has to be set before saTextEditor is called.
        .appendTo(this.Div)
        .css({'display': 'inline-block',
          'position': 'absolute',
          'overflow': 'visible',
          'fontFamily': 'Verdana,sans-serif',
          'border': '1px solid rgba(255, 255, 255, 0)',
              // defaults caller can reset these.
          'box-sizing': 'border-box',
          'left': '5%',
          'width': '50%',
          'top': '30%',
          'height': '10%',
          'padding': '2% 1% 1% 1%', // top right bottom left
          'z-index': '1'})
        .addClass('sa-presentation-text')
        // This makes the font scale with height of the window.
        .saScalableFont({scale: scale,
          editable: SA.Edit})
        // default content
        .text('Text');

    if (this.Edit) {
        // Make this div into a text editor.
      text.saTextEditor({dialog: true,
        editable: true});
    }

    return text;
  };

  HtmlPage.prototype.ShuffleQuestion = function () {
    var questions = this.Div.find('.sa-q [type="multiple-choice"]');
    for (var i = 0; i < questions.length; ++i) {
      var q = questions[i];
        // Shuffle the list.
      for (var j = q.childNodes.length; j > 0; --j) {
        var idx = Math.floor(Math.random() * j);
        q.appendChild(q.removeChild(q.childNodes[idx]));
      }
    }
  };

// Multiple choice for now.
// Answers stored as list items <li>.
  HtmlPage.prototype.InsertQuestion = function () {
    var bar = $('<div>')
        .css({'position': 'absolute',
          'left': '2%',
          'width': '92%',
          'top': '75%',
          'height': '22.5%',
          'background': '#FFF',
          'border': '1px solid #AAA',
          'padding': '1% 1% 1% 1%', // top right bottom left
          'z-index': '1'})
        .saScalableFont({scale: '0.03'})
        .saQuestion({editable: SA.Edit});

    // This is for interactive adding new question from the GUI / dialog.
    // Do not apped the question until apply is selected.
    var self = this;
    bar.saQuestion('OpenDialog',
                   function () {
                     bar.appendTo(self.Div);
                     bar.trigger('resize');
                   });
  };

// Should save the view as a child notes, or viewer record?
// For saving, it would be easy to encode the view id into the html as an
// attribute, but what would I do with the other viewer records?  Ignore
// them. One issue:  I have to save the new note to get the id, which is
// necessary, for the saViewer.  Well, maybe not.  I could pass in the
// note, and then get the id when saHtml() is called to save.
  HtmlPage.prototype.InsertView = function (viewObj) {
    if (!this.Note) {
      return;
    }

    // First make a copy of the view as a child.
    var newNote = new SA.Note();
    var tmpId = newNote.Id;
    newNote.Load(viewObj);
    delete newNote.Id;
    newNote.Id = tmpId;
    if (newNote.ViewerRecords.length === 0) {
      SA.Debug('Insert failed: Note has no viewer records.');
    } else if (this.Note.Parent) {
      this.Note.Children.push(newNote);
      newNote.Parent = this.Note;
      this.InsertView2(newNote);
    } else {
        // We cannot add a dual view to a tile page because the child note
        // will be interpreted as a new slide.
      this.InsertViewerRecord(newNote.ViewerRecords[0]);
    }
  };

// The html page is a note.  It contains viewer whose states are saved in
// viewerRecords.
// Helper method
// TODO: Change newNote to viewerRecord.
  HtmlPage.prototype.InsertViewerRecord = function (viewerRecord) {
    if (!this.Note) {
      return;
    }

    var viewerIdx = this.Note.ViewerRecords.length;
    this.Note.ViewerRecords.push(viewerRecord);

    var defaultPosition = {left: '5%', top: '25%', width: '40%', height: '40%'};
    if (this.DefaultViewerPositions.length > 0) {
      defaultPosition = this.DefaultViewerPositions.splice(0, 1)[0];
    } else {
      var n = (this.Div.children().length) * 5;
      defaultPosition.left = n.toString() + '%';
      defaultPosition.top = (n + 15).toString() + '%';
    }

    var self = this;
    var viewerDiv = $('<div>')
        .appendTo(this.Div)
        .css({'position': 'absolute',
          'box-shadow': '10px 10px 5px #AAA',
          'background-color': '#FFF',
          'opacity': '1.0',
          'left': defaultPosition.left,
          'width': defaultPosition.width,
          'top': defaultPosition.top,
          'height': defaultPosition.height})
        .saLightBoxViewer({
          'note': this.Note,
          'viewerIndex': viewerIdx,
          'hideCopyright': true,
          'editable': SA.Edit,
          'delete': function (dom) { self.ViewDeleteCallback(dom); }});

    return viewerDiv;
  };
// The html page is a note.  It contains viewer whose states are saved in
// viewerRecords.
// Helper method
// TODO: Change newNote to viewerRecord.
  HtmlPage.prototype.InsertView2 = function (view) {
    if (!this.Note) {
      return;
    }

    var defaultPosition = {left: '5%', top: '25%', width: '45%', height: '45%'};
    if (this.DefaultViewerPositions.length > 0) {
      defaultPosition = this.DefaultViewerPositions.splice(0, 1)[0];
    }

    var self = this;
    var viewerDiv = $('<div>')
        .appendTo(this.Div)
        .css({'position': 'absolute',
          'box-shadow': '10px 10px 5px #AAA',
          'background-color': '#FFF',
          'opacity': '1.0',
          'left': defaultPosition.left,
          'width': defaultPosition.width,
          'top': defaultPosition.top,
          'height': defaultPosition.height})
        .saLightBoxViewer({
          'note': view,
          'dual': true,
          'hideCopyright': true,
          'delete': function (dom) { self.ViewDeleteCallback(dom); },
          'editable': SA.Edit});

    return viewerDiv;
  };
// This was for development debugging
  HtmlPage.prototype.InsertViewId2 = function (viewId) {
    if (!this.Note) {
      return;
    }

    var defaultPosition = {left: '5%', top: '25%', width: '45%', height: '45%'};
    if (this.DefaultViewerPositions.length > 0) {
      defaultPosition = this.DefaultViewerPositions.splice(0, 1)[0];
    }

    var viewerDiv = $('<div>')
        .appendTo(this.Div)
        .css({'position': 'absolute',
          'box-shadow': '10px 10px 5px #AAA',
          'background-color': '#FFF',
          'opacity': '1.0',
          'left': defaultPosition.left,
          'width': defaultPosition.width,
          'top': defaultPosition.top,
          'height': defaultPosition.height})
        .saLightBoxViewer({
          'viewId': viewId,
          'dual': true,
          'hideCopyright': true,
          'editable': SA.Edit});

    return viewerDiv;
  };

  HtmlPage.prototype.ViewDeleteCallback = function (dom) {
    // When a viewer is deleted the next should replace it.
    this.DefaultViewerPositions.push(
      {left: dom.style.left,
        top: dom.style.top,
        width: dom.style.width,
        height: dom.style.height});

    // Extra viewer records get pruned when the page is converted to html
    // Get rid of dual viewer notes.
    if (dom.saViewer.saNote !== this.Note) {
      var childIdx = this.Note.Children.indexOf(dom.saViewer.saNote);
      if (childIdx >= 0) {
        this.Note.Children.splice(childIdx, 1);
      }
    }
  };

// NOTE: This should be lagacy now.  The jquery extensions should handle this.
// Text elements need to resize explicitly.
// TODO: Activate text (saScalatFont, saTextEditor, resize) on load.
// I could make this scalabe ifram as a jquery extension too.
  HtmlPage.prototype.BindElements = function () {
    // Similar to text, we need to scale the content.
    var frameElements = $('.sa-presentation-iframe');
    frameElements.addClass('sa-resize');
    for (var i = 0; i < frameElements.length; ++i) {
      var frame = frameElements[i];
      frame.onresize =
            function () {
              var w = $(this).parent().width();
              var h = $(this).parent().height();
              var scale = Math.min(h, w / 1.62) / 700;
              var scaleStr = scale.toString();
              w = (Math.floor(w / scale)).toString();
              h = (Math.floor(h / scale)).toString();

              $(this).css({'-ms-zoom': scaleStr,
                '-ms-transform-origin': '0 0',
                '-moz-transform': 'scale(' + scaleStr + ')',
                '-moz-transform-origin': '0px 50px',
                '-o-transform': 'scale(' + scaleStr + ')',
                '-o-transform-origin': '0px 50px',
                '-webkit-transform': 'scale(' + scaleStr + ')',
                '-webkit-transform-origin': '0 0',
                'width': w + 'px',
                'height': h + 'px'});
            };
      frame.onresize();
    }
  };

  HtmlPage.prototype.UpdateEdits = function () {
    if (this.Note) {
        // Record the camera position (and annotations).
      this.Div.find('.sa-lightbox-viewer').saRecordViewer();
        // Doing this here forces us to save the notes
        // TODO: This may created orphaned views. fix this be either
        // delaying copying saHtml to note, or incrementally saving
        // presentation to the database.
      var htmlDiv = this.Div;
      var note = this.Note;

        // prune deleted records.
        // I should really do this when a view is deleted, but there are
        // deleted records in the database.
        // NOTE: THIS ASSUME THAT ALL THE SA.VIEWERS USE THIS NOTE!!!
      var newRecords = [];
      for (var i = 0; i < this.Note.ViewerRecords.length; ++i) {
        var record = this.Note.ViewerRecords[i];
        var str = i.toString();
        var items = $('[sa-viewer-index=' + str + ']');
        if (items.length > 0) {
                // Replace the index with the new index
          items.attr('sa-viewer-index', newRecords.length);
          newRecords.push(record);
        }
      }
      this.Note.ViewerRecords = newRecords;

      note.Text = htmlDiv.saHtml();
    }
  };

// ==============================================================================
  function SearchPanel (parent, callback) {
    var self = this;
    this.UserCallback = callback;
    this.Parent = parent;

    // List of image data needed for callback.
    this.SearchData = [];

    // TODO:
    // User should probably be formating the parent.
    parent
        .css({'overflow': 'auto',
          'text-align': 'left',
          'color': '#303030',
          'font-size': '18px'});
    this.SearchForm = $('<form>')
        .appendTo(parent)
        .css({'width': '100%',
          'display': 'table'})
        .submit(function (e) { self.SearchCallback(); return false; });
    this.SearchLabel = $('<span>')
        .appendTo(this.SearchForm)
        .css({'display': 'table-cell',
          'padding': '8px',
          'width': '3.5em'})
        .text('Search:');
    this.SearchInput = $('<input>')
        .appendTo(this.SearchForm)
        .css({'width': '95%',
          'display': 'table-cell',
          'border': '2px inset #CCC'})
        .focusin(function () { SA.ContentEditableHasFocus = true; })
        .focusout(function () { SA.ContentEditableHasFocus = false; });
    this.SearchResults = $('<div>')
        .appendTo(parent)
        .css({'position': 'absolute',
          'top': '2em',
          'bottom': '0px',
          'width': '100%',
          'overflow-y': 'auto'});
  }

  SearchPanel.prototype.SearchCallback = function () {
    var self = this;
    var terms = this.SearchInput.val();

    this.Parent.css({'cursor': 'progress'});
    $.ajax({
      type: 'get',
      url: '/webgl-viewer/query',
      data: {'terms': terms},
      success: function (data, status) {
        self.LoadSearchResults(data);
        self.Parent.css({'cursor': 'default'});
      },
      error: function () {
        SA.Debug('AJAX - error() : query');
        self.Parent.css({'cursor': 'default'});
      }
    });
  };

  SearchPanel.prototype.LoadSearchResults = function (data) {
    var self = this;
    this.SearchResults.empty();
    this.SearchData = data.images;

    // These are in order of best match.
    for (var i = 0; i < data.images.length; ++i) {
      var imgObj = data.images[i];

      var imageDiv = $('<div>')
            .appendTo(this.SearchResults)
            .css({'float': 'left',
              'margin': '5px',
              'border': '1px solid #AAA'})
            .attr('id', imgObj._id)
            .data('index', i)
            .hover(function () { $(this).css({'border-color': '#00F'}); },
                   function () { $(this).css({'border-color': '#AAA'}); })
            .click(function () {
              self.SelectCallback($(this).data('index'));
            });

      var image = {img: imgObj._id,
        db: imgObj.database,
        levels: imgObj.levels,
        tile_width: imgObj.TileWidth,
        tile_height: imgObj.TileHeight,
        bounds: imgObj.bounds,
        label: imgObj.label};
      if (!image.bounds) {
        image.bounds = [0, imgObj.dimensions[0], 0,
          imgObj.dimensions[1]];
      }
      var thumb = new SA.CutoutThumb(image, 100);
      thumb.Div.appendTo(imageDiv);
      $('<div>')
            .css({'font-size': '50%'})
            .appendTo(imageDiv)
            .text(imgObj.label); // Should really have the image label.
    }
  };

  SearchPanel.prototype.SelectCallback = function (index) {
    // Search data is just a list of image objects.
    if (this.UserCallback && index >= 0 && index < this.SearchData.length) {
      (this.UserCallback)(this.SearchData[index]);
    }
  };

// ==============================================================================

  function ClipboardPanel (parent, callback) {
    var self = this;
    this.UserCallback = callback;

    parent
        .css({'overflow': 'auto',
          'text-align': 'left',
          'color': '#303030',
          'font-size': '18px'});
    this.ClearButton = $('<button>')
        .appendTo(parent)
        .click(function () { self.ClipboardDeleteAll(); })
        .text('Remove All');
    this.ClipboardDiv = $('<div>')
        .css({'overflow_y': 'auto'})
        .appendTo(parent);

    $.ajax({
      type: 'get',
      url: 'webgl-viewer/getfavoriteviews',
      success: function (data, status) {
        if (status === 'success') {
          self.LoadClipboardCallback(data);
        } else { SA.Debug('ajax failed - get favorite views 2'); }
      },
      error: function () {
        SA.Debug('AJAX - error() : getfavoriteviews 2');
      }
    });
  }

  ClipboardPanel.prototype.LoadClipboardCallback = function (sessionData) {
    var self = this;
    this.ClipboardDiv.empty();
    this.ClipboardViews = sessionData.viewArray;

    for (var i = 0; i < this.ClipboardViews.length; ++i) {
      var view = this.ClipboardViews[i];
      if (view.Thumb.substring(0, 6) === 'http:/') {
        view.Thumb = view.Thumb.substring(6);
      }
      $('<img>')
            .appendTo(this.ClipboardDiv)
            .attr('src', view.Thumb)
            .prop('title', view.Title)
            .css({'float': 'left',
              'margin': '5px',
              'border': '1px solid #AAA',
              'height': '60px'})
            .attr('index', i)
            .hover(function () { $(this).css({'border-color': '#00F'}); },
                   function () { $(this).css({'border-color': '#AAA'}); })
            .click(function () {
              self.ClickViewCallback(parseInt(this.getAttribute('index')));
            });
    }
  };

  ClipboardPanel.prototype.ClickViewCallback = function (idx) {
    if (this.UserCallback && idx >= 0 && idx < this.ClipboardViews.length) {
      (this.UserCallback)(this.ClipboardViews[idx]);
    }
  };

  ClipboardPanel.prototype.ClipboardDeleteAll = function () {
    this.ClipboardDiv.empty();

    for (var i = 0; i < this.ClipboardViews.length; ++i) {
      $.ajax({
        type: 'post',
        url: '/webgl-viewer/deleteusernote',
        data: {'noteId': this.ClipboardViews[i]._id,
          'col': 'views'}, // "favorites"
        success: function (data, status) {
        },
        error: function () {
          SA.Debug('AJAX - error() : deleteusernote');
        }
      });
    }
  };

  SA.SearchPanel = SearchPanel;
  SA.ClipboardPanel = ClipboardPanel;
  SA.Presentation = Presentation;
})();

// Make this a singlton (effectively) for now.
// Two levels of caching and pruning.
// Image without an associated texture map.
// Texture maps (scarcer resource).

(function () {
  'use strict';

  // TODO: Mny of these can remain private.
  SA.TileLoader = 'http';

  // Keep a queue of tiles to load so we can sort them as
  // new requests come in.
  SA.LoadQueue = [];
  SA.LoadingCount = 0;
  SA.LoadingMaximum = 10;
  SA.LoadTimeoutId = 0;

  SA.TimeStamp = 0;
  SA.NumberOfTiles = 0;
  SA.NumberOfTextures = 0;
  // SA.MaximumNumberOfTiles = 50000;
  SA.MaximumNumberOfTiles = 3000;
  SA.MaximumNumberOfTextures = 5000;
  SA.PruneTimeTiles = 0;
  SA.PruneTimeTextures = 0;

  if (SA.MOBILE_DEVICE) {
    SA.MaximumNumberOfTiles = 5000;
  }

  SA.LoadProgressMax = 0;
  SA.ProgressBar = null;

  // Only used for saving images right now.
  SA.FinishedLoadingCallbacks = [];

  SA.InitProgressBar = function () {
    if (SA.ProgressBar) { return; }
    SA.ProgressBar = $('<div>')
            .appendTo('body')
            .addClass('sa-view-progress-bar');
  };

  SA.AdvanceTimeStamp = function () {
    ++SA.TimeStamp;
  };

  SA.GetCurrentTime = function () {
    return SA.TimeStamp;
  };

  // Prunning could be rethought to avoid so much depdency on the cache.
  SA.Prune = function () {
    var prune = false;
    if (SA.NumberOfTiles >= SA.MaximumNumberOfTiles) {
      // Overflow may be possible after running for a while.
      if (SA.PruneTimeTiles > SA.TimeStamp) {
        SA.PruneTimeTiles = 0;
      }
      // Advance the prune threshold.
      SA.PruneTimeTiles += 0.05 * (SA.TimeStamp - SA.PruneTimeTiles);
      prune = true;
    }

    if (SA.NumberOfTextures >= SA.MaximumNumberOfTextures) {
      // Overflow may be possible after running for a while.
      if (SA.PruneTimeTextures > SA.TimeStamp) {
        SA.PruneTimeTextures = 0;
      }
      // Advance the prune threshold.
      SA.PruneTimeTextures += 0.05 * (SA.TimeStamp - SA.PruneTimeTextures);
      prune = true;
    }

    // console.log("Prune test " + SA.NumberOfTiles + ", limit " + SA.MaximumNumberOfTiles);

    if (prune) {
      console.log('prune !!!!!!');
      for (var i in SA.Caches) {
        var cache = SA.Caches[i];
        cache.PruneTiles();
      }
    }
  };

  SA.ClearQueue = function () {
    for (var i = 0; i < SA.LoadQueue.length; ++i) {
      var tile = SA.LoadQueue[i];
      if (tile) {
        tile.LoadState = 0;
      }
    }
    SA.LoadQueue = [];
    SA.LoadQueueUpdate();
  };

  // You have to call LoadQueueUpdate after adding tiles.
  // We could chop off the lowest priority tiles if the queue gets too long.
  // Simply add the tile to the queue.
  SA.LoadQueueAddTile = function (tile) {
    if (tile.LoadState === 0 || tile.LoadState === 4) {
      // New tile or error
      tile.LoadState = 1;
      // Add the tile at the front of the queue.
      SA.LoadQueue.push(tile);
    }
  };

  // Push the best tile to the end of the queue.
  var PushBestToLast = function () {
    // Do a sort pass (pushing high priority items to the end.
    var t0 = SA.LoadQueue[0];
    for (var i = 1; i < SA.LoadQueue.length; ++i) {
      var t1 = SA.LoadQueue[i];
      var swap = false;
      if (t1 !== null) {
        if (t0 === null) {
          swap = true;
        } else if (t0.TimeStamp > t1.TimeStamp) {
          swap = true;
        } else if (t0.TimeStamp === t1.TimeStamp && t0.Level < t1.Level) {
          swap = true;
        }
      }
      if (swap) {
        // Swap the pair.
        SA.LoadQueue[i] = t0;
        SA.LoadQueue[i - 1] = t1;
      } else {
        t0 = t1;
      }
    }
  };

  // I need a way to remove tiles from the queue when they are deleted.
  // I know this is inefficient.
  SA.LoadQueueRemove = function (tile) {
    var length = SA.LoadQueue.length;
    for (var i = 0; i < length; ++i) {
      if (SA.LoadQueue[i] === tile) {
        tile.LoadState = 0;
        SA.LoadQueue[i] = null;
        return;
      }
    }
  };

  var LoadTimeout = function () {
    // 4 images requests are too slow.  Reset
    // I do not know which requests failed so I cannot mak another request.
    // TODO: Remember loading tiles (even if only for debugging).
    SA.LoadingCount = 0;
    SA.LoadQueueUpdate();
  };

  // We will have some number of tiles loading at one time.
  // Take the first N tiles from the queue and start loading them.
  // Too many and we cannot abort loading.
  // Too few and we will serialize loading.
  SA.LoadQueueUpdate = function () {
    if (SA.LoadingCount < 0) {
      // Tiles must have arrived after timeout.
      SA.LoadingCount = 0;
    }
    while (SA.LoadingCount < SA.LoadingMaximum &&
           SA.LoadQueue.length > 0) {
      PushBestToLast();
      var tile = SA.LoadQueue.pop();
      if (tile !== null && tile.LoadState === 1) {
        tile.StartLoad(tile.Cache);
        tile.LoadState = 2; // Loading.
        ++SA.LoadingCount;
      }
    }

    // Observed bug: If 4 tile requests never return, loading stops.
    // Do a time out to clear this hang.
    if (SA.LoadTimeoutId) {
      clearTimeout(SA.LoadTimeoutId);
      SA.LoadTimeoutId = 0;
    }
    if (SA.LoadingCount) {
      SA.LoadTimeoutId = setTimeout(function () { LoadTimeout(); }, 1000);
    }

    if (SA.ProgressBar) {
      if (SA.LoadProgressMax < SA.LoadQueue.length) {
        SA.LoadProgressMax = SA.LoadQueue.length;
      }
      var width = (100 * SA.LoadQueue.length / SA.LoadProgressMax).toFixed();
      width = width + '%';
      SA.ProgressBar.css({'width': width});
      // Reset maximum
      if (SA.LoadQueue.length === 0) {
        SA.LoadProgressMax = 0;
      }
    }

    if (SA.FinishedLoadingCallbacks.length > 0 &&
            SA.LoadQueue.length === 0 && SA.LoadingCount === 0) {
      var tmp = SA.FinishedLoadingCallbacks.slice(0); // copy
      SA.FinishedLoadingCallbacks = [];
      for (var i = 0; i < tmp.length; ++i) {
        (tmp[i])();
      }
    }
  };

  SA.AddFinishedLoadingCallback = function (callback) {
    SA.FinishedLoadingCallbacks.push(callback);
    SA.LoadQueueUpdate();
  };

  SA.ClearFinishedLoadingCallbacks = function () {
    SA.FinishedLoadingCallbacks = [];
  };

  // Issue: Tiles call this method when their image gets loaded.
  // How does the tile know which cache it belongs too.
  // Marks a tile as loaded so another can start.
  SA.LoadQueueLoaded = function (tile) {
    --SA.LoadingCount;
    tile.LoadState = 3; // Loaded
    // Cache has a LoadRootsCallback
    if (tile.Cache.LoadTileCallback) {
      (tile.Cache.LoadTileCallback)();
      tile.Cache.LoadTileCallback = undefined;
    }
    SA.LoadQueueUpdate();
  };

  // This is called if their was a 404 image not found error.
  SA.LoadQueueError = function (tile) {
    tile.LoadState = 4; // Error Loading
    --SA.LoadingCount;
    SA.LoadQueueUpdate();
  };
})();

// ==============================================================================
// Camera Object
// Set the viewport separately

window.SAM = window.SAM || {};

(function () {
  'use strict';

  function Camera () {
    // This transformation is from global/world to slide coordinate system
    this.WorldToImageTransform = [1, 0, 0, 1, 0, 0];

    // Better managmenet of layers and sub layers.
    // Assign a range of the z buffer  for the view to use exclusively.
    // The full range is -1->1.  -1 is in front.
    this.ZRange = [-1.0, 1.0];
    this.WorldRoll = 0;
    this.WorldMatrix = mat4.create();
    this.ImageMatrix = mat4.create();
    this.Height = 16000;
    this.Width = this.Height * 1.62;
    this.WorldFocalPoint = [128.0 * 64.0, 128.0 * 64.0];
    this.ComputeMatrix();
    // for drawing the view bounds.
    this.Points = [];
    this.Buffer = null;
    this.CreateBuffer();
    this.Mirror = false;

    // When rotating, I want to stop at 0, 90, 180, and 270.
    this.RollStopFlag = false;
    this.RollStopCounter = 0.0;

    // Placeholders
    this.ViewportWidth = 162;
    this.ViewportHeight = 100;
  }

  // User can draw in image coordinates.
  /*
  Camera.prototype.ContextSetImageTransform = function (ctx) {
    // Start with a transform that flips the y axis.
    ctx.setTransform(1, 0, 0, -1, 0, this.ViewportHeight);
    // Map (-1->1, -1->1) to the viewport.
    ctx.transform(0.5 * this.ViewportWidth, 0.0,
                  0.0, 0.5 * this.ViewportHeight,
                  0.5 * this.ViewportWidth,
                  0.5 * this.ViewportHeight);
    // Apply the image matrix
    var m = this.GetImageMatrix();
    var h = 1.0 / m[15];
    ctx.transform(m[0] * h, m[1] * h,
                  m[4] * h, m[5] * h,
                  m[12] * h, m[13] * h);
  }; */
  // Get the image to viewer transformation (for the canvas).
  Camera.prototype.GetImageToViewerTransform = function () {
    // Start with a transform that flips the y axis.
    var t1 = [1, 0, 0, -1, 0, this.ViewportHeight];
    // Map (-1->1, -1->1) to the viewport.
    var t2 = [
      0.5 * this.ViewportWidth, 0.0,
      0.0, 0.5 * this.ViewportHeight,
      0.5 * this.ViewportWidth,
      0.5 * this.ViewportHeight
    ];
    // Apply the image matrix
    var m = this.GetImageMatrix();
    var h = 1.0 / m[15];
    var t3 = [
      m[0] * h, m[1] * h,
      m[4] * h, m[5] * h,
      m[12] * h, m[13] * h
    ];
    var t = SAM.MultiplyTransforms(t1, t2);
    t = SAM.MultiplyTransforms(t, t3);
    return t;
  };

  // This transformation is from global/world to slide coordinate system
  Camera.prototype.SetWorldToImageTransform = function (trans) {
    this.WorldToImageTransform = trans;
    this.ComputeMatrix();
  };

  Camera.prototype.GetViewportHeight = function () {
    return this.ViewportHeight;
  };

  Camera.prototype.GetViewportWidth = function () {
    return this.ViewportWidth;
  };

  // Spacing of pixels of the screen.
  Camera.prototype.GetSpacing = function () {
    return this.GetHeight() / this.ViewportHeight;
  };

  // Copies the world view but not the slide to world transform.
  Camera.prototype.WorldCopy = function (inCam) {
    if (inCam.ZRange) { this.ZRange = inCam.ZRange.slice(0); }
    this.WorldRoll = inCam.WorldRoll;
    this.Height = inCam.Height;
    this.Width = inCam.Width;
    this.SetWorldFocalPoint(inCam.WorldFocalPoint);
    if (inCam.ViewportWidth) { this.ViewportWidth = inCam.ViewportWidth; }
    if (inCam.ViewportHeight) { this.ViewportHeight = inCam.ViewportHeight; }
    this.ComputeMatrix();
  };

  Camera.prototype.DeepCopy = function (inCam) {
    this.WorldToImageTransform = inCam.WorldToImageTransform.slice(0);
    this.WorldCopy(inCam);
  };

  Camera.prototype.SetViewport = function (viewport) {
    if (10 * viewport[3] < viewport[2]) {
      // alert('Unusual viewport ' + viewport[3]);
      return;
    }
    this.ViewportWidth = viewport[2];
    this.ViewportHeight = viewport[3];
    this.Width = this.Height * this.ViewportWidth / this.ViewportHeight;
    this.ComputeMatrix();
  };

  Camera.prototype.Serialize = function () {
    var obj = {};
    obj.WorldFocalPoint = [this.WorldFocalPoint[0], this.WorldFocalPoint[1]];
    obj.WorldRoll = this.WorldRoll;
    obj.Height = this.GetHeight();
    obj.Width = this.GetWidth();
    return obj;
  };

  Camera.prototype.Load = function (obj) {
    this.SetWorldFocalPoint(obj.FocalPoint);
    this.WorldRoll = obj.Roll;
    this.Height = obj.Height;
    if (obj.Width) {
      this.Width = obj.Width;
    } else {
      this.Width = this.Height * this.ViewportWidth / this.ViewportHeight;
    }

    // Width is computed from height and aspect.
    this.ComputeMatrix();
  };

  // Roll is in Radians
  // Rotation is in Degrees
  Camera.prototype.GetWorldRotation = function () {
    return this.WorldRoll * 180.0 / 3.1415926535;
  };

  Camera.prototype.GetImageRotation = function () {
    return this.GetImageRoll() * 180.0 / 3.1415926535;
  };

  Camera.prototype.GetWorldRoll = function () {
    return this.WorldRoll;
  };

  // Legacy: What a pain.
  Camera.prototype.GetImageRoll = function () {
    // Create a world up vector.
    var x = Math.cos(this.WorldRoll);
    var y = Math.sin(this.WorldRoll);
    // Transform to image coordinate system.
    var t = this.WorldToImageTransform;
    var imx = (t[0] * x) + (t[2] * y);
    var imy = (t[1] * x) + (t[3] * y);
    // Now normalize.
    var mag = Math.sqrt(imx * imx + imy * imy);
    imx = imx / mag;
    imy = imy / mag;
    // Now convert back into radians.
    return Math.atan2(imy, imx);
  };

  Camera.prototype.GetWorldFocalPoint = function () {
    // Copy to avoid bugs because arrays are shared.
    // These are nasty to find.
    return [this.WorldFocalPoint[0], this.WorldFocalPoint[1]];
  };

  Camera.prototype.GetImageFocalPoint = function () {
    return SAM.ApplyTransform(this.WorldToImageTransform, this.WorldFocalPoint);
  };

  // This is in global/world coordinate system.
  Camera.prototype.SetWorldFocalPoint = function (fp) {
    if (isNaN(fp[0]) || isNaN(fp[1])) {
      return;
    }
    this.WorldFocalPoint[0] = fp[0];
    this.WorldFocalPoint[1] = fp[1];
    // Ignore z on purpose.
  };

  // View is in screen pixel coordinates.
  Camera.prototype.ConvertPointViewerToImage = function (x, y) {
    // Convert to world coordinate system
    // Compute focal point from inverse overview camera.
    var m = this.ImageMatrix;
    x = x / this.ViewportWidth;
    y = y / this.ViewportHeight;
    x = (x * 2.0 - 1.0) * m[15];
    y = (1.0 - y * 2.0) * m[15];
    var det = m[0] * m[5] - m[1] * m[4];
    var xNew = (x * m[5] - y * m[4] + m[4] * m[13] - m[5] * m[12]) / det;
    var yNew = (y * m[0] - x * m[1] - m[0] * m[13] + m[1] * m[12]) / det;

    return [xNew, yNew];
  };

  // View is in screen pixel coordinates.
  Camera.prototype.ConvertPointViewerToWorld = function (x, y) {
    // Convert to world coordinate system
    // Compute focal point from inverse overview camera.
    var m = this.WorldMatrix;
    x = x / this.ViewportWidth;
    y = y / this.ViewportHeight;
    x = (x * 2.0 - 1.0) * m[15];
    y = (1.0 - y * 2.0) * m[15];
    var det = m[0] * m[5] - m[1] * m[4];
    var xNew = (x * m[5] - y * m[4] + m[4] * m[13] - m[5] * m[12]) / det;
    var yNew = (y * m[0] - x * m[1] - m[0] * m[13] + m[1] * m[12]) / det;

    return [xNew, yNew];
  };

  Camera.prototype.ConvertPointWorldToViewer = function (x, y) {
    var m = this.WorldMatrix;

    // Convert from world coordinate to view (-1->1);
    var h = (x * m[3] + y * m[7] + m[15]);
    var xNew = (x * m[0] + y * m[4] + m[12]) / h;
    var yNew = (x * m[1] + y * m[5] + m[13]) / h;
    // Convert from view to screen pixel coordinates.
    xNew = (1.0 + xNew) * 0.5 * this.ViewportWidth;
    yNew = (1.0 - yNew) * 0.5 * this.ViewportHeight;

    return [xNew, yNew];
  };

  Camera.prototype.ConvertScaleViewerToImage = function (dist) {
    // It looks like ImageMatrix is scaled to width so to keep things
    // simple ....
    var m = this.ImageMatrix;
    return dist * 2.0 * m[15] / this.ViewportWidth;
  };

  Camera.prototype.ConvertScaleWorldToViewer = function (dist) {
    // It looks like ImageMatrix is scaled to width so to keep things
    // simple ....
    var m = this.WorldMatrix;
    return dist * this.ViewportWidth / (2.0 * m[15]);
  };

  // dx, dy are in view coordinates [-0.5,0.5].
  // The camera world matrix converts world to view.
  Camera.prototype.HandleTranslate = function (dx, dy) {
    // Convert view vector to world vector.
    // We could invert the matrix to get the transform, but this is easier for now.....
    var s = Math.sin(this.WorldRoll);
    var c = Math.cos(this.WorldRoll);
    var w = this.GetWidth();

    if (this.Mirror) {
      dy = -dy;
    }

    // Scale to world.
    dx = dx * w;
    dy = dy * w;
    // Rotate
    var rx = dx * c + dy * s;
    var ry = dy * c - dx * s;

    this.Translate(rx, ry, 0.0);
  };

  // x,y are in display coordiantes (origin at the center).
  // dx,dy are in the same coordinates system (scale).
  // Scale does not matter because we only care about rotation.
  Camera.prototype.HandleRoll = function (x, y, dx, dy) {
    // Avoid divide by zero / singularity
    if (x === 0 && y === 0) {
      return;
    }
    // Orthogonal (counter clockwise) dot dVect.
    var dRoll = -y * dx + x * dy;
    // Remove magnitude of location.
    // Scale by R to get correct angle.
    dRoll = dRoll / (x * x + y * y);
    if (this.Mirror) {
      dRoll = -dRoll;
    }
    this.IncrementRollWithStops(dRoll);
  };

  Camera.prototype.IncrementRollWithStops = function (dRoll) {
    // Keep roll in radians.
    var newRoll = this.WorldRoll + dRoll;
    // Logic for 90 degree stops
    var rad90 = Math.PI * 0.5;

    // How long to stop in units radians.
    var stopDuration = rad90 / 9; // 10 degrees
    var quadrant = ((Math.floor(this.WorldRoll / rad90) % 4) + 4) % 4;
    var newQuadrant = ((Math.floor(newRoll / rad90) % 4) + 4) % 4;
    // Are we going to pass a stop?
    if (!this.RollStopFlag && quadrant !== newQuadrant) {
      // Yes, compute the stop angle.
      var stopAngle = 0;
      if (Math.abs(quadrant - newQuadrant) < 2) {
        stopAngle = (((quadrant + newQuadrant) / 2.0) + 0.5) * rad90;
      }
      this.RollStopFlag = true;
      // Rotate upto the stop (update dRoll) and let remaining cases execute..
      dRoll -= (this.WorldRoll - stopAngle);
      // Handle the 360->0 boundaries.
      var rad360 = Math.PI * 2.0;
      while (dRoll > Math.PI) {
        dRoll -= rad360;
      }
      while (dRoll < -Math.PI) {
        dRoll += rad360;
      }
      this.WorldRoll = stopAngle;
      if (dRoll > 0) {
        this.RollStopCounter = 0;
      } else {
        this.RollStopCounter = stopDuration;
      }
      dRoll = 0;
    }
    // If we are at a stop, advance the stop by dRoll.
    if (this.RollStopFlag) {
      this.RollStopCounter += dRoll;
      console.log('roll stop counter: ' + this.RollStopCounter);
      dRoll = 0;
      if (this.RollStopCounter < 0.0) {
        this.RollStopFlag = false;
        dRoll = this.RollStopCounter;
      }
      if (this.RollStopCounter > stopDuration) {
        this.RollStopFlag = false;
        dRoll = this.RollStopCounter - stopDuration;
      }
    }
    // Handle normal rotation.
    this.WorldRoll += dRoll;

    this.ComputeMatrix();
  };

  Camera.prototype.Translate = function (dx, dy, dz) {
    if (isNaN(dx) || isNaN(dy) || isNaN(dz)) {
      return;
    }
    // I will leave this as an exception.
    // Everything else uses SetWorldFocalPoint([x,y]);
    this.WorldFocalPoint[0] += dx;
    this.WorldFocalPoint[1] += dy;
    this.ComputeMatrix();
  };

  Camera.prototype.GetHeight = function () {
    return this.Height;
  };

  Camera.prototype.SetHeight = function (height) {
    if (isNaN(height)) {
      return;
    }
    this.Height = height;
    // Width tracks height.
    this.Width = height * this.ViewportWidth / this.ViewportHeight;
  };

  Camera.prototype.GetWidth = function () {
    return this.Width;
  };

  Camera.prototype.SetWidth = function (width) {
    if (isNaN(width)) {
      return;
    }
    this.Width = width;
    // Width tracks height.
    this.Height = width * this.ViewportHeight / this.ViewportWidth;
  };

  // In radians
  Camera.prototype.SetWorldRoll = function (roll) {
    this.WorldRoll = roll;
  };

  // Image coordinates.
  Camera.prototype.GetImageBounds = function () {
    var w = this.ViewportWidth;
    var h = this.ViewportHeight;

    var pt = this.ConvertPointViewerToImage(0, 0);
    var sBds = [pt[0], pt[0], pt[1], pt[1]];
    pt = this.ConvertPointViewerToImage(w, h);
    sBds[0] = Math.min(sBds[0], pt[0]);
    sBds[1] = Math.max(sBds[1], pt[0]);
    sBds[2] = Math.min(sBds[2], pt[1]);
    sBds[3] = Math.max(sBds[3], pt[1]);

    return sBds;
  };

  // World Matrix (world -> view)?
  Camera.prototype.GetWorldMatrix = function () {
    return this.WorldMatrix;
  };

  // Image Matrix (slide -> view)?
  Camera.prototype.GetImageMatrix = function () {
    return this.ImageMatrix;
  };

  // Camera matrix transforms points into camera coordinate system
  // X:(-1->1)
  // Y:(-1->1) (-1 is bottom)
  // Z:(-1->1) (-1 is front)
  // Image may not have a perfect matrix in the future We may support
  // nonlinear slide to world transformationss
  Camera.prototype.ComputeMatrix = function () {
    var fp = this.GetWorldFocalPoint();
    var roll = this.GetWorldRoll();
    var s = Math.sin(roll);
    var c = Math.cos(roll);
    var x = fp[0];
    var y = fp[1];
    var z = 10;
    var w = this.GetWidth();
        // var ht = this.GetHeight();  The iPad got this wrong?????
    var ht = this.Height;

    if (w < 0) { return; }

    if (this.Mirror) { ht = -ht; }

    mat4.identity(this.WorldMatrix);

    this.WorldMatrix[0] = c;
    this.WorldMatrix[1] = -s * w / ht;
    this.WorldMatrix[4] = -s;
    this.WorldMatrix[5] = -c * w / ht;
    this.WorldMatrix[9] = 0;
    this.WorldMatrix[10] = (this.ZRange[1] - this.ZRange[0]) * 0.5;
    this.WorldMatrix[12] = -c * x + s * y;
    this.WorldMatrix[13] = -(w / ht) * (-s * x - c * y);
    this.WorldMatrix[14] = -z + (this.ZRange[1] + this.ZRange[0]) * 0.25 * w;
    this.WorldMatrix[15] = 0.5 * w;

    // Now the ImageMatrix.  In the future slide to world transform will be
    // more general so the matrix will not capture the entire
    // transformation.
    var slideToWorld = SAM.InvertTransform(this.WorldToImageTransform);

    mat4.identity(this.ImageMatrix);
    this.ImageMatrix[0] = this.WorldMatrix[0];
    this.ImageMatrix[1] = this.WorldMatrix[1];
    this.ImageMatrix[4] = this.WorldMatrix[4];
    this.ImageMatrix[5] = this.WorldMatrix[5];
    this.ImageMatrix[9] = this.WorldMatrix[9];
    this.ImageMatrix[10] = this.WorldMatrix[10];
    this.ImageMatrix[12] = this.WorldMatrix[12];
    this.ImageMatrix[13] = this.WorldMatrix[13];
    this.ImageMatrix[14] = this.WorldMatrix[14];
    this.ImageMatrix[15] = this.WorldMatrix[15];

    // Concatenate the section mmatrix.

    var m0 = this.ImageMatrix[0];
    var m1 = this.ImageMatrix[1];
    var m4 = this.ImageMatrix[4];
    var m5 = this.ImageMatrix[5];
    this.ImageMatrix[0] = (m0 * slideToWorld[0]) + (m4 * slideToWorld[1]);
    this.ImageMatrix[1] = (m1 * slideToWorld[0]) + (m5 * slideToWorld[1]);
    this.ImageMatrix[4] = (m0 * slideToWorld[2]) + (m4 * slideToWorld[3]);
    this.ImageMatrix[5] = (m1 * slideToWorld[2]) + (m5 * slideToWorld[3]);
    this.ImageMatrix[12] += (m0 * slideToWorld[4]) + (m4 * slideToWorld[5]);
    this.ImageMatrix[13] += (m1 * slideToWorld[4]) + (m5 * slideToWorld[5]);
  };

  // Currenly assumes parallel projection and display z range = [-1,1].
  // Also no rotation!
  // a.k.a. This method does not work.
  Camera.prototype.DisplayToWorld = function (x, y, z) {
    var scale = this.Height / this.ViewportHeight;
    x = x - (0.5 * this.ViewportWidth);
    y = y - (0.5 * this.ViewportHeight);
    var worldPt = [];
    worldPt[0] = this.WorldFocalPoint[0] + (x * scale);
    worldPt[1] = this.WorldFocalPoint[1] + (y * scale);
    worldPt[2] = 10 + (z * this.Height * 0.5);

    return worldPt;
  };

  Camera.prototype.AddPoint = function (x, y, z) {
    this.Points.push(x);
    this.Points.push(y);
    this.Points.push(z);
  };

  Camera.prototype.CreateBuffer = function (gl) {
    if (gl) {
      if (this.Buffer !== null) {
        gl.deleteBuffer(this.Buffer);
      }
      this.Buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this.Buffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.Points),
                          gl.STATIC_DRAW);
    }
  };

  // Getting rid of this.
  Camera.prototype.UpdateBuffer = function () {
    this.Points = [];
    var cx = this.WorldFocalPoint[0];
    var cy = this.WorldFocalPoint[1];
    var rx = this.GetWidth() * 0.5;
    var ry = this.GetHeight() * 0.5;
    this.AddPoint(cx - rx, cy - ry);
    this.AddPoint(cx + rx, cy - ry);
    this.AddPoint(cx + rx, cy + ry);
    this.AddPoint(cx - rx, cy + ry);
    this.AddPoint(cx - rx, cy - ry);
    this.CreateBuffer();
  };

  // Camera is already set.
  Camera.prototype.Draw = function (overview, gl) {
    var overviewCam = overview.Camera;
    var viewport = overview.Viewport;

    var fp = this.GetWorldFocalPoint();
    var rx = this.GetWidth() * 0.5;
    var ry = this.GetHeight() * 0.5;

    // To handle rotation, I need to pass the center through
    // the overview camera matrix. Coordinate system is -1->1
    var newCx = (fp[0] * overviewCam.WorldMatrix[0] + fp[1] * overviewCam.WorldMatrix[4] +
                     overviewCam.WorldMatrix[12]) / overviewCam.WorldMatrix[15];
    var newCy = (fp[0] * overviewCam.WorldMatrix[1] + fp[1] * overviewCam.WorldMatrix[5] +
                     overviewCam.WorldMatrix[13]) / overviewCam.WorldMatrix[15];

    if (gl) { /*
            // I having trouble using the overview camera, so lets just compute
            // the position of the rectangle here.
            var ocx = overviewCam.WorldFocalPoint[0];
            var ocy = overviewCam.WorldFocalPoint[1];
            var orx = overviewCam.GetWidth() * 0.5;
            var ory = overviewCam.GetHeight() * 0.5;

            program = SA.polyProgram;
            gl.useProgram(program);
            gl.uniform3f(program.colorUniform, 0.9, 0.0, 0.9);

            gl.viewport(viewport[0],viewport[1],viewport[2],viewport[3]);
            mat4.identity(pMatrix);
            gl.uniformMatrix4fv(program.pMatrixUniform, false, pMatrix);

            var viewFrontZ = overviewCam.ZRange[0]+0.001;

            mat4.identity(mvMatrix);
            //mvMatrix[12] = ((cx-rx)-ocx)/orx;
            //mvMatrix[13] = ((cy-ry)-ocy)/ory;
            mvMatrix[12] = newCx-(rx/orx);
            mvMatrix[13] = newCy-(ry/ory);
            mvMatrix[14] = viewFrontZ;
            mvMatrix[0] = 2*rx/orx;
            mvMatrix[5] = 2*ry/ory;

            gl.bindBuffer(gl.ARRAY_BUFFER, SA.squareOutlinePositionBuffer);
            gl.vertexAttribPointer(program.vertexPositionAttribute,
                                   SA.squareOutlinePositionBuffer.itemSize,
                                   gl.FLOAT, false, 0, 0);
            gl.uniformMatrix4fv(program.mvMatrixUniform, false, mvMatrix);
            gl.drawArrays(gl.LINE_STRIP, 0,
            SA.squareOutlinePositionBuffer.numItems);
            */
    } else {
      // Transform focal point from -1->1 to viewport
      newCx = (1.0 + newCx) * viewport[2] * 0.5;
      newCy = (1.0 - newCy) * viewport[3] * 0.5;
      // Scale width and height from world to viewport.
      rx = rx * viewport[3] / overviewCam.GetHeight();
      ry = ry * viewport[3] / overviewCam.GetHeight();

      // The 2d canvas was left in world coordinates.
      var ctx = overview.Context2d;
      /*
        ctx.beginPath();
        //ctx.strokeStyle='#E500E5';
        ctx.rect(this.WorldFocalPoint[0]-(0.5*width),
                 this.WorldFocalPoint[1]-(0.5*height),width,height);
        //ctx.fillStyle='#E500E5';
        //ctx.fillRect(this.WorldFocalPoint[0]-(0.5*width),
                       this.WorldFocalPoint[1]-(0.5*height),width,height);
        ctx.stroke();
      */
      ctx.save();
      // ctx.setTransform(1,0,0,1,0,0);
      // Now that the while slide / overview canvas is rotating
      // We have to rotate the rectangle.
      var c = Math.cos(this.WorldRoll);
      var s = Math.sin(this.WorldRoll);
      ctx.setTransform(c, -s, +s, c,
                       (1 - c) * newCx - s * newCy,
                       (1 - c) * newCy + s * newCx);

      ctx.strokeStyle = '#4011E5';
      ctx.beginPath();
      ctx.rect(newCx - rx, newCy - ry, 2 * rx, 2 * ry);
      ctx.stroke();
      ctx.restore();
    }
  };

  SAM.Camera = Camera;

  // Transform utilites.
  SAM.ApplyTransform = function (t, pt) {
    var x = (t[0] * pt[0]) + (t[2] * pt[1]) + t[4];
    var y = (t[1] * pt[0]) + (t[3] * pt[1]) + t[5];
    return [x, y];
  };

  SAM.TransformBounds = function (t, bds) {
    var pt, out;
    pt = SAM.ApplyTransform(t, [bds[0], bds[2]]);
    out = [pt[0], pt[0], pt[1], pt[1]];
    pt = SAM.ApplyTransform(t, [bds[1], bds[2]]);
    out[0] = Math.min(out[0], pt[0]);
    out[1] = Math.max(out[1], pt[0]);
    out[2] = Math.min(out[2], pt[1]);
    out[3] = Math.max(out[3], pt[1]);
    pt = SAM.ApplyTransform(t, [bds[0], bds[3]]);
    out[0] = Math.min(out[0], pt[0]);
    out[1] = Math.max(out[1], pt[0]);
    out[2] = Math.min(out[2], pt[1]);
    out[3] = Math.max(out[3], pt[1]);
    pt = SAM.ApplyTransform(t, [bds[1], bds[3]]);
    out[0] = Math.min(out[0], pt[0]);
    out[1] = Math.max(out[1], pt[0]);
    out[2] = Math.min(out[2], pt[1]);
    out[3] = Math.max(out[3], pt[1]);
    return out;
  };

  SAM.MultiplyTransforms = function (t1, t2) {
    return [
      (t1[0] * t2[0]) + (t1[2] * t2[1]),
      (t1[1] * t2[0]) + (t1[3] * t2[1]),
      (t1[0] * t2[2]) + (t1[2] * t2[3]),
      (t1[1] * t2[2]) + (t1[3] * t2[3]),
      (t1[0] * t2[4]) + (t1[2] * t2[5]) + t1[4],
      (t1[1] * t2[4]) + (t1[3] * t2[5]) + t1[5]];
  };

  SAM.InvertTransform = function (t) {
    var p = (t[0] * t[3]) - (t[1] * t[2]);
    var q = (t[2] * t[5]) - (t[3] * t[4]);
    var s = (t[0] * t[5]) - (t[1] * t[4]);
    var inv = [t[3] / p, -t[1] / p, -t[2] / p, t[0] / p, q / p, -s / p];
    return inv;
  };
})();

// Generate an image of any resolution and size.

// You can use "FindCache(image)" to get the cache.
// image is the database image object with all the image meta data.

// How can you use the image data returned?
// canvasContext.putImageData(data, 0, 0);
// image = document.createElement('img');
// image.src = canvas.toDataURL('image/png');

// - cache: references the image source.
// - dimensions [xDim,yDim]: Final image dimensions in image pixels.
// - focalPoint [x,y,z]: the center of the image in slide coordinates.
// - rotation: Rotation around the focal point in degrees.
// - scale:  Image pixel size in slide coordinates. 1 is highest resolution.
// - returnCallback(data): Since non blocking ajax calls get the tiles necessary
//     to construct the image, we return the image data with a callback
//     function. The data returned is same as "ctx.getImageData(0,0,w,h);",
//     but we add data.Camera for conversion to the slide coordinate system.

(function () {
  'use strict';

  SA.DownloadImageData = function (data, filename) {
        // The only way I know if is to put in into a canvas.

        // Construct a view to render the image on the client.
    var width = data.width;
    var height = data.height;
    var viewport = [0, 0, width, height];

    var view = new SA.TileView();
    view.InitializeViewport(viewport, 1, true);
    view.Canvas.attr('width', width);
    view.Canvas.attr('height', height);
    view.Context2d.putImageData(data, 0, 0);

    view.Canvas[0].toBlob(function (blob) { saveAs(blob, filename); }, 'image/png');
  };

    // If file name is not null or "", this image is save to the client.
    // cache: The image/tile source.
    // dimensions: size of the image in pixels [xDim,yDim]
    // focalPoint: Center of the image in world / slide coordinates.
    // scale:  Size of a pixel in world coordinates.
    // roll: in radians?
    // fileName: name of file to download. (null, or "" means do not download).
    // returnCallback:  function to call (with data as argument) when done.
  SA.GetCutoutImage = function (cache, dimensions, focalPoint, scale, roll, fileName,
                                  returnCallback) {
        // Construct a view to render the image on the client.
    var width = dimensions[0];
    var height = dimensions[1];
    var viewport = [0, 0, width, height];

    var view = new SA.TileView();
    view.SetCache(cache);
    view.SetViewport(viewport);
    var newCam = view.Camera;
    newCam.SetWorldFocalPoint(focalPoint);
    newCam.SetWorldRoll(roll);
    newCam.SetHeight(height * scale);
    // TODO:  Hide matrix computation.  Make it automatic.
    newCam.ComputeMatrix();

    // Load only the tiles we need.
    var tiles = cache.ChooseTiles(newCam, 0, []);
    for (var i = 0; i < tiles.length; ++i) {
      SA.LoadQueueAddTile(tiles[i]);
    }

    SA.AddFinishedLoadingCallback(
            function () { SA.GetCutoutImage2(view, fileName, returnCallback); }
        );

    SA.LoadQueueUpdate();

    console.log('trigger ' + SA.LoadQueue.length + ' ' + SA.LoadingCount);
  };

  // This probably does not need to be exposed.
  SA.GetCutoutImage2 = function (view, fileName, returnCallback) {
    // All the tiles are loaded and waiting in the cache.
    view.DrawTiles();

    if (fileName && fileName !== '') {
      view.Canvas[0].toBlob(function (blob) { saveAs(blob, fileName); }, 'image/png');
    }

    if (returnCallback) {
      var data = view.GetImageData();
      returnCallback(data);
    }
  };

  // This works great!
  // Light weight viewer.
  // Attempt to make a div with multiple images.
  // image = database image object.
  // height = height in screen pixels of the returned div image.
  // request = (optional) bounds of cropped image in slide pixel units.
  //           if request is not defined, it defaults to the whole image bounds.
  // Events are funny,  The mouse position is relative to
  // the tiles.  click and bounds are callback functions to make
  // interaction simpler.
  var CutoutThumb = function (image, height, request) {
    if (!request) {
      request = image.bounds;
    }

    this.ImageData = image;
    this.Height = height;
    this.Width = Math.ceil(height * (request[1] - request[0]) / (request[3] - request[2]));
    this.Div = $('<div>')
            .css({'width': this.Width + 'px',
              'height': this.Height + 'px' })
            .addClass('sa-view-cutout-thumb-div');
        // Crop the request so we do not ask for tiles that do not exist.
    var levelReq;
    if (image.bounds) {
      levelReq = [
        Math.max(request[0], image.bounds[0]),
        Math.min(request[1], image.bounds[1]),
        Math.max(request[2], image.bounds[2]),
        Math.min(request[3], image.bounds[3])];
    } else {
      levelReq = [
        Math.max(request[0], 0),
        request[1],
        Math.max(request[2], 0),
        request[3]];
    }

    // Size of each tile.
    var tileDim = 256;
    if (image.tile_size) {
      tileDim = image.tile_size;
    }

    // Pick the level to use.
    this.Level = 0; // 0 = leaves
    while ((levelReq[3] - levelReq[2]) > this.Height &&
               this.Level < image.levels - 1) {
      this.Level += 1;
      levelReq[0] *= 0.5;
      levelReq[1] *= 0.5;
      levelReq[2] *= 0.5;
      levelReq[3] *= 0.5;
    }

    // Size of each tile.
    tileDim = 256;
    if (image.tile_size) {
      tileDim = image.tile_size;
    }

    this.ScreenPixelSpacing = (request[3] - request[2]) / this.Height;
    var imgSize = (tileDim << this.Level) / this.ScreenPixelSpacing;

    // grid of tiles to render.
    this.GridReq = [Math.floor(levelReq[0] / tileDim),
      Math.floor(levelReq[1] / tileDim),
      Math.floor(levelReq[2] / tileDim),
      Math.floor(levelReq[3] / tileDim)];

    // Compute the origin: the upper left corner of the upper left image.
    this.ScreenPixelOrigin = [this.GridReq[0] * (tileDim << this.Level),
      this.GridReq[2] * (tileDim << this.Level)];

    // loop over the tiles.
    for (var y = this.GridReq[2]; y <= this.GridReq[3]; ++y) {
      for (var x = this.GridReq[0]; x <= this.GridReq[1]; ++x) {
        // Compute the tile name.
        var tx = x;
        var ty = y;
        var tl = this.Level;
        var tileName = '';
        while (tl < image.levels - 1) {
          if ((tx & 1) === 0 && (ty & 1) === 0) { tileName = 'q' + tileName; }
          if ((tx & 1) === 1 && (ty & 1) === 0) { tileName = 'r' + tileName; }
          if ((tx & 1) === 0 && (ty & 1) === 1) { tileName = 't' + tileName; }
          if ((tx & 1) === 1 && (ty & 1) === 1) { tileName = 's' + tileName; }
          tx = (tx >> 1);
          ty = (ty >> 1);
          ++tl;
        }
        var left = (((x << this.Level) * tileDim) - request[0]) / this.ScreenPixelSpacing;
        var top = (((y << this.Level) * tileDim) - request[2]) / this.ScreenPixelSpacing;
        // img
        $('<img>')
          .appendTo(this.Div)
          .attr('width', imgSize)
          .attr('height', imgSize)
          .attr('src', '/tile?img=' + image.img + '&db=' + image.db + '&name=t' + tileName + '.jpg')
          .attr('alt', image.label)
          .css({'left': left.toString() + 'px', 'top': top.toString() + 'px'})
          .addClass('sa-view-cutout-thumb-tile');
      }
    }
  };

  CutoutThumb.prototype.AppendTo = function (parent) {
    this.Div.appendTo(parent);
    return this;
  };

    // Call back argument is this thumb object.
    // slideX, and slideY are set to mouse in slide coordinates.
  CutoutThumb.prototype.Click = function (callback) {
    var self = this;
    this.ClickCallback = callback;
    this.Div.click(function (e) {
            // It is a real pain to get the mouse position relative to the div.
      var x = e.pageX;
      var y = e.pageY;
            // Now get the location of this thumb on the screen.
      var offset = self.Div.offset();
      x -= offset.left;
      y -= offset.top;
      console.log('click: ' + x + ', ' + y);

      self.SlideX = (x * self.ScreenPixelSpacing) + self.ScreenPixelOrigin[0];
      self.SlideY = (y * self.ScreenPixelSpacing) + self.ScreenPixelOrigin[1];
      (self.ClickCallback)(self);
    });

    return this;
  };

    // todo:
    // - Bind delete key to stack creator.
    // - debug why some slides are not working.
    // - Get the average color of sections and get rid of outliers.
    //     (Maybe after delete)?
    // - First pass rigid alignment in stack creator.
    // - save the contour with the stack sections.
    // - move the transformations to load with the sections.
    // - Toggle slide / section view in stack viewer.
    // - Implement a way to reorder the sections.
    // - Implement a way to add a section in the slide stack viewer.
    // - Implement multiple pieces in a single section.
    // - Improve the gradient descent to be less sensitive to outliers
    //     (mismatched contours.)

  SA.CutoutThumb = CutoutThumb;
})();

// I want to avoid adding a Cache instance variable.
// I need to create the temporary object to hold pointers
// to both the cache and the tile which we are waiting for
// the image to load.  The callback only gives a single reference.

window.SA = window.SA || {};

(function () {
  'use strict';

  function LoadTileCallback (tile, cache) {
    this.Tile = tile;
    this.Cache = cache;
  }

  // Cache is now saved in tile ivar.
  LoadTileCallback.prototype.HandleLoadedImage = function () {
    var curtime = new Date().getTime();
    TILESTATS.add({
      'name': this.Tile.Name,
      'loadtime': curtime - this.Tile.starttime
    });
    SA.LoadQueueLoaded(this.Tile);
  };

  // If we cannot load a tile, we need to inform the cache so it can start
  // loading another tile.
  LoadTileCallback.prototype.HandleErrorImage = function () {
    console.log('LoadTile error ' + this.Tile.Name);

    SA.LoadQueueError(this.Tile);
  };

  function TileStats () {
    this.tiles = [];
  }

  TileStats.prototype.add = function (atile) {
    this.tiles.push(atile);
  };

  TileStats.prototype.report = function () {
    var total = 0;

    for (var i = 0; i < this.tiles.length; i++) {
      total = total + this.tiles[i].loadtime;
    }

    var report = {};
    report.count = this.tiles.length;
    report.average = total / this.tiles.length;
    report.total = total;
    console.log(report);
  };

  function GetLoadImageFunction (callback) {
    return function () { callback.HandleLoadedImage(); };
  }
  function GetErrorImageFunction (callback) {
    return function () { callback.HandleErrorImage(); };
  }

  var TILESTATS = new TileStats();

  // Three stages to loading a tile: (texture map is created when the tile is rendered.
  // 1: Create a tile object.
  // 2: Initialize the texture.
  // 3: onload is called indicating the image has been loaded.
  function Tile (x, y, z, level, name, cache) {
    // This should be implicit.
    // this is just for debugging
    // this.Id = x + (y<<level)
    //
    this.Cache = cache;
    this.X = x;
    this.Y = y;
    this.Z = z;
    this.Level = level;
    this.Children = [null, null, null, null];
    this.Parent = null;
    this.LoadState = 0;

    this.Name = name;
    this.Texture = null;
    this.TimeStamp = SA.TimeStamp;
    this.BranchTimeStamp = SA.TimeStamp;

    this.Matrix = mat4.create();
    mat4.identity(this.Matrix);
    this.Matrix[14] = z * cache.RootSpacing[2] - (0.1 * this.Level);

    // TODO: Warping depends on a global GL (which I am getting rid of) Fix
    // on demand :)
    // Default path is to shared geometry and move/scale it with the matrix.
    // The shared polygon is a square [(0,0),(1,0),(1,1),(0,1)]
    // The matrix transforms it into world coordinates.
    if (!cache.Warp) {
      // TODO: We should have a simple version of warp that creates this matrix for us.
      // Use shared buffers and place them with the matrix transformation.
      var xScale = cache.TileDimensions[0] * cache.RootSpacing[0] / (1 << this.Level);
      var yScale = cache.TileDimensions[1] * cache.RootSpacing[1] / (1 << this.Level);
      this.Matrix[0] = xScale;
      this.Matrix[5] = -yScale;
      this.Matrix[12] = this.X * xScale;
      this.Matrix[13] = (this.Y + 1) * yScale;
      this.Matrix[15] = 1.0;

      // Note:  I am breaking the warping to test multiple gl Contexts.
      // We do not have the view at this spot to build buffers.
      /*
        if (view && view.gl) {
        // These tiles share the same buffers.  Do not crop when there
        // is no warp. Actually, we should crop.
        this.VertexPositionBuffer = view.tileVertexPositionBuffer;
        this.VertexTextureCoordBuffer = view.tileVertexTextureCoordBuffer;
        this.CellBuffer = view.tileCellBuffer;
        }
      */

      // Trying to crop away the padding.
      // Compute bounds in tile pixel coordinate system.
      var bds = cache.Image.bounds.slice(0);
      var tileSpacingX = cache.RootSpacing[0] / (1 << this.Level);
      var tileSpacingY = cache.RootSpacing[1] / (1 << this.Level);
      var tileOriginX = this.X * cache.TileDimensions[0];
      var tileOriginY = this.Y * cache.TileDimensions[1];
      bds[0] = (bds[0] / tileSpacingX) - tileOriginX;
      bds[1] = (bds[1] / tileSpacingX) - tileOriginX;
      bds[2] = (bds[2] / tileSpacingY) - tileOriginY;
      bds[3] = (bds[3] / tileSpacingY) - tileOriginY;
      // Do we need to crop?
      if (bds[0] > 0 || bds[1] < cache.TileDimensions[0] ||
                bds[1] > 0 || bds[3] < cache.TileDimensions[1]) {
        // Yes we need to crop. Put it in
        // [minx,miny,sizex,sizey]
        // Useful for draw image.
        this.Crop = [];
        this.Crop[0] = Math.max(bds[0], 0);
        this.Crop[1] = Math.max(bds[2], 0);
        this.Crop[2] = (Math.min(bds[1], cache.TileDimensions[0])) - this.Crop[0];
        this.Crop[3] = (Math.min(bds[3], cache.TileDimensions[1])) - this.Crop[1];
      }
    } else {
      // Warp model.
      // In draw now.
      // this.CreateWarpBuffer(cache.Warp);
    }

    ++SA.NumberOfTiles;
  }

  // It is upto the caller to clean up references to this tile.
  Tile.prototype.destructor = function (gl) {
    --SA.NumberOfTiles;
    if (gl) {
      this.DeleteTexture(gl);
    }
    delete this.Matrix;
    this.Matrix = null;
    if (this.Image) {
      delete this.Image;
      this.Image = 0;
    }
    for (var i = 0; i < 4; ++i) {
      if (this.Children[i] !== null) {
        this.Children[i].delete(gl);
        this.Children[i] = null;
      }
    }
    delete this.Children;
    delete this.Parent;
    delete this.Cache;
  };

  // Youy have to call LoadQueueUpdate after adding tiles.
  // Add the first unloaded ancestor to the load queue.
  Tile.prototype.LoadQueueAdd = function () {
    // Record that the tile is used (for prioritizing loading and pruning).
    // Mark all lower res tiles so they will be loaded inthe correct order.
    var tmp = this;
    while (tmp && tmp.TimeStamp !== SA.TimeStamp) {
      tmp.TimeStamp = SA.TimeStamp;
      tmp = tmp.Parent;
    }

    if (this.LoadState !== 0) { // === 2
      // This tiles is already in the load queue or loaded.
      return;
    }

    // Now I want progressive loading so I will not add tiles to the queue if their parents are not completely loaded.
    // I could add all parent and children to the que at the same time, but I have seen children rendered before parents
    // (levels are skipped in progresive updata).  So, lets try this.
    // Now that I am prioritizing the queue on the tiles time stamp and level,  the previous issues should be resolved.
    if (this.Parent) {
      if (this.Parent.LoadState === 0) {
        // Not loaded and not in the queue.
        return this.Parent.LoadQueueAdd();
      } else if (this.Parent.LoadState === 1) {
        // Not loaded but in the queue
        return;
      }
    }

    // The tile's parent is loaded.  Add the tile to the load queue.
    SA.LoadQueueAddTile(this);
  };

  // This is for connectome stitching.  It uses texture mapping
  // to dynamically warp images.  It only works with webGL.
  Tile.prototype.CreateWarpBuffer = function (warp, gl) {
    // Compute the tile bounds.
    var tileDimensions = this.Cache.TileDimensions;
    var rootSpacing = this.Cache.RootSpacing;
    var p = (1 << this.Level);
    var size = [rootSpacing[0] * tileDimensions[0] / p, rootSpacing[1] * tileDimensions[1] / p];
    var bds = [size[0] * this.X, size[0] * (this.X + 1),
      size[1] * this.Y, size[1] * (this.Y + 1),
      this.Level, this.Level];

    // Tile geometry buffers.
    var vertexPositionData = [];
    var tCoordsData = [];
    var cellData = [];

    warp.CreateMeshFromBounds(bds, vertexPositionData, tCoordsData, cellData);

    this.VertexTextureCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.VertexTextureCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(tCoordsData), gl.STATIC_DRAW);
    this.VertexTextureCoordBuffer.itemSize = 2;
    this.VertexTextureCoordBuffer.numItems = tCoordsData.length / 2;

    this.VertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.VertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), gl.STATIC_DRAW);
    this.VertexPositionBuffer.itemSize = 3;
    this.VertexPositionBuffer.numItems = vertexPositionData.length / 3;

    this.CellBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.CellBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cellData), gl.STATIC_DRAW);
    this.CellBuffer.itemSize = 1;
    this.CellBuffer.numItems = cellData.length;
  };

  // This starts the loading of the tile.
  // Loading is asynchronous, so the tile will not
  // immediately change its state.
  Tile.prototype.StartLoad = function (cache) {
    if (this.LoadState >= 2) {
      return;
    }

    // Reusing the image caused problems.
    // if (this.Image === null) {
    this.Image = new Image();

    this.starttime = new Date().getTime();
    // Setup callbacks
    var callback = new LoadTileCallback(this, cache);
    this.Image.onload = GetLoadImageFunction(callback);
    this.Image.onerror = GetErrorImageFunction(callback);
    // This starts the loading.

    // SA.TileLoader === "http"
    this.LoadHttp(cache);
  };

  Tile.prototype.LoadHttp = function (cache) {
    // For http simply set the data url and wait
    if (cache.TileSource) {
      // This should eventually displace all other methods
      // of getting the tile source.
      this.Name = cache.TileSource.getTileUrl(this.Level,
                                              this.X, this.Y, this.Z);
      // Name is just for debugging.
      this.Image.src = this.Name;

      return;
    }

    // Legacy
    var imageSrc;
    if (cache.Image.type && cache.Image.type === 'stack') {
      imageSrc = cache.GetSource() + this.Name + '.png';
    } else {
      imageSrc = cache.GetSource() + this.Name + '.jpg';
    }

    if (cache.UseIIP) {
      var level = this.Level + 2;
      var xDim = Math.ceil(cache.Image.dimensions[0] / (cache.Image.TileWidth << (cache.Image.levels - this.Level - 1)));
      var idx = this.Y * xDim + this.X;
      imageSrc = 'http://iip.slide-atlas.org/iipsrv.fcgi?FIF=' + cache.Image.filename + '&jtl=' + level + ',' + idx;
    }

    this.Image.src = imageSrc;
  };

  // TODO: Put program as iVar of view.
  Tile.prototype.Draw = function (program, view) {
    // Load state 0 is: Not loaded and not scheduled to be loaded yet.
    // Load state 1 is: not loaded but in the load queue.
    if (this.LoadState !== 3) {
      // This should never happen.
      return;
    }

    /* sacrifice clipped/warped tiles so tiles can be shared between views.
    // Initialization has to be here because we do not have the view in
    // the constructor.  NOTE: tiles cannot be shared between views
    if (view.gl && ! this.VertexPositionBuffer) {
    if ( ! cache.Warp) {
    this.VertexPositionBuffer = view.tileVertexPositionBuffer;
    this.VertexTextureCoordBuffer = view.tileVertexTextureCoordBuffer;
    this.CellBuffer = view.tileCellBuffer;
    } else {
    // Warp model.
    this.CreateWarpBuffer(cache.Warp, view.gl);
    }
    }
    */

    if (view.gl) {
      if (this.Texture === null) {
        this.CreateTexture(view.gl);
      }
      // These are the same for every tile.
      // Vertex points (shifted by tiles matrix)
      view.gl.bindBuffer(view.gl.ARRAY_BUFFER, view.tileVertexPositionBuffer);
      // Needed for outline ??? For some reason, DrawOutline did not work
      // without this call first.
      view.gl.vertexAttribPointer(view.ShaderProgram.vertexPositionAttribute,
                                        view.tileVertexPositionBuffer.itemSize,
                                        view.gl.FLOAT, false, 0, 0);     // Texture coordinates
      view.gl.bindBuffer(view.gl.ARRAY_BUFFER, view.tileVertexTextureCoordBuffer);
      view.gl.vertexAttribPointer(view.ShaderProgram.textureCoordAttribute,
                                        view.tileVertexTextureCoordBuffer.itemSize,
                                        view.gl.FLOAT, false, 0, 0);
      // Cell Connectivity
      view.gl.bindBuffer(view.gl.ELEMENT_ARRAY_BUFFER, view.tileCellBuffer);

      // Texture
      view.gl.activeTexture(view.gl.TEXTURE0);
      view.gl.bindTexture(view.gl.TEXTURE_2D, this.Texture);

      view.gl.uniform1i(program.samplerUniform, 0);
      // Matrix that tranforms the vertex p
      view.gl.uniformMatrix4fv(program.mvMatrixUniform, false, this.Matrix);

      view.gl.drawElements(view.gl.TRIANGLES, view.tileCellBuffer.numItems, view.gl.UNSIGNED_SHORT, 0);
    } else {
      // It is harder to flip the y axis in 2d canvases because the image turns upside down too.
      // WebGL handles this by flipping the texture coordinates.  Here we have to
      // translate the tiles to the correct location.
      view.Context2d.save(); // Save the state of the transform so we can restore for the next tile.

      // Map tile to image.
      // Context is in image coordinate system
      view.Context2d.transform(this.Matrix[0], this.Matrix[1],
                               this.Matrix[4], this.Matrix[5],
                               this.Matrix[12], this.Matrix[13]);

      // Flip the tile upside down, but leave it in the same place
      view.Context2d.transform(1.0, 0.0, 0.0, -1.0, 0.0, 1.0);

      // map pixels to Tile

      var tileWidth = this.Cache.Image.TileWidth;
      // This should not be necessary, quick hack around a bug in __init__.py
      if (tileWidth === undefined) {
        tileWidth = 256;
      }
      var tileHeight = this.Cache.Image.TileHeight;
      if (tileHeight === undefined) {
        tileHeight = 256;
      }
      view.Context2d.transform(1.0 / tileWidth, 0.0, 0.0, 1.0 / tileHeight, 0.0, 0.0);
      if (this.Crop) {
        view.Context2d.drawImage(this.Image, this.Crop[0], this.Crop[1], this.Crop[2], this.Crop[3],
                                         this.Crop[0], this.Crop[1], this.Crop[2], this.Crop[3]);
      } else {
        view.Context2d.drawImage(this.Image, 0, 0);
      }
      if (SA.WaterMark) {
        var angle = (this.X + 1) * (this.Y + 1) * 4.0;
        view.Context2d.translate(128, 128);
        view.Context2d.rotate(angle);
        view.Context2d.translate(-128, -128);
        view.Context2d.fillStyle = 'rgba(0, 0, 0, 0.016)';
        view.Context2d.strokeStyle = 'rgba(50,50,50, 0.05)';
        view.Context2d.font = '30px Comic Sans MS';
        // view.Context2d.strokeText("SlideAtlas",10,100);
        view.Context2d.fillText('SlideAtlas', 10, 10);
      }

      //  Transform to map (0->1, 0->1)
      view.Context2d.restore();
    }
  };

  Tile.prototype.CreateTexture = function (gl) {
    if (!gl) {
      alert('Textures need a gl instance');
      return;
    }
    if (this.Texture !== null) { return; }

    ++SA.NumberOfTextures; // To determine when to prune textures.
    this.Texture = gl.createTexture();
    var texture = this.Texture;
    // alert(tile);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.Image);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.bindTexture(gl.TEXTURE_2D, null);
  };

  Tile.prototype.DeleteTexture = function (gl) {
    if (!this.Texture) {
      return;
    }
    if (!gl) {
      alert('Textures need a gl instance');
      return;
    }
    --SA.NumberOfTextures; // To determine when to prune textures.
    gl.deleteTexture(this.Texture);
    this.Texture = null;
  };

  SA.Tile = Tile;
})();

(function () {
  'use strict';

  // The levels are causing a problem for very large images.
  // They are preallocated and take up too much space.
  // TODO:
  // 1: (finished) No access to level except through API.
  // 2: (finished) Allocate on demand
  // 3: Make them into a fat tree (64x64 children).
  //    Two levels should hold us over for a long time.

  // I am adding a levels with grids to index tiles in addition
  // to the tree.  Eventually I want to get rid fo the tree.
  // I am trying to get rid of the roots now.

// ==============================================================================

  var CacheLevel = function (xGridDim, yGridDim) {
    this.GridDims = [xGridDim, yGridDim];
  };

  // No bounds checking.
  CacheLevel.prototype.SetTile = function (tile) {
    if (this.Tiles === undefined) {
      this.Tiles = new Array(this.GridDims[0] * this.GridDims[1]);
    }

    this.Tiles[tile.X + (tile.Y * this.GridDims[0])] = tile;
    return tile;
  };

  CacheLevel.prototype.GetTile = function (x, y) {
    if (this.Tiles === undefined) {
      return null;
    }
    var idx = x + (y * this.GridDims[0]);
    var tile = this.Tiles[idx];
    if (tile && !tile.Matrix) {
      this.Tiles[idx] = undefined;
      return;
    }
    return tile;
  };

  // We only need an iterator for pruning.  BUild it right into the Cache Level.
  CacheLevel.prototype.StartIteration = function () {
    if (this.Tiles === undefined || this.Tiles.length === 0) {
      this.IteratorIndex = undefined;
    } else {
      this.IteratorIndex = 0;
    }
  };

  CacheLevel.prototype.Next = function () {
    if (this.IteratorIndex === undefined) {
      this.IteratorIndex = undefined;
      return null;
    }

    var idx = this.IteratorIndex;
    while (this.Tiles[idx] === null) {
      idx += 1;
      if (idx >= this.Tiles.length) {
        this.IteratorIndex = undefined;
        return null;
      }
    }

    return this.Tiles[idx];
  };

// ==============================================================================

  // A stripped down source object.
  // A source object must have a getTileUrl method.
  // It can have any instance variables it needs to
  // compute the URL.
  SA.SlideAtlasSource = function () {
    this.Prefix = undefined;

    // Higher levels are higher resolution.
    // x, y, slide are integer indexes of tiles in the grid.
    this.getTileUrl = function (level, x, y, z) {
      var name = this.Prefix + 't';
      while (level > 0) {
        --level;
        var cx = (x >> level) & 1;
        var cy = (y >> level) & 1;
        var childIdx = cx + (2 * cy);
        if (childIdx === 0) { name += 'q'; }
        if (childIdx === 1) { name += 'r'; }
        if (childIdx === 2) { name += 't'; }
        if (childIdx === 3) { name += 's'; }
      }
      name = name + '.jpg';
      return name;
    };
  };

  SA.GigamacroSource = function () {
    this.Prefix = 'http://www.gigamacro.com/content/AMNH/unit_box_test2_05-01-2015/zoomify/';
    this.GridSizeDebug = [[1, 1], [2, 2], [4, 3], [7, 5], [14, 9], [28, 17], [56, 34]];

    this.setDimensions = function (xDim, yDim) {
      this.Dimensions = [xDim, yDim];
      this.GridSize = [];
      this.Levels = 0;
      while (true) {
        var gridLevelDim = [Math.ceil(xDim / 256), Math.ceil(yDim / 256)];
        this.GridSize.splice(0, 0, gridLevelDim);
        this.Levels += 1;
        if (gridLevelDim[0] === 1 && gridLevelDim[1] === 1) {
          return;
        }
        xDim = xDim / 2;
        yDim = yDim / 2;
      }
    };

    // Higher levels are higher resolution.
    // x, y, slide are integer indexes of tiles in the grid.
    this.getTileUrl = function (level, x, y, z) {
      var g = this.GridSize[level];
      if (x < 0 || x >= g[0] || y < 0 || y >= g[1]) {
        return '';
      }
      var num = y * g[0] + x;
      for (var i = 0; i < level; ++i) {
        g = this.GridSize[i];
        num += g[0] * g[1];
      }
      var tileGroup = Math.floor(num / 256);
      var name = this.Prefix + 'TileGroup' + tileGroup + '/' + level + '-' + x + '-' + y + '.jpg';
      return name;
    };
  };

  // Our subdivision of leaves is arbitrary.
  SA.IIIFSource = function () {
    this.Prefix = 'http://ids.lib.harvard.edu/ids/view/Converter?id=834753&c=jpgnocap';
    alert('Hard coded tile size');
    this.TileWidth = this.TileHeight = 256;

    this.setDimensions = function (xDim, yDim) {
      this.Dimensions = [xDim, yDim];
      this.GridSize = [];
      this.Levels = 0;
      while (true) {
        var gridLevelDim = [Math.ceil(xDim / 256), Math.ceil(yDim / 256)];
        this.Levels += 1;
        if (gridLevelDim[0] === 1 && gridLevelDim[1] === 1) {
          return;
        }
        xDim = xDim / 2;
        yDim = yDim / 2;
      }
    };

    // Higher levels are higher resolution. (0 is the root).
    // x, y, slide are integer indexes of tiles in the grid.
    this.getTileUrl = function (level, x, y, z) {
      // compute the dimensions of this resolution.
      var x0 = x * 256;
      var y0 = y * 256;
      var x1 = x0 + 256;
      var y1 = y0 + 256;
      // crop the tile
      var res = this.Levels - level - 1;
      var dx = this.Dimensions[0] >> res;
      var dy = this.Dimensions[1] >> res;
      if (x1 > dx) { x1 = dx; }
      if (y1 > dy) { y1 = dy; }
      dx = x1 - x0;
      dy = y1 - y0;
      // Compute the scale.
      res = 1.0 / (1 << res);

      var name = this.Prefix + '&s=' + res + '&r=0&x=' + x0 + '&y=' + y0 + '&w=' + dx + '&h=' + dy;
      return name;
    };
  };

  SA.DanielSource = function () {
    this.Prefix = 'http://dragon.krash.net:2009/data/1';
    this.MinLevel = 0;
    this.MaxLevel = 7;

    // Higher levels are higher resolution.
    // x, y, slide are integer indexes of tiles in the grid.
    this.getTileUrl = function (level, x, y, z) {
      if (z < this.MinLevel) { return ''; }
      if (z > this.MaxLevel) { return ''; }
      var name = this.Prefix + level + '-' + x + '-' + y;
      return name;
    };
  };

// ==============================================================================
  SA.FindCache = function (image) {
    // Look through existing caches and reuse one if possible
    for (var i = 0; i < SA.Caches.length; ++i) {
      if (SA.Caches[i].Image._id === image._id) {
        return SA.Caches[i];
      }
    }
    var cache = new SA.Cache();
    cache.SetImageData(image);

    return cache;
  };

// ==============================================================================
  function Cache () {
    //  this.UseIIP = Boolean(image.filename !== undefined && image.filename.split(".")[1] === 'ptif');
    this.UseIIP = false;
    this.Levels = [];

    // Keep a global list for pruning tiles.
    SA.Caches.push(this);
    this.NumberOfSections = 1;
  }

  Cache.prototype.destructor = function () {
  };

  Cache.prototype.GetImageData = function () {
    return this.Image;
  };

  // This is specific for slideAtlas images.
  Cache.prototype.SetImageData = function (image) {
    if (!image.TileWidth) {
      image.TileWidth = 256;
    }
    if (!image.TileHeight) {
      image.TileHeight = image.TileWidth;
    }

    this.Image = image;

    if (image.copyright === undefined) {
      image.copyright = 'Copyright 2019. All Rights Reserved.';
    }

    this.Levels = new Array(image.levels);
    for (var i = 0; i < image.levels; ++i) {
      var level = image.levels - 1 - i;
      this.Levels[i] = new CacheLevel(
            Math.ceil(image.dimensions[0] / (image.TileWidth << level)),
            Math.ceil(image.dimensions[1] / (image.TileHeight << level)));
    }

    if (!this.TileSource) {
      // TODO:  This should not be here.
      // Source should be initialized someplace else.
      // Other sources have to overwrite this default.
      this.TileSource = new SA.SlideAtlasSource();
      this.TileSource.Prefix = '/tile?img=' + image._id + '&db=' + image.database + '&name=';
    }
    this.Warp = null;
    this.RootSpacing = [1 << (image.levels - 1), 1 << (image.levels - 1), 10.0];

    if (image.type && image.type === 'stack') {
      this.NumberOfSections = image.dimensions[2];
      this.TileDimensions = [image.dimensions[0], image.dimensions[1]];
      var qTile;
      for (var slice = 1; slice <= this.NumberOfSections; ++slice) {
        qTile = this.GetTile(slice, 0, 0);
        qTile.LoadQueueAdd();
      }
      SA.LoadQueueUpdate();
    } else {
      this.TileDimensions = [image.TileWidth, image.TileHeight];
      this.NumberOfSections = 1;
    }
  };

  Cache.prototype.SetTileSource = function (source) {
    var w = source.width;
    var h = source.height;
    this.TileSource = source;
    // Make an id for the image so it can be reused.
    var image = {levels: source.maxLevel + 1,
      dimensions: [w, h],
      bounds: [0, w - 1, 0, h - 1]};
    if (source.bounds) {
      image.bounds = source.bounds;
    }
    if (source.TileWidth) {
      image.TileWidth = source.TileWidth;
    }
    if (source.TileHeight) {
      image.TileHeight = source.TileHeight;
    }

    if (source.filename) {
      image.filename = source.filename;
      image.label = source.filename;
    }
    this.SetImageData(image);
  };

  Cache.prototype.GetLeafSpacing = function () {
    return this.RootSpacing[0] / (1 << (this.Image.levels - 1));
  };

  Cache.prototype.GetBounds = function () {
    if (this.Image && this.Image.bounds) {
      return this.Image.bounds;
    }
    return [0, 10000, 0, 10000];
  };

  // This method converts a point in image coordinates to a point in world coordinates.
  Cache.prototype.ImageToWorld = function (imagePt) {
    if (this.Warp) {
      return this.Warp.ImageToWorld(imagePt);
    }
    // Just shift by the origin.
    // Assume spacing is 1.
    // This should be a simple matrix version of warp.
    return [imagePt[0] + this.Origin[0], imagePt[1] + this.Origin[1]];
  };

  // This method converts a point in world coordinates to a point in cache-image coordinates.
  Cache.prototype.WorldToImage = function (worldPt) {
    if (this.Warp) {
      return this.Warp.WorldToImage(worldPt);
    }
    // Just shift by the origin.
    // Assume spacing is 1.
    // TODO:
    // This should be a simple matrix version of warp.
    return [worldPt[0] - this.Origin[0], worldPt[1] - this.Origin[1]];
  };

  Cache.prototype.GetSource = function () {
    return this.Source;
  };

  Cache.prototype.LoadRoots = function (callback) {
    var qTile;
    if (this.Image.dimensions === undefined) {
      return;
    }
    // Callback handled by the loaded which deletes the callback after it
    // is executed.
    this.LoadTileCallback = callback;
    if (this.Image.dimensions.length < 3) {
      qTile = this.GetTile(0, 0, 0);
      qTile.LoadQueueAdd();
    } else {
      for (var slice = 1; slice <= this.Image.dimensions[2]; ++slice) {
        qTile = this.GetTile(slice, 0, 0);
        qTile.LoadQueueAdd();
      }
    }
    SA.LoadQueueUpdate();
  };

  // ------ I think this method really belongs in the view! -----------
  // This could get expensive because it is called so often.
  // Eventually I want a quick coverage test to exit early.
  // iPad flag includes low resolution ancestors to get rid of white lines between tiles.
  // Tiles is actually the return value.  It is not used for anything else.
  Cache.prototype.ChooseTiles = function (camera, slice, tiles) {
    // I am prioritizing tiles in the queue by time stamp.
    // Loader sets the the tiles time stamp.
    // Time stamp only progresses after a whole render.
    SA.AdvanceTimeStamp();

    // I am putting this here to avoid deleting tiles
    // in the rendering list.
    SA.Prune();

    // Pick a level to display.
    // var fast = document.getElementById("fast").checked;
    // level 0 is the root.  This chooses too high a level (resolution).
    // WHen I fixed it, the snap between levels was too noticable.
    // THis must be a problem with creation of the pyramid!!!!!
    var canvasHeight = camera.GetViewportHeight();
    var tmp = this.TileDimensions[1] * this.RootSpacing[1] / camera.GetHeight();
    // if (fast) {
    //  tmp = tmp * 0.5;
    // }
    tmp = tmp * canvasHeight / this.TileDimensions[1];
    var level = 0;
    while (tmp > 1.0) {
      ++level;
      tmp = tmp * 0.5;
    }
    if (level >= this.Image.levels) {
      level = this.Image.levels - 1;
    }
    // Alternative code
    // var level = this.Image.levels - 1; // The highest resolution / leaves
    // var canvasHeight = camera.ViewportHeight;
    // // At the current level(0), each screen pixel covers this many image
    // // pixels. If this is above 1, then we would render too many pixels.
    // var pixelRatio = camera.Height / camera.ViewportHeight;
    // while (pixelRatio > 1.1 && level > 0) { // a little slop.
    //    pixelRatio = pixelRatio * 0.5;
    //    level = level - 1;
    // }

    // TODO: Have camera return world bounds and compute this stuff internally.
    var bounds = camera.GetImageBounds();

    // Some logic for progressive rendering is in the loader:
    // Do not load a tile if its parent is not loaded.

    var tile;
    var tileIds;
    tiles = [];
    // TODO: Make a "GetVisibleTiles" method.
    // Render all tiles from low res to high.
    // Although this is extra work, it covers up cracks.
    // Rendering just level 0 (root) should be enough, but that
    // messed up progressive rendering logic in section.js.
    // Just do this until I unify the progressive rendering
    // Probably in this method. (check is loaded).
    for (var i = level; i >= 0; --i) {
      tileIds = this.GetVisibleTileIds(i, bounds);
      for (var j = 0; j < tileIds.length; ++j) {
        tile = this.GetTile(slice, i, tileIds[j]);
        // If the tile is loaded or loading,
        // this does nothing.
        if (tile) {
          tile.LoadQueueAdd();
          tiles.push(tile);
        }
      }
    }

    SA.LoadQueueUpdate();

    return tiles;
  };

  // Get ids of all visible tiles (including ones that have not been
  // loaded yet.)
  Cache.prototype.GetVisibleTileIds = function (level, bounds) {
    // Intersect the view bounds with the image bounds.
    // The ptif reader gives wrong times when out of bounds.
    if (this.Image.bounds) {
      bounds[0] = Math.max(bounds[0], this.Image.bounds[0]);
      bounds[1] = Math.min(bounds[1], this.Image.bounds[1]);
      bounds[2] = Math.max(bounds[2], this.Image.bounds[2]);
      bounds[3] = Math.min(bounds[3], this.Image.bounds[3]);
    }

    var idList = [];
    var dim = 1 << level;
    var bds = [];
    bds[0] = Math.floor(bounds[0] * dim / (this.TileDimensions[0] * this.RootSpacing[0]));
    bds[1] = Math.ceil(bounds[1] * dim / (this.TileDimensions[0] * this.RootSpacing[0])) - 1.0;
    bds[2] = Math.floor(bounds[2] * dim / (this.TileDimensions[1] * this.RootSpacing[1]));
    bds[3] = Math.ceil(bounds[3] * dim / (this.TileDimensions[1] * this.RootSpacing[1])) - 1.0;
    // I am allowing level 0 to have a grid of tiles (not just one root).
    // This will not work for the trsq tile names, but is used for grid
    // indexing of tiles that every other server uses.
    // This will only work NOW for the y axis (the case I am trying to
    // solve).  To work for the z axis, tile indexing has to change.
    // Javascript currently can handle 16 levels safely (32 bits) with the
    // current indexing scheme.

    /*
    var id;
    for (var y = bds[2]; y <= bds[3]; ++y) {
      for (var x = bds[0]; x <= bds[1]; ++x) {
        id = x | (y << level);
        idList.push(id);
      }
    }
    */
    // Experiment: Lets try sorting from middle to outside to simulate
    // fovia sorted request priority.
    // Reverse order of priority.
    var cx = Math.floor((bds[0] + bds[1]) * 0.5);
    var cy = Math.floor((bds[2] + bds[3]) * 0.5);
    var radius = Math.max((cx - bds[0]), (bds[1] - cx), (cy - bds[2]), (bds[3] - cy));
    var x, y, i;
    while (radius > 0) {
      for (i = -radius; i < radius; ++i) {
        x = cx - radius;
        y = cy - i;
        if (x >= bds[0] && x <= bds[1] && y >= bds[2] && y <= bds[3]) {
          idList.push(x | (y << level));
        }
        x = cx + i;
        y = cy - radius;
        if (x >= bds[0] && x <= bds[1] && y >= bds[2] && y <= bds[3]) {
          idList.push(x | (y << level));
        }
        x = cx + radius;
        y = cy + i;
        if (x >= bds[0] && x <= bds[1] && y >= bds[2] && y <= bds[3]) {
          idList.push(x | (y << level));
        }
        x = cx - i;
        y = cy + radius;
        if (x >= bds[0] && x <= bds[1] && y >= bds[2] && y <= bds[3]) {
          idList.push(x | (y << level));
        }
      }
      radius -= 1;
    }
    // Add the special case center.
    idList.push(cx | (cy << level));
    return idList;
  };

// I do not think this ever gets called.  No class calls this method.
  Cache.prototype.GetTileIdContainingPoint = function (level, wPt) {
    var dim = 1 << level;
    var xIdx = Math.floor(wPt[0] * dim);
    var yIdx = Math.floor(wPt[1] * dim);
    if (xIdx < 0) { xIdx = 0; }
    if (xIdx >= dim) { xIdx = dim - 1; }
    if (yIdx < 0) { yIdx = 0; }
    if (yIdx >= dim) { yIdx = dim - 1; }
    var id = xIdx | (yIdx << level);
    return id;
  };

// Set parent to be minimum of children.
  Cache.prototype.UpdateBranchTimeStamp = function (tile) {
    var min = SA.GetCurrentTime();
    if (tile.Children[0] !== null) {
      if (tile.Children[0].BranchTimeStamp < min) {
        min = tile.Children[0].BranchTimeStamp;
      }
    }
    if (tile.Children[1] !== null) {
      if (tile.Children[1].BranchTimeStamp < min) {
        min = tile.Children[1].BranchTimeStamp;
      }
    }
    if (tile.Children[2] !== null) {
      if (tile.Children[2].BranchTimeStamp < min) {
        min = tile.Children[2].BranchTimeStamp;
      }
    }
    if (tile.Children[3] !== null) {
      if (tile.Children[3].BranchTimeStamp < min) {
        min = tile.Children[3].BranchTimeStamp;
      }
    }
    if (min === SA.GetCurrentTime()) { // no children
      min = tile.TimeStamp;
    }
    if (min !== tile.BranchTimeStamp) {
      tile.BranchTimeStamp = min;
      if (tile.Parent !== null) {
        this.UpdateBranchTimeStamp(tile.Parent);
      }
    }
  };

  Cache.prototype.GetTile = function (slice, level, id) {
    // Separate x and y.
    var dim = 1 << level;
    var x = id & (dim - 1);
    var y = id >> level;

    return this.RecursiveGetTile(level, x, y, slice);
  };

  Cache.prototype.RecursiveGetTile = function (level, x, y, z) {
    if (!this.Levels[level]) { return null; }
    var tile = this.Levels[level].GetTile(x, y);
    if (tile) {
      return tile;
    }
    tile = new SA.Tile(x, y, z, level,
                       this.TileSource.getTileUrl(level, x, y, z),
                       this);
    this.Levels[level].SetTile(tile);
    if (level > 0) {
      var parent = this.RecursiveGetTile(level - 1, x >> 1, y >> 1, z);
      // I do not know if this is still valid.
      // This is to fix a bug. Root.BranchTime larger
      // than all children BranchTimeStamps.  When
      // long branch is added, node never gets updated.
      if (parent.Children[0] === null && parent.Children[1] === null &&
            parent.Children[2] === null && parent.Children[3] === null) {
        parent.BranchTimeStamp = SA.GetCurrentTime();
      }
      var cx = x & 1;
      var cy = y & 1;
      var childIdx = cx + (2 * cy);
      parent.Children[childIdx] = tile;
      tile.Parent = parent;
    }
    return tile;
  };

  // Find the oldest tile, remove it from the tree and return it to be recycled.
  // This also prunes texture maps.
  // SA.PruneTimeTiles and SA.PruneTimeTextures are compared with used time of tile.
  Cache.prototype.PruneTiles = function () {
    this.Levels[0].StartIteration();
    var node = this.Levels[0].Next();
    if (node.LoadState === 3) {
      if (node.BranchTimeStamp < SA.PruneTimeTiles || node.BranchTimeStamp < SA.PruneTimeTextures) {
        var count = this.RecursivePruneTiles(node);
        if (count > 0) {
          console.log('prune ' + count + ' from ' + this.Image.label);
        }
      }
    }
  };

  Cache.prototype.RecursivePruneTiles = function (node) {
    var leaf = true;
    var count = 0;

    for (var i = 0; i < 4; ++i) {
      var child = node.Children[i];
      if (child !== null) {
        leaf = false;
        if (child.BranchTimeStamp < SA.PruneTimeTiles ||
          child.BranchTimeStamp < SA.PruneTimeTextures) {
          count += this.RecursivePruneTiles(child);
        }
      }
    }
    if (leaf && node.Parent !== null) { // Roots have null parents.  Do not prune roots.
      if (node.BranchTimeStamp < SA.PruneTimeTextures) {
        // when using webgl, texture memery was a more limited resource.
        node.DeleteTexture();
      }
      if (node.BranchTimeStamp < SA.PruneTimeTiles) {
        if (node.LoadState === 1) {
          SA.LoadQueueRemove(node);
        }
        var parent = node.Parent;
        // nodes will always have parents because we do not steal roots.
        if (parent.Children[0] === node) {
          parent.Children[0] = null;
        } else if (parent.Children[1] === node) {
          parent.Children[1] = null;
        } else if (parent.Children[2] === node) {
          parent.Children[2] = null;
        } else if (parent.Children[3] === node) {
          parent.Children[3] = null;
        }
        node.Parent = null;
        this.UpdateBranchTimeStamp(parent);
        node.destructor();
        count += 1;
      }
    }
    return count;
  };

  SA.Cache = Cache;
})();

// ==============================================================================
// Section Object
// Leftover from Connectome.
// Sections were a montage of multiple images (transformed and cropped)

// I have just started implementing an API for a section transformation.
// Use the same API as the canvas transform,
// TODO: Generatlize to mesh based transformation.
//   A transformation for each cache.
//   (but not stored in the cache.  Sections can share a cache.)

(function () {
  'use strict';

  var SLICE = 0;

  function Section () {
    // Warping to align this section with previous / next.
    // This is only a matrix transformation.
    this.Matrix = mat4.create();
    mat4.identity(this.Matrix);
    // The list of caches is really just a list of images in the montage.
    this.Caches = [];
    // For debugging stitching.
    this.Markers = [];
    this.Transform = [1, 0, 0, 1, 0, 0];
  }

  Section.prototype.GetNumberOfCaches = function () {
    return this.Caches.length;
  };

  Section.prototype.GetCache = function (idx) {
    if (idx < 0 || idx >= this.Caches.length) {
      return undefined;
    }
    return this.Caches[idx];
  };

  Section.prototype.SetCache = function (cache) {
    if (cache === undefined) {
      this.Caches = [];
    } else {
      this.Caches = [cache];
    }
    this.Bounds = undefined;
  };

  // Set the tranform for cache 0.  Same api as html canvas transform.
  // This tranform is applied before the camera.  It converts world to image
  // coordinates.
  Section.prototype.SetTransform = function (tran) {
    this.Transform = tran.slice(0);
  };

  Section.prototype.AddCache = function (cache) {
    if (cache) {
      this.Caches.push(cache);
      this.Bounds = undefined;
    }
  };

  // For limiting interaction.
  Section.prototype.GetBounds = function () {
    if (this.Bounds === undefined) {
      this.ComputeBounds();
    }
    return this.Bounds;
  };

  // For limiting interaction.
  Section.prototype.ComputeBounds = function () {
    this.Bounds = [0, 10000, 0, 10000];

    for (var cIdx = 0; cIdx < this.Caches.length; ++cIdx) {
      var cache = this.Caches[cIdx];
      var bds = cache.GetBounds();
      if (cIdx === 0) {
        this.Bounds = [bds[0], bds[1], bds[2], bds[3]];
      } else {
        if (bds[0] < this.Bounds[0]) {
          this.Bounds[0] = bds[0];
        }
        if (bds[1] > this.Bounds[1]) {
          this.Bounds[1] = bds[1];
        }
        if (bds[2] < this.Bounds[2]) {
          this.Bounds[2] = bds[2];
        }
        if (bds[3] < this.Bounds[3]) {
          this.Bounds[3] = bds[3];
        }
      }
    }
  };

  // Size of a pixel at the highest resolution.
  Section.prototype.GetLeafSpacing = function () {
    if (!this.LeafSpacing) {
      for (var cIdx = 0; cIdx < this.Caches.length; ++cIdx) {
        var cache = this.Caches[cIdx];
        var spacing = cache.GetLeafSpacing();
        if (!this.LeafSpacing || spacing < this.LeafSpacing) {
          this.LeafSpacing = spacing;
        }
      }
    }
    return this.LeafSpacing;
  };

  Section.prototype.LoadRoots = function () {
    for (var cIdx = 0; cIdx < this.Caches.length; ++cIdx) {
      var cache = this.Caches[cIdx];
      if (cache) {
        cache.LoadRoots();
      }
    }
  };

  Section.prototype.FindImage = function (imageCollectionName) {
    for (var i = 0; i < this.Caches.length; ++i) {
      var cache = this.Caches[i];
      if (cache.Image._id === imageCollectionName) {
        return cache;
      }
    }
    return null;
  };

  // I do not like passing in the whole view.
  // Could we get away with just passing the camera?
  // No, we need the viewport too.
  // Could the viewport be part of the camera?
  // Returns true if all the tiles to render were available.
  // False implies that the user shoudl render again.
  Section.prototype.Draw = function (view) {
    var finishedRendering = true;
    view.Camera.SetWorldToImageTransform(this.Transform);
    // var m = view.Camera.GetImageMatrix();

    if (view.gl) {
      // Draw tiles.
      var program = view.ShaderProgram;
      var gl = view.gl;
      gl.viewport(view.Viewport[0], view.Viewport[1],
                        view.Viewport[2], view.Viewport[3]);
      // program not defined ... gl.uniformMatrix4fv(program.pMatrixUniform, false, m);
    } else {
      // The camera maps the world coordinate system to (-1->1, -1->1).
      var t = view.Camera.GetImageToViewerTransform();
      view.Context2d.setTransform(t[0], t[1], t[2], t[3], t[4], t[5]);
    }

    for (var i = 0; i < this.Caches.length; ++i) {
      var cache = this.Caches[i];
      // Select the tiles to render first.
      this.Tiles = cache.ChooseTiles(view.Camera, SLICE, view.Tiles);
      // Trying to get rid of flashing by putting the clear closer to the draw.
      if (this.Tiles.length > 1 && view.ClearPending) {
        view.Clear();
        view.ClearPending = undefined;
      }

      // For the 2d viewer, the order the tiles are drawn is very important.
      // Low-resolution tiles have to be drawn first.  Make a new sorted array.
      // The problem is that unloaded tiles fall back to rendering parents.
      // Make  copy (although we could just destroy the "Tiles" array which is not really used again).
      var tiles = this.Tiles.slice(0);
      var loadedTiles = [];
      var j = 0;
      while (j < tiles.length) { // We add tiles in the loop so we need a while.
        var tile = tiles[j];
        if (tile.LoadState === 3) {
          loadedTiles.push(tile);
        } else {
          if (tiles[j].LoadState < 3) {
            // Keep rendering until we have all the tiles.
            finishedRendering = false;
          }
          // if (tile.Parent) { // Queue up the parent.
          //   Note: Parents might be added multiple times by different siblings.
          //   Ok, lets render the whole tree (low res first) to
          //   cover cracks.  This is done in choose tiles.
          //   This is not needed for prgressive rendering then.
          //   tiles.push(tile.Parent);
          // }
        }
        ++j;
      }

      // Reverse order to render low res tiles first.
      for (j = loadedTiles.length - 1; j >= 0; --j) {
        loadedTiles[j].Draw(program, view);
      }
    }
    return finishedRendering;
  };

  Section.prototype.LoadTilesInView = function (view) {
    for (var i = 0; i < this.Caches.length; ++i) {
      var cache = this.Caches[i];
      // Select the tiles to render first.
      // This also adds the tiles returned to the loading queue.
      this.Tiles = cache.ChooseTiles(view.Camera, SLICE, view.Tiles);
    }
  };

  // The above will load the first ancestor not loaded and will stop.
  // I need to pre load the actual high res tiles for connectome.
  Section.prototype.LoadTilesInView2 = function (view) {
    for (var cIdx = 0; cIdx < this.Caches.length; ++cIdx) {
      var cache = this.Caches[cIdx];
      // Select the tiles to load (loading is a byproduct).
      var tiles = cache.ChooseTiles(view.Camera, SLICE);
      for (var i = 0; i < tiles.length; ++i) {
        tiles[i].LoadState = 1;
        // Add the tile at the front of the queue.
        SA.LoadQueue.push(tiles[i]);
      }
    }
    SA.LoadQueueUpdate();
  };

  // This load tiles in the view like draw but does not render them.
  // I want to preload tiles in the next section.
  Section.prototype.LoadTilesInView = function (view) {
    for (var cIdx = 0; cIdx < this.Caches.length; ++cIdx) {
      var cache = this.Caches[cIdx];
      // Select the tiles to load (loading is a byproduct).
      cache.ChooseTiles(view.Camera, SLICE);
    }
  };

  SA.Section = Section;
})();

// ==============================================================================
// Subclass of view that renders tiled images.

(function () {
  'use strict';

  function TileView (parent, useWebGL) {
    SAM.View.call(this, parent, useWebGL);

    // connectome : default section so we cen set cache
    this.DefaultSection = new SA.Section();
    this.Section = this.DefaultSection;

    this.Tiles = []; // Not really used

    if (useWebGL) {
      this.gl = this.Canvas[0].getContext('webgl') || this.Canvas[0].getContext('experimental-webgl');
    }
    if (this.gl) {
      // Probably need a canvas object that keep track of
      // initialization (shared between layers).
      SA.initWebGL(this);
    } else {
      this.Context2d = this.Canvas[0].getContext('2d');
    }
  }
  TileView.prototype = new SAM.View();

  TileView.prototype.GetBounds = function () {
    return this.Section.GetBounds();
  };
  TileView.prototype.GetLeafSpacing = function () {
    return this.Section.GetLeafSpacing();
  };

  TileView.prototype.SetSection = function (section) {
    this.Section = section;
    if (section.Transform) {
      this.GetCamera().SetWorldToImageTransform(section.Transform);
    } else {
      this.GetCamera().SetWorldToImageTransform([1, 0, 0, 1, 0, 0]);
    }
  };

  TileView.prototype.AddCache = function (cache) {
    if (cache === undefined) { return; }
    if (this.Section === undefined) {
      this.Section = this.DefaultSection;
    }
    this.Section.Caches.push(cache);
  };

  // Non connectome API, simple.
  // Just use the default section.
  TileView.prototype.SetCache = function (cache) {
    this.Section = this.DefaultSection;
    if (!cache) {
      this.Section.Caches = [];
    } else {
      this.Section.Caches = [cache];
    }
  };

  TileView.prototype.GetCache = function () {
    // connectome: This makes less sense with a section with many caches.
    // TODO: try to get rid of this
    return this.Section.Caches[0];
  };

  // Not used at the moment
  TileView.prototype.Draw = function (masterView) {
    if (masterView) {
      var cam = masterView.Camera;
      if (this.Transform) {
        this.Transform.ForwardTransformCamera(cam, this.Camera);
      } else {
        this.Camera.WorldCopy(cam);
      }
    }

    if (this.gl) {
      var gl = this.gl;
      gl.clear(SA.GL.COLOR_BUFFER_BIT | SA.GL.DEPTH_BUFFER_BIT);
      var program = SA.imageProgram;
      gl.useProgram(program);
      gl.clearColor(1.0, 1.0, 1.0, 1.0);
      gl.disable(gl.DEPTH_TEST);
      gl.enable(gl.BLEND);
      // gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
    }

    return this.DrawTiles();
  };

  // I want only the annotation to create a mask image.
  // Note: Tile in the list may not be loaded yet.
  // Returns true if all the tiles to render were available.
  // False implies that the user shoudl render again.
  TileView.prototype.DrawTiles = function () {
    // Download view is not visible, but still needs to render tiles.
    // This causes black/blank download images
    // if ( ! this.Parent.is(':visible') ) {
    //    return;
    // }
    // console.time("  ViewDraw");
    if (this.gl) {
      return this.Section.Draw(this);
    } else {
      this.ClearPending = true;
      // Clear the canvas to start drawing.
      // this.Context2d.fillStyle = '#ffffff';
      // this.Context2d.fillRect(0, 0, this.Viewport[2], this.Viewport[3]);
      this.Context2d.resetTransform();
      this.Context2d.clearRect(0, 0, this.Canvas[0].width, this.Canvas[0].height);
      return this.Section.Draw(this);
    }
  };

  SA.TileView = TileView;
})();

// ==============================================================================
// The magic code to add show/hide custom event triggers
(function ($) {
  $.each(['show', 'hide'], function (i, ev) {
    var el = $.fn[ev];
    $.fn[ev] = function () {
      this.trigger(ev);
      return el.apply(this, arguments);
    };
  });
})(jQuery);

(function () {
  'use strict';

  // TODO: Fix
  // Add stack option to Save large image GUI.
  // SaveStackImages.

  // I think this can go away now that we have hover mode in text.

  // States for when the viewer consumes events.
  var SAVING_IMAGE = false;
  var INTERACTION_NONE = 0;
  var INTERACTION_DRAG = 1;
  var INTERACTION_ROTATE = 2;
  var INTERACTION_ZOOM = 3;
  var INTERACTION_OVERVIEW = 4;
  var INTERACTION_OVERVIEW_DRAG = 5;
  var INTERACTION_OVERVIEW_WHEEL = 6;

  // TODO: Can we get rid of args parameter now that we have ProcessArguments method?
  // See the top of the file for description of args.
  function Viewer (parent) {
    var self = this;

    this.Parent = parent;
    parent.addClass('sa-viewer');

    // Debugging
    SA.VIEWER = this;

    // For debugging event propagation.
    // this.SetupTestDivs(parent);
    // return;

    // This div is bound to all the events that propagate to the layers and widgets.
    this.Div = $('<div>')
      .appendTo(this.Parent)
      .css({
        'position': 'relative',
        'border-width': '0px',
        'width': '100%',
        'height': '100%',
        'box-sizing': 'border-box',
        'z-index': '49'
      })
      .addClass('sa-resize');
    this.Div.saOnResize(
            function () {
              self.UpdateSize();
            });
    this.Div.addClass('ViewerDiv');
    // So we can programatically set the keyboard focus
    this.Div.attr('tabindex', '1');

    // I am moving the eventually render feature into viewers.
    this.Drawing = false;
    this.RenderPending = false;
    this.Rotatable = true;

    this.HistoryFlag = false;
    this.MinPixelSize = 0.25;

    // Need this to avoid calling interaction on multiple times.
    this.InteractionEnabled = false;

    // Interaction state:
    // What to do for mouse move or mouse up.
    this.InteractionState = INTERACTION_NONE;
    // External callbacks
    this.InteractionListeners = [];

    this.AnimateLast = null;
    this.AnimateDuration = 0.0;
    this.TranslateTarget = [0.0, 0.0];

    this.MainView = new SA.TileView(this.Div, false);
    // webgl for main view.
    this.MainView.OutlineColor = [0, 0, 0];
    this.MainView.Camera.ZRange = [0, 1];
    this.MainView.Camera.ComputeMatrix();
    // necesary to respond to keyevents.
    this.MainView.Parent.attr('tabindex', '1');

    this.Layers = [];

    if (!SAM.detectMobile() || SAM.MOBILE_DEVICE === 'iPad') {
      this.OverViewVisibility = true;
      this.OverViewScale = 0.02; // Experimenting with scroll
      this.OverViewport = [80, 20, 180, 180];
      this.OverViewDiv = $('<div>')
                .appendTo(this.Div);

      this.OverView = new SA.TileView(this.OverViewDiv);
      this.OverView.Camera.ZRange = [-1, 0];
      this.OverView.Camera.SetWorldFocalPoint([13000.0, 11000.0]);
      this.OverView.Camera.SetHeight(22000.0);
      this.OverView.Camera.ComputeMatrix();

      // One must be true for the icon to be active (opaque).
      this.RotateIconHover = false;
      // I am not making this part of the InteractionState because
      // I want to make the overview its own widget.
      this.RotateIconDrag = false;

      this.RotateIcon =
                $('<img>')
                .appendTo(this.OverView.Parent)
                .attr('src', SA.ImagePathUrl + 'rotate.png')
                .addClass('sa-view-rotate')
                .mouseenter(function (e) { return self.RollEnter(e); })
                .mouseleave(function (e) { return self.RollLeave(e); })
                .mousedown(function (e) { return self.RollDown(e); })
                .attr('draggable', 'false')
                .on('dragstart', function () {
                  return false;
                });
      // Try to make the overview be on top of the rotate icon
      // It should receive events before the rotate icon.
      this.OverViewDiv.css({'z-index': '49'});
    }
    this.ZoomTarget = this.MainView.Camera.GetHeight();
    this.RollTarget = this.MainView.Camera.GetWorldRoll();

    this.DoubleClickX = 0;
    this.DoubleClickY = 0;

    // For stack correlations.
    this.StackCorrelations = undefined;
    // This is only for drawing correlations.
    this.RecordIndex = 0; // Only used for drawing correlations.

    this.InteractionOn();

    this.CopyrightWrapper = $('<div>')
            .appendTo(this.MainView.Parent)
            .addClass('sa-view-copyright');
    if (SA.Session && SA.Session.sessid === '560b5127a7a1412195d13685') {
      this.Icon = $('<img>')
                .appendTo(this.MainView.Parent)
                .attr('src', 'http://static1.squarespace.com/static/5126bbb4e4b08c2e6d1cb6e4/t/54e66f05e4b0440df79a5729/1424387847915/')
                .prop('title', 'UC Davis')
                .css({'position': 'absolute',
                  'bottom': '80px',
                  'left': '7px',
                  'width': '128px',
                  'z-index': '4'});
    }
    if (SA.Session && SA.Session.sessid === '57504ba7a7a1411310dd2637') {
      this.Icon = $('<img>')
                .appendTo(this.MainView.Parent)
                .attr('src', 'https://slide-atlas.org/api/v2/sessions/53d9230fdd98b54fd71e8ed7/attachments/57518ce4a7a14113156b8166')
                .prop('title', 'Philips')
                .css({'position': 'absolute',
                  'bottom': '90px',
                  'left': '7px',
                  'width': '100px',
                  'z-index': '4'});
    }

    // For accelerating mouse wheel zooming.  I should probably merg this with drag accerlation ...
    this.WheelSensitivity = 0.0;     // (0.1) + Sensitivity: fraction zoom with no acceleration
    this.WheelAcceleration = 0.025;   // Each wheel event increases sensitivty by this size.
    this.WheelTimeConstant = 1000.0; // Time constant for sensitivty to decay back to default value.
  }

  Viewer.prototype.GetParentDiv = function () {
    return this.Div;
  };

  Viewer.prototype.GetParent = function () {
    return this.Parent;
  };

  Viewer.prototype.ScaleOn = function () {
    if (!this.ScaleWidget) {
      this.ScaleWidget = new SAM.ScaleWidget();
    }
  };

  // I need to turn the bindins on and off, to make children 'contentEditable'.
  Viewer.prototype.InteractionOn = function () {
    // Keep from adding multiple bindings for events.
    if (this.InteractionEnabled) {
      return;
    }
    this.InteractionEnabled = true;

    var self = this;
    // var can = this.MainView.Parent;
    var can = this.Div;
    can.on(
      'mousedown.viewer',
      function (event) {
        // SA.FirefoxWhich(event);
        self.FirefoxWhich = event.which;
        return self.HandleMouseDown(event);
      });
    can.on(
      'mousemove.viewer',
      function (event) {
        // So key events go the the right viewer.
        this.focus();
        if (event.which === undefined) {
          event.which = self.FirefoxWhich;
        }
        // Firefox does not define offsetX ...?
        // SA.FirefoxWhich(event);
        // Firefox does not set which for mouse move events.
        if (event.which === undefined) {
          event.which = self.FirefoxWhich;
        }
        return self.HandleMouseMove(event);
      });
    // We need to detect the mouse up even if it happens outside the canvas,
    $(document.body).on(
      'mouseup.viewer',
      function (event) {
        // SA.FirefoxWhich(event);
        self.FirefoxWhich = 0;
        if (event.which === undefined) {
          event.which = 0;
        }
        self.HandleMouseUp(event);
        return true;
      });
    can.on(
      'wheel.viewer',
      function (event) {
        return self.HandleMouseWheel(event.originalEvent);
      });

    // I am delaying getting event manager out of receiving touch events.
    // It has too many helper functions.
    can.on(
      'touchstart.viewer',
      function (event) {
        return self.HandleTouchStart(event.originalEvent);
      });
    can.on(
      'touchmove.viewer',
      function (event) {
        if (event.which === undefined) {
          event.which = 0;
        }
        event.which = self.FirefoxWhich;
        return self.HandleTouchMove(event.originalEvent);
      });
    can.on(
      'touchend.viewer',
      function (event) {
        self.HandleTouchEnd(event.originalEvent);
        return true;
      });

    can.on(
      'keydown.viewer',
      function (event) {
        // alert('keydown');
        return self.HandleKeyDown(event);
      });
    can.on(
      'keyup.viewer',
      function (event) {
        return self.HandleKeyUp(event);
      });

    if (this.OverView) {
      // can = this.OverView.Parent;
      can = this.OverViewDiv;
      can.on(
        'mousedown.viewer',
        function (event) {
          SA.FirefoxWhich(event);
          self.FirefoxWhich = event.which;
          return self.HandleOverViewMouseDown(event);
        });

      can.on(
        'mouseup.viewer',
        function (event) {
          self.FirefoxWhich = 0;
          self.FirefoxWhich = 0;
          if (event.which === undefined) {
            event.which = 0;
          }
          return self.HandleOverViewMouseUp(event);
        });
      can.on(
        'mousemove.viewer',
        function (event) {
          // SA.FirefoxWhich(event);
          if (event.which === undefined) {
            event.which = self.FirefoxWhich;
          }
          return self.HandleOverViewMouseMove(event);
        });
      can.on(
        'mousewheel.viewer',
        function (event) {
          return self.HandleOverViewMouseWheel(event.originalEvent);
        });
    }
  };

  // I need to turn the bindins on and off, to make children 'contentEditable'.
  Viewer.prototype.InteractionOff = function () {
    this.InteractionEnabled = false;

    // Options:
    // 1: Just use off to get rid of all bindings. This will remove outside bindings too.
    // 2: Remove them 1 by 1.
    // Lets be verbose but safe.
    // var can = this.MainView.Parent;
    var can = this.Div;
    can.off('mousedown.viewer');
    can.off('mousemove.viewer');
    $(document.body).off('mouseup.viewer');
    can.off('wheel.viewer');
    can.off('touchstart.viewer');
    can.off('touchmove.viewer');
    can.off('touchend.viewer');
    can.off('keydown.viewer');
    can.off('keyup.viewer');

    if (this.OverView) {
      // can = this.OverView.Parent;
      can = this.OverViewDiv;
      can.off('mousedown.viewer');
      can.off('mouseup.viewer');
      can.off('mousemove.viewer');
      can.off('mousewheel.viewer');
    }
  };

  // Allow the viewer to receive keyboard events.
  Viewer.prototype.Focus = function () {
    var can = this.MainView.Parent;
    can.focus();
  };

  Viewer.prototype.SetRotatable = function (flag) {
    this.Rotatable = flag;
    if (flag) {
      this.RotateIcon.show();
    } else {
      this.RotateIcon.hide();
    }
  };

  // Try to remove all global references to this viewer.
  Viewer.prototype.Delete = function () {
    /*
    this.Div.remove();
    // Remove circular references too?
    // This will probably affect all viewers.
    $(document.body).off('mouseup.viewer');
    this.MainView.Delete();
    if (this.OverView) {
      this.OverView.Delete();
      delete this.OverView;
    }
    delete this.MainView;
    delete this.Parent;
    delete this.Div;
    delete this.InteractionListeners;
    delete this.RotateIcon;
    delete this.StackCorrelations;
    delete this.CopyrightWrapper;
    */
  };

  // Layers have a Draw(masterView) method.
  Viewer.prototype.AddLayer = function (layer) {
    this.Layers.push(layer);
  };

  // Abstracting saViewer  for viewer and dualViewWidget.
  // Save viewer state in a note.
  Viewer.prototype.Record = function (note, viewIdx) {
    viewIdx = viewIdx || 0;
    note.ViewerRecords[viewIdx].CopyViewer(this);
  };

  // TODO: Make the annotation layer optional.
  // I am moving some of the saViewer code into this viewer object because
  // I am trying to abstract the single viewer used for the HTML presentation
  // note and the full dual view / stack note.
  // TODO: Make an alternative path that does not require a note.
  Viewer.prototype.ProcessArguments = function (args) {
    if (args.overview !== undefined) {
      this.SetOverViewVisibility(args.overview);
    }
    if (args.zoomWidget !== undefined) {
      this.SetZoomWidgetVisibility(args.zoomWidget);
    }
    if (args.rotatable !== undefined) {
      this.SetRotatable(args.rotatable);
    }

    // The way I handle the viewer edit menu is messy.
    // TODO: Find a more elegant way to add tabs.
    // Maybe the way we handle the anntation tab shouodl be our pattern.
    if (args.menu !== undefined) {
      if (!this.Menu) {
        this.Menu = new SA.ViewEditMenu(this, null);
      }
      this.Menu.SetVisibility(args.menu);
    }

    if (args.tileSource) {
      args.note = SA.TileSourceToNote(args.tileSource);
    }

    if (args.note) {
      this.saNote = args.note;
      var index = this.saViewerIndex = args.viewerIndex || 0;
      this.SetViewerRecord(args.note.ViewerRecords[index]);

      this.Parent.attr('sa-note-id', args.note.Id || args.note.TempId);
      this.Parent.attr('sa-viewer-index', this.saViewerIndex);
    }
    if (args.hideCopyright !== undefined) {
      this.SetCopyrightVisibility(!args.hideCopyright);
    }
    if (args.interaction !== undefined) {
      this.SetInteractionEnabled(args.interaction);
    }
    this.UpdateSize();
  };

  // Which is better calling Note.Apply, or viewer.SetNote?  I think this
  // will  win.  The layer needs to have a load callback for vigilant threshold.
  Viewer.prototype.SetViewerRecord = function (viewerRecord, lockCamera) {
    // If a widget is active, then just inactivate it.
    // It would be nice to undo pencil strokes in the middle, but this feature will have to wait.
    if (this.ActiveWidget) {
      // Hackish way to deactivate.
      this.ActiveWidget.SetActive(false);
    }

    if (!lockCamera) {
      this.Reset();
    }

    var cache = this.GetCache();
    if (!cache || viewerRecord.Image._id !== cache.Image._id) {
      var newCache = SA.FindCache(viewerRecord.Image);
      this.SetCache(newCache);
    }

    if (!lockCamera) {
      this.SetOverViewBounds(viewerRecord.OverViewBounds);

      if (viewerRecord.Camera !== undefined && viewerRecord.Transform === undefined) {
        var cameraRecord = viewerRecord.Camera;
        this.GetCamera().Load(cameraRecord);
        if (this.OverView) {
          this.OverView.Camera.SetWorldRoll(cameraRecord.Roll);
          this.OverView.Camera.ComputeMatrix();
        }
        this.UpdateZoomGui();
        this.UpdateCamera();
      }
    }

    // TODO: Get rid of this hack.
    if (this.AnnotationWidget && viewerRecord.AnnotationVisibility !== undefined) {
      this.AnnotationWidget.SetVisibility(viewerRecord.AnnotationVisibility);
    }

    // fit the canvas to the div size.
    this.UpdateSize();
  };

  Viewer.prototype.SetNote = function (note, viewIdx, lockCamera) {
    if (!note || viewIdx < 0 || viewIdx >= note.ViewerRecords.length) {
      console.log('Cannot set viewer record of note');
      return;
    }
    this.SetViewerRecord(note.ViewerRecords[viewIdx], lockCamera);
    this.saNote = note;
    this.saViewerIndex = viewIdx;
  };
  Viewer.prototype.SetNoteFromId = function (noteId, viewIdx) {
    var self = this;
    var note = SA.GetNoteFromId(noteId);
    if (!note) {
      note = new SA.Note();
      note.LoadViewId(
                noteId,
                function () {
                  self.SetNote(note, viewIdx);
                });
      return note;
    }
    this.SetNote(note, viewIdx);
    return note;
  };

  Viewer.prototype.SetOverViewVisibility = function (visible) {
    this.OverViewVisibility = visible;
    if (!this.OverViewDiv) { return; }
    if (visible) {
      this.OverViewDiv.show();
    } else {
      this.OverViewDiv.hide();
    }
  };

  Viewer.prototype.GetOverViewVisibility = function () {
    return this.OverViewVisibility;
  };

  Viewer.prototype.Hide = function () {
    this.MainView.Parent.hide();
    if (this.OverView) {
      this.OverView.Parent.hide();
    }
  };

  Viewer.prototype.Show = function () {
    this.MainView.Parent.show();
    if (this.OverView && this.OverViewVisibility) {
      this.OverView.Parent.show();
    }
  };

  // The interaction boolean argument will supress interaction events if false.
  Viewer.prototype.EventuallyRender = function (interaction) {
    if (!this.RenderPending) {
      this.RenderPending = true;
      var self = this;
      window.requestAnimationFrame(
                function () {
                  self.RenderPending = false;
                  self.Draw();
                  if (interaction) {
                    // Easiest place to make sure interaction events are triggered.
                    self.TriggerInteraction();
                  }
                });
    }
  };

  // These should be in an overview widget class.
  Viewer.prototype.RollEnter = function (e) {
    if (!this.Rotatable) { return; }
    this.RotateIconHover = true;
    this.RotateIcon.addClass('sa-active');
  };
  Viewer.prototype.RollLeave = function (e) {
    if (this.RotateIconDrag) { return; }
    this.RotateIconHover = false;
    if (!this.RotateIconDrag) {
      this.RotateIcon.removeClass('sa-active');
    }
  };
  Viewer.prototype.RollDown = function (e) {
    if (!this.OverView) { return; }
    if (!this.Rotatable) { return; }
    this.FirefoxWhich = e.which;
    this.RotateIconDrag = true;
    // Find the center of the overview window.
    var cx = this.OverViewport[0] + (0.5 * this.OverViewport[2]);
    var cy = this.OverViewport[1] + (0.5 * this.OverViewport[3]);
    var offset = this.MainView.Parent.offset();
    var x = e.pageX - offset.left - cx;
    var y = e.pageY - offset.top - cy;

    // Normalize
    var m = Math.sqrt((x * x) + (y * y));
    this.RotateIconX = x / m;
    this.RotateIconY = y / m;

    // Move event is in the viewer or overview.
    // It has a sanity check of which button was pressed.
    // It looks like the icon consumes the down event so
    // the viewer never has a chance to set this
    SA.FirefoxWhich(event);
    this.FirefoxWhich = event.which;

    return false;
  };

  Viewer.prototype.RollMove = function (e) {
    if (!this.OverView) { return; }
    if (!this.RotateIconDrag) { return; }
    if (!this.Rotatable) { return; }
    if (e.which !== 1) {
      // We must have missed the mouse up event.
      this.RotateIconDrag = false;
      return;
    }

    // Find the center of the overview window.
    // Relative to mainview?
    var cx = this.OverViewport[0] + (0.5 * this.OverViewport[2]);
    var cy = this.OverViewport[1] + (0.5 * this.OverViewport[3]);

    var offset = this.MainView.Parent.offset();
    var x = e.pageX - offset.left - cx;
    var y = e.pageY - offset.top - cy;

    // Normalize
    var m = Math.sqrt((x * x) + (y * y));
    x = x / m;
    y = y / m;

    // Cross product gives angle*m^2
    var dAngle = x * this.RotateIconY - y * this.RotateIconX;

    var roll = this.MainView.Camera.GetWorldRoll() - dAngle;
    this.MainView.Camera.SetWorldRoll(roll);
    this.UpdateCamera();
    this.EventuallyRender(true);

    this.RotateIconX = x;
    this.RotateIconY = y;

    return false;
  };

  // onresize callback.  Canvas width and height and the camera need
  // to be synchronized with the canvas div.
  Viewer.prototype.UpdateSize = function () {
    if (!this.MainView) {
      return;
    }
    if (this.MainView.UpdateCanvasSize()) {
      this.EventuallyRender();
    }

    for (var i = 0; i < this.Layers.length; ++i) {
      var layer = this.Layers[i];
      if (layer && layer.UpdateSize) {
        layer.UpdateSize();
      }
    }

    // I do not know the way the viewport is used to place
    // this overview.  It should be like other widgets
    // and be placed relative to the parent.
    if (this.OverView) {
      var width = this.MainView.GetWidth();
      var height = this.MainView.GetHeight();
      var area = width * height;
      var bounds = this.GetOverViewBounds();
      var aspect = (bounds[1] - bounds[0]) / (bounds[3] - bounds[2]);
      // size of overview
      var h = Math.sqrt(area * this.OverViewScale / aspect);
      var w = h * aspect;
      // Limit size
      if (h > height / 2) {
        h = height / 2;
        w = h * aspect;
        this.OverViewScale = w * h / area;
      }
      // center of overview
      var radius = Math.sqrt(h * h + w * w) / 2;
      // Construct the viewport.  Hack: got rid of viewport[0]
      // TODO: I really need to get rid of the viewport stuff
      this.OverViewport = [width - radius - w / 2,
        radius - h / 2,
        w, h];
      this.OverViewDiv.css({
        'left': this.OverViewport[0] + 'px',
        'width': this.OverViewport[2] + 'px',
        'top': this.OverViewport[1] + 'px',
        'height': this.OverViewport[3] + 'px'
      });
      this.OverView.UpdateCanvasSize();
    }
  };

  // TODO: Events are a pain because most are handled by parent.
  // Time to make the overview a real widget?
  Viewer.prototype.RollUp = function (e) {
    this.RotateIconDrag = false;
    if (!this.RotateIconHover) {
      this.RotateIcon.addClass('sa-active');
    }

    return false;
  };

  Viewer.prototype.GetMainCanvas = function () {
    return this.MainView.Canvas;
  };

  // A way to have a method called every time the camera changes.
  // Will be used for synchronizing viewers for stacks.
  Viewer.prototype.OnInteraction = function (callback) {
    // How should we remove listners?
    // Global clear for now.
    if (!callback) {
      this.InteractionListeners = [];
    } else {
      this.InteractionListeners.push(callback);
    }
  };

  Viewer.prototype.TriggerInteraction = function () {
    for (var i = 0; i < this.InteractionListeners.length; ++i) {
      var callback = this.InteractionListeners[i];
      callback();
    }
  };

  Viewer.prototype.GetDiv = function () {
    return this.MainView.Parent;
  };

  Viewer.prototype.InitializeZoomGui = function () {
    // Links: URL for the current view, and url to a highres cutout.
    this.ShareTab = new SA.Tab(this.GetDiv(),
                               SA.ImagePathUrl + 'share.png',
                               'shareTab');
    this.ShareTab.Div
      .css({
        'box-sizing': 'border-box',
        'position': 'absolute',
        'bottom': '0px',
        'right': '47px',
        'z-index': '49'});
    this.ShareTab.Panel
      .css({
        'box-sizing': 'border-box',
        'left': '-400px',
        'width': '480px',
        'z-index': '500',
        // 'height': '45px',
        'padding': '0 2px'});
    var self = this;
    this.ShareDisplay = $('<div>')
      .appendTo(this.ShareTab.Panel)
      .addClass('sa-view-share-text')
      .html('')
      .attr('contenteditable', 'true')
      .css({
        'tabindex': '1',
        'z-index': '501',
        'width': '100%',
        '-webkit-user-select': 'all',
        'user-select': 'all'});

    // TODO: Separate the share update from EndInteraction.
    this.ShareTab.Panel.on('show', function () {
      self.TriggerEndInteraction();
      self.ShareDisplay.focus();
    });
    // Gymnastics to let the textarea get events.
    // Allow copy of text.
    this.ShareDisplay.on('mouseenter', function () {
      self.InteractionOff();
      self.ShareDisplay.focus();
    });
    this.ShareDisplay.on('mouseleave', function () {
      self.InteractionOn();
      self.ShareDisplay.blur();
    });

    // Put the zoom bottons in a tab.
    this.ZoomTab = new SA.Tab(this.GetDiv(),
                               SA.ImagePathUrl + 'mag.png',
                               'zoomTab');
    this.ZoomTab.Div
      .css({
        'box-sizing': 'border-box',
        'position': 'absolute',
        'bottom': '0px',
        'right': '7px',
        'z-index': '49'});
    // .prop('title', 'Zoom scroll');
    this.ZoomTab.Panel
      .addClass('sa-view-zoom-panel');
    // Put the magnification factor inside the magnify glass icon.
    this.ZoomDisplay = $('<div>')
      .appendTo(this.ZoomTab.Div)
      .addClass('sa-view-zoom-text')
      .html('');

    // Place the zoom in / out buttons.
    // Todo: Make the button become more opaque when pressed.
    // Associate with viewer (How???).
    // Place properly (div per viewer?) (viewer.SetViewport also places buttons).

    this.ZoomDiv = $('<div>')
      .appendTo(this.ZoomTab.Panel)
      .addClass('sa-view-zoom-panel-div');
    this.ZoomInButton = $('<img>')
      .appendTo(this.ZoomDiv)
      .addClass('sa-view-zoom-button sa-zoom-in')
      .attr('type', 'image')
      .attr('src', SA.ImagePathUrl + 'zoomin2.png')
      .on('click touchstart', function () { self.AnimateZoom(0.5); })
      .attr('draggable', 'false')
      .on('dragstart', function () {
        return false;
      });

    this.ZoomOutButton = $('<img>').appendTo(this.ZoomDiv)
      .addClass('sa-view-zoom-button sa-zoom-out')
      .attr('type', 'image')
      .attr('src', SA.ImagePathUrl + 'zoomout2.png')
      .on('click touchstart', function () { self.AnimateZoom(2.0); })
      .attr('draggable', 'false')
      .on('dragstart', function () {
        return false;
      });

    this.ZoomInButton.addClass('sa-active');
    this.ZoomOutButton.addClass('sa-active');
  };

  Viewer.prototype.UpdateZoomGui = function () {
    if (!this.ZoomDisplay) { return; }
    var camHeight = this.GetCamera().GetHeight();
    var windowHeight = this.GetViewport()[3];
    // Assume image scanned at 40x
    var zoomValue = 40.0 * windowHeight / camHeight;
    // 2.5 and 1.25 are standard in the geometric series.
    if (zoomValue < 2) {
      zoomValue = zoomValue.toFixed(2);
    } else if (zoomValue < 4) {
      zoomValue = zoomValue.toFixed(1);
    } else {
      zoomValue = Math.round(zoomValue);
    }
    this.ZoomDisplay.html('x' + zoomValue);

    // I am looking for the best place to update this value.
    // Trying to fix a bug: Large scroll when wheel event occurs
    // first.
    this.ZoomTarget = camHeight;
  };

  Viewer.prototype.SaveImage = function (fileName) {
    this.MainView.Canvas[0].toBlob(function (blob) { saveAs(blob, fileName); }, 'image/png');
  };

  // Cancel the large image request before it finishes.
  Viewer.prototype.CancelLargeImage = function () {
    // This will abort the save blob that occurs after rendering.
    SA.ClearFinishedLoadingCallbacks();
    // We also need to stop the request for pending tiles.
    SA.ClearQueue();
    // Incase some of the queued tiles were for normal rendering.
    this.EventuallyRender(false);
  };

  // NOTE: Consider option for annotation layer to share a canvas with the
  // tile view.
  // Create a virtual viewer to save a very large image.
  Viewer.prototype.SaveLargeImage = function (fileName, width, height, stack,
                                               finishedCallback) {
    var self = this;
    var cache = this.GetCache();
    var cam = this.GetCamera();

    // Clone the main view.
    var view = new SA.TileView();
    view.SetCache(cache);
    view.Canvas.attr('width', width);
    view.Canvas.attr('height', height);
    view.SetViewport([0, 0, width, height]);
    var newCam = view.Camera;

    newCam.SetWorldFocalPoint(cam.GetWorldFocalPoint());
    newCam.SetWorldRoll(cam.GetWorldRoll());
    newCam.Height = cam.GetHeight();
    newCam.Width = cam.GetWidth();
    newCam.ViewportWidth = width;
    newCam.ViewportHeight = height;
    newCam.ComputeMatrix();

    // Load only the tiles we need.
    var tiles = cache.ChooseTiles(newCam, 0, []);
    for (var i = 0; i < tiles.length; ++i) {
      SA.LoadQueueAddTile(tiles[i]);
    }
    SA.LoadQueueUpdate();

    // this.CancelLargeImage = false;
    SA.AddFinishedLoadingCallback(
      function () {
        self.SaveLargeImage2(view, fileName,
                             width, height, stack,
                             finishedCallback);
      }
    );
  };

  Viewer.prototype.SaveLargeImage2 = function (view, fileName,
                                               width, height, stack,
                                               finishedCallback) {
    var sectionFileName = fileName;
    var note;
    if (stack) {
      note = SA.display.GetNote();
      var idx = fileName.indexOf('.');
      if (idx < 0) {
        sectionFileName = fileName + SA.ZERO_PAD(note.StartIndex, 4) + '.png';
      } else {
        sectionFileName = fileName.substring(0, idx) +
          SA.ZERO_PAD(note.StartIndex, 4) +
          fileName.substring(idx, fileName.length);
      }
    }
    console.log(sectionFileName + ' ' + SA.LoadQueue.length + ' ' + SA.LoadingCount);

    if (!view.Draw()) {
      console.log('Sanity check failed. Not all tiles were available.');
    }
    this.MainView.DrawShapes();

    for (var i = 0; i < this.Layers.length; ++i) {
      if (this.Layers[i].Draw) {
        this.Layers[i].Draw(view);
      }
    }

    console.log(JSON.stringify(this.GetCamera().Serialize()));

    view.Canvas[0].toBlob(function (blob) { saveAs(blob, sectionFileName); }, 'image/png');
    if (stack) {
      note = SA.display.GetNote();
      if (note.StartIndex < note.ViewerRecords.length - 1) {
        SA.display.NavigationWidget.NextNote();
        var self = this;
        setTimeout(function () {
          self.SaveLargeImage(fileName, width, height, stack,
                              finishedCallback);
        }, 1000);
        return;
      }
    }

    finishedCallback();
  };

  // This method waits until all tiles are loaded before saving.
  Viewer.prototype.EventuallySaveImage = function (fileName, finishedCallback) {
    var self = this;
    SA.AddFinishedLoadingCallback(
      function () {
        self.SaveImage(fileName);
        if (finishedCallback) {
          finishedCallback();
        }
      }
    );
    this.EventuallyRender(false);
  };

  // Not used anymore.  Incorpoarated in SaveLargeImage
  // delete these.
  // Save a bunch of stack images ----
  Viewer.prototype.SaveStackImages = function (fileNameRoot) {
    var self = this;
    SA.AddFinishedLoadingCallback(
      function () {
        self.SaveStackImage(fileNameRoot);
      }
    );
    this.EventuallyRender(false);
  };

  Viewer.prototype.SaveStackImage = function (fileNameRoot) {
    var self = this;
    var note = SA.display.GetNote();
    var fileName = fileNameRoot + SA.ZERO_PAD(note.StartIndex, 4);
    console.log(JSON.stringify(this.GetCamera().Serialize()));
    this.SaveImage(fileName);
    if (note.StartIndex < note.ViewerRecords.length - 1) {
      SA.display.NavigationWidget.NextNote();
      SA.AddFinishedLoadingCallback(
        function () {
          self.SaveStackImage(fileNameRoot);
        }
      );
      this.EventuallyRender(false);
    }
  };
  // -----

  Viewer.prototype.SetOverViewBounds = function (bounds) {
    this.OverViewBounds = bounds;
    if (this.OverView) {
      // With the rotating overview, the overview camera
      // never changes. Maybe this should be set in
      // 'UpdateCamera'.
      this.OverView.Camera.SetHeight(bounds[3] - bounds[2]);
      this.OverView.Camera.SetWorldFocalPoint([
        0.5 * (bounds[0] + bounds[1]),
        0.5 * (bounds[2] + bounds[3])]);
      this.OverView.Camera.ComputeMatrix();
    }
  };

  Viewer.prototype.GetOverViewBounds = function () {
    if (this.OverViewBounds) {
      return this.OverViewBounds;
    }
    var cache = this.GetCache();
    if (cache && cache.Image) {
      if (cache.Image.bounds) {
        return cache.Image.bounds;
      }
      if (cache.Image.dimensions) {
        var dims = cache.Image.dimensions;
        return [0, dims[0], 0, dims[1]];
      }
    }
    // Depreciated code.
    if (this.OverView) {
      var cam = this.OverView.Camera;
      var halfHeight = cam.GetHeight() / 2;
      var halfWidth = cam.GetWidth() / 2;
      var fp = cam.GetWorldFocalPoint();
      this.OverViewBounds = [
        fp[0] - halfWidth, fp[0] + halfWidth,
        fp[1] - halfHeight, fp[1] + halfHeight];
      return this.OverViewBounds;
    }
    // This method is called once too soon.  There is no image, and mobile devices have no overview.
    return [0, 10000, 0, 10000];
  };

  Viewer.prototype.SetSection = function (section) {
    if (section === null) {
      return;
    }

    if (section.Bounds) {
      this.SetOverViewBounds(section.Bounds);
    }
    if (section.Caches.length > 0) {
      this.CopyrightWrapper
        .html(section.Caches[0].Image.copyright);
    }

    this.MainView.SetSection(section);

    if (this.OverView) {
      this.OverView.SetSection(section);
      var bds = section.Bounds;
      if (bds) {
        this.OverView.Camera.SetWorldFocalPoint([
          (bds[0] + bds[1]) / 2,
          (bds[2] + bds[3]) / 2]);
        var height = (bds[3] - bds[2]);
        // See if the view is constrained by the width.
        var height2 = (bds[1] - bds[0]) * this.OverView.Viewport[3] / this.OverView.Viewport[2];
        if (height2 > height) {
          height = height2;
        }
        this.OverView.Camera.SetHeight(height);
        this.OverView.Camera.ComputeMatrix();
      }
    }
    // Change the overview to fit the new image dimensions.
    this.UpdateSize();
  };

  // Change the source / cache after a viewer has been created.
  // TODO: clean this up. Should probably call set section.
  // OverView bounds appear to be handled twice.
  // Handle copyright for sections. (multple caches?)
  Viewer.prototype.SetCache = function (cache) {
    if (cache && cache.Image) {
      if (cache.Image.bounds) {
        this.SetOverViewBounds(cache.Image.bounds);
      }

      this.CopyrightWrapper
        .html(cache.Image.copyright);
    }

    this.MainView.SetCache(cache);
    if (this.OverView) {
      this.OverView.SetCache(cache);
      if (cache) {
        var bds = cache.GetBounds();
        if (bds) {
          this.OverView.Camera.SetWorldFocalPoint([
            (bds[0] + bds[1]) / 2,
            (bds[2] + bds[3]) / 2]);
          var height = (bds[3] - bds[2]);
          // See if the view is constrained by the width.
          var height2 = (bds[1] - bds[0]) * this.OverView.Viewport[3] / this.OverView.Viewport[2];
          if (height2 > height) {
            height = height2;
          }
          this.OverView.Camera.SetHeight(height);
          this.OverView.Camera.ComputeMatrix();
        }
      }
    }
    // Change the overview to fit the new image dimensions.
    this.UpdateSize();
  };

  Viewer.prototype.GetCache = function () {
    return this.MainView.GetCache();
  };

  // ORIGIN SEEMS TO BE BOTTOM LEFT !!!
  // I intend this method to get called when the window resizes.
  // TODO: Redo all this overview viewport junk.
  // viewport: [left, top, width, height]
  // When I remove this function, move the logic to UpdateSize().
  Viewer.prototype.SetViewport = function (viewport) {
    // TODO: Get rid of this positioning hack.
    // Caller should be positioning the parent.
    // The whole 'viewport' concept needs to be eliminated.
    // this.MainView.SetViewport(viewport, this.Parent);
    // this.MainView.Camera.ComputeMatrix();

    // I do not know the way the viewport is used to place
    // this overview.  It should be like other widgets
    // and be placed relative to the parent.
    if (this.OverView) {
      var area = viewport[2] * viewport[3];
      var bounds = this.GetOverViewBounds();
      var aspect = (bounds[1] - bounds[0]) / (bounds[3] - bounds[2]);
      // size of overview
      var h = Math.sqrt(area * this.OverViewScale / aspect);
      var w = h * aspect;
      // Limit size
      if (h > viewport[3] / 2) {
        h = viewport[3] / 2;
        w = h * aspect;
        this.OverViewScale = w * h / area;
      }
      // center of overview
      var radius = Math.sqrt(h * h + w * w) / 2;
      // Construct the viewport.  Hack: got rid of viewport[0]
      // TODO: I really need to get rid of the viewport stuff
      this.OverViewport = [viewport[2] - radius - w / 2,
        viewport[1] + radius - h / 2,
        w, h];

      this.OverViewDiv.css({
        'left': this.OverViewport[0] + 'px',
        'width': this.OverViewport[2] + 'px',
        'top': this.OverViewport[1] + 'px',
        'height': this.OverViewport[3] + 'px'
      });
      this.OverView.UpdateCanvasSize();
    }
  };

  Viewer.prototype.GetViewport = function () {
    return this.MainView.Viewport;
  };

  // To fix a bug in the perk and elmer uploader.
  Viewer.prototype.ToggleMirror = function () {
    this.MainView.Camera.Mirror = !this.MainView.Camera.Mirror;
    if (this.OverView) {
      this.OverView.Camera.Mirror = !this.OverView.Camera.Mirror;
    }
  };

  // Same as set camera but use animation
  Viewer.prototype.AnimateCamera = function (center, rotation, height) {
    this.ZoomTarget = height;
    // Compute traslate target to keep position in the same place.
    this.TranslateTarget[0] = center[0];
    this.TranslateTarget[1] = center[1];
    this.RollTarget = rotation;

    this.AnimateLast = new Date().getTime();
    this.AnimateDuration = 200.0; // hard code 200 milliseconds
    this.EventuallyRender(true);
  };

  // This sets the overview camera from the main view camera.
  // The user can change the mainview camera and then call this method.
  Viewer.prototype.UpdateCamera = function () {
    var cam = this.MainView.Camera;
    this.ZoomTarget = cam.Height;

    var fp = cam.GetWorldFocalPoint();
    this.TranslateTarget[0] = fp[0];
    this.TranslateTarget[1] = fp[1];
    this.RollTarget = cam.GetWorldRoll();
    if (this.OverView) {
      this.OverView.Parent.css({'transform': 'rotate(' + this.RollTarget + 'rad'});
      this.OverView.Camera.SetWorldRoll(0);
      this.OverView.Camera.ComputeMatrix();
    }

    this.MainView.Camera.ComputeMatrix();
    this.UpdateZoomGui();
  };

    // This is used to set the default camera so the complexities
    // of the target and overview are hidden.
  Viewer.prototype.SetCamera = function (center, rotation, height) {
    this.MainView.Camera.SetHeight(height);
    this.MainView.Camera.SetWorldFocalPoint([center[0], center[1]]);
    this.MainView.Camera.SetWorldRoll(rotation * 3.14159265359 / 180.0);

    this.ZoomTarget = height;
    this.TranslateTarget[0] = center[0];
    this.TranslateTarget[1] = center[1];
    this.RollTarget = rotation;

    this.UpdateCamera();
    this.EventuallyRender(true);
  };

  Viewer.prototype.GetCamera = function () {
    return this.MainView.Camera;
  };

  // I could merge zoom methods if position defaulted to focal point.
  Viewer.prototype.AnimateZoomTo = function (factor, position) {
    if (this.AnimateDuration > 0.0) {
      // Odd effect with multiple fast zoom clicks.  Center shifted.
      return;
    }

    SA.StackCursorFlag = false;

    this.ZoomTarget = this.MainView.Camera.GetHeight() * factor;
    if (this.ZoomTarget < 0.9 / (1 << 5)) {
      this.ZoomTarget = 0.9 / (1 << 5);
    }

    // Lets restrict discrete zoom values to be standard values.
    var windowHeight = this.GetViewport()[3];
    var tmp = Math.round(Math.log(32.0 * windowHeight / this.ZoomTarget) /
                             Math.log(2));
    this.ZoomTarget = 32.0 * windowHeight / Math.pow(2, tmp);

    factor = this.ZoomTarget / this.MainView.Camera.GetHeight(); // Actual factor after limit.

    // Compute translate target to keep position in the same place.
    var fp = this.MainView.Camera.GetWorldFocalPoint();
    this.TranslateTarget[0] = position[0] - factor * (position[0] - fp[0]);
    this.TranslateTarget[1] = position[1] - factor * (position[1] - fp[1]);

    this.RollTarget = this.MainView.Camera.GetWorldRoll();

    this.AnimateLast = new Date().getTime();
    this.AnimateDuration = 200.0; // hard code 200 milliseconds
    this.EventuallyRender(true);
  };

  Viewer.prototype.AnimateZoom = function (factor) {
    // I cannot get the canvas from processing this event too.
    // Issue with double click. Hack to stop double click from firing.
    this.MouseUpTime -= 1000.0;

    if (this.AnimateDuration > 0.0) {
      return;
    }

    var focalPoint = this.GetCamera().GetWorldFocalPoint();
    this.AnimateZoomTo(factor, focalPoint);
  };

  Viewer.prototype.AnimateTranslate = function (dx, dy) {
    var fp = this.MainView.Camera.WorldFocalPoint();
    this.TranslateTarget[0] = fp[0] + dx;
    this.TranslateTarget[1] = fp[1] + dy;

    this.ZoomTarget = this.MainView.Camera.GetHeight();
    this.RollTarget = this.MainView.Camera.GetWorldRoll();

    this.AnimateLast = new Date().getTime();
    this.AnimateDuration = 200.0; // hard code 200 milliseconds
    this.EventuallyRender(true);
  };

  Viewer.prototype.AnimateRoll = function (dRoll) {
    dRoll *= Math.PI / 180.0;
    this.RollTarget = this.MainView.Camera.GetWorldRoll() + dRoll;

    this.ZoomTarget = this.MainView.Camera.GetHeight();
    var fp = this.MainView.Camera.GetWorldFocalPoint();
    this.TranslateTarget[0] = fp[0];
    this.TranslateTarget[1] = fp[1];

    this.AnimateLast = new Date().getTime();
    this.AnimateDuration = 200.0; // hard code 200 milliseconds
    this.EventuallyRender(true);
  };

  Viewer.prototype.AnimateTransform = function (dx, dy, dRoll) {
    var fp = this.MainView.Camera.GetWorldFocalPoint();
    this.TranslateTarget[0] = fp[0] + dx;
    this.TranslateTarget[1] = fp[1] + dy;

    this.RollTarget = this.MainView.Camera.GetWorldRoll() + dRoll;

    this.ZoomTarget = this.MainView.Camera.GetHeight();

    this.AnimateLast = new Date().getTime();
    this.AnimateDuration = 200.0; // hard code 200 milliseconds
    this.EventuallyRender(true);
  };

  Viewer.prototype.DegToRad = function (degrees) {
    return degrees * Math.PI / 180;
  };

  Viewer.prototype.Draw = function () {
    if (SA && SA.RootNote && SA.RootNote.WaterMark) {
      SA.WaterMark = true;
    } else {
      SA.WaterMark = false;
    }

    // I do not think this is actually necessary.
    // I was worried about threads, but javascript does not work that way.
    if (this.Drawing) { return; }
    this.Drawing = true;

    // This just changes the camera based on the current time.
    this.Animate();

    // console.time('ViewerDraw');

    // connectome
    if (!this.MainView || !this.MainView.Section) {
      return;
    }

    // Should the camera have the viewport in them?
    // The do not currently hav a viewport.

    // If we are still waiting for tiles to load, schedule another render.
    // This works fine, but results in many renders while waiting.
    // TODO: Consider having the tile load callback scheduling the next render.
    if (!this.MainView.Draw()) {
      this.EventuallyRender();
    }

    for (var i = 0; i < this.Layers.length; ++i) {
      if (this.Layers[i].Draw) {
        this.Layers[i].Draw(this.MainView);
      }
    }

    // This is not used anymore
    // However, I am thinking of resurecting it.  With many widgets,
    // drawing becomes slow.
    this.MainView.DrawShapes();
    if (this.OverView) {
      this.OverView.Draw();
      this.OverView.DrawOutline(true);
    }

    // Draw a rectangle in the overview representing the camera's view.
    if (this.OverView) {
      this.MainView.Camera.Draw(this.OverView);
      if (this.HistoryFlag) {
        this.OverView.DrawHistory(this.MainView.Viewport[3]);
      }
    }

    if (this.ScaleWidget) {
      // Girder is not setting spacing correct.
      // But we still need the scale widget for the grid widget.
      this.ScaleWidget.Draw(this.MainView);
    }

    // TODO: Drawing correlations should not be embedded in a single
    // viewer. Maybe dualViewWidget or a new stack object should handle it.

    // I am using shift for stack interaction.
    // Turn on the focal point when shift is pressed.
    if (SA.StackCursorFlag && SA.Edit) {
      this.MainView.DrawFocalPoint();
      if (this.StackCorrelations) {
        this.MainView.DrawCorrelations(this.StackCorrelations, this.RecordIndex);
      }
    }

    // Here to trigger SA.FinishedLoadingCallbacks
    SA.LoadQueueUpdate();
    // console.timeEnd('ViewerDraw');
    this.Drawing = false;
  };

  // Makes the viewer clean to setup a new slide...
  Viewer.prototype.Reset = function () {
    this.MomentumX = 0.0;
    this.MomentumY = 0.0;
    this.MomentumRoll = 0.0;
    this.MomentumScale = 0.0;
    if (this.MomentumTimerId) {
      window.cancelAnimationFrame(this.MomentumTimerId);
      this.MomentumTimerId = 0;
    }

    // Keep further touch moves from having any impact.
    this.StartTouchTime = 0;

    this.SetCache(null);
    this.MainView.ShapeList = [];

    for (var i = 0; i < this.Layers.length; ++i) {
      if (this.Layers[i].Reset) {
        this.Layers[i].Reset();
      }
      if (this.Layers[i].Remove) {
        this.Layers[i].Remove();
      }
    }
    this.Layers = [];
  };

  // A list of shapes to render in the viewer
  Viewer.prototype.AddShape = function (shape) {
    this.MainView.AddShape(shape);
  };

  Viewer.prototype.Animate = function () {
    var roll;
    if (this.AnimateDuration <= 0.0) {
      return;
    }
    var timeNow = new Date().getTime();
    if (timeNow >= (this.AnimateLast + this.AnimateDuration)) {
      this.AnimateDuration = 0;
      // We have past the target. Just set the target values.
      this.MainView.Camera.SetHeight(this.ZoomTarget);
      this.MainView.Camera.SetWorldRoll(this.RollTarget);
      this.MainView.Camera.SetWorldFocalPoint([this.TranslateTarget[0],
        this.TranslateTarget[1]]);
      this.ConstrainCamera();
      if (this.OverView) {
        roll = this.RollTarget;
        this.OverView.Parent.css({'transform': 'rotate(' + roll + 'rad'});
        this.OverView.Camera.SetWorldRoll(0);
        this.OverView.Camera.ComputeMatrix();
      }
      this.TriggerEndInteraction();
    } else {
      // Interpolate
      var currentHeight = this.MainView.Camera.GetHeight();
      var currentCenter = this.MainView.Camera.GetWorldFocalPoint();
      var currentRoll = this.MainView.Camera.GetWorldRoll();

      this.MainView.Camera.SetHeight(
        currentHeight + (this.ZoomTarget - currentHeight) *
          (timeNow - this.AnimateLast) / this.AnimateDuration);
      this.MainView.Camera.SetWorldRoll(
        currentRoll + (this.RollTarget - currentRoll) *
          (timeNow - this.AnimateLast) / this.AnimateDuration);
      this.MainView.Camera.SetWorldFocalPoint(
        [currentCenter[0] + (this.TranslateTarget[0] - currentCenter[0]) *
         (timeNow - this.AnimateLast) / this.AnimateDuration,
          currentCenter[1] + (this.TranslateTarget[1] - currentCenter[1]) *
         (timeNow - this.AnimateLast) / this.AnimateDuration]);
      this.ConstrainCamera();
      if (this.OverView) {
        roll = this.MainView.Camera.GetWorldRoll();
        this.OverView.Parent.css({'transform': 'rotate(' + roll + 'rad'});
        this.OverView.Camera.SetWorldRoll(0);
        this.OverView.Camera.ComputeMatrix();
      }
      this.AnimateDuration -= (timeNow - this.AnimateLast);
      // We are not finished yet.
      // Schedule another render
      this.EventuallyRender(true);
    }
    this.MainView.Camera.ComputeMatrix();
    if (this.OverView) {
      this.OverView.Camera.ComputeMatrix();
    }
    this.AnimateLast = timeNow;
    // Synchronize cameras is necessary
  };

  Viewer.prototype.OverViewPlaceCameraPt = function (x, y) {
    if (!this.OverView) {
      return;
    }
    // Compute focal point from inverse overview camera.
    x = x / this.OverView.Viewport[2];
    y = y / this.OverView.Viewport[3];
    var m = this.OverView.Camera.GetWorldMatrix();
    x = (x * 2.0 - 1.0) * m[15];
    y = (1.0 - y * 2.0) * m[15];
    var det = m[0] * m[5] - m[1] * m[4];
    var xNew = (x * m[5] - y * m[4] + m[4] * m[13] - m[5] * m[12]) / det;
    var yNew = (y * m[0] - x * m[1] - m[0] * m[13] + m[1] * m[12]) / det;

    // Animate to get rid of jerky panning (overview to low resolution).
    this.TranslateTarget[0] = xNew;
    this.TranslateTarget[1] = yNew;
    this.AnimateLast = new Date().getTime();
    this.AnimateDuration = 100.0;
    this.EventuallyRender(true);
  };

  // TODO: I think these are legacy and need to be removed.
  Viewer.prototype.SetInteractionEnabled = function (enabled) {
    console.log('Get rid of this');
    this.InteractionEnabled = enabled;
  };
  Viewer.prototype.EnableInteraction = function () {
    console.log('Get rid of this');
    this.InteractionEnabled = true;
  };
  Viewer.prototype.DisableInteraction = function () {
    console.log('Get rid of this');
    this.InteractionEnabled = false;
  };

  // Used to be in EventManager.
  // TODO: Evaluate and cleanup.
  Viewer.prototype.RecordMouseDown = function (event) {
    // Evaluate where LastMouseX / Y are used.
    this.LastMouseX = this.MouseX || 0;
    this.LastMouseY = this.MouseY || 0;
    this.LastMouseTime = this.MouseTime || 0;
    if (!this.SetMousePositionFromEvent(event)) { return false; }

    // TODO:  Formalize a call back to make GUI disappear when
    // navigation starts.  I think I did this already but have not
    // converted this code yet.
    // Get rid of the favorites and the link divs if they are visible
    // if (SA.LinkDiv && SA.LinkDiv.is(':visible')) {
    //  SA.LinkDiv.fadeOut();
    // }
    // if (typeof SA.FAVORITES_WIDGET !== 'undefined' &&
    //       SA.FAVORITES_WIDGET.hidden === false) {
    //  SA.FAVORITES_WIDGET.ShowHideFavorites();
    // }

    var date = new Date();
    this.MouseDownTime = date.getTime();
    // Double click gets stuck on.  We do not really need it.
    // var dTime = date.getTime() - this.MouseUpTime;
    // if (dTime < 200.0) { // 200 milliseconds
    //  this.DoubleClick = true;
    // }

    // this.TriggerStartInteraction();
  };
  // Used to be in EventManager.
  // TODO: Evaluate and cleanup.
  Viewer.prototype.SetMousePositionFromEvent = function (event) {
    var pt = this.GetMousePosition(event);
    if (pt === undefined) {
      return false;
    }
    this.MouseX = pt[0];
    this.MouseY = pt[1];
    // For annotation
    event.MouseX = pt[0];
    event.MouseY = pt[1];
    this.MouseTime = (new Date()).getTime();
    return true;
  };
  Viewer.prototype.RecordMouseMove = function (event) {
    this.LastMouseX = this.MouseX;
    this.LastMouseY = this.MouseY;
    this.LastMouseTime = this.MouseTime;
    if (!this.SetMousePositionFromEvent(event)) { return false; }
    this.MouseDeltaX = this.MouseX - this.LastMouseX;
    this.MouseDeltaY = this.MouseY - this.LastMouseY;
    this.MouseDeltaTime = this.MouseTime - this.LastMouseTime;
    return this.MouseDeltaX !== 0 || this.MouseDeltaY !== 0;
  };
  Viewer.prototype.RecordMouseUp = function (event) {
    if (!this.SetMousePositionFromEvent(event)) { return false; }
    this.MouseDown = false;

    // Record time so we can detect double click.
    var date = new Date();
    this.MouseUpTime = date.getTime();
    this.DoubleClick = false;
  };

  // Save the previous touches and record the new
  // touch locations in viewport coordinates.
  Viewer.prototype.HandleTouch = function (e, startFlag) {
    var date = new Date();
    var t = date.getTime();
    // I have had trouble on the iPad with 0 delta times.
    // Lets see how it behaves with fewer events.
    // It was a bug in iPad4 Javascript.
    // This throttle is not necessary.
    if (t - this.Time < 20 && !startFlag) { return false; }

    this.LastTime = this.Time;
    this.Time = t;

    if (!e) {
      e = event;
    }

    // Still used on mobile devices?
    this.LastTouches = this.Touches;
    this.Touches = [];
    for (var i = 0; i < e.targetTouches.length; ++i) {
      var offset = this.MainView.Canvas.offset();
      var x = e.targetTouches[i].pageX - offset.left;
      var y = e.targetTouches[i].pageY - offset.top;
      this.Touches.push([x, y]);
    }

    this.LastMouseX = this.MouseX;
    this.LastMouseY = this.MouseY;

    // Compute the touch average.
    var numTouches = this.Touches.length;
    this.MouseX = this.MouseY = 0.0;
    for (i = 0; i < numTouches; ++i) {
      this.MouseX += this.Touches[i][0];
      this.MouseY += this.Touches[i][1];
    }
    this.MouseX = this.MouseX / numTouches;
    this.MouseY = this.MouseY / numTouches;

    // Hack because we are moving away from using the event manager
    // Mouse interaction are already independent...
    this.offsetX = this.MouseX;
    this.offsetY = this.MouseY;

    return true;
  };

  Viewer.prototype.HandleTouchStart = function (event) {
    if (!this.InteractionEnabled) { return true; }

    // Stuff from event manager
    this.HandleTouch(event, true);
    this.StartTouchTime = this.Time;

    // Let the annotation layers have first dibs on processing the event.
    for (var i = 0; i < this.Layers.length; ++i) {
      var layer = this.Layers[i];
      if (layer.HandleTouchStart && !layer.HandleTouchStart(event)) {
        return false;
      }
    }

    SA.TriggerStartInteraction();

    this.MomentumX = 0.0;
    this.MomentumY = 0.0;
    this.MomentumRoll = 0.0;
    this.MomentumScale = 0.0;
    if (this.MomentumTimerId) {
      window.cancelAnimationFrame(this.MomentumTimerId);
      this.MomentumTimerId = 0;
    }

    // Four finger grab resets the view.
    if (this.Touches.length >= 4) {
      var cam = this.GetCamera();
      var bds = this.MainView.Section.GetBounds();
      cam.SetWorldFocalPoint([(bds[0] + bds[1]) * 0.5, (bds[2] + bds[3]) * 0.5]);
      cam.SetWorldRoll(0.0);
      cam.SetHeight(bds[3] - bds[2]);
      cam.ComputeMatrix();
      this.EventuallyRender();
      // Return value hides navigation widget
      return true;
    }

    return false;
  };

  Viewer.prototype.HandleTouchMove = function (e) {
    // Case where sweep caused nextNote.
    // Short circuit interaction.
    if (this.StartTouchTime === 0) { return false; }

    // Put a throttle on events
    if (!this.HandleTouch(e, false)) { return; }

    /* the display global is no longer set.
    if (SA.display && SA.display.NavigationWidget &&
        SA.display.NavigationWidget.Visibility) {
      // No slide interaction with the interface up.
      // I had bad interaction with events going to browser.
      SA.display.NavigationWidget.ToggleVisibility();
    }

    if (typeof (SA.MOBILE_ANNOTATION_WIDGET) !== 'undefined' &&
            SA.MOBILE_ANNOTATION_WIDGET.Visibility) {
      // No slide interaction with the interface up.
      // I had bad interaction with events going to browser.
      SA.MOBILE_ANNOTATION_WIDGET.ToggleVisibility();
    }
    */

    // Let the annotation layers have first dibs on processing the event.
    for (var i = 0; i < this.Layers.length; ++i) {
      var layer = this.Layers[i];
      if (layer.HandleTouchMove && !layer.HandleTouchMove(event)) {
        return false;
      }
    }

    // detect sweep
    // Cross the screen in 1/2 second.
    var viewerWidth = this.MainView.Parent.width();
    var dxdt = 1000 * (this.MouseX - this.LastMouseX) / ((this.Time - this.LastTime) * viewerWidth);
    if (SA.display && SA.display.NavigationWidget) {
      if (dxdt > 4.0) {
        SA.display.NavigationWidget.PreviousNote();
        return false;
      }
      if (dxdt < -4.0) {
        SA.display.NavigationWidget.NextNote();
        return false;
      }
    }

    if (this.Touches.length === 1) {
      this.HandleTouchPan(this);
    } else if (this.Touches.length === 2) {
      this.HandleTouchPinch(this);
    } else if (this.Rotatable && this.Touches.length === 3) {
      this.HandleTouchRotate(this);
    }
  };

  // Only one touch
  Viewer.prototype.HandleTouchPan = function (event) {
    if (!this.InteractionEnabled) { return true; }
    if (this.Touches.length !== 1 || this.LastTouches.length !== 1) {
      // Sanity check.
      return;
    }

    // Let the annotation layers have first dibs on processing the event.
    // TODO Either forward primary or secondary events.
    for (var i = 0; i < this.Layers.length; ++i) {
      var layer = this.Layers[i];
      if (layer.HandleTouchPan && !layer.HandleTouchPan(event)) {
        return false;
      }
    }

    // I see an odd intermittent camera matrix problem
    // on the iPad that looks like a thread safety issue.
    if (this.MomentumTimerId) {
      window.cancelAnimationFrame(this.MomentumTimerId);
      this.MomentumTimerId = 0;
    }

    // Convert to world by inverting the camera matrix.
    // I could simplify and just process the vector.
    var w0 = this.ConvertPointViewerToWorld(this.LastMouseX, this.LastMouseY);
    var w1 = this.ConvertPointViewerToWorld(this.MouseX, this.MouseY);

    // This is the new focal point.
    var dx = w1[0] - w0[0];
    var dy = w1[1] - w0[1];
    var dt = event.Time - this.LastTime;

    // Remember the last motion to implement momentum.
    var momentumX = dx / dt;
    var momentumY = dy / dt;

    // Integrate momentum over a time period to avoid a fast event
    // dominating behavior.
    var k = Math.min(this.Time - this.LastTime, 250) / 250;
    this.MomentumX += (momentumX - this.MomentumX) * k;
    this.MomentumY += (momentumY - this.MomentumY) * k;
    this.MomentumRoll = 0.0;
    this.MomentumScale = 0.0;

    var cam = this.GetCamera();
    cam.Translate(-dx, -dy, 0);
    cam.ComputeMatrix();
    this.EventuallyRender(true);
  };

  Viewer.prototype.HandleTouchRotate = function (event) {
    if (!this.InteractionEnabled) { return true; }
    if (!this.Rotatable) { return true; }
    var numTouches = this.Touches.length;
    if (this.LastTouches.length !== numTouches || numTouches !== 3) {
      // Sanity check.
      return;
    }

    // I see an odd intermittent camera matrix problem
    // on the iPad that looks like a thread safety issue.
    if (this.MomentumTimerId) {
      window.cancelAnimationFrame(this.MomentumTimerId);
      this.MomentumTimerId = 0;
    }

    var w0 = this.ConvertPointViewerToWorld(this.LastMouseX, this.LastMouseY);
    var w1 = this.ConvertPointViewerToWorld(this.MouseX, this.MouseY);
    var dt = event.Time - this.LastTime;

    // Compute rotation.
    // Consider weighting rotation by vector length to avoid over contribution of short vectors.
    // We could also take the maximum.
    var x;
    var y;
    var a = 0;
    for (var i = 0; i < numTouches; ++i) {
      x = this.LastTouches[i][0] - this.LastMouseX;
      y = this.LastTouches[i][1] - this.LastMouseY;
      var a1 = Math.atan2(y, x);
      x = this.Touches[i][0] - this.MouseX;
      y = this.Touches[i][1] - this.MouseY;
      a1 = a1 - Math.atan2(y, x);
      if (a1 > Math.PI) { a1 = a1 - (2 * Math.PI); }
      if (a1 < -Math.PI) { a1 = a1 + (2 * Math.PI); }
      a += a1;
    }
    a = a / numTouches;

    // rotation and scale are around the mid point .....
    // we need to compute focal point height and roll (not just a matrix).
    // Focal point is the only difficult item.
    var cam = this.GetCamera();
    var fp = cam.GetWorldFocalPoint();
    w0[0] = fp[0] - w1[0];
    w0[1] = fp[1] - w1[1];
    var c = Math.cos(a);
    var s = Math.sin(a);
    // This is the new focal point.
    x = w1[0] + (w0[0] * c - w0[1] * s);
    y = w1[1] + (w0[0] * s + w0[1] * c);

    // Remember the last motion to implement momentum.
    var momentumRoll = a / dt;

    this.MomentumX = 0.0;
    this.MomentumY = 0.0;
    this.MomentumRoll = (this.MomentumRoll + momentumRoll) * 0.5;
    this.MomentumScale = 0.0;

    cam.SetWorldRoll(cam.GetWorldRoll() - a);
    cam.ComputeMatrix();
    if (this.OverView) {
      var cam2 = this.OverView.Camera;
      cam2.SetWorldRoll(cam.GetWorldRoll());
      cam2.ComputeMatrix();
    }
    this.EventuallyRender(true);
  };

  // I want pinch to be able to zoom and translate.
  Viewer.prototype.HandleTouchPinch = function (event) {
    if (!this.InteractionEnabled) { return true; }
    var numTouches = this.Touches.length;
    if (this.LastTouches.length !== numTouches || numTouches !== 2) {
      // Sanity check.
      return;
    }

    // I see an odd intermittent camera matrix problem
    // on the iPad that looks like a thread safety issue.
    if (this.MomentumTimerId) {
      window.cancelAnimationFrame(this.MomentumTimerId);
      this.MomentumTimerId = 0;
    }

    var w0 = this.ConvertPointViewerToWorld(this.LastMouseX, this.LastMouseY);
    var w1 = this.ConvertPointViewerToWorld(this.MouseX, this.MouseY);
    var dx = w1[0] - w0[0];
    var dy = w1[1] - w0[1];
    var dt = event.Time - this.LastTime;
    // iPad / iPhone must have low precision time
    if (dt === 0) {
      return;
    }

    // Compute scale.
    // Consider weighting rotation by vector length to avoid over contribution of short vectors.
    // We could also take max.
    // This should rarely be an issue and could only happen with 3 or more touches.
    var scale = 1;
    var s0 = 0;
    var s1 = 0;
    var x, y;
    for (var i = 0; i < numTouches; ++i) {
      x = this.LastTouches[i][0] - this.LastMouseX;
      y = this.LastTouches[i][1] - this.LastMouseY;
      s0 += Math.sqrt(x * x + y * y);
      x = this.Touches[i][0] - this.MouseX;
      y = this.Touches[i][1] - this.MouseY;
      s1 += Math.sqrt(x * x + y * y);
    }
    // This should not happen, but I am having trouble with NaN camera parameters.
    if (s0 < 2 || s1 < 2) {
      return;
    }
    scale = s1 / s0;

    // scale is around the mid point .....
    // we need to compute focal point height and roll (not just a matrix).
    // Focal point is the only difficult item.
    var cam = this.GetCamera();
    var fp = cam.GetWorldFocalPoint();
    w0[0] = fp[0] - w1[0] - dx;
    w0[1] = fp[1] - w1[1] - dy;
    // This is the new focal point.
    x = w1[0] + w0[0] / scale;
    y = w1[1] + w0[1] / scale;

    // Remember the last motion to implement momentum.
    var momentumScale = (scale - 1) / dt;

    this.MomentumX = dx / dt;
    this.MomentumY = dy / dt;
    this.MomentumRoll = 0.0;
    this.MomentumScale = (this.MomentumScale + momentumScale) * 0.5;

    cam.SetWorldFocalPoint([x, y]);
    cam.SetHeight(cam.GetHeight() / scale);
    //  cam.Translate(-dx, -dy, 0);
    cam.ComputeMatrix();
    this.EventuallyRender(true);
  };

  Viewer.prototype.HandleTouchEnd = function (event) {
    if (!this.InteractionEnabled) { return true; }

    var date = new Date();
    var dTime = date.getTime() - this.StartTouchTime;
    if (dTime < 200.0) { // 200 milliseconds
      // The mouse down sets the state to drag.
      // Change it back.  We are not going to drag, only a click.
      this.InteractionState = INTERACTION_NONE;
      return this.HandleMouseClick(event);
    }

    // Let the annotation layers have first dibs on processing the event.
    for (var i = 0; i < this.Layers.length; ++i) {
      var layer = this.Layers[i];
      if (layer.HandleTouchEnd && !layer.HandleTouchEnd(event)) {
        return false;
      }
    }

    // Code from a conflict
    var t = new Date().getTime();
    this.LastTime = this.Time;
    this.Time = t;

    var k = Math.min(this.Time - this.LastTime, 250) / 250;

    this.MomentumX = this.MomentumX * (1 - k);
    this.MomentumY = this.MomentumY * (1 - k);
    this.MomentumRoll = this.MomentumRoll * (1 - k);
    this.MomentumScale = this.MomentumScale * (1 - k);

    t = t - this.StartTouchTime;
    if (event.targetTouches.length === 0 && SAM.MOBILE_DEVICE) {
      this.StartTouchTime = 0;
      if (t < 90) {
        // We should not have a navigation widget on mobile
        // devices. (maybe iPad?).
        if (SA.display && SA.display.NavigationWidget) {
          SA.display.NavigationWidget.ToggleVisibility();
        }
        if (typeof (SA.MOBILE_ANNOTATION_WIDGET) !== 'undefined') {
          SA.MOBILE_ANNOTATION_WIDGET.ToggleVisibility();
        }
        return;
      }
      if (this.ActiveWidget !== undefined) {
        this.ActiveWidget.HandleTouchEnd(event);
        return;
      }
      // this.UpdateZoomGui();
      this.HandleMomentum();
    }
    // end conflict

    // this.UpdateZoomGui();
    this.HandleMomentum(event);

    // Use this as a flag to indicate ongoing interation (sweep, next
    // note .
    this.StartTouchTime = 0;
  };

  Viewer.prototype.HandleMomentum = function () {
    var self = this;
    // I see an odd intermittent camera matrix problem
    // on the iPad that looks like a thread safety issue.
    if (this.MomentumTimerId) {
      window.cancelAnimationFrame(this.MomentumTimerId);
      this.MomentumTimerId = 0;
    }

    var t = new Date().getTime();
    if (t - this.LastTime < 50) {
      this.MomentumTimerId = window.requestAnimationFrame(function () { self.HandleMomentum(); });
      return;
    }

    // Integrate the momentum.
    this.LastTime = this.Time;
    this.Time = t;
    var dt = this.Time - this.LastTime;

    var k = 200.0;
    var decay = Math.exp(-dt / k);
    var integ = (-k * decay + k);

    var cam = this.MainView.Camera;
    cam.Translate(-(this.MomentumX * integ), -(this.MomentumY * integ), 0);
    cam.SetHeight(cam.Height / ((this.MomentumScale * integ) + 1));
    cam.SetWorldRoll(cam.GetWorldRoll() - (this.MomentumRoll * integ));
    cam.ComputeMatrix();
    if (this.OverView) {
      var cam2 = this.OverView.Camera;
      cam2.SetWorldRoll(cam.GetWorldRoll());
      cam2.ComputeMatrix();
    }
    // I think the problem with the ipad is thie asynchronous render.
    // Maybe two renders occur at the same time.
    // this.EventuallyRender();
    this.Draw();

    // Decay the momentum.
    this.MomentumX *= decay;
    this.MomentumY *= decay;
    this.MomentumScale *= decay;
    this.MomentumRoll *= decay;

    if (Math.abs(this.MomentumX) < 0.01 && Math.abs(this.MomentumY) < 0.01 &&
            Math.abs(this.MomentumRoll) < 0.0002 && Math.abs(this.MomentumScale) < 0.00005) {
      // Change is small. Stop the motion.
      this.MomentumTimerId = 0;
      if (this.InteractionState !== INTERACTION_NONE) {
        this.InteractionState = INTERACTION_NONE;
        this.TriggerEndInteraction();
      }
    } else {
      this.MomentumTimerId = window.requestAnimationFrame(function () { self.HandleMomentum(); });
    }
  };

  Viewer.prototype.ConstrainCamera = function () {
    var bounds = this.GetOverViewBounds();
    if (!bounds) {
      // Cache has not been set.
      return;
    }
    var spacing = this.MainView.GetLeafSpacing();
    var viewport = this.MainView.GetViewport();
    var cam = this.MainView.Camera;

    var modified = false;
    var fp = cam.GetWorldFocalPoint();
    if (fp[0] < bounds[0]) {
      cam.SetWorldFocalPoint([bounds[0], fp[1]]);
      modified = true;
    }
    if (fp[0] > bounds[1]) {
      cam.SetWorldFocalPoint([bounds[1], fp[1]]);
      modified = true;
    }
    if (fp[1] < bounds[2]) {
      cam.SetWorldFocalPoint([fp[0], bounds[2]]);
      modified = true;
    }
    if (fp[1] > bounds[3]) {
      cam.SetWorldFocalPoint([fp[0], bounds[3]]);
      modified = true;
    }
    var heightMax = 2 * (bounds[3] - bounds[2]);
    if (cam.GetHeight() > heightMax) {
      cam.SetHeight(heightMax);
      // this.ZoomTarget = heightMax;
      modified = true;
    }
    var heightMin = viewport[3] * spacing * this.MinPixelSize;
    if (cam.GetHeight() < heightMin) {
      cam.SetHeight(heightMin);
      // this.ZoomTarget = heightMin;
      modified = true;
    }
    if (modified) {
      cam.ComputeMatrix();
    }
  };

  Viewer.prototype.HandleMouseClick = function (event) {
    if (!this.InteractionEnabled) { return true; }

    // Let the annotation layers have first dibs on processing the event.
    for (var i = 0; i < this.Layers.length; ++i) {
      var layer = this.Layers[i];
      if (layer.HandleMouseClick && !layer.HandleMouseClick(event)) {
        return false;
      }
    }
    return true;
  };

  Viewer.prototype.HandleMouseDown = function (event) {
    this.Shift = event.shiftKey;
    // Hack.  I am getting multiple mouse down and mouse up for a single click.
    // This will make sure we only respond to one.
    this.MouseDownFlag = true;
    if (!this.InteractionEnabled) { return true; }

    this.FirefoxWhich = event.which;
    event.preventDefault(); // Keep browser from selecting images.
    this.RecordMouseDown(event);

    if (this.RotateIconDrag) {
      // Problem with leaving the browser with mouse down.
      // This is a mouse down outside the icon, so the mouse must
      // have been let up and we did not get the event.
      this.RotateIconDrag = false;
    }

    if (this.DoubleClick) {
      // Without this, double click selects sub elementes.
      event.preventDefault();
      return this.HandleDoubleClick(event);
    }

    // Let the annotation layers have first dibs on processing the event.
    for (var i = 0; i < this.Layers.length; ++i) {
      var layer = this.Layers[i];
      if (layer.HandleMouseDown && !layer.HandleMouseDown(event)) {
        return false;
      }
    }

    // Choose what interaction will be performed.
    if (event.which === 1) {
      if (event.ctrlKey) {
        if (this.Rotatable) { this.InteractionState = INTERACTION_ROTATE; }
      } else if (event.altKey) {
        this.InteractionState = INTERACTION_ZOOM;
      } else {
        this.InteractionState = INTERACTION_DRAG;
      }
      return false;
    }
    if (event.which === 2 && this.Rotatble) {
      this.InteractionState = INTERACTION_ROTATE;
      return false;
    }
    return true;
  };

  Viewer.prototype.HandleDoubleClick = function (event) {
    if (!this.InteractionEnabled) { return true; }

    // Let the annotation layers have first dibs on processing the event.
    for (var i = 0; i < this.Layers.length; ++i) {
      var layer = this.Layers[i];
      if (layer.HandleDoubleClick && !layer.HandleDoubleClick(event)) {
        return false;
      }
    }

    var mWorld = this.ConvertPointViewerToWorld(event.offsetX, event.offsetY);
    if (event.which === 1) {
      this.AnimateZoomTo(0.5, mWorld);
    } else if (event.which === 3) {
      this.AnimateZoomTo(2.0, mWorld);
    }
    return true;
  };

  Viewer.prototype.HandleMouseUp = function (event) {
    // Hack.  I am getting multiple mouse down and mouse up for a single click.
    // This will make sure we only respond to one.
    if (!this.MouseDownFlag) {
      return;
    }
    this.MouseDownFlag = false;
    if (!this.InteractionEnabled) { return true; }
    var date = new Date();
    this.MouseUpTime = date.getTime();

    var dTime = date.getTime() - this.MouseDownTime;
    if (dTime < 200.0) { // 200 milliseconds
      // The mouse down sets the state to drag.
      // Change it back.  We are not going to drag, only a click.
      this.InteractionState = INTERACTION_NONE;
      return this.HandleMouseClick(event);
    }

    this.FirefoxWhich = 0;
    this.RecordMouseUp(event);

    if (this.RotateIconDrag) {
      this.RollUp(event);
      return false;
    }

    // Let the annotation layers have first dibs on processing the event.
    for (var i = 0; i < this.Layers.length; ++i) {
      var layer = this.Layers[i];
      if (layer.HandleMouseUp && !layer.HandleMouseUp(event)) {
        this.InteractionState = INTERACTION_NONE;
        return false;
      }
    }

    if (this.InteractionState === INTERACTION_OVERVIEW ||
        this.InteractionState === INTERACTION_OVERVIEW_DRAG) {
      return this.HandleOverViewMouseUp(event);
    }

    if (this.InteractionState !== INTERACTION_NONE) {
      this.InteractionState = INTERACTION_NONE;
      this.TriggerEndInteraction();
    }

    return false; // trying to keep the browser from selecting images
  };

  // I forget why this is necesary. Firefox, MS Edge?
  Viewer.prototype.GetEventOffset = function (event) {
    if (event.offsetX && event.offsetY) {
      return [event.offsetX, event.offsetY];
    } else if (event.layerX && event.layerY) {
      return [event.layerX, event.layerY];
    }
    return undefined;
  };

  // Relative to the div receiving the event. I do not know why this is so hard.
  // The event has postiion relative to the local child, or top window.
  // I might consider adding a class to divs that are 'transparent' to events.
  Viewer.prototype.GetMousePosition = function (event) {
    // Possibly a child.
    var pt = this.GetEventOffset(event);
    if (pt === undefined) {
      return undefined;
    }
    var element = event.target;
    if (element === this.Div[0]) {
      return pt;
    }

    // look one parent up.
    pt[0] += element.offsetLeft;
    pt[1] += element.offsetTop;
    element = element.parentElement;
    if (element === this.Div[0]) {
      return pt;
    }

    // one more.
    pt[0] += element.offsetLeft;
    pt[1] += element.offsetTop;
    element = element.parentElement;
    if (element === this.Div[0]) {
      return pt;
    }

    return undefined;
  };

  Viewer.prototype.HandleMouseMove = function (event) {
    if (!this.InteractionEnabled) { return true; }

    var pt = this.GetMousePosition(event);
    if (pt === undefined) {
      return true;
    }

    if (!this.RecordMouseMove(event)) { return true; }

    // I think we need to deal with the move here because the mouse can
    // exit the icon and the events are lost.
    if (event.which === 1 && this.Rotatable && this.RotateIconDrag) {
      this.RollMove(event);
      return false;
    }

    // Let the annotation layers have first dibs on processing the event.
    for (var i = 0; i < this.Layers.length; ++i) {
      var layer = this.Layers[i];
      if (layer.HandleMouseMove && !layer.HandleMouseMove(event)) {
        return false;
      }
    }

    // Arrow now tracks the mouse when first created (and no button pressed).
    // We no longer have any action for moving the mouse when no button is pressed.
    if (event.which === 0) {
      this.InteractionState = INTERACTION_NONE;
      return true;
    }

    if (this.InteractionState === INTERACTION_OVERVIEW ||
        this.InteractionState === INTERACTION_OVERVIEW_DRAG) {
      return this.HandleOverViewMouseMove(event);
    }

    if (this.InteractionState === INTERACTION_NONE) {
      // Allow the ResizePanel drag to process the events.
      return true;
    }

    var x = pt[0];
    var y = pt[1];
    var dx;
    var dy;

    // Drag camera in main view.
    // Dragging is too slow.  I want to accelerate dragging the further
    // this mouse moves.  This is a moderate change, so I am
    // going to try to accelerate with speed.
    if (this.InteractionState === INTERACTION_ROTATE) {
      // Rotate
      // Origin in the center.
      // GLOBAL GL will use view's viewport instead.
      var cx = x - (this.MainView.Viewport[2] * 0.5);
      var cy = y - (this.MainView.Viewport[3] * 0.5);
      // GLOBAL views will go away when views handle this.
      this.MainView.Camera.HandleRoll(cx, cy,
                                      this.MouseDeltaX,
                                      this.MouseDeltaY);
      this.RollTarget = this.MainView.Camera.GetWorldRoll();
      this.UpdateCamera();
    } else if (this.InteractionState === INTERACTION_ZOOM) {
      dy = this.MouseDeltaY / this.MainView.Viewport[2];
      this.MainView.Camera.SetHeight(this.MainView.Camera.GetHeight() /
                                           (1.0 + (dy * 5.0)));
      this.ZoomTarget = this.MainView.Camera.GetHeight();
      this.UpdateCamera();
    } else if (this.InteractionState === INTERACTION_DRAG) {
      // Translate
      // Convert to view [-0.5,0.5] coordinate system.
      // Note: the origin gets subtracted out in delta above.
      dx = -this.MouseDeltaX / this.MainView.Viewport[2];
      dy = -this.MouseDeltaY / this.MainView.Viewport[2];
      // compute the speed of the movement.
      var speed = Math.sqrt(dx * dx + dy * dy) / this.MouseDeltaTime;
      speed = 1.0 + speed * 1000; // f(0) = 1 and increasing.
      // I am not sure I like the speed acceleration.
            // Lets try a limit.
      if (speed > 3.0) { speed = 3.0; }
      dx = dx * speed;
      dy = dy * speed;
      this.MainView.Camera.HandleTranslate(dx, dy, 0.0);
      this.ConstrainCamera();
    }
    // The only interaction that does not go through animate camera.
    this.TriggerInteraction();
    this.EventuallyRender(true);

    x = event.offsetX;
    y = event.offsetY;

    return false;
  };

  Viewer.prototype.HandleMouseWheel = function (event) {
    if (!this.InteractionEnabled) { return true; }

    // Decay computations.
    this.MouseTime = (new Date()).getTime();
    if (this.LastMouseTime) {
      var dt = this.MouseTime - this.LastMouseTime;
      this.WheelSensitivity *= Math.exp(-dt / this.WheelTimeConstant);
      // console.log(dt);
    }
    this.LastMouseTime = this.MouseTime;
    this.WheelSensitivity += this.WheelAcceleration;
    if (this.WheelSensitivity > 0.2) {
      this.WheelSensitivity = 0.2;
    }

    // console.log(this.WheelSensitivity);

    if (!event.offsetX) {
      // for firefox
      event.offsetX = event.layerX;
      event.offsetY = event.layerY;
    }

    // Let the annotation layers have first dibs on processing the event.
    for (var i = 0; i < this.Layers.length; ++i) {
      var layer = this.Layers[i];
      if (layer.HandleMouseWheel && !layer.HandleMouseWheel(event)) {
        return false;
      }
    }

    // We want to accumulate the target, but not the duration.
    var tmp = 0;
    if (event.deltaY) {
      tmp = event.deltaY;
    } else if (event.wheelDelta) {
      tmp = event.wheelDelta;
    }
    // Wheel event seems to be in increments of 3.
    // depreciated mousewheel had increments of 120....
    // Initial delta cause another bug.
    // Lets restrict to one zoom step per event.
    if (tmp > 0) {
      this.ZoomTarget *= (1.0 + this.WheelSensitivity);
    } else if (tmp < 0) {
      this.ZoomTarget /= (1.0 + this.WheelSensitivity);
    }

    // Compute translate target to keep position in the same place.
    var position = this.ConvertPointViewerToWorld(event.offsetX, event.offsetY);
    var factor = this.ZoomTarget / this.MainView.Camera.GetHeight();
    var fp = this.MainView.Camera.GetWorldFocalPoint();
    this.TranslateTarget[0] = position[0] -
            factor * (position[0] - fp[0]);
    this.TranslateTarget[1] = position[1] -
            factor * (position[1] - fp[1]);

    this.RollTarget = this.MainView.Camera.GetWorldRoll();

    this.AnimateLast = new Date().getTime();
    this.AnimateDuration = 200.0; // hard code 200 milliseconds
    this.EventuallyRender(true);
    return false;
  };

  // returns false if the event was 'consumed' (browser convention).
  // Returns true if nothing was done with the event.
  Viewer.prototype.HandleKeyDown = function (event) {
    SAM.ShiftKey = event.shiftKey;
    SAM.ControlKey = event.ctrlKey;

    if (!this.InteractionEnabled) { return true; }

    // Key events are not going first to layers like mouse events.
    // Give layers a change to process them.
    for (var i = 0; i < this.Layers.length; ++i) {
      if (this.Layers[i].HandleKeyDown && !this.Layers[i].HandleKeyDown(event)) {
        return false;
      }
    }

    if (event.keyCode === 83 && event.ctrlKey) { // control -s to save.
      if (!SAVING_IMAGE) {
        SAVING_IMAGE = new SAM.Dialog();
        SAVING_IMAGE.Title.text('Saving');
        SAVING_IMAGE.Body.css({'margin': '1em 2em'});
        SAVING_IMAGE.WaitingImage = $('<img>')
                    .appendTo(SAVING_IMAGE.Body)
                    .attr('src', SA.ImagePathUrl + 'circular.gif')
                    .attr('alt', 'waiting...')
                    .addClass('sa-view-save');
        SAVING_IMAGE.ApplyButton.hide();
        SAVING_IMAGE.SavingFlag = false;
        SAVING_IMAGE.Count = 0;
      }
      if (!SAVING_IMAGE.SavingFlag) {
        SAVING_IMAGE.SavingFlag = true;
        SAVING_IMAGE.Show(1);
        this.EventuallySaveImage(
          'slideAtlas' + SA.ZERO_PAD(SAVING_IMAGE.Count, 3),
           function () {
             SAVING_IMAGE.SavingFlag = false;
             SAVING_IMAGE.Count += 1;
             SAVING_IMAGE.Hide();
           }
         );
      }

      return false;
    }

    // Handle paste
    if (event.keyCode === 79) {
      // o to print out world mouse location for debugging.
      // var wPt = this.ConvertPointViewerToWorld(this.LastMouseX, this.LastMouseY);
    }

    if (String.fromCharCode(event.keyCode) === 'R') {
      // this.MainView.Camera.Reset();
      this.MainView.Camera.ComputeMatrix();
      this.ZoomTarget = this.MainView.Camera.GetHeight();
      this.EventuallyRender(true);
      return false;
    }

    var cam, idx;
    var dx, dy, rx, ry;
    cam = this.GetCamera();
    var roll = cam.GetWorldRoll();
    var fp = cam.GetWorldFocalPoint();
    var c = Math.cos(roll);
    var s = -Math.sin(roll);
    if (event.keyCode === 38) {
      // Up cursor key
      if (event.ctrlKey) {
        // Rotate to the next 90 degree lock.
        idx = (this.MainView.Camera.GetWorldRoll() / (Math.PI * 0.5)) - 0.01;
        idx = Math.floor(idx);
        this.RollTarget = idx * Math.PI * 0.5;
      } else {
        dx = 0.0;
        dy = -0.5 * cam.GetHeight();
        rx = dx * c - dy * s;
        ry = dx * s + dy * c;
        this.TranslateTarget[0] = fp[0] + rx;
        this.TranslateTarget[1] = fp[1] + ry;
      }
      this.AnimateLast = new Date().getTime();
      this.AnimateDuration = 200.0;
      this.EventuallyRender(true);
      return false;
    } else if (event.keyCode === 40) {
      // Down cursor key
      if (event.ctrlKey) {
        // Rotate to the next 90 degree lock.
        idx = (this.MainView.Camera.GetWorldRoll() / (Math.PI * 0.5)) + 0.01;
        idx = Math.ceil(idx);
        this.RollTarget = idx * Math.PI * 0.5;
      } else {
        dx = 0.0;
        dy = 0.5 * cam.GetHeight();
        rx = dx * c - dy * s;
        ry = dx * s + dy * c;
      }
      this.TranslateTarget[0] = fp[0] + rx;
      this.TranslateTarget[1] = fp[1] + ry;
      this.AnimateLast = new Date().getTime();
      this.AnimateDuration = 200.0;
      this.EventuallyRender(true);
      return false;
    } else if (event.keyCode === 37) {
      // Left cursor key
      if (event.ctrlKey) {
        // Rotate by 90 degrees.
        this.RollTarget = this.MainView.Camera.GetWorldRoll() -
          Math.PI / 2.0;
      } else {
        dx = -0.5 * cam.GetWidth();
        dy = 0.0;
        rx = dx * c - dy * s;
        ry = dx * s + dy * c;
        this.TranslateTarget[0] = fp[0] + rx;
        this.TranslateTarget[1] = fp[1] + ry;
      }
      this.AnimateLast = new Date().getTime();
      this.AnimateDuration = 200.0;
      this.EventuallyRender(true);
      return false;
    } else if (event.keyCode === 39) {
      // Right cursor key
      if (event.ctrlKey) {
        // Rotate by 90 degrees.
        this.RollTarget = this.MainView.Camera.GetWorldRoll() +
          Math.PI / 2.0;
      } else {
        dx = 0.5 * cam.GetWidth();
        dy = 0.0;
        rx = dx * c - dy * s;
        ry = dx * s + dy * c;
        this.TranslateTarget[0] = fp[0] + rx;
        this.TranslateTarget[1] = fp[1] + ry;
      }
      this.AnimateLast = new Date().getTime();
      this.AnimateDuration = 200.0;
      this.EventuallyRender(true);
      return false;
    }

    if (event.keyCode === 27 && this.EscapeCallback) {
      this.EscapeCallback();
    }

    return true;
  };

  // returns false if the event was 'consumed' (browser convention).
  // Returns true if nothing was done with the event.
  Viewer.prototype.HandleKeyUp = function (event) {
    SAM.ShiftKey = event.shiftKey;
    SAM.ControlKey = event.ctrlKey;

    if (!this.InteractionEnabled) { return true; }

    // Let the annotation layers have first dibs on processing the event.
    var i;
    for (i = 0; i < this.Layers.length; ++i) {
      var layer = this.Layers[i];
      if (layer.HandleKeyUp && !layer.HandleKeyUp(event)) {
        return false;
      }
    }

    // Copy paste error?
    // Key events are not going first to layers like mouse events.
    // Give layers a change to process them.
    // for (i = 0; i < this.Layers.length; ++i) {
    //  if (this.Layers[i].HandleKeyUp && !this.Layers[i].HandleKeyUp(event)) {
    //    return false;
    //  }
    // }
    return true;
  };

  // Get the current scale factor between pixels and world units.
  Viewer.prototype.GetPixelsPerUnit = function () {
    return this.MainView.GetPixelsPerUnit();
  };

  Viewer.prototype.GetMetersPerUnit = function () {
    return this.MainView.GetMetersPerUnit();
  };

  // Covert a point from world coordiante system to viewer coordinate system (units pixels).
  Viewer.prototype.ConvertPointWorldToViewer = function (x, y) {
    var cam = this.MainView.Camera;
    return cam.ConvertPointWorldToViewer(x, y);
  };

  Viewer.prototype.ConvertPointViewerToWorld = function (x, y) {
    var cam = this.MainView.Camera;
    return cam.ConvertPointViewerToWorld(x, y);
  };

  // ==============================================================================
  // OverView slide widget stuff.

  Viewer.prototype.OverViewCheckActive = function (event) {
    if (!this.OverView) {
      return false;
    }
    var x = event.offsetX;
    var y = event.offsetY;
    // Half height and width
    var hw = this.OverViewport[2] / 2;
    var hh = this.OverViewport[3] / 2;
    // Center of the overview.
    var cx = this.OverViewport[0] + hw;
    var cy = this.OverViewport[1] + hh;

    x = x - cx;
    y = y - cy;
    // Rotate into overview slide coordinates.
    var roll = this.MainView.Camera.GetWorldRoll();
    var c = Math.cos(roll);
    var s = Math.sin(roll);
    var nx = Math.abs(c * x + s * y);
    var ny = Math.abs(c * y - s * x);
    if ((Math.abs(hw - nx) < 5 && ny < hh) ||
            (Math.abs(hh - ny) < 5 && nx < hw)) {
      this.OverViewActive = true;
      this.OverView.Parent.addClass('sa-view-overview-canvas sa-active');
    } else {
      this.OverViewActive = false;
      this.OverView.Parent.removeClass('sa-view-overview-canvas sa-active');
    }
    // return this.OverViewActive;
  };

  // Interaction events that change the main camera.

  // Resize of overview window will be drag with left mouse.
  // Reposition camera with left click (no drag).
  // Removing drag camera in overview.

  // TODO: Make the overview slide a widget.
  Viewer.prototype.HandleOverViewMouseDown = function (event) {
    if (!this.InteractionEnabled) { return true; }
    if (this.RotateIconDrag) { return; }

    this.InteractionState = INTERACTION_OVERVIEW;

    // Delay actions until we see if it is a drag or click.
    this.OverViewEventX = event.pageX;
    this.OverViewEventY = event.pageY;

    // Now that I do not drag the overview window tosize it,
    // This is simple.  TODO: Clean up modes and other leftover code.
    this.OverViewPlaceCamera(event);

    return false;
  };

  Viewer.prototype.HandleOverViewMouseUp = function (event) {
    if (!this.InteractionEnabled) { return true; }
    if (this.RotateIconDrag) { return; }

    // This target for animation is not implemented cleanly.
    // This fixes a bug: OverView translated rotates camamera back to zero.
    this.RollTarget = this.MainView.Camera.GetWorldRoll();

    this.OverViewPlaceCamera(event);

    this.InteractionState = INTERACTION_NONE;

    return false;
  };

  Viewer.prototype.OverViewPlaceCamera = function (event) {
    if (event.which === 1) {
      var x = event.offsetX;
      var y = event.offsetY;
      if (x === undefined) { x = event.layerX; }
      if (y === undefined) { y = event.layerY; }
      // Transform to view's coordinate system.
      this.OverViewPlaceCameraPt(x, y);
    }
  };

  Viewer.prototype.HandleOverViewMouseWheel = function (event) {
    // This is needed to keep resizing the overview if the events
    // move tothe viewer proper.
    // event.wheelDelta;
    // return false;

    this.InteractionState = INTERACTION_OVERVIEW_WHEEL;

    var tmp = 0;
    if (event.deltaY) {
      tmp = event.deltaY;
    } else if (event.wheelDelta) {
      tmp = event.wheelDelta;
    }

    if (tmp > 0) {
      this.OverViewScale *= 1.2;
    } else if (tmp < 0) {
      this.OverViewScale /= 1.2;
    }

    // overview scale is the fraction of the area of
    // the window covered by the overview window.
    var width = this.MainView.GetWidth();
    var height = this.MainView.GetHeight();
    var area = width * height;
    var bounds = this.GetOverViewBounds();
    var aspect = (bounds[1] - bounds[0]) / (bounds[3] - bounds[2]);
    // size of overview
    var h = Math.sqrt(area * this.OverViewScale / aspect);
    var w = h * aspect;

    if (w < 60) {
      this.RotateIcon.hide();
    } else {
      if (this.Rotatable) { this.RotateIcon.show(); }
    }

    this.UpdateSize();

    return false;
  };

  Viewer.prototype.HandleOverViewMouseMove = function (event) {
    if (!this.InteractionEnabled) { return true; }
    if (event.which === 1 && this.RotateIconDrag) {
      this.RollMove(event);
      return false;
    }

    this.OverViewPlaceCamera(event);

    return false;
  };

  Viewer.prototype.SetZoomWidgetVisibility = function (vis) {
    if (vis) {
      if (!this.ZoomTab) {
        this.InitializeZoomGui();
      }
      this.ZoomTab.show();
    } else {
      if (this.ZoomTab) {
        this.ZoomTab.hide();
      }
    }
  };

  Viewer.prototype.SetCopyrightVisibility = function (vis) {
    if (vis) {
      this.CopyrightWrapper.show();
    } else {
      this.CopyrightWrapper.hide();
    }
  };

  // ------------------------------------------------------
  // Access methods for vigilant

  Viewer.prototype.GetNumberOfLayers = function () {
    return this.Layers.length;
  };
  Viewer.prototype.GetLayer = function (idx) {
    if (idx >= 0 && idx < this.Layers.length) {
      return this.Layers[idx];
    }
    return null;
  };
  Viewer.prototype.RemoveLayer = function (layer) {
    var idx = this.Layers.indexOf(layer);
    if (idx < 0) {
      return;
    }
    this.Layers.splice(idx, 1);
  };

  // TODO:
  // Get rid of this.
  Viewer.prototype.NewAnnotationLayer = function () {
    // Create an annotation layer by default.
    var annotationLayer = new SAM.AnnotationLayer(this.Div);
    // Only for the text widget (dialog).
    // It needs to turn off events to make the text input work.
    annotationLayer.SetViewer(this);
    // Lets just shallow copy the camera.
    annotationLayer.SetCamera(this.GetCamera());

    this.AddLayer(annotationLayer);
    // TODO: Get rid of this.  master view is passed to draw.
    // Hack so the scale widget can get the spacing.
    annotationLayer.ScaleWidget.View = this.MainView;
    // Hack only used for girder testing.
    annotationLayer.Viewer = this;
    annotationLayer.UpdateSize();

    return annotationLayer;
  };

  Viewer.prototype.NewViewLayer = function () {
    // Create an annotation layer by default.
    var viewLayer = new SA.TileView(this.Div, false);
    this.AddLayer(viewLayer);
    viewLayer.UpdateSize();

    return viewLayer;
  };

  Viewer.prototype.TriggerEndInteraction = function () {
    this.UpdateZoomGui();

    // Save the state when the animation is finished.
    if (SA.RECORDER_WIDGET) {
      SA.RECORDER_WIDGET.RecordState();
    }

    // Update the url to the current view.
    var cam = this.GetCamera();
    var fp = cam.GetWorldFocalPoint();
    var width = Math.round(cam.GetWidth());
    var height = Math.round(cam.GetHeight());
    var left = Math.round(fp[0] - width / 2);
    var top = Math.round(fp[1] - height / 2);
    var rot = Math.round(cam.GetWorldRotation());

    // TODO: Fix this
    // Image._id is just a random id.
    // var imageId = this.GetCache().Image._id;
    // Hack to get th real id from a tile url.
    var url = this.GetCache().TileSource.getTileUrl(0, 0, 0, 0);
    var imageId = url.split('/')[3];

    url = window.location.href;
    var end = url.indexOf('item/');
    url = url.substr(0, end + 4);
    url = url + '/' + imageId + '?bounds=' + left + ',' + top +
      ',' + (left + width) + ',' + (top + height);

    if (rot !== 0) {
      url += '&rotate=' + rot;
    }

    this.ShareDisplay.text(url);
  };

  // ------------------------------------------------------

  SA.Viewer = Viewer;
})();

(function () {
  'use strict';

  // ==============================================================================
  // A correlation is just a pair of matching points from two sections.
  // Abstract the correlation so we have an api for getting points.
  // Currently, stack has direct access to correlation ivars / points.
  // The api will make forward and back transformations use the same code.

  function PairCorrelation () {
    this.point0 = [0, 0];
    this.point1 = [0, 0];
    this.Roll = 0;
    this.Height = 0;
  }

  PairCorrelation.prototype.Serialize = function () {
    return {'point0': [this.point0[0], this.point0[1]],
      'point1': [this.point1[0], this.point1[1]],
      'roll': this.Roll,
      'height': this.Height};
  };

  PairCorrelation.prototype.Load = function (obj) {
    this.point0[0] = obj.point0[0];
    this.point0[1] = obj.point0[1];
    this.point1[0] = obj.point1[0];
    this.point1[1] = obj.point1[1];
    if (obj.roll) {
      this.Roll = obj.roll;
    }
    if (obj.height) {
      this.Height = obj.height;
    }
  };

    // Idx changes the ordedr of the points and sign of delta roll.
  PairCorrelation.prototype.GetRoll = function (idx) {
    if (idx !== undefined && idx === 0) {
      return -this.Roll;
    } else {
      return this.Roll;
    }
  };

  PairCorrelation.prototype.GetPoint = function (idx) {
    if (idx === 0) {
      return this.GetPoint0();
    } else if (idx === 1) {
      return this.GetPoint1();
    }
    alert('Bad correlation point index: ' + idx);
    return [0, 0];
  };

  PairCorrelation.prototype.GetPoint0 = function () {
    return [this.point0[0], this.point0[1]];
  };

  PairCorrelation.prototype.SetPoint0 = function (pt) {
    this.point0[0] = pt[0];
    this.point0[1] = pt[1];
  };

  PairCorrelation.prototype.GetPoint1 = function () {
    return [this.point1[0], this.point1[1]];
  };

  PairCorrelation.prototype.SetPoint1 = function (pt) {
    this.point1[0] = pt[0];
    this.point1[1] = pt[1];
  };

  PairCorrelation.prototype.SetRoll = function (roll) {
    this.Roll = roll;
  };

  PairCorrelation.prototype.SetHeight = function (height) {
    this.Height = height;
  };

    // ==============================================================================
    // This object abstract the warp transformation between a pair of sections.

  function PairTransformation () {
    this.Correlations = [];
  }

  PairTransformation.prototype.Serialize = function () {
    return JSON.parse(JSON.stringify(this));
  };

  PairTransformation.prototype.Load = function (obj) {
    for (var ivar in obj) {
      this[ivar] = obj[ivar];
    }
  };

  PairTransformation.prototype.AddCorrelation = function (pt0, pt1) {
    var index = this.Correlations.length;
    var corr = new SA.PairCorrelation();
    corr.SetPoint0(pt0);
    corr.SetPoint1(pt1);
    this.Correlations.push(corr);
    return index;
  };

  PairTransformation.prototype.Load = function (obj) {
        // Views are not used anymore for viewer record stacks.
    if (obj.View0) {
      this.View0 = obj.View0;
    }
    if (obj.View1) {
      this.View1 = obj.View1;
    }
    for (var i = 0; i < obj.Correlations.length; ++i) {
      var correlation = new SA.PairCorrelation();
      correlation.Load(obj.Correlations[i]);
      this.Correlations.push(correlation);
    }
  };

    // Weighted neighbor.
    // Until we implement a closed form solution:
    // Compute the weighted average of points as center of rotation and translation.
  PairTransformation.prototype.WeightedTransform = function (idx0, idx1, fpIn, sigma) {
    var fpOut = [fpIn[0], fpIn[1]];
    if (this.Correlations.length === 0) {
      return fpOut;
    }

    if (sigma === undefined) {
      sigma = 20000;
    }

    if (this.Correlations.length === 0) {
      fpOut[0] = fpIn[0];
      fpOut[1] = fpIn[1];
      this.DeltaRoll = 0;
      return fpOut;
    }

    var correlation;
    var c;
    var s;
    var pt0, pt1;
    if (this.Correlations.length <= 1) {
      correlation = this.Correlations[0];
      this.DeltaRoll = correlation.GetRoll(idx1);
      pt0 = correlation.GetPoint(idx0);
      var dx = fpIn[0] - pt0[0];
      var dy = fpIn[1] - pt0[1];
      c = Math.cos(this.DeltaRoll);
      s = Math.sin(this.DeltaRoll);
      pt1 = correlation.GetPoint(idx1);
      fpOut[0] = c * dx + s * dy + pt1[0];
      fpOut[1] = c * dy - s * dx + pt1[1];
      return fpOut;
    }

    // Compute the average weighted correlation point for each image.
    var x, y;
    var sigma2 = sigma * sigma;
    var sumGauss = 0.0;
    var sum0 = [0.0, 0.0];
    var sum1 = [0.0, 0.0];
    var gauss;
    for (var i = 0; i < this.Correlations.length; ++i) {
      correlation = this.Correlations[i];
      pt0 = correlation.GetPoint(idx0);
      pt1 = correlation.GetPoint(idx1);
            // Distance from the focal point being transformed (for weight)
      x = pt0[0] - fpIn[0];
      y = pt0[1] - fpIn[1];
      var dist2 = x * x + y * y;
            // Compute the gaussian (minimum for numerical stability)
      gauss = Math.max(Math.exp(-dist2 / sigma2), 0.0000001);

      sumGauss += gauss;
      sum0[0] += gauss * pt0[0];
      sum0[1] += gauss * pt0[1];
      sum1[0] += gauss * pt1[0];
      sum1[1] += gauss * pt1[1];
    }
    sum0[0] = sum0[0] / sumGauss;
    sum0[1] = sum0[1] / sumGauss;
    sum1[0] = sum1[0] / sumGauss;
    sum1[1] = sum1[1] / sumGauss;

    // Now compute orientation.
    this.DeltaRoll = 0;

    // For now lets ignore the roll in the correlation
    // and compute roll from multiple points.

    // Compute rotation
    var roll = 0;
    sumGauss = 0.0;
    var sumTheta = 0.0;
    for (i = 0; i < this.Correlations.length; ++i) {
      correlation = this.Correlations[i];
      pt0 = correlation.GetPoint(idx0);
      pt1 = correlation.GetPoint(idx1);
            // Distance from the focal point (for weight).
      x = pt0[0] - fpIn[0];
      y = pt0[1] - fpIn[1];
      var dist = x * x + y * y;
      gauss = Math.max(Math.exp(-dist / sigma2), 0.0000001);
            // Compute the two angles using the average centers.
            // angle 0:
      x = pt0[0] - sum0[0];
      y = pt0[1] - sum0[1];
      var angle0 = Math.atan2(x, y);
            // Compute distance for small angle consideration.
      var dist0 = x * x + y * y;
            // Angle 1:
      x = pt1[0] - sum1[0];
      y = pt1[1] - sum1[1];
      var angle1 = Math.atan2(x, y);
            // Compute distance for small angle consideration.
      var dist1 = x * x + y * y;

            // Now combine weights.
      gauss = gauss * Math.sqrt(Math.min(dist0, dist1));

            // Averaging angles is tricky because of cycles.
            // Assume all angles are small.
      var dAngle = (angle1 - angle0);
      var twoPi = Math.PI * 2;
      while (dAngle > Math.PI) { dAngle -= twoPi; }
      while (dAngle < -Math.PI) { dAngle += twoPi; }

      sumTheta += dAngle * gauss;
      sumGauss += gauss;
    }
    if (sumGauss > 0) {
      roll = (sumTheta / sumGauss);
    }
        // Silly converting this to degrees, but set camera takes degrees.
        // This is the second return value.
    this.DeltaRoll = (sumTheta / sumGauss);

        // Since focal points are not at center of rotation (sum0 and sum1).
        // We need to translate center to origin, rotate, then translate back.
    fpOut[0] -= sum0[0];
    fpOut[1] -= sum0[1];
    c = Math.cos(roll);
    s = Math.sin(roll);
        // Left handed pixel coordinate system messes the rotation.
    x = c * fpOut[0] + s * fpOut[1];
    y = c * fpOut[1] - s * fpOut[0];

    fpOut[0] = x + sum1[0];
    fpOut[1] = y + sum1[1];

    return fpOut;
  };

    // Nearest neighbor.
  PairTransformation.prototype.ForwardTransform = function (pt0, sigma) {
    this.DeltaRoll = 0;
    if (this.Correlations.length === 0) {
      return pt0;
    }

    return this.WeightedTransform(0, 1, pt0, sigma);
  };

    // Nearest neighbor.
  PairTransformation.prototype.ReverseTransform = function (pt1, sigma) {
    this.DeltaRoll = 0;
    if (this.Correlations.length === 0) {
      return pt1;
    }

    return this.WeightedTransform(1, 0, pt1, sigma);
  };

  PairTransformation.prototype.ForwardTransformCamera = function (camIn, camOut) {
    camOut.SetWorldFocalPoint(this.ForwardTransform(camIn.GetWorldFocalPoint(),
                                                    camIn.Height / 2));
    camOut.SetWorldRoll(camIn.GetWorldRoll() + this.DeltaRoll);
    camOut.SetHeight(camIn.GetHeight());
    // This should be computed from the viewport
    // camOut.Width = camIn.Width;
    camOut.SetWidth(camOut.GetHeight() * camOut.GetViewportWidth() / camOut.GetViewportHeight());
  };

  // TODO: Fix this (image camera coordinate system) or get rid of pairTransform
  PairTransformation.prototype.ReverseTransformCamera = function (camIn, camOut) {
    camOut.FocalPoint = this.ReverseTransform(camIn.FocalPoint, camIn.Height / 2);
    camOut.Roll = camIn.Roll + this.DeltaRoll;
    camOut.Height = camIn.Height;
    // TODO: Camera should do this internally.
    camOut.SetWidth(camOut.GetHeight() * camOut.GetViewportWidth() / camOut.GetViewportHeight());
  };

  SA.PairCorrelation = PairCorrelation;
  SA.PairTransformation = PairTransformation;
})();

// ==============================================================================
// Initially a contour found for each section in a stack.
// Each section gets on of these StackSectionWidgets.  I am extending this
// to include multiple contours fo sections that have multiple pieces,
// and internal contours / features.  Internal edges may not be closed
// loops.
// Initially, these widgets will have no interaction, so they might
// be better as shapes, but we will see.

// Eventually I will put a transformation in here.
// Also, I would like this to have its own instance variable in
// the viewerRecord.

(function () {
    // Depends on the CIRCLE widget
  'use strict';

  function StackSectionWidget (viewer) {
    this.Thumb = null; // default click. in stack creator.

    // Active is just to turn the section yellow temporarily.
    this.Active = false;
    this.Color = [0, 1, 0];
    this.Shapes = [];

    this.Bounds = null;
    if (viewer) {
      this.Viewer = viewer;
      this.Viewer.AddWidget(this);
    }
  }

  StackSectionWidget.prototype.IsEmpty = function () {
    return this.Shapes.length === 0;
  };

  // Add all the lines in the in section to this section.
  StackSectionWidget.prototype.Union = function (section) {
    for (var i = 0; i < section.Shapes.length; ++i) {
      this.Shapes.push(section.Shapes[i]);
    }
    this.Bounds = null;
  };

  // Bounds are in slide / world coordinates.
  // Returns 0 if is does not overlap at all.
  // Returns 1 if part of the section is in the bounds.
  // Returns 2 if all of the section is in the bounds.
  StackSectionWidget.prototype.ContainedInBounds = function (bds) {
    var sBds = this.GetBounds();
    if (sBds[0] > bds[0] && sBds[1] < bds[1] &&
            sBds[2] > bds[2] && sBds[3] < bds[3]) {
      // section is fully contained in the bounds.
      return 2;
    }
    if (sBds[1] < bds[0] || sBds[0] > bds[1] ||
            sBds[3] < bds[2] || sBds[2] > bds[3]) {
      // No overlap of bounds.
      return 0;
    }

    // Bounds partially overlap.  Look closer.
    var pointsIn = false;
    var pointsOut = false;
    for (var i = 0; i < this.Shapes.length; ++i) {
      var contained = this.Shapes[i].ContainedInBounds(bds);
      if (contained === 1) {
        return 1;
      }
      if (contained === 0) {
        pointsOut = true;
      }
      if (contained === 2) {
        pointsIn = true;
      }
      if (pointsIn && pointsOut) {
        return 1;
      }
    }

    if (pointsIn) {
      return 2;
    }
    return 0;
  };

    // Returns the center of the bounds in view coordinates.
  StackSectionWidget.prototype.GetViewCenter = function (view) {
    var bds = this.GetBounds();
    return view.Camera.ConvertPointWorldToViewer((bds[0] + bds[1]) * 0.5,
                                                     (bds[2] + bds[3]) * 0.5);
  };

  // We need bounds in view coordinates for sorting.
  // Do not bother caching the value.
  StackSectionWidget.prototype.GetViewBounds = function (view) {
    if (this.Shapes.length === 0) {
      return [0, 0, 0, 0];
    }
    var c = this.GetViewCenter(view);
    var bds = [c[0], c[0], c[1], c[1]];
    for (var i = 0; i < this.Shapes.length; ++i) {
      var shape = this.Shapes[i];
      for (var j = 0; j < shape.Points.length; ++j) {
        var pt = shape.Points[j];
        pt = view.Camera.ConvertPointWorldToViewer(pt[0], pt[1]);
        if (pt[0] < bds[0]) { bds[0] = pt[0]; }
        if (pt[0] > bds[1]) { bds[1] = pt[0]; }
        if (pt[1] < bds[2]) { bds[2] = pt[1]; }
        if (pt[1] > bds[3]) { bds[3] = pt[1]; }
      }
    }
    return bds;
  };

  StackSectionWidget.prototype.ComputeViewUpperRight = function (view) {
    // Compute the upper right corner in view coordinates.
    // This is used by the SectionsWidget holds this section.
    var bds = this.GetBounds();
    var p0 = view.Camera.ConvertPointWorldToViewer(bds[0], bds[2]);
    var p1 = view.Camera.ConvertPointWorldToViewer(bds[0], bds[3]);
    var p2 = view.Camera.ConvertPointWorldToViewer(bds[1], bds[3]);
    var p3 = view.Camera.ConvertPointWorldToViewer(bds[1], bds[2]);
        // Pick the furthest upper right corner.
    this.ViewUpperRight = p0;
    var best = p0[0] - p0[1];
    var tmp = p1[0] - p1[1];
    if (tmp > best) {
      best = tmp;
      this.ViewUpperRight = p1;
    }
    tmp = p2[0] - p2[1];
    if (tmp > best) {
      best = tmp;
      this.ViewUpperRight = p2;
    }
    tmp = p3[0] - p3[1];
    if (tmp > best) {
      best = tmp;
      this.ViewUpperRight = p3;
    }
  };

  StackSectionWidget.prototype.Draw = function (view) {
    this.ComputeViewUpperRight(view);
    for (var i = 0; i < this.Shapes.length; ++i) {
      if (this.Active) {
        this.Shapes[i].OutlineColor = [1, 1, 0];
      } else {
        this.Shapes[i].OutlineColor = this.Color;
      }
      this.Shapes[i].Draw(view);
    }
  };

  StackSectionWidget.prototype.Serialize = function () {
        // Backing away from 'every section has a contour'.
    if (this.Thumb) {
      return null;
    }
    var obj = {};
    obj.type = 'stack_section';
    obj.color = this.Color;
    obj.shapes = [];
    for (var i = 0; i < this.Shapes.length; ++i) {
      var shape = this.Shapes[i];
            // Is is a pain that polyline does not serialize.
      var polyLineObj = {
        closedloop: shape.Closed,
        points: []};
      for (var j = 0; j < shape.Points.length; ++j) {
        polyLineObj.points.push([shape.Points[j][0], shape.Points[j][1]]);
      }
      obj.shapes.push(polyLineObj);
    }
    return obj;
  };

    // Load a widget from a json object (origin MongoDB).
  StackSectionWidget.prototype.Load = function (obj) {
    if (obj.color) {
      this.Color[0] = parseFloat(obj.color[0]);
      this.Color[1] = parseFloat(obj.color[1]);
      this.Color[2] = parseFloat(obj.color[2]);
    }
    if (!obj.shapes) {
      return;
    }
    for (var n = 0; n < obj.shapes.length; n++) {
      var polylineObj = obj.shapes[n];
      if (polylineObj.points) {
        var points = polylineObj.points;
        var shape = new SAM.Polyline();
        shape.OutlineColor = this.Color;
        shape.FixedSize = false;
        shape.LineWidth = 0;
        if (polylineObj.closedloop) {
          shape.Closed = polylineObj.closedloop;
        }
        this.Shapes.push(shape);
        for (var m = 0; m < points.length; ++m) {
          shape.Points[m] = [points[m][0], points[m][1]];
        }
                // NewStack page uses this and does not have a "layer".
                // Annotations do not need webgl anyway.
                // TODO:Remove this uncessary argument altogether.
                // shape.UpdateBuffers(this.Layer.AnnotationView);
        shape.UpdateBuffers();
      }
    }
  };

    // We could recompute the bounds from the
  StackSectionWidget.prototype.GetCenter = function () {
    var bds = this.GetBounds();
    return [(bds[0] + bds[1]) * 0.5, (bds[2] + bds[3]) * 0.5];
  };

    // We could recompute the bounds from the
  StackSectionWidget.prototype.GetBounds = function () {
        // Special case for simple thumb selection.
    if (this.Thumb) {
      var rad = this.Thumb.Height * this.Thumb.ScreenPixelSpacing / 4.0;
      var cx = this.ThumbX;
      var cy = this.ThumbY;
      return [cx - rad, cx + rad, cy - rad, cy + rad];
    }

    if (this.Shapes.length === 0) {
      return this.Bounds;
    }
    if (!this.Bounds) {
      this.Bounds = this.Shapes[0].GetBounds();
      for (var i = 1; i < this.Shapes.length; ++i) {
        var bds = this.Shapes[i].GetBounds();
        if (bds[0] < this.Bounds[0]) {
          this.Bounds[0] = bds[0];
        }
        if (bds[1] > this.Bounds[1]) {
          this.Bounds[1] = bds[1];
        }
        if (bds[2] < this.Bounds[2]) {
          this.Bounds[2] = bds[2];
        }
        if (bds[3] > this.Bounds[3]) {
          this.Bounds[3] = bds[3];
        }
      }
    }
    return this.Bounds.slice(0);
  };

  StackSectionWidget.prototype.Deactivate = function () {
    this.Viewer.DeactivateWidget(this);
    for (var i = 0; i < this.Shapes.length; ++i) {
      this.Shapes[i].Active = false;
    }
    this.Viewer.EventuallyRender();
  };

  StackSectionWidget.prototype.HandleKeyPress = function (keyCode, shift) {
    return true;
  };

  StackSectionWidget.prototype.HandleMouseDown = function (event) {
    return true;
  };

  StackSectionWidget.prototype.HandleMouseUp = function (event) {
    return true;
  };

  StackSectionWidget.prototype.HandleDoubleClick = function (event) {
    return true;
  };

  StackSectionWidget.prototype.HandleMouseMove = function (event) {
    return true;
  };

  StackSectionWidget.prototype.CheckActive = function (event) {
    return false;
  };

  StackSectionWidget.prototype.GetActive = function () {
    return false;
  };

    // Setting to active always puts state into "active".
    // It can move to other states and stay active.
  StackSectionWidget.prototype.SetActive = function (flag) {
    if (flag) {
      this.Viewer.ActivateWidget(this);
      for (var i = 0; i < this.Shapes.length; ++i) {
        this.Shapes[i].Active = true;
      }

      this.Viewer.EventuallyRender();
    } else {
      this.Deactivate();
      this.Viewer.DeactivateWidget(this);
    }
  };

  StackSectionWidget.prototype.RemoveFromViewer = function () {
    if (this.Viewer) {
      this.Viewer.RemoveWidget(this);
    }
  };

    // ==============================================================================
    // These features might better belong in a separate object of edges.

    // Modifies this section's points to match argument section
    // Also returns the translation and rotation.
  StackSectionWidget.prototype.RigidAlign = function (section, trans) {
    var center1 = this.GetCenter();
    var center2 = section.GetCenter();
        // Translate so that the centers are the same.
        // this.Translate([(center2[0]-center1[0]),
        //                (center2[1]-center2[1])]);

        // Lets use a transformation instead.  It will be easier for the stack
        // editor.
    trans[0] = (center2[0] - center1[0]);
    trans[1] = (center2[1] - center1[1]);

    if (this.Thumb || section.Thumb) {
      trans[2] = 0;
      return;
    }

        // Get the bounds of both contours.
    var bds1 = this.GetBounds();
    bds1[0] += trans[0]; bds1[1] += trans[0];
    bds1[2] += trans[1]; bds1[3] += trans[1];
    var bds2 = section.GetBounds();

        // Combine them (union).
    bds2[0] = Math.min(bds1[0], bds2[0]);
    bds2[1] = Math.max(bds1[1], bds2[1]);
    bds2[2] = Math.min(bds1[2], bds2[2]);
    bds2[3] = Math.max(bds1[3], bds2[3]);
    // Expand the contour by 10%
    var xMid = (bds2[0] + bds2[1]) * 0.5;
    var yMid = (bds2[2] + bds2[3]) * 0.5;
    bds2[0] = xMid + 1.1 * (bds1[0] - xMid);
    bds2[1] = xMid + 1.1 * (bds1[1] - xMid);
    bds2[2] = yMid + 1.1 * (bds1[2] - yMid);
    bds2[3] = yMid + 1.1 * (bds1[3] - yMid);

    // choose a spacing.
    // about 160,000 kPixels (400x400);
    var spacing = Math.sqrt((bds2[1] - bds2[0]) * (bds2[3] - bds2[2]) / 160000);
    // Note. gradient decent messes up with spacing too small.

    var distMap = new SA.DistanceMap(bds2, spacing);
    for (var i = 0; i < section.Shapes.length; ++i) {
      // ignore origin.
      distMap.AddPolyline(section.Shapes[i]);
    }
    distMap.Update();

    this.ViewerEventuallyRender();
    // Coordinate system has changed.
    this.RigidAlignWithMap(distMap, trans);
  };

  // Perform gradient descent on the transform....
  // Do not apply to the points.
  // trans is the starting position as well as the return value.
  StackSectionWidget.prototype.RigidAlignWithMap = function (distMap, trans) {
    // Compute center of rotation
    var center = this.GetCenter();

    // shiftX, shiftY, roll
    var tmpTrans = [0, 0, 0];

    // Try several rotations to see which is the best.
    var bestTrans = null;
    var bestDist = -1;
    var i;
    for (var a = -180; a < 180; a += 30) {
      tmpTrans = [trans[0], trans[1], Math.PI * a / 180];
      var dist;
      for (i = 0; i < 5; ++i) {
        dist = this.RigidDecentStep(tmpTrans, center, distMap, 200000);
      }
      // For symmetrical cases, give no rotation a slight advantage.
      dist = dist * (1.0 + Math.abs(a / 180));
      if (bestDist < 0 || dist < bestDist) {
        bestDist = dist;
        bestTrans = tmpTrans.slice(0);
      }
    }

    // Now the real gradient decent.
    tmpTrans = bestTrans;
    // Slowing discount outliers.
    var aveDist = 200000;
    for (i = 0; i < 100; ++i) {
      aveDist = this.RigidDecentStep(tmpTrans, center, distMap, aveDist);
    }
    // caller can do this if they want.
    // this.Transform([trans[0],trans[1]], center, trans[2]);
    // Just return the transformation parameters.
    // The center is als part of the transform, but it can be gotten with GetCenter.
    trans[0] = tmpTrans[0];
    trans[1] = tmpTrans[1];
    trans[2] = tmpTrans[2];
  };

  // Returns the average distance as the error.
  // trans is the starting transform (dx,dy, dRoll). This state is modified
  // by this method.
  // Center: center of rotation.
  // distMap is the array of distances.
  // Threshold sets large distances to a constant. It should be reduced to
  // minimize the contribution of outliers. Thresh is in units of map pixels.
  StackSectionWidget.prototype.RigidDecentStep = function (trans, center,
                                                             distMap, thresh) {
    var vx, vy, rx, ry;
    var s = Math.sin(trans[2]);
    var c = Math.cos(trans[2]);
    var sumx = 0;
    var sumy = 0;
    var totalDist = 0;
    var sumr = 0;
    var numContributingPoints = 0;
    for (var j = 0; j < this.Shapes.length; ++j) {
      var shape = this.Shapes[j];
      // var debugScalars = new Array(shape.Points.length);
      // shape.DebugScalars = debugScalars;
      for (var k = 0; k < shape.Points.length; ++k) {
        var pt = shape.Points[k];
        var x = pt[0];
        var y = pt[1];

        // transform the point.
        vx = (x - center[0]);
        vy = (y - center[1]);
        rx = c * vx + s * vy;
        ry = -s * vx + c * vy;
        x = x + (rx - vx) + trans[0];
        y = y + (ry - vy) + trans[1];

        // Get the distance for this point.
        var dist = distMap.GetDistance(x, y) * distMap.Spacing;
        totalDist += dist;
        // Use threshold to minimize effect of outliers.
        // debugScalars[k] = (thresh)/(thresh + dist);
        // dist = (thresh*dist)/(thresh + dist);

        // debugScalars[k] = (dist < thresh) ? 1:0;
        // if (dist > thresh) {dist = 0;}
        // debugScalars[k] = Math.exp(-0.69*(dist*dist)/(thresh*thresh));
        var gs = 1;
        if (thresh > 0) { gs = Math.exp(-0.69 * (dist * dist) / (thresh * thresh)); }
        dist = dist * gs;

        // Scale the negative gradient by thresholded distance.
        var grad = distMap.GetGradient(x, y);
        var mag = Math.sqrt(grad[0] * grad[0] + grad[1] * grad[1]);

        if (mag > 0) {
          ++numContributingPoints;

          // Keep a total for translation
          grad[0] = -grad[0] * dist / mag;
          grad[1] = -grad[1] * dist / mag;
          sumx += grad[0];
          sumy += grad[1];

          // For rotation
          var cross = ry * grad[0] - rx * grad[1];
          sumr += cross / (rx * rx + ry * ry);
        } else {
          // skip
        }
      }
    }

    var aveDist = totalDist / numContributingPoints;
        // Trying to be intelligent about the step size
    trans[0] += sumx / numContributingPoints;
    trans[1] += sumy / numContributingPoints;
    trans[2] += sumr / numContributingPoints;

        // for debugging (the rest is in shape.js
        // t = {cx: center[0], cy: center[1],
        //     c: Math.cos(trans[2]), s: Math.sin(trans[2]),
        //     sx: trans[0], sy: trans[1]};
        // for (var i = 0; i < this.Shapes.length; ++i) {
        //    this.Shapes[i].Trans = t;
        // }
        // VIEWER1.Draw();

    return aveDist;
  };

  StackSectionWidget.prototype.Transform = function (shift, center, roll) {
    this.Bounds = null;
    for (var i = 0; i < this.Shapes.length; ++i) {
      var shape = this.Shapes[i];
      shape.Trans = null;
      for (var j = 0; j < shape.Points.length; ++j) {
        var pt = shape.Points[j];
        var x = pt[0];
        var y = pt[1];
        var vx = x - center[0];
        var vy = y - center[1];
        var s = Math.sin(roll);
        var c = Math.cos(roll);
        var rx = c * vx + s * vy;
        var ry = -s * vx + c * vy;
        pt[0] = x + (rx - vx) + shift[0];
        pt[1] = y + (ry - vy) + shift[1];
      }
      shape.UpdateBuffers(this.Layer.AnnotationView);
    }
  };

    // shift is [x,y]
  StackSectionWidget.prototype.Translate = function (shift) {
    this.Bounds = null;
    for (var i = 0; i < this.Shapes.length; ++i) {
      var shape = this.Shapes[i];
      for (var j = 0; j < shape.Points.length; ++j) {
        var pt = shape.Points[j];
        pt[0] += shift[0];
        pt[1] += shift[1];
      }
      shape.UpdateBuffers(this.Layer.AnnotationView);
    }
  };

    // I could also implement a resample to get uniform spacing.
  StackSectionWidget.prototype.RemoveDuplicatePoints = function (epsilon) {
    if (epsilon === undefined) {
      epsilon = 0;
    }
    for (var i = 0; i < this.Shapes.length; ++i) {
      var shape = this.Shapes[i];
      var p0 = shape.Points[shape.Points.length - 1];
      var idx = 0;
      while (idx < shape.Points.length) {
        var p1 = shape.Points[idx];
        var dx = p1[0] - p0[0];
        var dy = p1[1] - p0[1];
        if (Math.sqrt(dx * dx + dy * dy) <= epsilon) {
          shape.Points.splice(idx, 1);
        } else {
          ++idx;
          p0 = p1;
        }
      }
      shape.UpdateBuffers(this.Layer.AnnotationView);
    }
  };

  StackSectionWidget.prototype.Decimate = function () {
    var bds = this.GetBounds();
    var spacing = (bds[1] - bds[0] + bds[3] - bds[2]) / 400;
    for (var i = 0; i < this.Shapes.length; ++i) {
      this.Shapes[i].Decimate(spacing);
    }
  };

  SA.StackSectionWidget = StackSectionWidget;
})();

// ==============================================================================
// A gui for that controls layers in multiple viewers.

(function () {
  'use strict';

  function LayerView (parent, label) {
    this.Layers = [];
    this.Label = label;
    this.Color = [Math.random(), Math.random(), Math.random()];

    this.Initialize(parent, label);
    this.SetSizeScale(1.0);

    this.Changeflag = false;
  }

  LayerView.prototype.AddLayer = function (layer) {
    var self = this;
    // For the stack viewer.  The layer gets loaded with another view,
    // We hve to apply the color and threshold.
    layer.LoadCallbacks.push(function () {
      self.UpdateLayer(layer);
    });

    this.Layers.push(layer);
    if (this.VisibilityCheckBox && this.Slider) {
      this.UpdateLayer(layer);
    }
  };

  // Initialize the gui / dom
  LayerView.prototype.Initialize = function (parent, label) {
    var self = this;

    // The wrapper div that controls a single layer.
    var layerControl = $('<div>')
      .appendTo(parent)
      .css({'border': '1px solid #CCC', 'width': '100%'});

    var leftWrapper = $('<div>')
      .appendTo(layerControl)
      .css({
        'width': '80%',
        'border-right': '1px solid #CCC',
        'height': '100%',
        'display': 'inline-block'});
    // the sub-div that holds the direct toggle and the label.
    var toggleWrapper = $('<div>')
      .appendTo(leftWrapper)
      .css({
        'border-bottom': '1px solid #CCC',
        'width': '100%',
        'float': 'top' });

    this.VisibilityCheckBox = $('<input type="checkbox">')
      .appendTo(toggleWrapper)
      .css({'display': 'inline-block'})
      .on('change',
          function () {
            self.VisibilityCheckCallback();
          })
      .prop('checked', true);

    $('<div>')
      .appendTo(toggleWrapper)
      .css({
        'display': 'inline-block',
        'margin-left': '1em'})
      .html(label);

    this.ChangeCheckBox = $('<input type="checkbox">')
      .appendTo(toggleWrapper)
      .css({
        'display': 'inline-block',
        'float': 'right'})
      .on('change',
          function () {
            self.ChangeCheckCallback();
          })
      .prop('checked', false);

    // Wrapper for the confidence slider.
    var confWrapper = $('<div>')
      .appendTo(leftWrapper)
      .css({'width': '100%'});

    this.Slider = $('<input type="range" min="0" max="100">')
      .appendTo(confWrapper)
      .on('input',
          function () {
            self.SliderCallback();
          });

    $('<div>')
      .appendTo(confWrapper)
      .html('0%')
      .css({ 'float': 'left' });

    $('<div>')
      .appendTo(confWrapper)
      .html('100%')
      .css({ 'float': 'right' });

    var colorWrapper = $('<div>')
      .appendTo(layerControl)
      .css({
        'padding': '5px',
        'height': '100%',
        'width': '20%',
        'display': 'inline-block'});
    this.ColorInput = $('<input type="color">')
      .appendTo(colorWrapper)
      .css({'width': '100%'})
      .val(SAM.ConvertColorToHex(this.Color))
      .change(function () {
        self.ColorCallback();
      });

    this.SizeScaleInput = $('<input type="number">').appendTo(colorWrapper)
      .css({'width': '100%'})
      .prop('title', 'Change the size of the detections')
      .on('change', function () { self.SizeScaleCallback(); });
  };

  LayerView.prototype.SetSizeScale = function (sizeScale) {
    this.SizeScaleInput.val((Math.round(sizeScale * 100)).toString());
    // not used this.RectSizeScale = sizeScale;
    // This might not be necessary. Change event might trigger it for us.
    this.SizeScaleCallback();
  };

  LayerView.prototype.SizeScaleCallback = function () {
    this.Color = SAM.ConvertColor(this.ColorInput.val());
    this.UpdateLayers();
  };

  LayerView.prototype.ColorCallback = function () {
    this.Color = SAM.ConvertColor(this.ColorInput.val());
    this.UpdateLayers();
  };

  LayerView.prototype.VisibilityCheckCallback = function () {
    // var checked = this.VisibilityCheckBox.prop('checked');
    // for (var i = 0; i < this.Layers.length; ++i) {
    //   this.Layers[i].SetVisibility(checked);
    //   this.Layers[i].EventuallyDraw();
    // }
    this.UpdateLayers();
  };

  LayerView.prototype.ChangeCheckCallback = function () {
    this.ChangeFlag = this.ChangeCheckBox.prop('checked');
    this.UpdateLayers();
    if (this.ChangeFlag) {
      var set1 = this.Layers[0].WidgetList[0].Shape;
      var set2 = this.Layers[1].WidgetList[0].Shape;
      set1.ChangeDetectionVisibilities(set1, set2);
      set1.SetOutlineColor('#FF0000');
      set2.SetOutlineColor('#0000FF');
    }
  };

  LayerView.prototype.SliderCallback = function () {
    this.UpdateLayers();
  };

  LayerView.prototype.UpdateLayer = function (layer) {
    var visibility = this.VisibilityCheckBox.prop('checked');
    var sizeScale = parseInt(this.SizeScaleInput.val() / 100);
    var visValue = parseInt(this.Slider.val()) / 100.0;
    for (var wIndex = 0; wIndex < layer.WidgetList.length; wIndex++) {
      var widget = layer.WidgetList[wIndex];
      if (widget.Label === undefined || widget.Label === this.Label) {
        widget.Visibility = visibility;
        widget.SetThreshold(visValue);
        widget.Shape.SetOutlineColor(this.Color);
        widget.Shape.SetScale(sizeScale);
        widget.ComputeVisibilities();
      }
    }
    layer.EventuallyDraw();
  };

  LayerView.prototype.UpdateLayers = function () {
    for (var i = 0; i < this.Layers.length; ++i) {
      var layer = this.Layers[i];
      this.UpdateLayer(layer);
    }
  };

  SA.LayerView = LayerView;
})();

(function () {
  'use strict';

  function HeatMap (parent) {
    this.HeatMapDiv = $('<div>')
            .appendTo(parent)
            .css({'position': 'absolute',
              'left': '0px',
              'top': '0px',
              'border-width': '0px',
              'width': '100%',
              'height': '100%',
              'box-sizing': 'border-box',
              'z-index': '150'})
            .addClass('sa-resize');

    this.View = new SA.TileView(this.HeatMapDiv, true);
    var gl = this.View.gl;
    this.Color = [0.0, 0.4, 0.0];
    this.Window = 1.0;
    this.Level = 0.5;
    this.Gamma = 1.0;

    var self = this;
    this.HeatMapDiv.saOnResize(
            function () {
              self.View.UpdateCanvasSize();
                // Rendering will be a slave to the view because it needs the
                // view's camera anyway.
            });

        // Test red->alpha, constant color set externally
    var heatMapFragmentShaderString =
            'precision highp float;' +
            'varying vec2 vTextureCoord;' +
            'uniform sampler2D uSampler;' +
            'uniform vec3 uColor;' +
            'uniform vec2 uWindowLevel;' +
            'uniform float uGamma;' +
            'void main(void) {' +
            '  vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t)).rgba;' +
            '  float alpha = textureColor[0];' +
            '  if (uWindowLevel[0] !== 1.0 || uWindowLevel[1] !== 0.5) {' +
            '    alpha = ((alpha-0.5)/uWindowLevel[0]) + uWindowLevel[1];' +
            '  }' +
            '  if (uGamma !== 1.0) {' +
            '    if (uGamma < 0.0) {' +
            '      alpha = pow((1.0-alpha), -uGamma);' +
            '    } else {' +
            '      alpha = pow(alpha, uGamma);' +
            '    }' +
            '  }' +
            '  textureColor = vec4(uColor, alpha);' +
            '  gl_FragColor = textureColor;' +
            '}';
    var vertexShaderString =
            'attribute vec3 aVertexPosition;' +
            'attribute vec2 aTextureCoord;' +
            'uniform mat4 uMVMatrix;' +
            'uniform mat4 uPMatrix;' +
            'uniform mat3 uNMatrix;' +
            'varying vec2 vTextureCoord;' +
            'void main(void) {' +
            '  gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition,1.0);' +
            '  vTextureCoord = aTextureCoord;' +
            '}';

    var shaderProgram = SA.createWebGlProgram(heatMapFragmentShaderString, vertexShaderString, gl);
        // Setup the shader program to render heatmaps.
    shaderProgram.textureCoordAttribute =
            gl.getAttribLocation(shaderProgram, 'aTextureCoord');
    gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
    shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, 'uSampler');
    shaderProgram.colorUniform = gl.getUniformLocation(shaderProgram, 'uColor');
    shaderProgram.gamaUniform = gl.getUniformLocation(shaderProgram, 'uGamma');
    shaderProgram.windowLevelUniform = gl.getUniformLocation(shaderProgram, 'uWindowLevel');
    this.View.ShaderProgram = shaderProgram;
  }

  HeatMap.prototype.SetCache = function (cache) {
    this.View.SetCache(cache);
    var imageObj = cache.GetImageData();
    if (!imageObj.spacing) {
      imageObj.spacing = [1, 1, 1];
    }
    if (!imageObj.origin) {
      imageObj.origin = [0, 0, 0];
    }
    var width = imageObj.dimensions[0] * imageObj.spacing[0];
    var height = imageObj.dimensions[1] * imageObj.spacing[1];
    this.View.Camera.Load(
      {FocalPoint: [width / 2, height / 2],
        Roll: 0,
        Height: height});
    this.View.Camera.ComputeMatrix();
    this.View.UpdateCanvasSize();
  };

    // Only works for images served by slide atlas.
  HeatMap.prototype.SetImageData = function (imageObj) {
    imageObj.spacing = imageObj.spacing || [1.0, 1.0, 1.0];
    imageObj.origin = imageObj.origin || [0.0, 0.0, 0.0];

    var heatMapSource = new SA.SlideAtlasSource();
    heatMapSource.Prefix = imageObj.prefix;
    var heatMapCache = new SA.Cache();
    heatMapCache.TileSource = heatMapSource;
    heatMapCache.SetImageData(imageObj);
    this.View.SetCache(heatMapCache);
  };

  HeatMap.prototype.Draw = function (masterView, inCam) {
    inCam = inCam || masterView.Camera;

    if (inCam) {
      if (this.Transform) {
        this.Transform.ForwardTransformCamera(inCam, this.View.GetCamera());
      } else {
                // Use spacing and origin for a transformation.
        var outCam = this.View.Camera;
        var imageObj = this.View.GetCache().Image;
        outCam.DeepCopy(inCam);
        var fp = outCam.GetWorldFocalPoint();
        outCam.SetWorldFocalPoint([
          (fp[0] - imageObj.origin[0]) / imageObj.spacing[0],
          (fp[1] - imageObj.origin[1]) / imageObj.spacing[1]]);
        outCam.SetWidth(outCam.GetWidth() / imageObj.spacing[0]);
        outCam.SetHeight(outCam.GetHeight() / imageObj.spacing[0]);
        outCam.ComputeMatrix();
        this.Camera.DeepCopy(outCam);
      }
    }

    if (this.View.gl) {
      var gl = this.View.gl;
      var program = this.View.ShaderProgram;
      gl.useProgram(program);
      gl.clearColor(1.0, 1.0, 1.0, 1.0);
      gl.disable(gl.DEPTH_TEST);
      gl.enable(gl.BLEND);
            // The blending in funky because there is no destination.
            // It is blending with data from canvas behind the webGl canvas.
      gl.blendFunc(gl.SRC_ALPHA, gl.ZERO);
      gl.uniform3f(program.colorUniform, this.Color[0], this.Color[1], this.Color[2]);
      gl.uniform1f(program.gamaUniform, this.Gamma);
      gl.uniform2f(program.windowLevelUniform, this.Window, this.Level);
    }

    this.View.DrawTiles();
  };

    // Clear the canvas for another render.
  HeatMap.prototype.Reset = function () {
  };

  SA.HeatMap = HeatMap;
})();

// A Renderer - layer tints an image and adds opacity.  Maybe lens in the future.
(function () {
  'use strict';

  function OverlayView (parent) {
    this.OverlayViewDiv = $('<div>')
            .appendTo(parent)
            .css({'position': 'absolute',
              'left': '0px',
              'top': '0px',
              'border-width': '0px',
              'width': '100%',
              'height': '100%',
              'box-sizing': 'border-box',
              'z-index': '150'})
            .addClass('sa-resize');

    this.View = new SA.TileView(this.OverlayViewDiv, true);
    var gl = this.View.gl;
    this.Color = [1.0, 0.0, 1.0];
    this.Center = [500, 500];
    this.Radius = 0;
    this.Opacity = 1.0;

    var self = this;
    this.OverlayViewDiv.saOnResize(
            function () {
              self.View.UpdateCanvasSize();
                // Rendering will be a slave to the view because it needs the
                // view's camera anyway.
            });

        // Test red->alpha, constant color set externally
    var heatMapFragmentShaderString =
            'precision highp float;' +
            'varying vec2 vTextureCoord;' +
            'uniform sampler2D uSampler;' +
            'uniform vec3 uColor;' +
            'uniform vec2 uCenter;' +
            'uniform float uOpacity;' +
            'void main(void) {' +
            '  float alpha = uOpacity;' +
            '  float dx = gl_FragCoord.x - uCenter.x;' +
            '  float dy = gl_FragCoord.y - uCenter.y;' +
            '  if ((dx * dx) + (dy * dy) < 40000.0) { alpha = 0.0;}' +
            '  vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t)).rgba;' +
            '  float intensity = textureColor[0];' +
            '  textureColor[0] = intensity * uColor[0];' +
            '  textureColor[1] = intensity * uColor[1];' +
            '  textureColor[2] = intensity * uColor[2];' +
            '  textureColor[3] = alpha;' +
            '  gl_FragColor = textureColor;' +
            // "  gl_FragColor = vec4(gl_FragCoord.x / 1000.0, gl_FragCoord.y / 1000.0, 0, alpha);" +
            '}';
    var vertexShaderString =
            'attribute vec3 aVertexPosition;' +
            'attribute vec2 aTextureCoord;' +
            'uniform mat4 uMVMatrix;' +
            'uniform mat4 uPMatrix;' +
            'uniform mat3 uNMatrix;' +
            'varying vec2 vTextureCoord;' +
            'varying vec4 vPos;' +
            'void main(void) {' +
            '  gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition,1.0);' +
            '  vTextureCoord = aTextureCoord;' +
            '}';

    var shaderProgram = SA.createWebGlProgram(heatMapFragmentShaderString, vertexShaderString, gl);
        // Setup the shader program to render heatmaps.
    shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, 'aTextureCoord');
    gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
    shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, 'uSampler');
    shaderProgram.colorUniform = gl.getUniformLocation(shaderProgram, 'uColor');
    shaderProgram.opacityUniform = gl.getUniformLocation(shaderProgram, 'uOpacity');
    shaderProgram.centerUniform = gl.getUniformLocation(shaderProgram, 'uCenter');
    this.View.ShaderProgram = shaderProgram;

    // this.View.Canvas
    this.OverlayViewDiv.on(
      'mousemove.overlay',
      function (event) {
        self.Center[0] = event.offsetX;
        self.Center[1] = self.OverlayViewDiv.height() - event.offsetY;
        self.EventuallyDraw();
        return true;
      });
  }

  // To compress draw events.
  OverlayView.prototype.EventuallyDraw = function () {
    if (!this.RenderPending) {
      this.RenderPending = true;
      var self = this;
      window.requestAnimationFrame(
                function () {
                  self.RenderPending = false;
                  self.Draw();
                });
    }
  };

  OverlayView.prototype.SetCache = function (cache) {
    this.View.SetCache(cache);
    var imageObj = cache.GetImageData();
    if (!imageObj.spacing) {
      imageObj.spacing = [1, 1, 1];
    }
    if (!imageObj.origin) {
      imageObj.origin = [0, 0, 0];
    }
    var width = imageObj.dimensions[0] * imageObj.spacing[0];
    var height = imageObj.dimensions[1] * imageObj.spacing[1];
    this.View.Camera.Load(
      {FocalPoint: [width / 2, height / 2],
        Roll: 0,
        Height: height});
    this.View.Camera.ComputeMatrix();
    this.View.UpdateCanvasSize();
  };

    // Only works for images served by slide atlas.
  OverlayView.prototype.SetImageData = function (imageObj) {
    imageObj.spacing = imageObj.spacing || [1.0, 1.0, 1.0];
    imageObj.origin = imageObj.origin || [0.0, 0.0, 0.0];

    var heatMapSource = new SA.SlideAtlasSource();
    heatMapSource.Prefix = imageObj.prefix;
    var heatMapCache = new SA.Cache();
    heatMapCache.TileSource = heatMapSource;
    heatMapCache.SetImageData(imageObj);
    this.View.SetCache(heatMapCache);
  };

  OverlayView.prototype.Draw = function (masterView, inCam) {
    // TODO: Clear any pending renders.
    if (masterView) {
      inCam = inCam || masterView.Camera;
    }

    if (inCam) {
      if (this.Transform) {
        this.Transform.ForwardTransformCamera(inCam, this.View.GetCamera());
      } else {
        // Use spacing and origin for a transformation.
        var outCam = this.View.Camera;
        var imageObj = this.View.GetCache().Image;
        outCam.DeepCopy(inCam);
        var fp = outCam.GetWorldFocalPoint();
        outCam.SetWorldFocalPoint([
          (fp[0] - imageObj.origin[0]) / imageObj.spacing[0],
          (fp[1] - imageObj.origin[1]) / imageObj.spacing[1]]);
        outCam.SetWidth(outCam.GetWidth() / imageObj.spacing[0]);
        outCam.SetHeight(outCam.GetHeight() / imageObj.spacing[0]);
        outCam.ComputeMatrix();
        this.Camera.DeepCopy(outCam);
      }
    }

    if (this.View.gl) {
      var gl = this.View.gl;
      var program = this.View.ShaderProgram;
      gl.useProgram(program);
      gl.clearColor(1.0, 1.0, 1.0, 1.0);
      gl.disable(gl.DEPTH_TEST);
      gl.enable(gl.BLEND);
            // The blending in funky because there is no destination.
            // It is bleniding with data from canvas behind the webGl canvas.
      gl.blendFunc(gl.SRC_ALPHA, gl.ZERO);
      gl.uniform3f(program.colorUniform, this.Color[0], this.Color[1], this.Color[2]);
      gl.uniform1f(program.opacityUniform, this.Opacity);
      gl.uniform2f(program.centerUniform, this.Center[0], this.Center[1]);
    }

    this.View.DrawTiles();
  };

    // Clear the canvas for another render.
  OverlayView.prototype.Reset = function () {
  };

  SA.OverlayView = OverlayView;
})();

/*
 * Copyright 2017-2022 EPAM Systems, Inc. (https://www.epam.com/)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from 'react';
import {inject, observer} from 'mobx-react';
import {Link} from 'react-router';
import classNames from 'classnames';
import connect from '../../../utils/connect';
import {computed} from 'mobx';
import PropTypes from 'prop-types';
import dataStorageCache from '../../../models/dataStorage/DataStorageCache';
import MetadataUpdateKeys from '../../../models/metadata/MetadataUpdateKeys';
import MetadataDeleteKeys from '../../../models/metadata/MetadataDeleteKeys';
import DataStorageTagsUpdate from '../../../models/dataStorage/tags/DataStorageTagsUpdate';
import DataStorageTagsDelete from '../../../models/dataStorage/tags/DataStorageTagsDelete';
import LoadingView from '../../special/LoadingView';
import {
  Alert,
  AutoComplete,
  Button,
  Col,
  Icon,
  Input,
  message,
  Modal,
  Row,
  Select
} from 'antd';
import ItemsTable, {isJson} from './items-table';
import styles from './Metadata.css';
import {SplitPanel} from '../splitPanel';
import localization from '../../../utils/localization';
import {
  RunCapabilitiesMetadataPreference,
  METADATA_KEY as RUN_CAPABILITIES
} from '../../pipelines/launch/form/utilities/run-capabilities';
import UserName from '../../special/UserName';
import FSNotifications from './special/fs-notifications';
import LimitMountsUserPreference from './special/limit-mounts';
import RequestDavAccess from './special/request-dav-access';
import MuteEmailNotifications from './special/mute-email-notifications';
import SshThemeSelect from './special/ssh-theme-select';
import OpenStaticPreview from './special/open-static-preview';
import SampleSheet, {utilities} from '../sample-sheet';
import auditStorageAccessManager from '../../../utils/audit-storage-access';
import {base64toString} from '../../../utils/base64';

const AutoGeneratedTags = {
  owner: 'CP_OWNER',
  source: 'CP_SOURCE',
  runId: 'CP_RUN_ID',
  job: {
    id: 'CP_JOB_ID',
    name: 'CP_JOB_NAME',
    version: 'CP_JOB_VERSION',
    configuration: 'CP_JOB_CONFIGURATION'
  },
  dockerImage: 'CP_DOCKER_IMAGE',
  calculationConfig: 'CP_CALC_CONFIG'
};

const SpecialTags = {
  [FSNotifications.metatadaKey]: FSNotifications,
  [LimitMountsUserPreference.metatadaKey]: LimitMountsUserPreference,
  [RequestDavAccess.metatadaKey]: RequestDavAccess,
  [MuteEmailNotifications.metadataKey]: MuteEmailNotifications,
  [SshThemeSelect.metadataKey]: SshThemeSelect,
  [RUN_CAPABILITIES]: RunCapabilitiesMetadataPreference
};

const metadataLoad = (params, metadataCache, dataStorageCache) => {
  if (params.entityClass === 'DATA_STORAGE_ITEM') {
    return dataStorageCache.getTags(params.entityParentId, params.entityId, params.entityVersion);
  } else {
    return metadataCache.getMetadata(params.entityId, params.entityClass);
  }
};

const previewLoad = (params, dataStorageCache) => {
  if (params.entityClass === 'DATA_STORAGE_ITEM' && !params.fileIsEmpty) {
    return dataStorageCache.getContent(
      params.entityParentId,
      params.entityId,
      params.entityVersion
    );
  } else {
    return null;
  }
};

const downloadUrlLoad = (params, dataStorageCache) => {
  if (params.entityClass === 'DATA_STORAGE_ITEM' && !params.fileIsEmpty) {
    return dataStorageCache.getDownloadUrl(
      params.entityParentId,
      params.entityId,
      params.entityVersion,
      false
    );
  } else {
    return null;
  }
};

const MetadataDisplayOptions = {
  preview: {
    maxLength: 100,
    display: function (value) {
      if (value && value.length > this.maxLength) {
        return `${value.substring(0, this.maxLength)}...`;
      }
      return value;
    }
  },
  edit: {
    autosize: {
      maxRows: 6,
      minRows: undefined
    }
  }
};

const ApplyChanges = {
  callback: 'callback',
  inline: 'inline'
};

const queueRequests = (requests, results = []) => {
  if (requests.length === 0) {
    return Promise.resolve(results);
  }
  const [current, ...next] = requests;
  return new Promise((resolve, reject) => {
    current()
      .then((result) => {
        return queueRequests(next, [...results, result]);
      })
      .then(resolve)
      .catch(reject);
  });
};

const wrapRequest = (request, fn) => new Promise((resolve) => {
  fn()
    .then(() => {
      if (request.error) {
        resolve({error: request.error});
      } else {
        resolve({});
      }
    })
    .catch(e => resolve({error: e.message}));
});

const applyRequests = (requests) => {
  if (requests.length === 0) {
    return Promise.resolve();
  }
  return new Promise((resolve) => {
    queueRequests(
      requests.map(({request, apply}) => () => wrapRequest(request, apply))
    )
      .then(payloads => {
        const error = payloads
          .map(payload => payload.error)
          .find(Boolean);
        resolve(error);
      });
  });
};

@connect({
  dataStorageCache
})
@localization.localizedComponent
@inject('metadataCache', 'pipelines', 'dockerRegistries', 'systemDictionaries')
@inject((
  {
    metadataCache,
    dataStorageCache,
    pipelines,
    dockerRegistries,
    systemDictionaries
  },
  params
) => ({
  pipelines,
  dockerRegistries,
  metadataCache,
  dataStorageCache,
  systemDictionaries,
  metadata: metadataLoad(params, metadataCache, dataStorageCache),
  dataStorageTags: params.entityClass === 'DATA_STORAGE_ITEM',
  preview: previewLoad(params, dataStorageCache),
  downloadUrl: downloadUrlLoad(params, dataStorageCache)
}))
@observer
export default class Metadata extends localization.LocalizedReactComponent {
  static propTypes = {
    readOnly: PropTypes.bool,
    hideMetadataTags: PropTypes.bool,
    entityName: PropTypes.string,
    entityClass: PropTypes.string,
    entityId: PropTypes.oneOfType([
      PropTypes.string,
      PropTypes.number
    ]),
    entityParentId: PropTypes.oneOfType([
      PropTypes.string,
      PropTypes.number
    ]),
    entityVersion: PropTypes.string,
    canNavigateBack: PropTypes.bool,
    onNavigateBack: PropTypes.func,
    fileIsEmpty: PropTypes.bool,
    applyChanges: PropTypes.oneOf([
      ApplyChanges.callback,
      ApplyChanges.inline
    ]),
    value: PropTypes.object,
    onChange: PropTypes.func,
    downloadable: PropTypes.bool,
    showContent: PropTypes.bool,
    title: PropTypes.string,
    titleStyle: PropTypes.object,
    removeAllAvailable: PropTypes.bool,
    restrictedKeys: PropTypes.array,
    extraKeys: PropTypes.arrayOf(PropTypes.string),
    extraInfo: PropTypes.arrayOf(PropTypes.node),
    specialTagsProperties: PropTypes.object,
    pending: PropTypes.bool,
    metadataRenderFn: PropTypes.func,
    showMetadata: PropTypes.bool,
    jobList: PropTypes.node
  };

  static defaultProps = {
    applyChanges: ApplyChanges.inline,
    downloadable: true,
    showContent: true,
    removeAllAvailable: true
  };

  state = {
    addKey: null
  };

  confirmDeleteMetadata = () => {
    Modal.confirm({
      title: 'Do you want to delete all metadata?',
      style: {
        wordWrap: 'break-word'
      },
      content: null,
      okText: 'OK',
      cancelText: 'Cancel',
      onOk: async () => {
        const {error, refresh} = await this.applyRemoveChanges({all: true});
        if (error) {
          message.error(error, 5);
        }
        if (refresh) {
          this.props.metadata.fetch();
        }
      }
    });
  };

  confirmDeleteKey = (item) => {
    Modal.confirm({
      title: `Do you want to delete key "${item.key}"?`,
      content: null,
      style: {
        wordWrap: 'break-word'
      },
      okText: 'OK',
      cancelText: 'Cancel',
      onOk: async () => {
        const {error, refresh} = await this.applyRemoveChanges({item});
        if (error) {
          message.error(error, 5);
        }
        if (refresh) {
          this.props.metadata.fetch();
        }
      }
    });
  };

  autoFocusInputRef = (input) => {
    if (input && input.refs && input.refs.input && input.refs.input.focus) {
      input.refs.input.focus();
    }
  };

  applyChanges = async (modified = [], removed = []) => {
    const {
      applyChanges,
      dataStorageTags,
      onChange,
      entityId,
      entityParentId,
      entityVersion,
      entityClass
    } = this.props;
    if (applyChanges === ApplyChanges.callback && onChange) {
      const mapItem = ({key, value, type}) => ({key, value, type});
      const metadata = this.metadata
        .map(mapItem)
        .filter(({key}) => !this.isReadOnlyTag(key) && !removed.find(r => r.key === key))
        .concat(modified.map(mapItem))
        .map(({key, ...rest}) => ({[key]: rest}))
        .reduce((r, c) => ({...r, ...c}), {});
      await onChange(metadata);
      return {refresh: false};
    } else {
      const requests = [];
      if (dataStorageTags) {
        if (removed.length > 0) {
          const removeRequest = new DataStorageTagsDelete(
            entityParentId,
            entityId,
            entityVersion
          );
          const removeRequestFn = () => removeRequest.send(
            removed.map(item => item.key)
          );
          requests.push({
            request: removeRequest,
            apply: removeRequestFn
          });
        }
        if (modified.length > 0) {
          const updateRequest = new DataStorageTagsUpdate(
            entityParentId,
            entityId,
            entityVersion,
            false
          );
          const updateRequestFn = () => updateRequest.send(
            modified
              .map(({key, value}) => ({[key]: value}))
              .reduce((r, c) => ({...r, ...c}), {})
          );
          requests.push({
            request: updateRequest,
            apply: updateRequestFn
          });
        }
      } else {
        if (removed.length > 0) {
          const removeRequest = new MetadataDeleteKeys();
          const removeRequestFn = () => removeRequest.send({
            entity: {
              entityId,
              entityClass
            },
            data: removed
              .map(({key, value, type}) => ({[key]: {value, type: type || 'string'}}))
              .reduce((r, c) => ({...r, ...c}), {})
          });
          requests.push({
            request: removeRequest,
            apply: removeRequestFn
          });
        }
        if (modified.length > 0) {
          const updateRequest = new MetadataUpdateKeys();
          const updateRequestFn = () => updateRequest.send({
            entity: {
              entityId,
              entityClass
            },
            data: modified
              .filter(({value}) => value !== undefined)
              .map(({key, value, type}) => ({[key]: {value, type: type || 'string'}}))
              .reduce((r, c) => ({...r, ...c}), {})
          });
          requests.push({
            request: updateRequest,
            apply: updateRequestFn
          });
        }
      }
      const error = await applyRequests(requests);
      return {error, refresh: !error};
    }
  };

  applyRemoveChanges = async ({item, all = false}) => {
    if (all) {
      return this.applyChanges(
        [],
        this.metadata.filter(
          ({key, value}) => !this.isReadOnlyTag(key) && !this.isSpecialItem(key)
        )
      );
    } else if (item) {
      return this.applyChanges([], [item]);
    } else {
      return {refresh: false};
    }
  };

  saveMetadata = (opts) => async () => {
    const {index, field} = opts;
    const metadata = this.metadata;
    const [currentMetadataItem] = metadata.filter(m => m.index === index);
    const modified = [];
    const removed = [];
    if (this.state.addKey) {
      if (
        !this.state.addKey.key ||
        !this.state.addKey.key.length ||
        !this.state.addKey.key.trim().length
      ) {
        message.error('Enter key', 5);
        return;
      }
      const [existedMetadataItem] = metadata.filter(m => m.key === this.state.addKey.key);
      if (existedMetadataItem) {
        message.error(`Key '${this.state.addKey.key}' already exists.`, 5);
        return;
      }
      if (!this.state.addKey.value || !this.state.addKey.value.length) {
        message.error('Enter value', 5);
        return;
      }
      await this.props.systemDictionaries.fetchIfNeededOrWait();
      const {
        result,
        warnings
      } = this.getCascadeValues(
        this.state.addKey.key.trim(),
        this.state.addKey.value,
        this.props.systemDictionaries.loaded
          ? (this.props.systemDictionaries.value || [])
          : []
      );
      if (warnings.size > 0) {
        message.warning(
          // eslint-disable-next-line
          `Error auto-filling attributes: circular dependency for "${[...warnings].join(', ')}" dictionar${warnings.size > 1 ? 'ies' : 'y'}`,
          5
        );
      }
      modified.push(...result);
    } else if (currentMetadataItem) {
      const value = this.state.editableText;
      if ((field === 'key' && currentMetadataItem.key === value) ||
        (field === 'value' && currentMetadataItem.value === value)) {
        this.setState({editableKeyIndex: null, editableValueIndex: null, editableText: null});
        return;
      }
      if (field === 'key') {
        if (!value || !value.length || !value.trim().length) {
          message.error('Key should not be empty', 5);
          return;
        }
        const [existedMetadataItem] = metadata.filter(m => m.index !== index && m.key === value);
        if (existedMetadataItem) {
          message.error(`Key '${value}' already exists.`, 5);
          return;
        }
        modified.push({...currentMetadataItem, key: value.trim()});
        removed.push({...currentMetadataItem});
      } else if (field === 'value') {
        modified.push({...currentMetadataItem, value});
      }
    }
    const {error, refresh} = await this.applyChanges(modified, removed);
    if (error) {
      message.error(error, 5);
      return;
    }
    if (refresh) {
      this.props.metadata.fetch();
    }
    this.setState({
      addKey: null,
      editableKeyIndex: null,
      editableValueIndex: null,
      editableText: null
    });
  };

  applyValues = async (values = []) => {
    const metadata = this.metadata;
    const modified = [];
    values.forEach(({key, value}) => {
      const currentMetadataItem = metadata.find(m => m.key === key);
      if (currentMetadataItem) {
        modified.push({...currentMetadataItem, value});
      } else {
        modified.push({key, value});
      }
    });
    const {error, refresh} = await this.applyChanges(modified);
    if (error) {
      message.error(error, 5);
      return;
    }
    if (refresh) {
      this.props.metadata.fetch();
    }
    this.setState({
      addKey: null,
      editableKeyIndex: null,
      editableValueIndex: null,
      editableText: null
    });
  };

  getCascadeValues = (key, value, dictionaries, processed = []) => {
    let warnings = new Set();
    let result = processed.slice().concat(({key, value}));
    const dictionary = dictionaries.find(dict => dict.key === key);
    if (dictionary) {
      const {values = []} = dictionary;
      const dictValue = values.find(v => v.value === value);
      if (dictValue) {
        const {links = []} = dictValue;
        for (let l = 0; l < links.length; l++) {
          const {key: linkKey, value: linkValue} = links[l];
          const existedLink = result.find(p => p.key === linkKey);
          if (existedLink) {
            if (existedLink.value !== linkValue) {
              // eslint-disable-next-line
              warnings.add(linkKey);
            }
          } else {
            const {
              result: childResult,
              warnings: childWarnings
            } = this.getCascadeValues(linkKey, linkValue, dictionaries, result);
            result = childResult;
            warnings = new Set([...warnings, ...childWarnings]);
          }
        }
      }
    }
    return {
      result,
      warnings
    };
  };

  applyCascadeValues = async (key, value) => {
    const {systemDictionaries} = this.props;
    await systemDictionaries.fetchIfNeededOrWait();
    if (systemDictionaries.loaded) {
      const {
        result: values,
        warnings
      } = this.getCascadeValues(key, value, systemDictionaries.value || []);
      if (warnings.size > 0) {
        message.warning(
          // eslint-disable-next-line
          `Error auto-filling attributes: circular dependency for "${[...warnings].join(', ')}" dictionar${warnings.size > 1 ? 'ies' : 'y'}`,
          5
        );
      }
      await this.applyValues(values);
    }
  };

  saveDictionaryMetadata = (opts) => async (value) => {
    const {index} = opts;
    const metadata = this.metadata;
    const [currentMetadataItem] = metadata.filter(m => m.index === index);
    if (currentMetadataItem) {
      if (currentMetadataItem.value === value) {
        this.setState({editableKeyIndex: null, editableValueIndex: null, editableText: null});
        return;
      }
      await this.applyCascadeValues(currentMetadataItem.key, value);
    }
  };

  saveMetadataValue = (index) => async (value) => {
    const metadata = this.metadata;
    const [currentMetadataItem] = metadata.filter(m => m.index === index);
    if (currentMetadataItem) {
      if (currentMetadataItem.value === value) {
        return;
      }
      const {error, refresh} = await this.applyChanges([{...currentMetadataItem, value}]);
      if (error) {
        message.error(error, 5);
        return false;
      }
      if (refresh) {
        await this.props.metadata.fetch();
      }
      return true;
    }
    return false;
  };

  onMetadataEditStarted = (field, index, value) => () => {
    if (this.props.readOnly) {
      return;
    }
    if (field === 'key') {
      this.setState({
        addKey: null,
        editableKeyIndex: index,
        editableValueIndex: null,
        editableText: value
      });
    } else if (field === 'value') {
      this.setState({
        addKey: null,
        editableKeyIndex: null,
        editableValueIndex: index,
        editableText: value
      });
    }
  };

  onMetadataChange = (e) => {
    this.setState({editableText: e.target.value});
  };

  discardChanges = () => {
    this.setState({
      addKey: null,
      editableKeyIndex: null,
      editableValueIndex: null,
      editableText: null
    });
  };

  isAutoGeneratedItem = (key) => {
    return [AutoGeneratedTags.calculationConfig,
      AutoGeneratedTags.dockerImage,
      AutoGeneratedTags.job.configuration,
      AutoGeneratedTags.job.id,
      AutoGeneratedTags.job.name,
      AutoGeneratedTags.job.version,
      AutoGeneratedTags.owner,
      AutoGeneratedTags.runId,
      AutoGeneratedTags.source
    ].indexOf(key) >= 0;
  };

  isSpecialItem = (key) => {
    return Object.keys(SpecialTags || {}).includes(key);
  };

  isReadOnlyTag = (tag) => (this.props.restrictedKeys || []).includes(tag);

  renderAutogeneratedTag = (key, title, icon, link, value) => {
    return [
      <tr
        key={`${key}_key`}
        className={
          classNames(
            'cp-metadata-item-row',
            'key',
            'read-only'
          )
        }
      >
        <td
          id={`key-column-${key}`}
          colSpan={6}
          className={classNames('cp-metadata-item-key', 'cp-ellipsis-text')}
        >
          <Icon type={icon} /> {title}
        </td>
      </tr>,
      <tr
        key={`${key}_value`}
        className="cp-metadata-item-row"
      >
        <td
          id={`value-column-${key}`}
          colSpan={6}>
          {
            link
              ? <Link to={link}>{value}</Link>
              : value
          }
        </td>
      </tr>
    ];
  };

  renderSpecialTag = (metadataItem) => {
    const {key, index} = metadataItem || {};
    const {specialTagsProperties = {}} = this.props;
    const readOnly = this.props.readOnly ||
      this.isReadOnlyTag(metadataItem.key);
    if (key && SpecialTags.hasOwnProperty(key)) {
      const Component = SpecialTags[key];
      const onRemove = async () => {
        const {error, refresh} = await this.applyRemoveChanges({item: {key}});
        if (error) {
          message.error(error, 5);
        }
        if (refresh) {
          this.props.metadata.fetch();
        }
      };
      return (
        <tr
          key={`${key}_key`}
          className={
            classNames(
              'cp-metadata-item-row',
              'special',
              {'read-only': readOnly}
            )
          }
        >
          <td
            id={`value-column-${key}`}
            colSpan={6}
          >
            <Component
              key={key}
              metadata={metadataItem}
              readOnly={readOnly}
              onChange={this.saveMetadataValue(index)}
              onRemove={onRemove}
              info={specialTagsProperties}
              reload={this.refresh}
            />
          </td>
        </tr>
      );
    }
    return null;
  };

  renderOwnerTag = (metadata) => {
    const [ownerTag] = metadata.filter(item => item.key === AutoGeneratedTags.owner);
    if (ownerTag) {
      return this.renderAutogeneratedTag(
        ownerTag.key,
        'Owner',
        'user',
        false,
        (<UserName userName={ownerTag.value} />)
      );
    }
    return [];
  };

  renderSourceTag = (metadata) => {
    const [sourceTag] = metadata.filter(item => item.key === AutoGeneratedTags.source);
    if (sourceTag) {
      return this.renderAutogeneratedTag(
        sourceTag.key,
        'Source',
        'download',
        false,
        sourceTag.value
      );
    }
    return [];
  };

  renderRunTag = (metadata) => {
    const [runIdTag] = metadata.filter(item => item.key === AutoGeneratedTags.runId);
    if (runIdTag) {
      return this.renderAutogeneratedTag(
        runIdTag.key,
        'RunID',
        'play-circle-o',
        `/run/${runIdTag.value}`,
        runIdTag.value
      );
    }
    return [];
  };

  renderJobTag = (metadata) => {
    const [pipelineIdTag] = metadata.filter(item => item.key === AutoGeneratedTags.job.id);
    const [pipelineNameTag] = metadata.filter(item => item.key === AutoGeneratedTags.job.name);
    let pipelineName = 'Unknown';
    if (!pipelineNameTag && pipelineIdTag) {
      const pipelines = this.props.pipelines.loaded
        ? (this.props.pipelines.value || []).map(p => p)
        : [];
      const [pipeline] = pipelines.filter(p => `${p.id}` === `${pipelineIdTag.value}`);
      if (pipeline) {
        pipelineName = pipeline.name;
      }
    } else if (pipelineNameTag) {
      pipelineName = pipelineNameTag.value;
    }
    if (pipelineIdTag) {
      return this.renderAutogeneratedTag(
        pipelineIdTag.key,
        this.localizedString('Pipeline'),
        'fork',
        `/${pipelineIdTag.value}`,
        pipelineName
      );
    }
    return [];
  };

  renderJobVersionTag = (metadata) => {
    const pipelineVersionTag = metadata.find(item => item.key === AutoGeneratedTags.job.version);
    const pipelineIdTag = metadata.find(item => item.key === AutoGeneratedTags.job.id);
    if (pipelineIdTag && pipelineVersionTag) {
      return this.renderAutogeneratedTag(
        pipelineVersionTag.key,
        `${this.localizedString('Pipeline')} version`,
        'tag-o',
        `/${pipelineIdTag.value}/${pipelineVersionTag.value}`,
        pipelineVersionTag.value
      );
    }
    return [];
  };

  renderJobConfigurationTag = (metadata) => {
    const pipelineIdTag = metadata.find(item => item.key === AutoGeneratedTags.job.id);
    const pipelineVersionTag = metadata.find(item => item.key === AutoGeneratedTags.job.version);
    const pipelineConfigurationTag = metadata
      .find(item => item.key === AutoGeneratedTags.job.configuration);
    if (pipelineIdTag && pipelineVersionTag && pipelineConfigurationTag) {
      const id = pipelineIdTag.value;
      const version = pipelineVersionTag.value;
      const configuration = pipelineConfigurationTag.value;
      return this.renderAutogeneratedTag(
        pipelineConfigurationTag.key,
        `${this.localizedString('Pipeline')} configuration`,
        'setting',
        `/${id}/${version}/configuration/${configuration}`,
        configuration
      );
    }
    return [];
  };

  renderDockerImageTag = (metadata) => {
    const [dockerImageTag] = metadata.filter(item => item.key === AutoGeneratedTags.dockerImage);
    let dockerImageId = null;
    if (dockerImageTag && this.props.dockerRegistries.loaded) {
      const [registryPath, groupName, toolWithVersion] = dockerImageTag.value.split('/');
      const [toolName] = toolWithVersion.split(':');
      const registry = (this.props.dockerRegistries.value.registries || [])
        .find(r => r.path.toLowerCase() === (registryPath || '').toLowerCase());
      if (registry) {
        const group = (registry.groups || [])
          .find(g => g.name.toLowerCase() === (groupName || '').toLowerCase());
        if (group) {
          const tool = (group.tools || [])
            .find(t => t.image.toLowerCase() === `${(groupName || '')}/${toolName}`.toLowerCase());
          if (tool) {
            dockerImageId = tool.id;
          }
        }
      }
    }
    if (dockerImageTag) {
      return this.renderAutogeneratedTag(
        dockerImageTag.key,
        'Docker image',
        'tool',
        dockerImageId ? `/tool/${dockerImageId}` : null,
        dockerImageTag.value
      );
    }
    return [];
  };

  renderCalculationConfigTag = (metadata) => {
    const calcConfigTag = metadata
      .find(item => item.key === AutoGeneratedTags.calculationConfig);
    if (calcConfigTag) {
      let [instanceType, workersCount, totalCPU] = calcConfigTag.value.split(':');
      instanceType = (instanceType || '').toLowerCase() === 'none' ? null : instanceType;
      workersCount = (workersCount || '').toLowerCase() === 'none' ? null : workersCount;
      totalCPU = (totalCPU || '').toLowerCase() === 'none' ? null : totalCPU;
      const value = (
        <ul style={{listStyle: 'disc inside'}}>
          {
            instanceType &&
            <li>Instance type: {instanceType}</li>
          }
          {
            workersCount &&
            <li>Workers count: {workersCount}</li>
          }
          {
            totalCPU &&
            <li>Total CPU: {totalCPU}</li>
          }
        </ul>
      );
      return this.renderAutogeneratedTag(
        calcConfigTag.key,
        'Compute',
        'calculator',
        null,
        value
      );
    }
    return [];
  };

  renderAutogeneratedMetadata = (metadata) => {
    if (!this.props.dataStorageTags) {
      return null;
    }
    return [
      ...this.renderOwnerTag(metadata),
      ...this.renderSourceTag(metadata),
      ...this.renderRunTag(metadata),
      ...this.renderJobTag(metadata),
      ...this.renderJobVersionTag(metadata),
      ...this.renderJobConfigurationTag(metadata),
      ...this.renderDockerImageTag(metadata),
      ...this.renderCalculationConfigTag(metadata)
    ];
  };

  renderMetadataItem = (metadataItem) => {
    if (this.props.dataStorageTags && this.isAutoGeneratedItem(metadataItem.key)) {
      return null;
    }
    if (this.isSpecialItem(metadataItem.key)) {
      return this.renderSpecialTag(metadataItem);
    }
    let keyElement;
    let valueElement;
    const readOnly = this.props.readOnly || this.isReadOnlyTag(metadataItem.key);
    const inputOptions = (field) => {
      return {
        id: `${field}-input-${metadataItem.key}`,
        ref: this.autoFocusInputRef,
        onBlur: this.saveMetadata({index: metadataItem.index, field}),
        onPressEnter: this.saveMetadata({index: metadataItem.index, field}),
        size: 'small',
        value: this.state.editableText,
        onChange: this.onMetadataChange,
        onKeyDown: (e) => {
          if (e.key && e.key === 'Escape') {
            this.discardChanges();
          }
        }
      };
    };
    if (this.state.editableKeyIndex === metadataItem.index) {
      keyElement = (
        <tr
          key={`${metadataItem.key}_key`}
          className={
            classNames(
              'cp-metadata-item-row',
              'key',
              'editable'
            )
          }
        >
          <td colSpan={6}>
            <Input
              {...inputOptions('key')}
              style={{minHeight: '28px'}}
              className={classNames(
                'qa-metadata-item-key-input',
                `qa-metadata-item-key-input-${metadataItem.key}`
              )}
            />
          </td>
        </tr>
      );
    } else {
      keyElement = (
        <tr
          key={`${metadataItem.key}_key`}
          className={
            classNames(
              'cp-metadata-item-row',
              'key',
              {
                'read-only': readOnly
              })
          }
        >
          <td
            id={`key-column-${metadataItem.key}`}
            colSpan={
              readOnly
                ? 6
                : 5
            }
            className={classNames('cp-metadata-item-key', 'cp-ellipsis-text')}
            onClick={
              readOnly
                ? undefined
                : this.onMetadataEditStarted('key', metadataItem.index, metadataItem.key)
            }
          >
            <span style={{display: 'inline-block'}}>
              {metadataItem.key}
            </span>
          </td>
          {
            readOnly
              ? undefined
              : (
                <td style={{minWidth: 30, textAlign: 'right'}}>
                  <Button
                    id={`delete-metadata-key-${metadataItem.key}-button`}
                    type="danger"
                    size="small"
                    onClick={() => this.confirmDeleteKey(metadataItem)}>
                    <Icon type="delete" />
                  </Button>
                </td>
              )
          }
        </tr>
      );
    }
    const {systemDictionaries} = this.props;
    const key = this.state.editableKeyIndex === metadataItem.index
      ? (this.state.editableText || metadataItem.key)
      : metadataItem.key;
    const dictionary = systemDictionaries.getDictionary(key);
    if (dictionary) {
      valueElement = (
        <tr
          key={`${metadataItem.key}_value`}
          className={classNames(
            'cp-metadata-item-row',
            'value',
            'editable'
          )}
        >
          <td colSpan={6}>
            <Select
              showSearch
              style={{width: '100%'}}
              filterOption={
                (input, option) => option.props.children.toLowerCase()
                  .indexOf(input.toLowerCase()) >= 0
              }
              value={metadataItem.value}
              onChange={this.saveDictionaryMetadata({index: metadataItem.index})}
            >
              {
                (dictionary.values || []).map((v) => (
                  <Select.Option key={v.value} value={v.value}>
                    {v.value}
                  </Select.Option>
                ))
              }
            </Select>
          </td>
        </tr>
      );
    } else if (isJson(metadataItem.value)) {
      valueElement = (
        <tr
          key={`${metadataItem.key}_value`}
          className={classNames(
            'cp-metadata-item-row',
            'value',
            'editable'
          )}
        >
          <td colSpan={6}>
            <ItemsTable
              title={metadataItem.key}
              disabled={readOnly}
              value={metadataItem.value}
              onChange={this.saveMetadataValue(metadataItem.index)}
            />
          </td>
        </tr>
      );
    } else if (this.state.editableValueIndex === metadataItem.index) {
      valueElement = (
        <tr
          key={`${metadataItem.key}_value`}
          className={
            classNames(
              'cp-metadata-item-row',
              'value',
              'editable'
            )
          }
        >
          <td colSpan={6}>
            <Input
              {...inputOptions('value')}
              type="textarea"
              autosize={MetadataDisplayOptions.edit.autosize}
              className={classNames(
                'qa-metadata-item-value-input',
                `qa-metadata-item-value-input-${metadataItem.index}`
              )}
            />
          </td>
        </tr>
      );
    } else {
      valueElement = (
        <tr
          key={`${metadataItem.key}_value`}
          className={
            classNames(
              'cp-metadata-item-row',
              'value'
            )
          }
        >
          <td
            id={`value-column-${metadataItem.key}`}
            colSpan={6}
            onClick={
              readOnly
                ? undefined
                : this.onMetadataEditStarted('value', metadataItem.index, metadataItem.value)
            }
          >
            <span style={{display: 'inline-block'}}>
              {MetadataDisplayOptions.preview.display(metadataItem.value)}
            </span>
          </td>
        </tr>
      );
    }
    return [this.getDivider(`${metadataItem.key}_divider`, 6), keyElement, valueElement];
  };

  getDivider = (key, span) => {
    return (
      <tr key={key} >
        <td colSpan={span || 3}>
          <div className={classNames(
            styles.divider,
            'cp-divider',
            'horizontal'
          )}
          />
        </td>
      </tr>
    );
  };

  @computed
  get metadata () {
    if (!this.props.value && !this.props.metadata.loaded) {
      return [];
    }
    const value = [];
    if (this.props.value) {
      const data = this.props.value;
      for (let property in data) {
        if (data.hasOwnProperty(property)) {
          value.push({
            key: property,
            value: data[property].value,
            type: data[property].type
          });
        }
      }
    } else if (this.props.dataStorageTags) {
      const data = this.props.metadata.value;
      for (let property in data) {
        if (data.hasOwnProperty(property)) {
          value.push({
            key: property,
            value: data[property]
          });
        }
      }
    } else {
      const [data] = (this.props.metadata.value || [])
        .filter(key => key && key.data).map(key => key.data);
      if (data) {
        for (let property in data) {
          if (data.hasOwnProperty(property)) {
            value.push({
              key: property,
              value: data[property].value,
              type: data[property].type
            });
          }
        }
      }
    }
    const {extraKeys = []} = this.props;
    extraKeys.forEach(extraKey => {
      if (!value.find(o => o.key === extraKey)) {
        value.push({
          key: extraKey
        });
      }
    });
    const getExtraKeyIndex = (key) => {
      const index = extraKeys.indexOf(key);
      if (index === -1) {
        return Infinity;
      }
      return index;
    };
    value
      .sort((a, b) => {
        if (a.key < b.key) {
          return -1;
        } else if (a.key > b.key) {
          return 1;
        }
        return 0;
      })
      .sort((a, b) =>
        (Number(this.isSpecialItem(b.key)) - Number(this.isSpecialItem(a.key))) ||
        (getExtraKeyIndex(a.key) - getExtraKeyIndex(b.key))
      );
    return value.map((value, index) => { return {...value, index}; });
  }

  @computed
  get filePreview () {
    if (this.props.preview) {
      if (this.props.preview.pending) {
        return null;
      }
      const preview = this.props.preview.value.content
        ? base64toString(this.props.preview.value.content)
        : '';
      const truncated = this.props.preview.value.truncated;
      const noContent = !preview;
      const mayBeBinary = this.props.preview.value.mayBeBinary;
      const error = this.props.preview.error;

      return {
        preview,
        truncated,
        noContent,
        error,
        mayBeBinary
      };
    } else if (this.props.fileIsEmpty) {
      return {
        preview: '',
        mayBeBinary: false,
        truncated: false,
        noContent: true,
        error: null
      };
    }

    return null;
  }

  @computed
  get downloadUrl () {
    if (this.props.downloadUrl) {
      if (this.props.downloadUrl.error || this.props.downloadUrl.pending) {
        return null;
      }
      return this.props.downloadUrl.value.url;
    }

    return null;
  }

  renderAddKeyRow = () => {
    if (this.state.addKey) {
      const {systemDictionaries} = this.props;
      const existingKeys = new Set(this.metadata.map(m => m.key));
      const {key} = this.state.addKey;
      const readOnly = this.isReadOnlyTag(key);
      const dictionary = systemDictionaries.getDictionary(key);
      const availableDictionaries = systemDictionaries.loaded
        ? (systemDictionaries.value || [])
          .map(dict => dict.key)
          .filter(dict => !existingKeys.has(dict))
        : [];
      const addKeyCancelClicked = () => {
        this.setState({
          editableKeyIndex: null,
          editableValueIndex: null,
          editableText: null,
          addKey: null
        });
      };

      const onChange = (field) => (e) => {
        const addKey = this.state.addKey;
        addKey[field] = e.target.value;
        this.setState({addKey});
      };

      const onDictionaryChange = (e) => {
        const addKey = this.state.addKey;
        addKey.value = e;
        this.setState({addKey});
      };

      const onEnter = (e) => {
        e.stopPropagation();
        this.saveMetadata({})();
        return false;
      };

      let valueItem;
      if (dictionary) {
        valueItem = (
          <Select
            allowClear
            showSearch
            style={{width: '100%'}}
            filterOption={
              (input, option) => option.props.children.toLowerCase()
                .indexOf(input.toLowerCase()) >= 0
            }
            value={this.state.addKey.value}
            onChange={onDictionaryChange}
            disabled={readOnly}
          >
            {
              (dictionary.values || [])
                .map((v) => (
                  <Select.Option key={v.value} value={v.value}>
                    {v.value}
                  </Select.Option>
                ))
            }
          </Select>
        );
      } else {
        valueItem = (
          <Input
            disabled={readOnly}
            onPressEnter={readOnly ? undefined : onEnter}
            onKeyDown={(e) => {
              if (e.key && e.key === 'Escape') {
                this.discardChanges();
              }
            }}
            value={this.state.addKey.value}
            onChange={onChange('value')}
            size="small"
            type="textarea"
            autosize
          />
        );
      }

      return [
        this.getDivider('new key'),
        <tr className={styles.newKeyRow} key="new key row">
          <td style={{textAlign: 'right', width: 80}}>
            Key:
          </td>
          <td colSpan={2}>
            <AutoComplete
              allowClear
              backfill
              autoFocus
              value={this.state.addKey.key}
              onChange={value => onChange('key')({target: {value}})}
              size="small"
              style={{width: '100%'}}
              filterOption={
                (input, option) =>
                  option.props.children.toLowerCase().indexOf(input.toLowerCase()) >= 0
              }
            >
              {
                availableDictionaries.map((dict) => (
                  <AutoComplete.Option key={dict} value={dict}>
                    {dict}
                  </AutoComplete.Option>
                ))
              }
            </AutoComplete>
          </td>
        </tr>,
        <tr className={styles.newKeyRow} key="new value row">
          <td style={{textAlign: 'right', width: 80}}>
            Value:
          </td>
          <td colSpan={2}>
            {valueItem}
          </td>
        </tr>,
        <tr className={styles.newKeyRow} key="new key title row">
          <td colSpan={3} style={{textAlign: 'right'}}>
            <Button
              id="add-metadata-item-button"
              size="small"
              type="primary"
              onClick={this.saveMetadata({})}
              disabled={readOnly}
            >
              <Icon type="check" /> Add
            </Button>
            <Button
              id="cancel-add-metadata-item-button"
              size="small"
              onClick={addKeyCancelClicked}>
              <Icon type="close" /> Cancel
            </Button>
          </td>
        </tr>
      ];
    } else {
      return undefined;
    }
  };

  renderEmptyPlaceholder = () => {
    return (
      <tr
        className="cp-text-not-important"
        style={{height: 40}}
      >
        <td colSpan={3} style={{textAlign: 'center'}}>
          No attributes set
        </td>
      </tr>
    );
  };

  renderNoPreviewAvailable = () => {
    return (
      <Row
        type="flex"
        key="preview body"
        className="cp-text-not-important"
        style={{height: 40, margin: '0 auto'}}>
        No preview available
      </Row>
    );
  };

  renderFilePreview = () => {
    if (this.props.preview && this.props.preview.pending) {
      return <LoadingView key="loading_view" />;
    }
    const previewRes = [];
    const {
      entityParentId,
      metadataRenderFn,
      entityId,
      entityClass
    } = this.props;

    if (
      entityClass === 'DATA_STORAGE_ITEM' &&
      entityParentId &&
      entityId
    ) {
      previewRes.push((
        <OpenStaticPreview
          key="open-static"
          storageId={entityParentId}
          path={entityId}
          style={{margin: '5px 0'}}
        />
      ));
    }

    if (!this.filePreview) {
      previewRes.push(this.renderNoPreviewAvailable());
      return previewRes;
    }

    const {
      preview,
      truncated,
      noContent,
      error,
      mayBeBinary
    } = this.filePreview;
    if (error) {
      previewRes.push(
        <div key="body" style={{width: '100%', flex: 1, overflowY: 'auto', paddingTop: 10}}>
          <Alert type="error" message={error} />
        </div>
      );
      return previewRes;
    }
    if (metadataRenderFn) {
      return metadataRenderFn();
    }
    if (!mayBeBinary) {
      previewRes.push(
        <Row
          type="flex"
          justify="space-between"
          key="preview heading"
          className="cp-text-not-important"
          style={{marginTop: 5, marginBottom: 5}}
        >
          <Col colSpan={2}>
            File preview
          </Col>
          <Col style={{textAlign: 'right'}}>
            <Button
              onClick={this.props.openEditFileForm}
              size="small" style={{border: 'none'}}>
              <Icon type="arrows-alt" />
            </Button>
          </Col>
        </Row>
      );
    }
    if (noContent && !mayBeBinary) {
      previewRes.push(
        <Row
          type="flex"
          key="preview body"
          className="cp-text-not-important"
          style={{height: 40, margin: '0 auto'}}>
          No content
        </Row>
      );
      return previewRes;
    }
    if (!mayBeBinary && utilities.isSampleSheetContent(preview, entityId)) {
      previewRes.push(
        <div
          id="file-preview-container"
          key="preview body"
          style={{flex: 1, overflow: 'auto'}}
        >
          <SampleSheet.Preview
            style={{
              width: '100%',
              height: '100%',
              overflow: 'auto'
            }}
            content={preview}
            size="small"
          />
        </div>
      );
    } else if (!mayBeBinary) {
      previewRes.push(
        <Row
          id="file-preview-container"
          type="flex"
          key="preview body"
          className="cp-text-not-important"
          style={{flex: 1}}
        >
          <Input
            spellCheck="false"
            autoComplete="off"
            autoCorrect="off"
            autoCapitalize="off"
            type="textarea"
            className={classNames(
              styles.disabledTextarea,
              'cp-metadata-item-content-preview'
            )}
            value={preview}
            readOnly
            disabled
          />
        </Row>
      );
    }
    const renderDownloadLink = () => {
      const handleDownload = () => auditStorageAccessManager.reportReadAccess({
        storageId: this.props.entityParentId,
        path: this.props.entityId,
        reportStorageType: 'S3'
      });
      return (
        <span>
          <a
            href={this.downloadUrl}
            target="_blank"
            download={this.props.entityId}
            style={{marginLeft: 5, marginRight: 5}}
            onClick={handleDownload}
          >
            Download file
          </a>
          to view full contents
        </span>
      );
    };
    if (mayBeBinary && this.downloadUrl) {
      previewRes.push(
        <Row
          type="flex"
          key="preview footer"
          className="cp-text-not-important"
          style={{marginTop: 5, marginBottom: 5}}
        >
          {/* eslint-disable-next-line */}
          File preview is not available. {this.props.downloadable && renderDownloadLink()}
        </Row>
      );
    } else if (!mayBeBinary && truncated && this.downloadUrl) {
      previewRes.push(
        <Row
          type="flex"
          key="preview footer"
          className="cp-text-not-important"
          style={{marginTop: 5, marginBottom: 5}}
        >
          {/* eslint-disable-next-line */}
          File is too large to be shown. {this.props.downloadable && renderDownloadLink()}
        </Row>
      );
    }
    return previewRes;
  };

  renderTableHeader = (editable) => {
    const addKeyClicked = () => {
      this.setState({
        editableKeyIndex: null,
        editableValueIndex: null,
        editableText: null,
        addKey: {
          key: '',
          value: ''
        }
      });
    };
    const renderTitle = () => {
      if (this.props.entityName && this.props.onNavigateBack && this.props.canNavigateBack) {
        const titleParts = [];
        titleParts.push(
          <Button
            id="back-button"
            key="back-button"
            style={{marginRight: 5}}
            size="small"
            onClick={this.props.onNavigateBack}>
            <Icon type="left" />
          </Button>
        );
        titleParts.push(<b key="entity name">{this.props.entityName}</b>);
        return titleParts;
      } else if (this.props.title) {
        return (
          <span style={this.props.titleStyle}>
            {this.props.title || '\u00A0'}
          </span>
        );
      }
      return undefined;
    };
    const renderActions = () => {
      const actions = [];
      if (editable && !this.state.addKey && this.props.showMetadata) {
        actions.push(
          <Button
            id="add-key-button"
            key="add button"
            size="small"
            onClick={addKeyClicked}>
            <Icon type="plus" /> Add
          </Button>
        );
      }
      if (
        editable &&
        this.metadata
          .filter(o => !this.isReadOnlyTag(o.key) && !this.isSpecialItem(o.key)).length > 0 &&
        this.props.removeAllAvailable
      ) {
        actions.push(
          <Button
            id="remove-all-keys-button"
            key="remove all keys button"
            size="small"
            type="danger"
            onClick={this.confirmDeleteMetadata}>
            <Icon type="delete" /> Remove all
          </Button>
        );
      }
      return actions;
    };
    return (
      <thead className={styles.metadataHeader}>
        <tr style={{}}>
          <td colSpan={3} style={{padding: 5}}>
            <Row type="flex" justify="space-between" align="middle">
              <div>
                {renderTitle()}
              </div>
              <div>
                {renderActions()}
              </div>
            </Row>
          </td>
        </tr>
      </thead>
    );
  };

  renderMetadataTable = () => {
    const header = (
      <table key="header" style={{width: '100%'}}>
        {this.renderTableHeader(
          !this.props.readOnly && (!this.props.hideMetadataTags || !this.props.dataStorageTags)
        )}
        <tbody>
          {this.renderAddKeyRow()}
        </tbody>
      </table>
    );
    let metadata;
    if (this.props.metadata.error) {
      metadata = (
        <div key="body" style={{width: '100%', flex: 1, overflowY: 'auto', paddingTop: 10}}>
          <Alert type="error" message={this.props.metadata.error} />
        </div>
      );
    } else if (!this.props.hideMetadataTags || !this.props.dataStorageTags) {
      metadata = (
        <div key="body" style={{width: '100%', flex: 1, overflowY: 'auto'}}>
          <table key="body" style={{width: '100%', tableLayout: 'fixed'}}>
            <tbody>
              {
                (this.props.extraInfo || []).map((info, idx) => (
                  <tr key={`extra-info-${idx}`}>
                    <td colSpan={6}>
                      {info}
                    </td>
                  </tr>
                ))
              }
              {
                this.renderAutogeneratedMetadata(
                  this.metadata
                    .filter(({key}) => !this.isReadOnlyTag(key))
                )
              }
              {
                this.metadata
                  .filter(({key}) => !this.isReadOnlyTag(key))
                  .map(this.renderMetadataItem)
                  .reduce((arr, val) => {
                    if (!arr) {
                      arr = [];
                    }
                    arr.push(val);
                    return arr;
                  }, [])
              }
              {
                this.metadata.length === 0
                  ? this.renderEmptyPlaceholder()
                  : undefined
              }
            </tbody>
          </table>
        </div>
      );
    }
    const result = [header];
    if ((this.props.dataStorageTags && this.props.showContent) ||
      this.props.jobList) {
      result.push(
        <SplitPanel
          key="split"
          style={{flex: 1, overflow: 'auto'}}
          orientation="vertical">
          {
            (this.props.dataStorageTags && this.props.showContent) &&
            <div key="file preview" style={{
              display: 'flex',
              flexDirection: 'column',
              height: '100%'
            }}>
              {this.renderFilePreview()}
            </div>
          }
          {this.props.showMetadata && !this.props.hideMetadataTags ? metadata : null}
          {this.props.jobList ? this.props.jobList : null}
        </SplitPanel>
      );
    } else {
      result.push(metadata);
    }
    return result;
  };

  render () {
    if (
      this.props.pending ||
      (this.props.metadata.pending && !this.props.metadata.loaded)
    ) {
      return <LoadingView />;
    }
    return (
      <div
        style={{
          flex: 1,
          display: 'flex',
          flexDirection: 'column',
          overflow: 'auto'
        }}
      >
        {this.renderMetadataTable()}
      </div>
    );
  }

  refresh = () => {
    this.props.metadata.fetch();
    if (this.props.dataStorageTags) {
      this.props.dataStorageTags.fetch();
    }
    if (this.props.preview) {
      this.props.preview.fetch();
    }
    if (this.props.downloadUrl) {
      this.props.downloadUrl.fetch();
    }
  };

  componentWillReceiveProps (nextProps) {
    if (this.props.entityClass !== nextProps.entityClass ||
      this.props.entityId !== nextProps.entityId ||
      this.props.entityParentId !== nextProps.entityParentId) {
      if (nextProps.entityClass === 'DATA_STORAGE_ITEM') {
        this.props.dataStorageCache.invalidateTags(
          nextProps.entityParentId,
          nextProps.entityId,
          nextProps.entityVersion
        );
        this.props.dataStorageCache.invalidateContent(
          nextProps.entityParentId,
          nextProps.entityId,
          nextProps.entityVersion
        );
        this.props.dataStorageCache.invalidateDownloadUrl(
          nextProps.entityParentId,
          nextProps.entityId,
          nextProps.entityVersion
        );
      } else {
        this.props.metadataCache.invalidateMetadata(nextProps.entityId, nextProps.entityClass);
      }
    }
  }
}

export {ApplyChanges, SpecialTags};

/*
 * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.epam.pipeline.dao.tool;

import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.function.Function;
import java.util.stream.Collectors;

import com.epam.pipeline.config.JsonMapper;
import com.epam.pipeline.entity.pipeline.ToolScanStatus;
import com.epam.pipeline.entity.scan.ToolDependency;
import com.epam.pipeline.entity.scan.ToolOSVersion;
import com.epam.pipeline.entity.scan.ToolVersionScanResult;
import com.epam.pipeline.entity.scan.Vulnerability;
import com.epam.pipeline.entity.scan.VulnerabilitySeverity;
import com.fasterxml.jackson.core.type.TypeReference;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Required;
import org.springframework.jdbc.core.ResultSetExtractor;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcDaoSupport;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

@Slf4j
public class ToolVulnerabilityDao extends NamedParameterJdbcDaoSupport {

    private String insertVulnerabilitiesQuery;
    private String loadVulnerabilitiesByToolAndVersionQuery;
    private String loadVulnerabilitiesByToolQuery;
    private String deleteVulnerabilitiesQuery;
    private String loadVulnerabilityCountQuery;

    private String insertToolVersionScanQuery;
    private String updateToolVersionScanQuery;
    private String updateWhiteListWithToolVersionQuery;
    private String updateToolVersionScanWithSuccessQuery;
    private String loadToolVersionScanQuery;
    private String loadToolAllVersionScansQuery;
    private String loadToolListVersionsScanQuery;
    private String deleteToolVersionScansQuery;

    private String insertToolDependencyQuery;
    private String loadDependencyByToolAndVersionQuery;
    private String loadDependencyByToolQuery;
    private String deleteDependencyQuery;

    @Transactional(propagation = Propagation.MANDATORY)
    public void createVulnerabilityRecords(List<Vulnerability> vulnerabilities, long toolId, String version) {
        MapSqlParameterSource[] params = vulnerabilities.stream()
            .map(v -> ToolVulnerabilityColumns.getParams(v, toolId, version))
            .collect(Collectors.toList())
            .toArray(new MapSqlParameterSource[vulnerabilities.size()]);
        getNamedParameterJdbcTemplate().batchUpdate(insertVulnerabilitiesQuery, params);
    }

    public List<Vulnerability> loadVulnerabilities(long toolId, String version) {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue(ToolVulnerabilityColumns.TOOL_ID.name(), toolId);
        params.addValue(ToolVulnerabilityColumns.VERSION.name(), version);

        return getNamedParameterJdbcTemplate().query(loadVulnerabilitiesByToolAndVersionQuery, params,
                                                     ToolVulnerabilityColumns.getRowMapper());
    }

    public Map<String, List<Vulnerability>> loadVulnerabilities(long toolId) {
        Map<String, List<Vulnerability>> allVulnerabilities = new HashMap<>();
        RowMapper<Vulnerability> rowMapper = ToolVulnerabilityColumns.getRowMapper();

        getJdbcTemplate().query(loadVulnerabilitiesByToolQuery, (rs) -> {
            String version = rs.getString(ToolVulnerabilityColumns.VERSION.name());
            if (!allVulnerabilities.containsKey(version)) {
                allVulnerabilities.put(version, new ArrayList<>());
            }

            allVulnerabilities.get(version).add(rowMapper.mapRow(rs, 0));
        }, toolId);

        return allVulnerabilities;
    }

    @Transactional(propagation = Propagation.MANDATORY)
    public void deleteVulnerabilities(long toolId, String version) {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue(ToolVulnerabilityColumns.TOOL_ID.name(), toolId);
        params.addValue(ToolVulnerabilityColumns.VERSION.name(), version);

        getNamedParameterJdbcTemplate().update(deleteVulnerabilitiesQuery, params);
    }

    @Transactional(propagation = Propagation.MANDATORY)
    public void createDependencyRecords(List<ToolDependency> dependencies, long toolId, String version) {
        MapSqlParameterSource[] params = dependencies.stream()
                .map(v -> ToolDependencyColumns.getParams(v, toolId, version))
                .collect(Collectors.toList())
                .toArray(new MapSqlParameterSource[dependencies.size()]);
        getNamedParameterJdbcTemplate().batchUpdate(insertToolDependencyQuery, params);
    }

    public List<ToolDependency> loadDependencies(long toolId, String version) {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue(ToolDependencyColumns.TOOL_ID.name(), toolId);
        params.addValue(ToolDependencyColumns.TOOL_VERSION.name(), version);

        return getNamedParameterJdbcTemplate().query(loadDependencyByToolAndVersionQuery, params,
                ToolDependencyColumns.getRowMapper());
    }

    public Map<String, List<ToolDependency>> loadDependencies(long toolId) {
        Map<String, List<ToolDependency>> allDependencies = new HashMap<>();
        RowMapper<ToolDependency> rowMapper = ToolDependencyColumns.getRowMapper();

        getJdbcTemplate().query(loadDependencyByToolQuery, (rs) -> {
            String version = rs.getString(ToolDependencyColumns.TOOL_VERSION.name());
            if (!allDependencies.containsKey(version)) {
                allDependencies.put(version, new ArrayList<>());
            }

            allDependencies.get(version).add(rowMapper.mapRow(rs, 0));
        }, toolId);

        return allDependencies;
    }

    @Transactional(propagation = Propagation.MANDATORY)
    public void deleteDependencies(long toolId, String version) {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue(ToolDependencyColumns.TOOL_ID.name(), toolId);
        params.addValue(ToolDependencyColumns.TOOL_VERSION.name(), version);

        getNamedParameterJdbcTemplate().update(deleteDependencyQuery, params);
    }

    @Transactional(propagation = Propagation.MANDATORY)
    public void insertToolVersionScan(long toolId, String version, ToolOSVersion toolOSVersion, String layerRef,
                                      String digest, ToolScanStatus newStatus, Date scanDate,
                                      Map<VulnerabilitySeverity, Integer> vulnerabilitiesCount) {

        MapSqlParameterSource params = ToolVulnerabilityColumns.getParams(
                toolId, version, toolOSVersion, layerRef, digest, newStatus, scanDate, false, vulnerabilitiesCount
        );
        getNamedParameterJdbcTemplate().update(insertToolVersionScanQuery, params);
    }

    @Transactional(propagation = Propagation.MANDATORY)
    public void updateToolVersionScan(long toolId, String version, ToolOSVersion toolOSVersion, String layerRef,
                                      String digest, ToolScanStatus newStatus, Date scanDate, boolean whiteList,
                                      Map<VulnerabilitySeverity, Integer> vulnerabilitiesCount) {
        MapSqlParameterSource params = ToolVulnerabilityColumns.getParams(
                toolId, version, toolOSVersion, layerRef, digest, newStatus, scanDate, whiteList, vulnerabilitiesCount
        );
        if (newStatus == ToolScanStatus.COMPLETED) {
            getNamedParameterJdbcTemplate().update(updateToolVersionScanWithSuccessQuery, params);
        } else {
            getNamedParameterJdbcTemplate().update(updateToolVersionScanQuery, params);
        }
    }

    @Transactional(propagation = Propagation.MANDATORY)
    public void deleteToolVersionScan(long toolId, String version) {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue(ToolVersionColumns.TOOL_ID.name(), toolId);
        params.addValue(ToolVersionColumns.VERSION.name(), version);

        getNamedParameterJdbcTemplate().update(deleteToolVersionScansQuery, params);
    }

    @Transactional(propagation = Propagation.MANDATORY)
    public void updateWhiteListWithToolVersion(long toolId, String version,
                                                                boolean fromWhiteList) {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue(ToolVersionColumns.TOOL_ID.name(), toolId);
        params.addValue(ToolVersionColumns.VERSION.name(), version);
        params.addValue(ToolVersionColumns.WHITE_LIST.name(), fromWhiteList);
        getNamedParameterJdbcTemplate().update(updateWhiteListWithToolVersionQuery, params);
    }

    public Optional<ToolVersionScanResult> loadToolVersionScan(long toolId, String version) {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue(ToolVersionColumns.TOOL_ID.name(), toolId);
        params.addValue(ToolVersionColumns.VERSION.name(), version);

        Optional<ToolVersionScanResult> optional = getNamedParameterJdbcTemplate()
                .query(loadToolVersionScanQuery, params, ToolVersionColumns.getRowMapper())
                .stream()
                .findFirst();

        optional.ifPresent(toolVersionScanResult -> {
            toolVersionScanResult.setVulnerabilities(loadVulnerabilities(toolId, version));
            toolVersionScanResult.setDependencies(loadDependencies(toolId, version));
        });

        return optional;
    }

    public Map<String, ToolVersionScanResult> loadToolVersionScanInfo(final long toolId,
                                                                      final List<String> versions) {
        final MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue(ToolVersionColumns.TOOL_ID.name(), toolId);
        params.addValue("VERSIONS", versions);
        return getNamedParameterJdbcTemplate()
                .query(loadToolListVersionsScanQuery, params, ToolVersionColumns.getRowMapper())
                .stream()
                .collect(Collectors.toMap(ToolVersionScanResult::getVersion, Function.identity()));
    }

    public Map<String, ToolVersionScanResult> loadAllToolVersionScans(long toolId) {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue(ToolVersionColumns.TOOL_ID.name(), toolId);
        Map<String, ToolVersionScanResult> resultMap = new HashMap<>();
        List<ToolVersionScanResult> toolVersionScanResults = getNamedParameterJdbcTemplate()
                .query(loadToolAllVersionScansQuery, params, ToolVersionColumns.getRowMapper());
        Map<String, List<Vulnerability>> vulnerabilitiesByVersion = loadVulnerabilities(toolId);
        Map<String, List<ToolDependency>> dependenciesByVersion = loadDependencies(toolId);
        for (ToolVersionScanResult scanResult : toolVersionScanResults) {
            scanResult.setVulnerabilities(vulnerabilitiesByVersion.get(scanResult.getVersion()));
            scanResult.setDependencies(dependenciesByVersion.get(scanResult.getVersion()));
            resultMap.put(scanResult.getVersion(), scanResult);
        }
        return resultMap;
    }

    public Map<String, Map<VulnerabilitySeverity, Integer>> loadVulnerabilityCount(final Long toolId,
                                                                                   final List<String> versions) {
        final MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue(ToolVersionColumns.TOOL_ID.name(), toolId);
        params.addValue("VERSIONS", versions);
        return getNamedParameterJdbcTemplate()
                .query(loadVulnerabilityCountQuery, params, ToolVulnerabilityColumns.getCountResultExtractor());
    }

    @Required
    public void setLoadToolListVersionsScanQuery(final String loadToolListVersionsScanQuery) {
        this.loadToolListVersionsScanQuery = loadToolListVersionsScanQuery;
    }

    @Required
    public void setLoadVulnerabilityCountQuery(final String loadVulnerabilityCountQuery) {
        this.loadVulnerabilityCountQuery = loadVulnerabilityCountQuery;
    }

    @Required
    public void setInsertVulnerabilitiesQuery(String insertVulnerabilitiesQuery) {
        this.insertVulnerabilitiesQuery = insertVulnerabilitiesQuery;
    }

    @Required
    public void setLoadToolVersionScanQuery(String loadToolVersionScanQuery) {
        this.loadToolVersionScanQuery = loadToolVersionScanQuery;
    }

    @Required
    public void setLoadVulnerabilitiesByToolAndVersionQuery(String loadVulnerabilitiesByToolAndVersionQuery) {
        this.loadVulnerabilitiesByToolAndVersionQuery = loadVulnerabilitiesByToolAndVersionQuery;
    }

    @Required
    public void setDeleteVulnerabilitiesQuery(String deleteVulnerabilitiesQuery) {
        this.deleteVulnerabilitiesQuery = deleteVulnerabilitiesQuery;
    }

    @Required
    public void setLoadVulnerabilitiesByToolQuery(String loadVulnerabilitiesByToolQuery) {
        this.loadVulnerabilitiesByToolQuery = loadVulnerabilitiesByToolQuery;
    }

    @Required
    public void setInsertToolVersionScanQuery(String insertToolVersionScanQuery) {
        this.insertToolVersionScanQuery = insertToolVersionScanQuery;
    }

    @Required
    public void setDeleteToolVersionScansQuery(String deleteToolVersionScansQuery) {
        this.deleteToolVersionScansQuery = deleteToolVersionScansQuery;
    }

    @Required
    public void setUpdateToolVersionScanQuery(String updateToolVersionScanQuery) {
        this.updateToolVersionScanQuery = updateToolVersionScanQuery;
    }

    @Required
    public void setUpdateToolVersionScanWithSuccessQuery(String updateToolVersionScanWithSuccessQuery) {
        this.updateToolVersionScanWithSuccessQuery = updateToolVersionScanWithSuccessQuery;
    }

    @Required
    public void setLoadToolAllVersionScansQuery(String loadToolAllVersionScansQuery) {
        this.loadToolAllVersionScansQuery = loadToolAllVersionScansQuery;
    }

    @Required
    public void setInsertToolDependencyQuery(String insertToolDependencyQuery) {
        this.insertToolDependencyQuery = insertToolDependencyQuery;
    }

    @Required
    public void setLoadDependencyByToolAndVersionQuery(String loadDependencyByToolAndVersionQuery) {
        this.loadDependencyByToolAndVersionQuery = loadDependencyByToolAndVersionQuery;
    }

    @Required
    public void setLoadDependencyByToolQuery(String loadDependencyByToolQuery) {
        this.loadDependencyByToolQuery = loadDependencyByToolQuery;
    }

    @Required
    public void setDeleteDependencyQuery(String deleteDependencyQuery) {
        this.deleteDependencyQuery = deleteDependencyQuery;
    }

    @Required
    public void setUpdateWhiteListWithToolVersionQuery(String updateWhiteListWithToolVersionQuery) {
        this.updateWhiteListWithToolVersionQuery = updateWhiteListWithToolVersionQuery;
    }

    private enum ToolDependencyColumns {
        TOOL_ID,
        TOOL_VERSION,
        DEPENDENCY_NAME,
        DEPENDENCY_VERSION,
        DEPENDENCY_ECOSYSTEM,
        DEPENDENCY_DESCRIPTION;


        private static MapSqlParameterSource getParams(ToolDependency dependency, long toolId, String version) {
            MapSqlParameterSource params = new MapSqlParameterSource();
            params.addValue(TOOL_ID.name(), toolId);
            params.addValue(TOOL_VERSION.name(), version);
            params.addValue(DEPENDENCY_NAME.name(), dependency.getName());
            params.addValue(DEPENDENCY_VERSION.name(), dependency.getVersion());
            params.addValue(DEPENDENCY_ECOSYSTEM.name(), dependency.getEcosystem().getValue());
            params.addValue(DEPENDENCY_DESCRIPTION.name(), dependency.getDescription());

            return params;
        }

        private static RowMapper<ToolDependency> getRowMapper() {
            return (rs, rowNum) -> {
                ToolDependency dependency = new ToolDependency();
                dependency.setToolId(rs.getLong(ToolDependencyColumns.TOOL_ID.name()));
                dependency.setToolVersion(rs.getString(ToolDependencyColumns.TOOL_VERSION.name()));
                dependency.setName(rs.getString(ToolDependencyColumns.DEPENDENCY_NAME.name()));
                String version = rs.getString(ToolDependencyColumns.DEPENDENCY_VERSION.name());

                if (!rs.wasNull()) {
                    dependency.setVersion(version);
                }

                String d = rs.getString(ToolDependencyColumns.DEPENDENCY_DESCRIPTION.name());
                if (!rs.wasNull()) {
                    dependency.setDescription(d);
                }

                dependency.setEcosystem(
                        ToolDependency.Ecosystem.getByName(
                                rs.getString(ToolDependencyColumns.DEPENDENCY_ECOSYSTEM.name())));
                return dependency;
            };
        }

    }

    private enum ToolVulnerabilityColumns {
        TOOL_ID,
        VERSION,
        VULNERABILITY_NAME,
        FEATURE,
        FEATURE_VERSION,
        DESCRIPTION,
        LINK,
        SEVERITY,
        FIXED_BY,
        CREATED_DATE,
        COUNT;

        private static MapSqlParameterSource getParams(Vulnerability vulnerability, long toolId, String version) {
            MapSqlParameterSource params = new MapSqlParameterSource();
            params.addValue(TOOL_ID.name(), toolId);
            params.addValue(VERSION.name(), version);
            params.addValue(VULNERABILITY_NAME.name(), vulnerability.getName());
            params.addValue(FEATURE.name(), vulnerability.getFeature());
            params.addValue(FEATURE_VERSION.name(), vulnerability.getFeatureVersion());
            params.addValue(DESCRIPTION.name(), vulnerability.getDescription());
            params.addValue(LINK.name(), vulnerability.getLink());
            params.addValue(SEVERITY.name(), vulnerability.getSeverity().getCode());
            params.addValue(FIXED_BY.name(), vulnerability.getFixedBy());
            params.addValue(CREATED_DATE.name(), vulnerability.getCreatedDate());

            return params;
        }

        private static MapSqlParameterSource getParams(final long toolId, final String version,
                                                       final ToolOSVersion toolOSVersion, final String layerRef,
                                                       final String digest, final ToolScanStatus newStatus,
                                                       final Date scanDate, final boolean whiteList,
                                                       final Map<VulnerabilitySeverity, Integer> vulnerabilitiesCount) {
            MapSqlParameterSource params = new MapSqlParameterSource();
            params.addValue(ToolVersionColumns.TOOL_ID.name(), toolId);
            params.addValue(ToolVersionColumns.VERSION.name(), version);
            params.addValue(ToolVersionColumns.LAYER_REFERENCE.name(), layerRef);
            params.addValue(ToolVersionColumns.DIGEST.name(), digest);
            params.addValue(ToolVersionColumns.SCAN_STATUS.name(), newStatus.getCode());
            params.addValue(ToolVersionColumns.SCAN_DATE.name(), scanDate);
            params.addValue(ToolVersionColumns.SUCCESS_SCAN_DATE.name(),
                            newStatus == ToolScanStatus.COMPLETED ? scanDate : null);
            params.addValue(ToolVersionColumns.WHITE_LIST.name(), whiteList);
            params.addValue(ToolVersionColumns.OS_NAME.name(),
                    Optional.ofNullable(toolOSVersion).map(ToolOSVersion::getDistribution).orElse(null));
            params.addValue(ToolVersionColumns.OS_VERSION.name(),
                    Optional.ofNullable(toolOSVersion).map(ToolOSVersion::getVersion).orElse(null));
            params.addValue(ToolVersionColumns.VULNERABILITIES_COUNT.name(),
                    Optional.ofNullable(vulnerabilitiesCount)
                            .map(count -> JsonMapper.convertDataToJsonStringForQuery(vulnerabilitiesCount))
                            .orElse(null));
            return params;
        }

        private static RowMapper<Vulnerability> getRowMapper() {
            return (rs, rowNum) -> {
                Vulnerability vulnerability = new Vulnerability();

                vulnerability.setName(rs.getString(VULNERABILITY_NAME.name()));
                vulnerability.setFeature(rs.getString(FEATURE.name()));
                vulnerability.setFeatureVersion(rs.getString(FEATURE_VERSION.name()));
                vulnerability.setDescription(rs.getString(DESCRIPTION.name()));
                vulnerability.setLink(rs.getString(LINK.name()));
                vulnerability.setSeverity(VulnerabilitySeverity.getByCode(rs.getInt(SEVERITY.name())));
                vulnerability.setFixedBy(rs.getString(FIXED_BY.name()));
                vulnerability.setCreatedDate(new Date(rs.getTimestamp(CREATED_DATE.name()).getTime()));

                return vulnerability;
            };
        }

        private static ResultSetExtractor<Map<String, Map<VulnerabilitySeverity, Integer>>> getCountResultExtractor() {
            return rs -> {
                final Map<String, Map<VulnerabilitySeverity, Integer>> result = new HashMap<>();
                while (rs.next()) {
                    final String version = rs.getString(VERSION.name());
                    result.putIfAbsent(version, new HashMap<>());
                    final VulnerabilitySeverity severity = VulnerabilitySeverity.getByCode(rs.getInt(SEVERITY.name()));
                    final Integer count = rs.getInt(COUNT.name());
                    result.get(version).put(severity, count);
                }
                return result;
            };
        }

    }

    private enum ToolVersionColumns {
        TOOL_ID,
        VERSION,
        LAYER_REFERENCE,
        DIGEST,
        SCAN_STATUS,
        SCAN_DATE,
        SUCCESS_SCAN_DATE,
        WHITE_LIST,
        OS_NAME,
        OS_VERSION,
        VULNERABILITIES_COUNT;

        private static RowMapper<ToolVersionScanResult> getRowMapper() {
            return (rs, rowNum) -> {
                ToolVersionScanResult versionScan = new ToolVersionScanResult();
                versionScan.setToolId(rs.getLong(ToolVersionColumns.TOOL_ID.name()));
                versionScan.setVersion(rs.getString(ToolVersionColumns.VERSION.name()));
                versionScan.setLastLayerRef(rs.getString(ToolVersionColumns.LAYER_REFERENCE.name()));
                versionScan.setDigest(rs.getString(ToolVersionColumns.DIGEST.name()));
                versionScan.setFromWhiteList(rs.getBoolean(ToolVersionColumns.WHITE_LIST.name()));

                Timestamp timestamp = rs.getTimestamp(ToolVersionColumns.SCAN_DATE.name());
                if (!rs.wasNull()) {
                    versionScan.setScanDate(new Date(timestamp.getTime()));
                }

                timestamp = rs.getTimestamp(ToolVersionColumns.SUCCESS_SCAN_DATE.name());
                if (!rs.wasNull()) {
                    versionScan.setSuccessScanDate(new Date(timestamp.getTime()));
                }

                int statusCode = rs.getInt(ToolVersionColumns.SCAN_STATUS.name());
                if (!rs.wasNull()) {
                    ToolScanStatus status = ToolScanStatus.getByCode(statusCode);
                    versionScan.setStatus(status);
                }

                String osVersion = rs.getString(ToolVersionColumns.OS_VERSION.name());
                String osName = rs.getString(ToolVersionColumns.OS_NAME.name());
                if (!rs.wasNull()) {
                    versionScan.setToolOSVersion(new ToolOSVersion(osName, osVersion));
                }
                final String vulnerabilitiesCount = rs.getString(VULNERABILITIES_COUNT.name());
                if (StringUtils.isNotBlank(vulnerabilitiesCount)) {
                    versionScan.setVulnerabilitiesCount(JsonMapper.parseData(vulnerabilitiesCount,
                            new TypeReference<Map<VulnerabilitySeverity, Integer>>() {}));
                }
                return versionScan;
            };
        }

    }
}
